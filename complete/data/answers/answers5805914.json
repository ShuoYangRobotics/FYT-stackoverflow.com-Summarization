[[{"text": ["itertools.compress (new in 2.7/3.1) nicely supports use cases like this one, especially when combined with itertools.cycle:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools.compress", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools.cycle", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import cycle, compress\nseq = range(100)\ncriteria = cycle([True]*10 + [False]*20) # Use whatever pattern you like\n&gt;&gt;&gt; list(compress(seq, criteria))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Python 2.7 timing (relative to Sven's explicit list comprehension):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ ./python -m timeit -s \"a = range(100)\" \"[x for start in range(0, len(a), 30) for x in a[start:start+10]]\"\n100000 loops, best of 3: 4.96 usec per loop\n\n$ ./python -m timeit -s \"from itertools import cycle, compress\" -s \"a = range(100)\" -s \"criteria = cycle([True]*10 + [False]*20)\" \"list(compress(a, criteria))\"\n100000 loops, best of 3: 4.76 usec per loop\n</code>\n</pre>\n", "senID": 3}, {"text": ["Python 3.2 timing (also relative to Sven's explicit list comprehension):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n $ ./python -m timeit -s \"a = range(100)\" \"[x for start in range(0, len(a), 30) for x in a[start:start+10]]\"\n100000 loops, best of 3: 7.41 usec per loop\n\n$ ./python -m timeit -s \"from itertools import cycle, compress\" -s \"a = range(100)\" -s \"criteria = cycle([True]*10 + [False]*20)\" \"list(compress(a, criteria))\"\n100000 loops, best of 3: 4.78 usec per loop\n</code>\n</pre>\n", "senID": 5}, {"text": ["As can be seen, it doesn't make a great deal of difference relative to the in-line list comprehension in 2.7, but helps significantly in 3.2 by avoiding the overhead of the implicit nested scope."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["A similar difference can also be seen in 2.7 if the aim is to iterate over the resulting sequence rather than turn it into a fully realised list:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n $ ./python -m timeit -s \"a = range(100)\" \"for x in (x for start in range(0, len(a), 30) for x in a[start:start+10]): pass\"\n100000 loops, best of 3: 6.82 usec per loop\n$ ./python -m timeit -s \"from itertools import cycle, compress\" -s \"a = range(100)\" -s \"criteria = cycle([True]*10 + [False]*20)\" \"for x in compress(a, criteria): pass\"\n100000 loops, best of 3: 3.61 usec per loop\n</code>\n</pre>\n", "senID": 8}, {"text": ["For especially long patterns, it is possible to replace the list in the pattern expression with an expression like chain(repeat(True, 10), repeat(False, 20)) so that it never has to be fully created in memory."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "chain(repeat(True, 10), repeat(False, 20))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Maybe the best way is the straight-forward approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def magicslicer(seq, take, skip):\n    return [x for start in range(0, len(seq), take + skip)\n              for x in seq[start:start + take]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't think you can avoid the loops."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: Since this is tagged \"performance\", here a comparison with the modulo solution for a = range(100):"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "a = range(100)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n In [2]: %timeit [x for start in range(0, len(a), 30)\n                   for x in a[start:start + 10]]\n100000 loops, best of 3: 4.89 us per loop\n\nIn [3]: %timeit [e for i, e in enumerate(a) if i % 30 &lt; 10]\n100000 loops, best of 3: 14.8 us per loop\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I think that slices cannot do it, unfortunately.", "I'd solve the problem using list comprehensions"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list comprehensions", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = range(100)\n&gt;&gt;&gt; a\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \n 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n    ...\n 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n&gt;&gt;&gt; [e for i, e in enumerate(a) if i % 30 &lt; 10]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \n 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\n 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'd use a loop:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\n\ndef magicslicer(l, stepsize, stepgap):\n    output = []\n    i = 0\n    while i&lt;len(l):\n        output += l[i:i+stepsize]\n        i += stepsize + stepgap\n    return output\n\n\nmylist = range(100)\nprint magicslicer(mylist,10,20)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt;[mylist[start:start+10] for start in mylist[::30]]\n&gt;&gt;&gt;[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [30, 31, 32, 33, 34, 35, 36, 37, 38, 39], [60, 61, 62, 63, 64, 65, 66, 67, 68, 69], [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]]\n</code>\n</pre>\n", "senID": 0}, {"text": ["but i obtain a list of list :("], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["[x for x in range(100) if x%30 &lt; 10] is another way to do it.", "But, this can be slow as the list size grows."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "[x for x in range(100) if x%30 &lt; 10]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["A function on the same lines"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def magic_slice(n, no_elems, step):\n    s = no_elems + step\n    return [x for x in range(n) if x%s &lt; no_elems]\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n mylist = range(100)\n\notherlist = ['21','31','689','777','479','51','71','yut','poi','ger',\n             '11','61','789','zozozozo','8888','1']\n\n\n\ndef magic_slicer(iterable,keep,throw):\n        it = iter(iterable).next\n        for n in xrange((len(iterable)//keep+throw)+1):\n                for i in xrange(keep):  yield it()\n                for i in xrange(throw):  it()\n\nprint list(magic_slicer(mylist,10,20))\nprint\nprint list(magic_slicer(otherlist,2,3))\n\n\nprint '__________________'\n\n\ndef magic_slicer2(iterable,keep,throw):\n        return ( x for i,x in enumerate(iterable) if -1&lt; i%(keep+throw)&lt;keep) \n\nprint list(magic_slicer2(mylist,10,20))\nprint\nprint list(magic_slicer2(otherlist,2,3))\n</code>\n</pre>\n", "senID": 0}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n\n['21', '31', '51', '71', '11', '61', '1']\n__________________\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\n\n['21', '31', '51', '71', '11', '61', '1']\n</code>\n</pre>\n", "senID": 2}]]