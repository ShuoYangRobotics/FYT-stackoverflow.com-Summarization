[[{"text": ["You have to record the original state and restore it explicitly.", "If the value existed before you changed it, restore that value; otherwise delete the value you set."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n  pass\n\ntry:\n    original_value = getattr(Foo, 'x')\n    originally_existed = True\nexcept AttributeError:\n    originally_existed = False\n\nFoo.x = 1\n\nif originally_existed:\n    Foo.x = original_value\nelse:\n    del Foo.x\n\no = Foo() # o should not have any of the previously added attributes\nprint o.x # Should raise exception\n</code>\n</pre>\n", "senID": 1}, {"text": ["You probably don't want to be doing this.", "There are valid cases for monkey patching, but you generally don't want to try to monkey unpatch.", "For example, if two independent bits of code monkey patch the same class, one of them trying to reverse the action without being aware of the other is likely to break things.", "For an example of a case where this is actually useful, see http://stackoverflow.com/questions/3829742#3829849."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "unpatch", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "http://stackoverflow.com/questions/3829742#3829849", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3829742#3829849"}]}], [{"text": ["I agree with Glenn that this is a horribly broken idea.", "Anyways, here how you'd do it with a decorator.", "Thanks to Glenn's post as well for reminding me that you can delete items from a class's dictionary, just not directly.", "Here's the code."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def resetable(cls):\n    cls._resetable_cache_ = cls.__dict__.copy()\n    return cls\n\ndef reset(cls):\n    cache = cls._resetable_cache_ # raises AttributeError on class without decorator\n    for key in [key for key in cls.__dict__ if key not in cache]:\n        delattr(cls, key)\n    for key, value in cache.items():  # reset the items to original values\n        try:\n            setattr(cls, key, value)\n        except AttributeError:\n            pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm torn on whether to reset the values by catching attempts to update non-assignable attributes with a try as I've shown or building a list of such attributes.", "I'll leave it up to you. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "try", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["And here's a use:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n @resetable   # use resetable on a class that you want to do this with\nclass Foo(object):\n    pass\n\nFoo.x = 1\nprint Foo.x\nreset(Foo)\no = Foo() \nprint o.x # raises AttributeError as expected\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I don't fully understand why you need this, but I'll have a go.", "Ordinary inheritance probably won't do because you want to 'reset' to the old state.", "How about a proxy pattern?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "about a proxy pattern", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.python.org/workshops/1997-10/proceedings/savikko.html#sec%3aproxy"}]}, {"code": "<pre>\n<code>\n class FooProxy(object):\n    def __init__(self, f):\n        self.f = foo\n        self.magic = {}\n\n    def set_magic(self, k, v):\n        self.magic[k] = v\n\n    def get_magic(self, k):\n        return self.magic.get(k)\n\n    def __getattr__(self, k):\n        return getattr(self.f, k)\n\n    def __setattr__(self, k, v):\n        setattr(self.f, k, v)\n\n    f = Foo() \n    p = FooProxy(f)\n    p.set_magic('m_bla', 123)\n</code>\n</pre>\n", "senID": 1}, {"text": ["use f for ordinary, 'original' access, use p for proxied access, it should behave mostly like Foo.", "Re-proxy f with new configuration if you need to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I don't know if you can accept an additional module file for class, if you can:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["my_class.py"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "my_class.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(object):\n  pass\n</code>\n</pre>\n", "senID": 2}, {"text": ["You main script:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import my_class  \nFoo = my_class.Foo\nFoo.x = 1\np = Foo()\nprint p.x # Printing '1'\n\n# Some code....\n\nreload(my_class) # reload to reset\nFoo = my_class.Foo\no = Foo()\nprint p.x # Printing '1'\nprint o.__class__ == p.__class__ # Printing 'False'\nprint o.x # Raising exception\n</code>\n</pre>\n", "senID": 4}, {"text": ["I am not sure if there is any side-effect.", "It seems to do what OP wants, though this is really unusal."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["In your second example you're making a reference to the class rather than an instance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Foo = _Foo # Reference"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you instead made an instance copy, what you want to do is exactly the way it will work.", "You can modify the instance all you want and 'revert' it by creating a new instance."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Foo = _Foo()"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["#!/usr/bin/python"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["class FooClass(object):\n      pass"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["FooInstance = FooClass() # Create an instance"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["FooInstance.x = 100      # Modify the instance"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["print dir(FooClass)      # Verify FooClass doesn't have an 'x' attribute"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["FooInstance = FooClass() # Creates a new instance"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["print FooInstance.x # Exception"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I don't understand what you are trying to do, but keep in mind that you don't have to add attributes to the class in order to make it look like you added attributes to the class."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "look like", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["You can give the class a __getattr__ method that will be invoked for any missing attribute.", "Where it gets the value from is up to you:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class MyTrickyClass(object):\n    self.magic_prefix = \"m_\"\n    self.other_attribute_source = SomeOtherObject()\n\n    def __getattr__(self, name):\n        if name.startswith(self.magic_prefix):\n            stripped = name[len(self.magic_prefix):]\n            return getattr(self.other_attribute_source, stripped)\n        raise AttributeError\n\nm = MyTrickyClass()\nassert hasattr(m, \"m_other\")\nMyTrickyClass.magic_prefix = \"f_\"\nassert hasattr(m, \"f_other\")\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If all the stuff you added starts with a given distinctive prefix, you could search the object's __dict__ for members with that prefix, and delete them, when it's time to restore."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can use inspect and maintain an original list of members and than delete all members that are not in the original list"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import inspect\norig_members = []\nfor name, ref in inspect.getmembers(o):\n  orig_members.append(name)\n...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now, when you need to restore back to original"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for name, ref in inspect.getmembers(o):\n  if name in orig_members:\n    pass\n  else:\n    #delete ref here\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The simplest way I found was this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo_maker():\n    class Foo(object):\n        pass\n    return Foo\nFoo = foo_maker()\nFoo.x = 1\nFoo = foo_maker() # Foo is now clean again\no = Foo() # Does not have any of the previously added attributes\nprint o.x # Raises exception\n</code>\n</pre>\n", "senID": 1}, {"text": ["edit: As pointed out in comments, does not actually reset class but has the same effect in practice."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["To create a deep copy of a class you can use the new.classobj function"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "new.classobj", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo:\n    pass\n\nimport new, copy\nFooSaved = new.classobj(Foo.__name__, Foo.__bases__, copy.deepcopy(Foo.__dict__))\n\n# ...play with original class Foo...\n\n# revert changes\nFoo = FooSaved\n</code>\n</pre>\n", "senID": 1}, {"text": ["UPD: module new is deprecated.", "Instead you should use types.ClassType with the same args"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "new", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "types.ClassType", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]