[[{"text": ["Are you trying to do this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dict( (name,eval(name)) for name in ['some','list','of','vars'] )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; some= 1\n&gt;&gt;&gt; list= 2\n&gt;&gt;&gt; of= 3\n&gt;&gt;&gt; vars= 4\n&gt;&gt;&gt; dict( (name,eval(name)) for name in ['some','list','of','vars'] )\n{'list': 2, 'some': 1, 'vars': 4, 'of': 3}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As unwind said, this isn't really something you do in Python - variables are actually name mappings to objects."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, here's one way to try and do it:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "However", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = 1\n &gt;&gt;&gt; for k, v in list(locals().iteritems()):\n         if id(v) == id(a):\n             a_as_str = k\n &gt;&gt;&gt; a_as_str\n a\n &gt;&gt;&gt; type(a_as_str)\n 'str'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This is not possible in Python, which really doesn't have \"variables\".", "Python has names, and there can be more than one name for the same object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Most objects don't have a __name__ attribute.", "(Classes, functions, and modules do; any more builtin types that have one?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__name__", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["What else would you expect for print(my_var.__name__) other than print(\"my_var\")?", "Can you simply use the string directly?"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "print(my_var.__name__)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "print(\"my_var\")", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["You could \"slice\" a dict:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def dict_slice(D, keys, default=None):\n  return dict((k, D.get(k, default)) for k in keys)\n\nprint dict_slice(locals(), [\"foo\", \"bar\"])\n# or use set literal syntax if you have a recent enough version:\nprint dict_slice(locals(), {\"foo\", \"bar\"})\n</code>\n</pre>\n", "senID": 3}, {"text": ["Alternatively:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n throw = object()  # sentinel\ndef dict_slice(D, keys, default=throw):\n  def get(k):\n    v = D.get(k, throw)\n    if v is not throw:\n      return v\n    if default is throw:\n      raise KeyError(k)\n    return default\n  return dict((k, get(k)) for k in keys)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["This is a hack.", "It will not work on all Python implementations distributions (in particular, those that do not have traceback.extract_stack."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "traceback.extract_stack", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import traceback\n\ndef make_dict(*expr):\n    (filename,line_number,function_name,text)=traceback.extract_stack()[-2]\n    begin=text.find('make_dict(')+len('make_dict(')\n    end=text.find(')',begin)\n    text=[name.strip() for name in text[begin:end].split(',')]\n    return dict(zip(text,expr))\n\nbar=True\nfoo=False\nprint(make_dict(bar,foo))\n# {'foo': False, 'bar': True}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that this hack is fragile:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n make_dict(bar,\n          foo)\n</code>\n</pre>\n", "senID": 3}, {"text": ["(calling make_dict on 2 lines) will not work."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Instead of trying to generate the dict out of the values foo and bar, \nit would be much more Pythonic to generate the dict out of the string variable names 'foo' and 'bar':"], "childNum": 6, "tag": "p", "senID": 5, "childList": [{"text": "values", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "childList": []}, {"text": "variable names", "childNum": 0, "tag": "strong", "childList": []}, {"text": "'foo'", "childNum": 0, "tag": "code", "childList": []}, {"text": "'bar'", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n dict([(name,locals()[name]) for name in ('foo','bar')])\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I've wanted to do this quite a lot.", "This hack is very similar to rlotun's suggestion, but it's a one-liner, which is important to me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n blah = 1\nblah_name = [ k for k,v in locals().iteritems() if v is blah][0]\n</code>\n</pre>\n", "senID": 1}]]