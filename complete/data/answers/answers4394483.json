[[{"text": ["Consider this.", "f is the object created by the make_incrementor function."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "make_incrementor", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It is a lambda, an \"anonymous function\"."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f= lambda x: x+42\n&gt;&gt;&gt; f(10)\n52\n</code>\n</pre>\n", "senID": 2}, {"text": ["The value for x showed up when we applied f to a value."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["First off, here's a translation into JavaScript:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n function makeIncrementor(n) {\n    return function (x) {return x + n}\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["A lambda expression consists of three parts."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "The word ", "tag": "none", "senID": 3}, {"text": "A list of parameters (In JavaScript, the part in ", "tag": "none", "senID": 4}, {"text": "Some expression to evaluate (In JavaScript, the part in ", "tag": "none", "senID": 5}]}, {"text": ["The list of parameters is the part before the colon.", "These parameters are visible within the scope of the expression.", "Whatever the expression evaluates to is returned as the result of the function."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Unlike in JavaScript, a lambda can only contain a single expression; you can't make an anonymous multi-line function with lambda."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Disclaimer: I have pretty much no Python background.", "This is going off my Scheme/lambda calculus knowledge."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["make_incrementor defines a function to make functions.", "make_incrementor(42) returns a function with x bounded to the lambda, and n with a value of 42.", "When you call the function f, the argument of f replaces the bound variable."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["lambda brings some lambda calculus to Python.", "In essence, this is what's happening: normally in lambda calculus a statement would look something like this:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lambda calculus", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Lambda_calculus"}]}, {"code": "<pre>\n<code>\n sum = add 3 4\n</code>\n</pre>\n", "senID": 1}, {"text": ["This would pass 3 and 4 to the add function and store the result in sum.", "However, we could also write something along the lines of add 3.", "Now, since add expects two arguments, we now get an object (or function, if you will) expecting one argument.", "That function will then call add with 3 as its first argument and whatever we pass it as the second argument.", "We can now do this:"], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "4", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "add", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "add 3", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "add", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "add", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n func = add 3\nsum = func 4\n</code>\n</pre>\n", "senID": 3}, {"text": ["This will be equivalent to the previous example.", "However, you can now use func whenever you want to add 3 to something.", "(Granted, this doesn't seem useful in this example, but in more complex situations it is)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "func", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["All this is closely related to currying, something very central in most functional languages.", "If you're interested in lambda calculus and its similarity to regular mathematics, I highly recommend that you take a look at Haskell."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "currying", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Currying"}, {"text": "functional languages", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Functional_language"}, {"text": "Haskell", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Haskell_%28programming_language%29"}]}], [{"text": ["When make_incrementor() is called it creates and returns a lambda function at that time.", "In the process the value of the argument n gets stored or remembered in the function object created.", "If you called it again with a different n a different function would be returned."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "make_incrementor()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["x gets its value from the parameter used to call f.\nn gets its value from the parameter used to call make_incrementor."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}, {"text": "make_incrementor", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["make_incrementor is a function that returns a function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def make_incrementor(n):\n  return lambda x: x + n\n</code>\n</pre>\n", "senID": 1}, {"text": ["When we call make_incrementor, we bind the parameter 42 to n, and return the concrete function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f = make_incrementor(42) # fill in n at this point and return a function\n</code>\n</pre>\n", "senID": 3}, {"text": ["This function we will return will therefore look like:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n lambda(x): x + 42\n</code>\n</pre>\n", "senID": 5}, {"text": ["f is bound to the returned function, so f will conceptually look like:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def f(x):\n   return x + 42\n</code>\n</pre>\n", "senID": 7}, {"text": ["When we call f, we provide the value for x"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "When we call f, we provide the value for x", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n f(1) # x == 1\nf(2) # x == 2\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Here's how I understand lambda:  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When we write x2, we often confuse two distinct ideas.", "Consider:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}]}, {"text": ["The first two statements are about the square of a particular but unspecified number.", "In those statements \"x\" represents an arbitrary single thing, and x2 represents a single related thing."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}]}, {"text": ["The third and fourth statement are about x2, the function.", "But this is not clearly communicated in 3. and 4. except by context and shared understanding of Calculus.", "We need a notational device to distinguish between x2 the single (but arbitrary) value, and x2 the function.", "The device also needs to communicate that it is a function of x.", "Therefore lambda is invented:"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"text": "2", "childNum": 0, "tag": "sup", "pos": 2, "childList": []}, {"text": "2", "childNum": 0, "tag": "sup", "pos": -1, "childList": []}, {"text": "of x", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["\"lambda x.x2\" is written to make this distinction and communicate \"the function of x whose value at x is x2\".", "The lambda operator takes a name (x) and an expression (x2) and returns a function.", "This has the same consequences as normal function definition, except that the function doesn't automatically receive a name."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"text": "2", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}, {"text": "2", "childNum": 0, "tag": "sup", "pos": -1, "childList": []}]}]]