[[{"text": ["numpy has a sinc() function, which is the normalised form of your function, i.e."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sinc()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n F = lambda x: sin(pi*x) / (pi*x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It handles the case for x == 0.0 correctly,"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "x == 0.0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n In [16]: x = numpy.linspace(-1,1,11)\n\nIn [17]: print x\n[-1.  -0.8 -0.6 -0.4 -0.2  0.   0.2  0.4  0.6  0.8  1. ]\n</code>\n</pre>\n", "senID": 3}, {"text": ["To \"unnormalize\" do,"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n In [22]: s = numpy.sinc(x/numpy.pi)\n\nIn [23]: print s.round(2)\n[ 0.84  0.9   0.94  0.97  0.99  1.    0.99  0.97  0.94  0.9   0.84]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["If you are already using numpy then:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = np.linspace(0.0,2*np.pi,100)\nb = np.sin(a)/a\n</code>\n</pre>\n", "senID": 1}, {"text": ["Will calculate without error leaving a NaN value in b[0].", "You could then just replace it by the following if that's how you want to handle it:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "NaN", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b[0]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n b[np.isnan(b)] = 1.0\n</code>\n</pre>\n", "senID": 3}, {"text": ["Update To suppress the warning, try: "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n np.seterr(divide='ignore') # Or possibly np.seterr(invalid='ignore')\n</code>\n</pre>\n", "senID": 5}], [{"text": ["In general you can't write a simple fix decorator as you might imagine.", "For example, a general function need not have a finite limiting value at a singularity as this particular example does."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fix", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Normal practice is to implement special handling on a case by case basis."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'll try this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def fix_singularity(F):\n...     def L(x):\n...         x1 = max(x,1e-16) if x &gt;=0 else min(x,-1e-16)\n...         return F(x1)\n...     return L\n...\n&gt;&gt;&gt; FS = fix_singularity(F)\n&gt;&gt;&gt; FS(0.0)\n1.0\n&gt;&gt;&gt; FS(-1e-17)\n1.0\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't know if this would work for your exact purposes, but there's a python library called sage that can handle quite a bit of Calculus-type situations."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sage", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sagemath.org/doc/tutorial/tour_algebra.html"}]}], [{"text": ["I believe sympy (symbolic python) can do limits, which is what you are really asking (that solution is only true as a limit).", "Regardless, you should check it out."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "limit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]