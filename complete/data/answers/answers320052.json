[[{"text": ["Unless your tree is really large or you have really high (real) requirements for speed, I would choose the recursive method.", "Easier to read, easier to code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I can't think of any big algorithmic improvements, but a simple microoptimisation you can make is to bind frequently called methods (such as stack.append / stack.pop) to locals (this saves a dictionary lookup)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def children(self):\n    stack = [self.entities]\n    push = stack.append\n    pop = stack.pop\n    while stack: \n        for e in pop():\n            yield e\n            if e.entities:\n                push(e.entities)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This gives a small (~15%) speedup by my tests (using 100 traversals of an 8-deep tree with 4 children at each node gives me the below timings:)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n children     :  5.53942348004\nchildren_bind:  4.77636131253\n</code>\n</pre>\n", "senID": 3}, {"text": ["Not huge, but worth doing if speed is important."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I'm not sure if you can reduce the overhead much on a full in-order traversal of a tree, if you use recursion the call stack will grow some, otherwise you must manually use a stack to push references of the children while visiting each node.", "Which way is fastest and uses less memory, depends on the expensiveness of the call stack vs. a normal stack.", "(I would guess the callstack is faster since it should be optimized for its use, and recursion is much easier to implement)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "full", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["If you don't care about the order you visit the nodes, some implementations of trees is actually stored in a dynamic array or linked list or stack wich you can traverse linearly if you don't care about the order it's traversed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["But why is it important to have a fast traversal anyway?", "Trees are good for searching, arrays/linked lists is good for full traversal.", "If you often need full in-order traversal but few searches and insertions/deletions, an ordered linked list might be best, if searching is what you do most you use a tree.", "If the data is really massive, so that memory overhead may render recursion impossible, you should use a database."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Recursive function calls are not incredibly inefficient, that is an old programming myth.", "(If they're badly implemented, they may incur a larger overhead than necessary, but calling them \"incredibly inefficient\" is plain wrong."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Remember: don't optimize prematurely, and never optimize without benchmarking first."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "never", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["If you have a lot of RAM and the tree doesn't change often, you can cache the result of the call:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def children(self):\n    if self._children_cache is not None:\n        return self._children_cache\n    # Put your code into collectChildren()\n    self._children_cache = self.collectChildren()\n    return self._children_cache\n</code>\n</pre>\n", "senID": 1}, {"text": ["Whenever the tree changes, set the cache to None.", "In this case, using recursive calls might be more effective since the results will accumulate faster."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I've written iterative tree-traversal code in the past: it's very ugly, and not fast, unless you know exactly how many children not only each subtree will have, but how many levels there are."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "exactly", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I don't know too much about Python internals of function calls, but I really can't imagine that your code snippet is faster than recursively traversing the tree."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The call stack (used for function calls, including recursive ones) is typically very fast.", "Going to the next object will only cost you a single function call.", "But in your snippet - where you use a stack object, going to the next object will cost you a stack.append (possibly allocating memory on heap), a stack.push (possibly freeing memory from heap), and a yield."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The main problem with recursive calls is that you might blow the stack if your tree gets too deep.", "This isn't likely to happen."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's a pair of small corrections."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def children(self):\n    stack = [self.entities]\n    for e in stack:\n        yield e\n        if e.entities:\n            stack.extend(e.entities)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I actually think the generator, using append, isn't visiting all the nodes.", "I think you mean to extend the stack with all entities, not append a simple list of entities to the stack."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "extend", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "append", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also, when the for loop terminates, the while loop in your original example will also terminate because there's no change to the empty stack after the for loop."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}]]