[[{"text": ["subprocess.Popen does exactly what you want."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "subprocess.Popen", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/subprocess.html"}]}, {"code": "<pre>\n<code>\n from subprocess import Popen\np = Popen(['watch', 'ls']) # something long running\n# ... do other stuff while subprocess is running\np.terminate()\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Edit to complete the answer from comments)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The Popen instance can do various other things like you can poll() it to see if it is still running, and you can communicate() with it to send it data on stdin, and wait for it to terminate."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "poll()", "tag": "a", "pos": 0, "childList": [{"text": "poll()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/subprocess.html#subprocess.Popen.poll"}, {"text": "poll()", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/subprocess.html#subprocess.Popen.communicate", "text": "communicate()", "childNum": 1, "tag": "a", "childList": [{"text": "communicate()", "tag": "code"}]}, {"text": "communicate()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If you want to run many processes in parallel and then handle them when they yield results, you can use polling like in the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from subprocess import Popen, PIPE\nimport time\n\nrunning_procs = [\n    Popen(['/usr/bin/my_cmd', '-i %s' % path], stdout=PIPE, stderr=PIPE)\n    for path in '/tmp/file0 /tmp/file1 /tmp/file2'.split()]\n\nwhile running_procs:\n    for proc in running_procs:\n        retcode = proc.poll()\n        if retcode is not None: # Process finished.\n            running_procs.remove(proc)\n            break\n    else: # No process is done, wait a bit and check again.\n        time.sleep(.1)\n        continue\n\n    # Here, `proc` has finished with return code `retcode`\n    if retcode != 0:\n        \"\"\"Error handling.\"\"\"\n    handle_results(proc.stdout)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The control flow there is a little bit convoluted because I'm trying to make it small -- you can refactor to your taste.", ":-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This has the advantage of servicing the early-finishing requests first.", "If you call communicate on the first running process and that turns out to run the longest, the other running processes will have been sitting there idle when you could have been handling their results."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "This has the advantage of servicing the early-finishing requests first.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "communicate", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["What I am wondering is if this [os.system()] is the proper way to accomplish such a thing?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "What I am wondering is if this [os.system()] is the proper way to accomplish such a thing?", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["No.", "os.system() is not the proper way.", "That's why everyone says to use subprocess.  "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "os.system()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "subprocess", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["For more information, read http://docs.python.org/library/os.html#os.system"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://docs.python.org/library/os.html#os.system", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/os.html#os.system"}]}], [{"text": ["I've had good success with the asyncproc module, which deals nicely with the output from the processes.", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "asyncproc", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.lysator.liu.se/~bellman/download/asyncproc.py"}]}, {"code": "<pre>\n<code>\n import os\nfrom asynproc import Process\nmyProc = Process(\"myprogram.app\")\n\nwhile True:\n    # check to see if process has ended\n    poll = myProc.wait(os.WNOHANG)\n    if poll != None:\n        break\n    # print any new output\n    out = myProc.read()\n    if out != \"\":\n        print out\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using pexpect [ http://www.noah.org/wiki/Pexpect ] with non-blocking readlines is another way to do this.", "Pexpect solves the deadlock problems, allows you to easily run the processes in the background, and gives easy ways to have callbacks when your process spits out predefined strings, and generally makes interacting with the process much easier."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.noah.org/wiki/Pexpect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.noah.org/wiki/Pexpect"}]}], [{"text": ["I have the same problem trying to connect to an 3270 terminal using the s3270 scripting software in Python.", "Now I'm solving the problem with an subclass of Process that I found here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://code.activestate.com/recipes/440554/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.activestate.com/recipes/440554/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/440554/"}]}, {"text": ["And here is the sample taken from file:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def recv_some(p, t=.1, e=1, tr=5, stderr=0):\n    if tr &lt; 1:\n        tr = 1\n    x = time.time()+t\n    y = []\n    r = ''\n    pr = p.recv\n    if stderr:\n        pr = p.recv_err\n    while time.time() &lt; x or r:\n        r = pr()\n        if r is None:\n            if e:\n                raise Exception(message)\n            else:\n                break\n        elif r:\n            y.append(r)\n        else:\n            time.sleep(max((x-time.time())/tr, 0))\n    return ''.join(y)\n\ndef send_all(p, data):\n    while len(data):\n        sent = p.send(data)\n        if sent is None:\n            raise Exception(message)\n        data = buffer(data, sent)\n\nif __name__ == '__main__':\n    if sys.platform == 'win32':\n        shell, commands, tail = ('cmd', ('dir /w', 'echo HELLO WORLD'), '\\r\\n')\n    else:\n        shell, commands, tail = ('sh', ('ls', 'echo HELLO WORLD'), '\\n')\n\n    a = Popen(shell, stdin=PIPE, stdout=PIPE)\n    print recv_some(a),\n    for cmd in commands:\n        send_all(a, cmd + tail)\n        print recv_some(a),\n    send_all(a, 'exit' + tail)\n    print recv_some(a, e=0)\n    a.wait()\n</code>\n</pre>\n", "senID": 3}]]