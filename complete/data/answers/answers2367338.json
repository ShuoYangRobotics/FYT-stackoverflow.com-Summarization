[[{"text": ["Are you aware of the fact that COPY FROM lets you specify which columns (as well as in which order they) are to be imported?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "COPY FROM", "tag": "a", "pos": 0, "childList": [{"text": "COPY FROM", "tag": "code"}], "childNum": 1, "href": "http://www.postgresql.org/docs/8.3/static/sql-copy.html"}, {"text": "COPY FROM", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n COPY tablename ( column1, column2, ... ) FROM ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Specifying directly, at the Postgres level, which columns to import and in what order, will typically be the fastest and most efficient import method."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This having been said, there is a much simpler (and portable) way of using sed (than what has been presented in other posts) to replace annth occurrence, e.g.", "replace the 4th and 5th occurrences of a comma with double commas:"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "sed", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "replace annth occurrence", "tag": "a", "pos": -1, "childList": [{"text": "n", "tag": "em"}], "childNum": 1, "href": "http://www.grymoire.com/Unix/Sed.html#uh-8"}, {"text": "n", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n echo '1,23,56,we,89,2009-12-06' | sed -e 's/,/,,/5;s/,/,,/4'\n</code>\n</pre>\n", "senID": 4}, {"text": ["produces:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n 1,23,56,we,,89,,2009-12-06\n</code>\n</pre>\n", "senID": 6}, {"text": ["Notice that I replaced the rightmost fields (#5) first."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["I see that you have also tagged your question as perl-related, although you make no explicit reference to perl in the body of the question; here would be one possible implementation which gives you the flexibility of also reordering or otherwise processing fields:"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "perl", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "perl", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n echo '1,23,56,we,89,2009-12-06' |\n  perl -F/,/ -nae 'print \"$F[0],$F[1],$F[2],$F[3],,$F[4],,$F[5]\"'\n</code>\n</pre>\n", "senID": 9}, {"text": ["also produces:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n 1,23,56,we,,89,,2009-12-06\n</code>\n</pre>\n", "senID": 11}, {"text": ["Very similarly with awk, for the record:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "awk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n echo '1,23,56,we,89,2009-12-06' |\n  awk -F, '{print $1\",\"$2\",\"$3\",\"$4\",,\"$5\",,\"$6}'\n</code>\n</pre>\n", "senID": 13}, {"text": ["I will leave Python to someone else.", ":)"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["Small note on the Perl example: I am using the -a and -F options to autosplit so I have a shorter command string; however, this leaves the newline embedded in the last field ($F[5]) which is fine as long as that field doesn't have to be reordered somewhere else.", "Should that situation arise, slightly more typing would be needed in order to zap the newline via chomp, then split by hand and finally print our own newline character \\n (the awk example above does not have this problem):"], "childNum": 7, "tag": "p", "senID": 15, "childList": [{"text": "-a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "-F", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "$F[5]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "chomp", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "split", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "childList": []}, {"text": "awk", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n perl -ne 'chomp;@F=split/,/;print \"$F[0],$F[1],$F[2],$F[3],,$F[4],,$F[5]\\n\"'\n</code>\n</pre>\n", "senID": 16}, {"code": "<pre>\n<code>\n COMMAS_TO_DOUBLE=\"1 4 5\"\necho '1,23,56,we,89,2009-12-06' |\n  sed -e `for f in $COMMAS_TO_DOUBLE ; do echo \"s/,/,,/$f\" ; done |\n    sort -t/ -k4,4nr | paste -s -d ';'`\n\n1,,23,56,we,,89,,2009-12-06\n</code>\n</pre>\n", "senID": 17}, {"text": ["Sorry, couldn't resist it.", ":)"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}], [{"text": ["To answer your first question, sed would have less overhead, but might be painful.", "awk would be a little better (it's more powerful).", "Perl or Python have more overhead, but would be easier to work with (regarding Perl, that's maybe a little subjective ;).", "Personally, I'd use Perl)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sed", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "awk", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["As far as the second question, I think the problem might be a little more complex.", "For example, don't you need to examine the string to figure out what fields are actually missing?", "Or is it guaranteed that it will always be the 4th and 5th?", "If it's the first case case, it would be way easier to do this in Python or Perl rather than in sed.", "Otherwise:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "way", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "sed", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n echo \"1,23,56,we,89,2009-12-06\" | sed -e 's/\\([^,]\\+\\),\\([^,]\\+\\),\\([^,]\\+\\),\\([^,]\\+\\),\\([^,]\\+\\),/\\1,\\2,\\3,\\4,,\\5,,/'\n</code>\n</pre>\n", "senID": 2}, {"text": ["or (easier on the eyes):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n echo \"1,23,56,we,89,2009-12-06\" | sed -e 's/\\(\\([^,]\\+,\\)\\{3\\}\\)\\([^,]\\+\\),\\([^,]\\+\\),/\\1,\\3,,\\4,,/'\n</code>\n</pre>\n", "senID": 4}, {"text": ["This will add a comma after the 5th and 4th columns assuming there are no other commas in the text."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Or you can use two seds for something that's a little less ugly (only slightly, though):"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "sed", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n echo \"1,23,56,we,89,2009-12-06\" | sed -e 's/\\(\\([^,]*,\\)\\{4\\}\\)/\\1,/' | sed -e 's/\\(\\([^,]*,\\)\\{6\\}\\)/\\1,/'\n</code>\n</pre>\n", "senID": 7}], [{"text": ["@OP, you are processing a csv file, which have distinct fields and delimiters.", "Use a tool that can split on delimiters and give you fields to work with easily.", "sed is not one of them, although it can be done, as some of the answers suggested, but you will get sed regex that is hard to read when it gets complicated.", "Use tools like awk/Python/Perl where they work with fields and delimiters easily, best of all, modules that specifically tailored to processing csv is available.", "For your example, a simple Python approach (without the use of csv module which ideally you should try to use it)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for line in open(\"file\"):\n    line=line.rstrip() #strip new lines\n    sline=line.split(\",\")\n    if len(sline) &lt; 8: # you want exact 8 fields\n        sline.insert(4,\"\")\n        sline.insert(6,\"\")\n        line=','.join(sline)\n    print line\n</code>\n</pre>\n", "senID": 1}, {"text": ["output"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ more file\n1,23,56,we,89,2009-12-06\n\n$ ./python.py\n1,23,56,we,,89,,2009-12-06\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n sed 's/^([^,]*,){4}/&amp;,/' &lt;original.csv &gt;output.csv\n</code>\n</pre>\n", "senID": 0}, {"text": ["Will add a comma after the 4th comma separated field (by matching 4 repetitions of &lt;anything&gt;, and then adding a comma after that).", "Note that there is a catch; make sure none of these values are quoted strings with commas in them."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "&lt;anything&gt;,", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You could chain multiple replacements via pipes if necessary, or modify the regex to add in any needed commas at the same time (though that gets more complex; you'd need to use subgroup captures in your replacement text)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Don't know regarding speed, but here is sed expr that should do the job:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sed -i 's/\\(\\([^,]*,\\)\\{4\\}\\)/\\1,/' file_name\n</code>\n</pre>\n", "senID": 1}, {"text": ["Just replace 4 by desured number of columns"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Depending on your requirements, consider using ETL software for this and future tasks.", "Tools like Pentaho and Talend offer you a great deal of flexibility and you don't have to write a single line of code."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "ETL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Etl"}, {"text": "Pentaho", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.pentaho.com/"}, {"href": "http://www.talend.com/index.php", "text": "Talend", "childNum": 0, "tag": "a", "childList": []}]}]]