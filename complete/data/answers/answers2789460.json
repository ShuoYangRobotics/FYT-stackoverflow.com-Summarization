[[{"text": ["You can use a decorator to modify the function if you want.", "However, since it's not a decorator applied at the time of the initial definition of the function, you won't be able to use the @ syntactic sugar to apply it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class A(object):\n...     def test(self):\n...         print \"orig\"\n...\n&gt;&gt;&gt; first_a = A()\n&gt;&gt;&gt; first_a.test()\norig\n&gt;&gt;&gt; def decorated_test(fn):\n...     def new_test(*args, **kwargs):\n...         fn(*args, **kwargs)\n...         print \"new\"\n...     return new_test\n...\n&gt;&gt;&gt; A.test = decorated_test(A.test)\n&gt;&gt;&gt; new_a = A()\n&gt;&gt;&gt; new_a.test()\norig\nnew\n&gt;&gt;&gt; first_a.test()\norig\nnew\n</code>\n</pre>\n", "senID": 1}, {"text": ["Do note that it will modify the method for existing instances as well."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: modified the args list for the decorator to the better version using args and kwargs"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "better", "childNum": 0, "tag": "em", "childList": []}, {"text": "args", "childNum": 0, "tag": "code", "childList": []}, {"text": "kwargs", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The typical way to add functionality to a function is to use a decorator (using the wraps function):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "decorator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators"}, {"href": "http://stackoverflow.com/questions/308999/what-does-functools-wraps-do", "text": "the wraps function", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from functools import wraps\n\ndef add_message(func):\n    @wraps\n    def with_additional_message(*args, **kwargs)\n        try:\n            return func(*args, **kwargs)\n        finally:\n            print \"and here\"\n    return with_additional_message\n\nclass A:\n    @add_message\n    def test(self):\n        print \"here\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, it really depends on what you're trying to accomplish.", "I use decorators a lot, but if all I wanted to do was to print extra messages, I'd probably do something like"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class A:\n    def __init__(self):\n        self.messages = [\"here\"]\n\n    def test(self):\n        for message in self.messages:\n            print message\n\na = A()\na.test()    # prints \"here\"\n\na.messages.append(\"and here\")\na.test()    # prints \"here\" then \"and here\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["This requires no meta-programming, but then again your example was probably greatly simplified from what you actually need to do.", "Perhaps if you post more detail about your specific needs, we can better advise what the Pythonic approach would be."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["EDIT: Since it seems like you want to call functions, you can have a list of functions instead of a list of messages.", "For example:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class A:\n    def __init__(self):\n        self.funcs = []\n\n    def test(self):\n        print \"here\"\n        for func in self.funcs:\n            func()\n\ndef test2():\n    print \"and here\"\n\na = A()\na.funcs.append(test2)\na.test()    # prints \"here\" then \"and here\"\n</code>\n</pre>\n", "senID": 6}, {"text": ["Note that if you want to add functions that will be called by all instances of A, then you should make funcs a class field rather than an instance field, e.g."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "A", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "funcs", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class A:\n    funcs = []\n    def test(self):\n        print \"here\"\n        for func in self.funcs:\n            func()\n\ndef test2():\n    print \"and here\"\n\nA.funcs.append(test2)\n\na = A()\na.test()    # print \"here\" then \"and here\"\n</code>\n</pre>\n", "senID": 8}], [{"text": ["There are a lot of really good suggestions above, but one I didn't see was passing in a function with the call.", "Might look something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def test(self, deep=lambda self: self):\n        print \"here\"\n        deep(self)\ndef test2(self):\n    print \"and here\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Using this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.test()\nhere\n&gt;&gt;&gt; a.test(test2)\nhere\nand here\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Why not use inheritance?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class B(A):\n    def test(self):\n        super(B, self).test()\n        print \"and here\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Copy and paste, enjoy!!!!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python \n\ndef say(host, msg): \n   print '%s says %s' % (host.name, msg) \n\ndef funcToMethod(func, clas, method_name=None): \n   setattr(clas, method_name or func.__name__, func) \n\nclass transplant: \n   def __init__(self, method, host, method_name=None): \n      self.host = host \n      self.method = method \n      setattr(host, method_name or method.__name__, self) \n\n   def __call__(self, *args, **kwargs): \n      nargs = [self.host] \n      nargs.extend(args) \n      return apply(self.method, nargs, kwargs) \n\nclass Patient: \n   def __init__(self, name): \n      self.name = name \n\nif __name__ == '__main__': \n   jimmy = Patient('Jimmy') \n   transplant(say, jimmy, 'say1') \n   funcToMethod(say, jimmy, 'say2') \n\n   jimmy.say1('Hello') \n   jimmy.say2(jimmy, 'Good Bye!')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If your class A inherits from object, you could do something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def test2():\n    print \"test\"\n\nclass A(object):\n    def test(self):\n        setattr(self, \"test2\", test2)\n        print self.test2\n        self.test2()\n\ndef main():\n    a = A()\n    a.test()\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code has no interest and you can't use self in your new method you added.", "I just found this code fun, but I will never use this.", "I don't like to dynamicaly change the object itself."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It's the fastest way, and more understandable."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]