[[{"text": ["You can always use a NamedTuple"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import collections\n&gt;&gt;&gt; Enum = collections.namedtuple('Enum','Add Subtract Multiply Divide None_')\n&gt;&gt;&gt; Enum(*range(1,6))\nEnum(Add=1, Subtract=2, Multiply=3, Divide=4, None_=5)\n&gt;&gt;&gt; operations = _\n&gt;&gt;&gt; operations.Add\n1\n</code>\n</pre>\n", "senID": 1}, {"text": ["On newer Python versions, you can't assign to None, so I changed it to None_."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None_", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["In Python any attribute or method is considered public unless you put underscores at the start of its name.", "Here is the relevant section in the Python 2.7 tutorial."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Here is the relevant section in the Python 2.7 tutorial", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#tut-private"}]}, {"text": ["Python doesn't have a way of exactly duplicating the function of static, but any attributes you define on a class will be visible in instances in the same way as static variables are.", "Just attribute = value inside your class definition and you're fine."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "static", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "static", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "attribute = value", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You can't make values constant in Python, but the convention is to use UPPERCASE_IDENTIFIERS to indicate that intention."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "constant", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "UPPERCASE_IDENTIFIERS", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Enums do not exist.", "In Python ordinary strings constants are usually used for this purpose.", "Just pass \"add\" \"subtract\", \"multiply\", \"divide\" or None to your function."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "\"add\"", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "\"subtract\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "\"multiply\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "\"divide\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For example, in your parser"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre class=\"lang-java prettyprint-override\">\n<code>\n if (operator.equals(\"+\"))\n    op = Expression.Operations.Add;\n</code>\n</pre>\n", "senID": 5}, {"text": ["would become"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n if operator == \"+\":\n    op = \"add\"\n</code>\n</pre>\n", "senID": 7}, {"text": ["and in your evaluator "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre class=\"lang-java prettyprint-override\">\n<code>\n if (op == Expression.Operations.Add)\n    value = a + b;\n</code>\n</pre>\n", "senID": 9}, {"text": ["would become"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n if op == \"add\"\n    value = a + b\n</code>\n</pre>\n", "senID": 11}], [{"text": ["Python doesn't have an enum class.", "It just does it using normal integers.", "The easiest way to make a template part of a class is to do the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Operation:\n    ADD, SUBTRACT, MULTIPLY, DIVIDE, NONE = range(5)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which will assign add to 0 and none to 4.", "This is the most clean way of doing it (and it will guarantee that you don't have any enums in this sequence that are the same number and that you haven't missed assigning something to one of the numbers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A dict can provide the mapping between the symbol and the function.", "The operator module provides convenient access to the built-in functions used in expressions.", "Also, you can protect some attributes from getting accidentally modified by buggy code by making them read-only properties.", "Attempting to modify them will raise an AttributeError at run time.", "If someone really needs write access it's still available via the underscore prefixed variables, but that's a private interface."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "operator", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import operator\n\nclass Expression(object):\n\n    _OP_MAP = dict((x, getattr(operator, y)) for x, y in \n        [('*', 'mul'), ('/', 'truediv'), ('//', 'floordiv'), \n         ('+', 'add'), ('-', 'sub')])\n\n    _OP_MAP[None] = lambda a, b: a\n\n    a = property(lambda self: self._a)   #read-only interface\n    b = property(lambda self: self._b) \n    op = property(lambda self: self._op)\n\n    def __init__(self, value1=0, value2=0, operation=None):\n        self._a = value1                 #mutable -- we're all adults\n        self._b = value2\n        self._op = self._OP_MAP[operation]\n\n    def parse_string(self, expression_string, variables): \n        #...\n        self._op = self._OP_MAP.get(operator) #defaults to None\n\n    def evaluate(self):\n        return self.op(self.a, self.b)\n\n    def __repr__(self): \n        for k, v in self._OP_MAP.items():\n            if self.op == v:\n                return '{0} {1} {2}'.format(self.a, k, self.b)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["best way to do it would be like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Operations:\n    Add=1\n    Subtract=2\n    Multiply=3\n    Divide=4\n    None=5\n</code>\n</pre>\n", "senID": 1}], [{"text": ["enums in java rely on the http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern - enums in java are like: Enum>.", "so unless python supports that sort of thing you may have to use something like the\nTypesafe Enum Pattern: http://java.sun.com/developer/Books/effectivejava/Chapter5.pdf"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"href": "http://java.sun.com/developer/Books/effectivejava/Chapter5.pdf", "text": "http://java.sun.com/developer/Books/effectivejava/Chapter5.pdf", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I like enums and I wish Python had an official enum of some sort."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is a link to another answer I wrote about Python enums:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["What&#39;s the best way to implement an &#39;enum&#39; in Python?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "What&#39;s the best way to implement an &#39;enum&#39; in Python?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/36932/whats-the-best-way-to-implement-an-enum-in-python/1753340#1753340"}]}, {"text": ["And here's a direct link to the recipe I recommend there:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["http://code.activestate.com/recipes/413486/"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://code.activestate.com/recipes/413486/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/413486/"}]}]]