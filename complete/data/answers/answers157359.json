[[{"text": ["time.clock() only measures wallclock time on Windows.", "On other systems, time.clock() actually measures CPU-time.", "On those systems time.time() is more suitable for wallclock time, and it has as high a resolution as Python can manage -- which is as high as the OS can manage; usually using gettimeofday(3) (microsecond resolution) or ftime(3) (millisecond resolution.", ") Other OS restrictions actually make the real resolution a lot higher than that.", "datetime.datetime.now() uses time.time(), so time.time() directly won't be better."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For the record, if I use datetime.datetime.now() in a loop, I see about a 1/10000 second resolution.", "From looking at your data, you have much, much coarser resolution than that.", "I'm not sure if there's anything Python as such can do, although you may be able to convince the OS to do better through other means."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I seem to recall that on Windows, time.clock() is actually (slightly) more accurate than time.time(), but it measures wallclock since the first call to time.clock(), so you have to remember to 'initialize' it first."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You're unlikely to get sufficiently fine-grained control that you can completely eliminate the possibility\nof duplicate timestamps - you'd need resolution smaller than the time it takes to generate a datetime object.", "There are a couple of other approaches you might take to deal with it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The following will guarantee unique timestamp values:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class TimeStamper(object):\n        def __init__(self):\n            self.lock = threading.Lock()\n            self.prev = None\n            self.count = 0\n\n         def getTimestamp(self):\n             with self.lock:\n                 ts = str(datetime.now())\n                 if ts == self.prev:\n                     ts +='.%04d' % self.count\n                     self.count += 1\n                 else:\n                     self.prev = ts\n                     self.count = 1\n             return ts\n</code>\n</pre>\n", "senID": 2}, {"text": ["For multiple processes (rather than threads), it gets a bit trickier though."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Thank you all for your contributions - they've all be very useful.", "Brian's answer seems closest to what I eventually went with (i.e.", "deal with it but use a sort of unique identifier - see below) so I've accepted his answer.", "I managed to consolidate all the various data receivers into a single thread which is where the timestamping is now done using my new AccurrateTimeStamp class.", "What I've done works as long as the time stamp is the first thing to use the clock."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "AccurrateTimeStamp", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["As S.Lott stipulates, without a realtime OS, they're never going to be absolutely perfect.", "I really only wanted something that would let me see relative to each incoming chunk of data, when things were being received so what I've got below will work well."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Thanks again everyone!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import time\n\nclass AccurateTimeStamp():\n    \"\"\"\n    A simple class to provide a very accurate means of time stamping some data\n    \"\"\"\n\n    # Do the class-wide initial time stamp to synchronise calls to \n    # time.clock() to a single time stamp\n    initialTimeStamp = time.time()+ time.clock()\n\n    def __init__(self):\n        \"\"\"\n        Constructor for the AccurateTimeStamp class.\n        This makes a stamp based on the current time which should be more \n        accurate than anything you can get out of time.time().\n        NOTE: This time stamp will only work if nothing has called clock() in\n        this instance of the Python interpreter.\n        \"\"\"\n        # Get the time since the first of call to time.clock()\n        offset = time.clock()\n\n        # Get the current (accurate) time\n        currentTime = AccurateTimeStamp.initialTimeStamp+offset\n\n        # Split the time into whole seconds and the portion after the fraction \n        self.accurateSeconds = int(currentTime)\n        self.accuratePastSecond = currentTime - self.accurateSeconds\n\n\ndef GetAccurateTimeStampString(timestamp):\n    \"\"\"\n    Function to produce a timestamp of the form \"13:48:01.87123\" representing \n    the time stamp 'timestamp'\n    \"\"\"\n    # Get a struct_time representing the number of whole seconds since the \n    # epoch that we can use to format the time stamp\n    wholeSecondsInTimeStamp = time.localtime(timestamp.accurateSeconds)\n\n    # Convert the whole seconds and whatever fraction of a second comes after\n    # into a couple of strings \n    wholeSecondsString = time.strftime(\"%H:%M:%S\", wholeSecondsInTimeStamp)\n    fractionAfterSecondString = str(int(timestamp.accuratePastSecond*1000000))\n\n    # Return our shiny new accurate time stamp   \n    return wholeSecondsString+\".\"+fractionAfterSecondString\n\n\nif __name__ == '__main__':\n    for i in range(0,500):\n        timestamp = AccurateTimeStamp()\n        print GetAccurateTimeStampString(timestamp)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here is a thread about Python timing accuracy:\nhttp://stackoverflow.com/questions/85451/python-timeclock-vs-timetime-accuracy"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"href": "http://stackoverflow.com/questions/85451/python-timeclock-vs-timetime-accuracy", "text": "http://stackoverflow.com/questions/85451/python-timeclock-vs-timetime-accuracy", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["\"timestamp should be accurate relative to each other \""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Why time?", "Why not a sequence number?", "If it's any client of client-server application, network latency makes timestamps kind of random."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Are you matching some external source of information?", "Say a log on another application?", "Again, if there's a network, those times won't be too close."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you must match things between separate apps, consider passing GUID's around so that both apps log the GUID value.", "Then you could be absolutely sure they match, irrespective of timing differences."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you want the relative order to be exactly right, maybe it's enough for your logger to assign a sequence number to each message in the order they were received."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "relative", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I wanted to thank J. Cage for this last post. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For my work, \"reasonable\" timing of events across  processes and platforms is essential.", "There are obviously lots of places where things can go askew (clock drift, context switching, etc.", "), however this accurate timing solution will, I think, help to ensure that the time stamps recorded are sufficiently accurate to see the other sources of error. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["That said, there are a couple of details I wonder about that are explained in When MicroSeconds Matter.", "For example, I think time.clock() will eventually wrap.", "I think for this to work for a long running process, you might have to handle that."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "When MicroSeconds Matter", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/library/i-seconds/"}]}]]