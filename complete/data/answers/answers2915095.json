[[{"code": "<pre>\n<code>\n import random\nimport collections\n\ndef maxvote(nlabels):\n  cnt = collections.defaultdict(int)\n  for i in nlabels:\n    cnt[i] += 1\n  maxv = max(cnt.itervalues())\n  return random.choice([k for k,v in cnt.iteritems() if v == maxv])\n\nprint maxvote([1,3,4,5,5,5,3,3,11])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["In Python 3.1 or future 2.7 you'd be able to use Counter:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Counter", "tag": "a", "pos": 0, "childList": [{"text": "Counter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/py3k/library/collections.html#collections.Counter"}, {"text": "Counter", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; Counter([1,3,4,5,5,5,3,12,11]).most_common(1)\n[(5, 3)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you don't have access to those versions of Python you could do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import defaultdict\n&gt;&gt;&gt; d = defaultdict(int)\n&gt;&gt;&gt; for i in nLabels:\n    d[i] += 1\n\n\n&gt;&gt;&gt; max(d, key=lambda x: d[x])\n5\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It appears to run in O(n) time.", "However there may be a bottleneck in checking if nLabel in count since this operation could also potentially run O(n) time as well, making the total efficiency O(n^2). "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if nLabel in count", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Using a dictionary instead of a list in this case is the only major efficiency boost I can spot."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'm not sure what exactly you want to optimize, but this should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\ndef maxVote(nLabels):\n   count = defaultdict(int)\n   for nLabel in nLabels:\n      count[nLabel] += 1\n   maxCount = max(count.itervalues())\n   maxList = [k for k in count if count[k] == maxCount]\n   return random.choice(maxList)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Idea 1"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Does the return really need to be random, or can you just return a maximum?", "If you just need to nondeterministically return a max frequency, you could just store a single label and remove the list logic, including"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "a", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n elif count[nLabel]==maxCount:\n        maxList.append(nLabel)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Idea 2"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["If this method is called frequently, would it be possible to only work on new data, as opposed to the entire data set?", "You could cache your count map and then only process new data.", "Assuming your data set is large and the calculations are done online, this could net huge improvements."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "online", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}], [{"text": ["Complete example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\ndef max_vote(l):\n    \"\"\"\n    Return the element with the (or a) maximum frequency in ``l``.\n    \"\"\"\n    unsorted = [(a, l.count(a)) for a in set(l)]\n    return sorted(unsorted, key=lambda x: x[1]).pop()[0]\n\nif __name__ == '__main__':\n    votes = [1, 3, 4, 5, 5, 5, 3, 12, 11]\n    print max_vote(votes)\n    # =&gt; 5\n</code>\n</pre>\n", "senID": 1}, {"text": ["Benchmarks:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport random\nimport collections\n\ndef max_vote_2(l):\n    \"\"\"\n    Return the element with the (or a) maximum frequency in ``l``.\n    \"\"\"\n    unsorted = [(a, l.count(a)) for a in set(l)]\n    return sorted(unsorted, key=lambda x: x[1]).pop()[0]\n\ndef max_vote_1(nlabels):\n    cnt = collections.defaultdict(int)\n    for i in nlabels:\n        cnt[i] += 1\n        maxv = max(cnt.itervalues())\n    return random.choice([k for k,v in cnt.iteritems() if v == maxv])\n\nif __name__ == '__main__':\n    from timeit import Timer\n    votes = [1, 3, 4, 5, 5, 5, 3, 12, 11]\n    print max_vote_1(votes)\n    print max_vote_2(votes)\n\n    t = Timer(\"votes = [1, 3, 4, 5, 5, 5, 3, 12, 11]; max_vote_2(votes)\", \\\n        \"from __main__ import max_vote_2\")\n    print 'max_vote_2', t.timeit(number=100000)\n\n    t = Timer(\"votes = [1, 3, 4, 5, 5, 5, 3, 12, 11]; max_vote_1(votes)\", \\\n        \"from __main__ import max_vote_1\")\n    print 'max_vote_1', t.timeit(number=100000)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Yields:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n 5\n5\nmax_vote_2 1.79455208778\nmax_vote_1 2.31705093384\n</code>\n</pre>\n", "senID": 5}]]