[[{"text": ["Beautiful soup is still probably your best bet."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Beautiful soup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}]}, {"text": ["If you need \"JavaScript support\" for the purpose of intercepting Ajax requests then you should use some sort of capture too (such as YATT) to monitor what those requests are, and then emulating / parsing them."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "YATT", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pocketsoap.com/YATT/"}]}, {"text": ["If you need \"JavaScript support\" in order to be able to see what the end result of a page with static JavaScript is, then my first choice would be to try and figure out what the JavaScript is doing on a case-by-case basis (e.g.", "if the JavaScript is doing something based on some Xml, then just parse the Xml directly instead)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you really want \"JavaScript support\" (as in you want to see what the html is after scripts have been run on a page) then I think you will probably need to create an instance of some browser control, and then read the resulting html / dom back from the browser control once its finished loading and parse it normally with beautiful soup.", "That would be my last resort however."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There are many options when dealing with static HTML, which the other responses cover.", "However if you need JavaScript support and want to stay in Python I recommend using webkit to render the webpage (including the JavaScript) and then examine the resulting HTML.", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "webkit", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qtwebkit.html"}]}, {"code": "<pre>\n<code>\n import sys\nimport signal\nfrom PyQt4.QtCore import *\nfrom PyQt4.QtGui import *\nfrom PyQt4.QtWebKit import QWebPage\n\nclass Render(QWebPage):\n    def __init__(self, url):\n        self.app = QApplication(sys.argv)\n        QWebPage.__init__(self)\n        self.html = None\n        signal.signal(signal.SIGINT, signal.SIG_DFL)\n        self.connect(self, SIGNAL('loadFinished(bool)'), self._finished_loading)\n        self.mainFrame().load(QUrl(url))\n        self.app.exec_()\n\n    def _finished_loading(self, result):\n        self.html = self.mainFrame().toHtml()\n        self.app.quit()\n\n\nif __name__ == '__main__':\n    try:\n        url = sys.argv[1]\n    except IndexError:\n        print 'Usage: %s url' % sys.argv[0]\n    else:\n        javascript_html = Render(url).html\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here you go: http://scrapy.org/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://scrapy.org/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://scrapy.org/"}]}], [{"text": ["Selenium maybe?", "It allows you to automate an actual browser (Firefox, IE, Safari) using python (amongst other languages).", "It is meant for testing websites, but seems it should be usable for scraping as well.", "(disclaimer: never used it myself)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Selenium", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://seleniumhq.org/"}]}], [{"text": ["I have not found anything for this.", "I use a combination of beautifulsoup and custom routines..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["you can try spidermonkey ?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "spidermonkey", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/python-spidermonkey/"}]}]]