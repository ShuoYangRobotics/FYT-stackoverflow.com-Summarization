[[{"text": ["I was inspired by lost-theory's decorator goodness, and after playing about with it for a bit came up with this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def actual_kwargs():\n    \"\"\"\n    Decorator that provides the wrapped function with an attribute 'actual_kwargs'\n    containing just those keyword arguments actually passed in to the function.\n    \"\"\"\n    def decorator(function):\n        def inner(*args, **kwargs):\n            inner.actual_kwargs = kwargs\n            return function(*args, **kwargs)\n        return inner\n    return decorator\n\n\nif __name__ == \"__main__\":\n\n    @actual_kwargs()\n    def func(msg, a=None, b=False, c='', d=0):\n        print msg\n        for arg, val in sorted(func.actual_kwargs.iteritems()):\n            print '  %s: %s' % (arg, val)\n\n    func(\"I'm only passing a\", a='a')\n    func(\"Here's b and c\", b=True, c='c')\n    func(\"All defaults\", a=None, b=False, c='', d=0)\n    func(\"Nothin'\")\n    try:\n        func(\"Invalid kwarg\", e=\"bogon\")\n    except TypeError, err:\n        print 'Invalid kwarg\\n  %s' % err\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which prints this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\nI'm only passing a\n  a: a\nHere's b and c\n  b: True\n  c: c\nAll defaults\n  a: None\n  b: False\n  c: \n  d: 0\nNothin'\nInvalid kwarg\n  func() got an unexpected keyword argument 'e'\n</pre>\n", "senID": 3}, {"text": ["I'm happy with this.", "A more flexible approach is to pass the name of the attribute you want to use to the decorator, instead of hard-coding it to 'actual_kwargs', but this is the simplest approach that illustrates the solution."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Mmm, Python is tasty."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Here is the easiest and simplest way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def func(a=None, b=None, c=None):\n    args = locals().copy()\n    print args\n\nfunc(2, \"egg\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["This give the output: {'a': 2, 'c': None, 'b': 'egg'}.", "The reason args should be a copy of the locals dictionary is that dictionaries are mutable, so if you created any local variables in this function args would contain all of the local variables and their values, not just the  arguments."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "{'a': 2, 'c': None, 'b': 'egg'}", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "args", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "locals", "childNum": 0, "tag": "code", "childList": []}, {"text": "args", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["More documentation on the built-in locals function here."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "locals", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/functions.html#locals", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["One possibility:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f(**kw):\n  acceptable_names = set('a', 'b', 'c')\n  if not (set(kw) &lt;= acceptable_names):\n    raise WhateverYouWantException(whatever)\n  ...proceed...\n</code>\n</pre>\n", "senID": 1}, {"text": ["IOW, it's very easy to check that the passed-in names are within the acceptable set and otherwise raise whatever you'd want Python to raise (TypeError, I guess;-).", "Pretty easy to turn into a decorator, btw."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Another possibility:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n _sentinel = object():\ndef f(a=_sentinel, b=_sentinel, c=_sentinel):\n   ...proceed with checks `is _sentinel`...\n</code>\n</pre>\n", "senID": 4}, {"text": ["by making a unique object _sentinel you remove the risk that the caller might be accidentally passing None (or other non-unique default values the caller could possibly pass).", "This is all object() is good for, btw: an extremely-lightweight, unique sentinel that cannot possibly be accidentally confused with any other object (when you check with the is operator)."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "_sentinel", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "object()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "is", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Either solution is preferable for slightly different problems."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["How about using a decorator to validate the incoming kwargs?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def validate_kwargs(*keys):\n    def entangle(f):\n        def inner(*args, **kwargs):\n            for key in kwargs:\n                if not key in keys:\n                    raise ValueError(\"Received bad kwarg: '%s', expected: %s\" % (key, keys))\n            return f(*args, **kwargs)\n        return inner\n    return entangle\n\n###\n\n@validate_kwargs('a', 'b', 'c')\ndef func(**kwargs):\n   for arg,val in kwargs.items():\n       print arg, \"-&gt;\", val\n\nfunc(b=2)\nprint '----'\nfunc(a=3, c=5)\nprint '----'\nfunc(d='not gonna work')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Gives this output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n b -&gt; 2\n----\na -&gt; 3\nc -&gt; 5\n----\nTraceback (most recent call last):\n  File \"kwargs.py\", line 20, in &lt;module&gt;\n    func(d='not gonna work')\n  File \"kwargs.py\", line 6, in inner\n    raise ValueError(\"Received bad kwarg: '%s', expected: %s\" % (key, keys))\nValueError: Received bad kwarg: 'd', expected: ('a', 'b', 'c')\n</code>\n</pre>\n", "senID": 3}], [{"text": ["There's probably better ways to do this, but here's my take:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def CompareArgs(argdict, **kwargs):\n    if not set(argdict.keys()) &lt;= set(kwargs.keys()):\n        # not &lt;= may seem weird, but comparing sets sometimes gives weird results.\n        # set1 &lt;= set2 means that all items in set 1 are present in set 2\n        raise ValueError(\"invalid args\")\n\ndef foo(**kwargs):\n    # we declare foo's \"standard\" args to be a, b, c\n    CompareArgs(kwargs, a=None, b=None, c=None)\n    print \"Inside foo\"\n\n\nif __name__ == \"__main__\":\n    foo(a=1)\n    foo(a=1, b=3)\n    foo(a=1, b=3, c=5)\n    foo(c=10)\n    foo(bar=6)\n</code>\n</pre>\n", "senID": 1}, {"text": ["and its output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\nInside foo\nInside foo\nInside foo\nInside foo\nTraceback (most recent call last):\n  File \"a.py\", line 18, in \n    foo(bar=6)\n  File \"a.py\", line 9, in foo\n    CompareArgs(kwargs, a=None, b=None, c=None)\n  File \"a.py\", line 5, in CompareArgs\n    raise ValueError(\"invalid args\")\nValueError: invalid args\n</pre>\n", "senID": 3}, {"text": ["This could probably be converted to a decorator, but my decorators need work.", "Left as an exercise to the reader :P"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Perhaps raise an error if they pass any *args?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def func(*args, **kwargs):\n  if args:\n    raise TypeError(\"no positional args allowed\")\n  arg1 = kwargs.pop(\"arg1\", \"default\")\n  if kwargs:\n    raise TypeError(\"unknown args \" + str(kwargs.keys()))\n</code>\n</pre>\n", "senID": 1}, {"text": ["It'd be simple to factor it into taking a list of varnames or a generic parsing function to use.", "It wouldn't be too hard to make this into a decorator (python 3.1), too:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def OnlyKwargs(func):\n  allowed = func.__code__.co_varnames\n  def wrap(*args, **kwargs):\n    assert not args\n    # or whatever logic you need wrt required args\n    assert sorted(allowed) == sorted(kwargs)\n    return func(**kwargs)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note: i'm not sure how well this would work around already wrapped functions or functions that have *args or **kwargs already."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "*args", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "**kwargs", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Mostly Magic is not the answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def funky(a=None, b=None, c=None):\n    for name, value in [('a', a), ('b', b), ('c', c)]:\n        print name, value\n</code>\n</pre>\n", "senID": 1}]]