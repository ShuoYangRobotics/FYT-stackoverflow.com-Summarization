[[{"text": ["You can pick items with weighted probabilities if you assign each item a number range proportional to its probability, pick a random number between zero and the sum of the ranges and find what item matches it.", "The following class does exactly that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from random import random\n\nclass WeightedChoice(object):\n    def __init__(self, weights):\n        \"\"\"Pick items with weighted probabilities.\n\n            weights\n                a sequence of tuples of item and it's weight.\n        \"\"\"\n        self._total_weight = 0.\n        self._item_levels = []\n        for item, weight in weights:\n            self._total_weight += weight\n            self._item_levels.append((self._total_weight, item))\n\n    def pick(self):\n        pick = self._total_weight * random()\n        for level, item in self._item_levels:\n            if level &gt;= pick:\n                return item\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can then load the CSV file with the csv module and feed it to the WeightedChoice class:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "csv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "WeightedChoice", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import csv\n\nweighed_items = [(item,float(weight)) for item,weight in csv.reader(open('file.csv'))]\npicker = WeightedChoice(weighed_items)\nprint(picker.pick())\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n lst = [ ('Orange', 0.10), ('Apple', 0.05), ('Mango', 0.15), ('etc', 0.69) ]\n\nx = 0.0\nlst2 = []\nfor fruit, chance in lst:\n    tup = (x, fruit)\n    lst2.append(tup)\n    x += chance\n\ntup = (x, None)\nlst2.append(tup)\n\nimport random\n\ndef pick_one(lst2):\n    if lst2[0][1] is None:\n        raise ValueError, \"no valid values to choose\"\n    while True:\n        r = random.random()\n        for x, fruit in reversed(lst2):\n            if x &lt;= r:\n                if fruit is None:\n                    break  # try again with a different random value\n                else:\n                    return fruit\n\npick_one(lst2)\n</code>\n</pre>\n", "senID": 0}, {"text": ["This builds a new list, with ascending values representing the range of values that choose a fruit; then pick_one() walks backward down the list, looking for a value that is &lt;= the current random value.", "We put a \"sentinel\" value on the end of the list; if the values don't reach 1.0, there is a chance of a random value that shouldn't match anything, and it will match the sentinel value and then be rejected.", "random.random() returns a random value in the range [0.0, 1.0) so it is certain to match something in the list eventually."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The nice thing here is that you should be able to have one value with a 0.000001 chance of matching, and it should actually match with that frequency; the other solutions, where you make a list with the items repeated and just use random.choice() to choose one, would require a list with a million items in it to handle this case."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["What you want is to draw from a multinomial distribution.", "Assuming you have two lists of items and probabilities, and the probabilities sum to 1 (if not, just add some default value to cover the extra):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multinomial distribution", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Multinomial%5Fdistribution"}]}, {"code": "<pre>\n<code>\n def choose(items,chances):\n    import random\n    p = chances[0]\n    x = random.random()\n    i = 0\n    while x &gt; p :\n    \ti = i + 1\n    \tp = p + chances[i]\n    return items[i]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n lst = [ ('Orange', 0.10), ('Apple', 0.05), ('Mango', 0.15), ('etc', 0.69) ]\n\nx = 0.0\nlst2 = []\nfor fruit, chance in lst:\n    low = x\n    high = x + chance\n    tup = (low, high, fruit)\n    lst2.append(tup)\n    x += chance\n\nif x &gt; 1.0:\n    raise ValueError, \"chances add up to more than 100%\"\n\nlow = x\nhigh = 1.0\ntup = (low, high, None)\nlst2.append(tup)\n\nimport random\n\ndef pick_one(lst2):\n    if lst2[0][2] is None:\n        raise ValueError, \"no valid values to choose\"\n    while True:\n        r = random.random()\n        for low, high, fruit in lst2:\n            if low &lt;= r &lt; high:\n                if fruit is None:\n                    break  # try again with a different random value\n                else:\n                    return fruit\n\npick_one(lst2)\n\n\n# test it 10,000 times\nd = {}\nfor i in xrange(10000):\n    x = pick_one(lst2)\n    if x in d:\n        d[x] += 1\n    else:\n        d[x] = 1\n</code>\n</pre>\n", "senID": 0}, {"text": ["I think this is a little clearer.", "Instead of a tricky way of representing ranges as ascending values, we just keep ranges.", "Because we are testing ranges, we can simply walk forward through the lst2 values; no need to use reversed()."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "reversed()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["One solution is to normalize the probabilities to integers and then repeat each element once per value (e.g.", "a list with 2 Oranges, 1 Apple, 3 Mangos).", "This is incredibly easy to do (from random import choice).", "If that is not practical, try the code here."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "from random import choice", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "here", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/498229/"}]}], [{"code": "<pre>\n<code>\n import random\nd= {'orange': 0.10, 'mango': 0.15, 'apple': 0.05}\nweightedArray = []\nfor k in d:\n  weightedArray+=[k]*int(d[k]*100)\nrandom.choice(weightedArray)\n</code>\n</pre>\n", "senID": 0}, {"text": ["EDITS"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "EDITS", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This is essentially what Brian said above."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]