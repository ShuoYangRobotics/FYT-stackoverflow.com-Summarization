[[{"text": ["Try this on for size:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def negpos (lst):\n    (neg, pos) = (0, 0)\n    for elem in lst:\n        if elem &lt; 0:\n            neg = neg + elem\n        else:\n            pos = pos + elem\n    return [neg, pos]\n\nprint negpos ([-5,5,6,-8,9])\n</code>\n</pre>\n", "senID": 1}, {"text": ["It simply maintains two accumulators and adds to the relevant one.", "The output is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [-13, 20]\n</code>\n</pre>\n", "senID": 3}, {"text": ["as desired."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Check out filter and sum.", "The first argument to filter is a function that returns True if the value should be included, and False if it should not.", "Pass a function to it the first time that only selects integers less than 0, and the second time pass one that only selects integers greater than 0, then pass the resulting list to sum.", "If you need help past that, just add a comment and I'll help, but I think you'll learn more than if I just give you straight source code."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "filter", "tag": "a", "pos": 0, "childList": [{"text": "filter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#filter"}, {"text": "filter", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sum", "tag": "a", "pos": 2, "childList": [{"text": "sum", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#sum"}, {"text": "sum", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Generator expressions can make life easy and highly efficient:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def negpos( inlist ):\n    p = sum(x for x in inlist if x &gt; 0)\n    n = sum(x for x in inlist if x &lt; 0)\n    return (n,p)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It might also be more appropriate to return a fixed tuple than a list, which I have done."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["without any fancy stuff"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; neg=0\n&gt;&gt;&gt; pos=0\n&gt;&gt;&gt; for i in [-5,5,6,-8,9]:\n...   if i&lt;0: neg+=i\n...   if i&gt;0: pos+=i\n...\n&gt;&gt;&gt; print neg,pos\n-13 20\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using sum with a filtered generator expression is the easiest way to add up a subset of a sequence:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n positive_tally = sum(x for x in seq if x &gt; 0)\nnegative_tally = sum(x for x in seq if x &lt; 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Combining those into a single negpos function would be easy enough, but probably unnecessary unless you're doing this in several different places."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "negpos", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Out of curiousity, I decided to do the actual timing comparison between the generator expression approach and the simple for loop:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n code1 = \"\"\"\ndata = [-5,5,6,-8,9]\ndef negpos(seq):\n  neg, pos = 0, 0\n  for x in seq:\n    if x &gt;= 0:\n      pos += x\n    else:\n      neg += x\n  return neg, pos\n\"\"\"\ncode2 = \"\"\"\ndata = [-5,5,6,-8,9]\ndef negpos(seq):\n  neg = sum(x for x in seq if x &lt; 0)\n  pos = sum(x for x in seq if x &gt; 0)\n  return neg, pos\n\"\"\"\ncommand = \"negpos(data)\"\ntimer1 = timeit.Timer(command, code1)\ntimer2 = timeit.Timer(command, code2)\ntimer1.repeat()\ntimer2.repeat()\n</code>\n</pre>\n", "senID": 4}, {"text": ["On my system, the dedicated for loop comes out as being roughly twice as fast (that's not particularly surprising, since the loop is executed twice with the generator based approach, but it is still interesting to confirm it)."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n import functools\nimport operator\n\nltzero = functools.partial(operator.ge, 0)  # 0&gt;=num -&gt; num&lt;0\ngtzero = functools.partial(operator.le, 0)  # 0&lt;=num -&gt; num&gt;0\n\ndef negpos(lst):\n    return [sum(filter(ltzero, lst)), sum(filter(gtzero, lst))]\n\nnegpos([-5,5,6,-8,9])  # -&gt;  [-13, 20]\n</code>\n</pre>\n", "senID": 0}]]