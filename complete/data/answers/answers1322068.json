[[{"text": ["You appear to be interested in assuring the simplejson will handle your types.", "This is done trivially by "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    json.dumps( object )\nexcept TypeError:\n    print \"Can't convert\", object\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which is more reliable than trying to guess which types your JSON implementation handles."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The typesmodule contains all types."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "typesmodule", "tag": "a", "pos": 0, "childList": [{"text": "types", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/types.html"}, {"text": "types", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Just put all the ones you want in a list or tuple primitiveTypes and:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "primitiveTypes", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if type(myvar) in primitiveTypes:\n    ...\n</code>\n</pre>\n", "senID": 2}], [{"text": ["What is a \"native type\" in Python?", "Please don't base your code on types, use Duck Typing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Duck Typing", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Duck%5FTyping"}]}], [{"text": ["Not that I know why you would want to do it, as there isn't any \"simple\" types in Python, it's all objects.", "But this works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n type(theobject).__name__ in dir(__builtins__)\n</code>\n</pre>\n", "senID": 1}, {"text": ["But explicitly listing the types is probably better as it's clearer.", "Or even better: Changing the application so you don't need to know the difference."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Update: The problem that needs solving is how to make a serializer for objects, even those built-in.", "The best way to do this is not to make a big phat serializer that treats builtins differently, but to look up serializers based on type."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Something like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def IntSerializer(theint):\n    return str(theint)\n\ndef StringSerializer(thestring):\n    return repr(thestring)\n\ndef MyOwnSerializer(value):\n    return \"whatever\"\n\nserializers = {\n    int: IntSerializer,\n    str: StringSerializer,\n    mymodel.myclass: MyOwnSerializer,\n}\n\ndef serialize(ob):\n    try:\n        return ob.serialize() #For objects that know they need to be serialized\n    except AttributeError:\n        # Look up the serializer amongst the serializer based on type.\n        # Default to using \"repr\" (works for most builtins).\n        return serializers.get(type(ob), repr)(ob)\n</code>\n</pre>\n", "senID": 5}, {"text": ["This way you can easily add new serializers, and the code is easy to maintain and clear, as each type has its own serializer.", "Notice how the fact that some types are builtin became completely irrelevant.", ":)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Built in type function may be helpful:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = 5\n&gt;&gt;&gt; type(a)\n&lt;type 'int'&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["building off of S.Lott's answer you should have something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from simplejson import JSONEncoder\n\nclass JSONEncodeAll(JSONEncoder):\n  def default(self, obj):\n    try:\n      return JSONEncoder.default(self, obj)\n    except TypeError:\n      ## optionally\n      # try:\n      #   # you'd have to add this per object, but if an object wants to do something\n      #   # special then it can do whatever it wants\n      #   return obj.__json__()\n      # except AttributeError:\n      ##\n\n      # ...do whatever you are doing now...\n      # (which should be creating an object simplejson understands)\n</code>\n</pre>\n", "senID": 1}, {"text": ["to use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n >>> json = JSONEncodeAll()\n\n>>> json.encode(myObject)\n# whatever myObject looks like when it passes through your serialization code\n</code>\n</pre>\n", "senID": 3}, {"text": ["these calls will use your special class and if simplejson can take care of the object it will.", "Otherwise your catchall functionality will be triggered, and possibly (depending if you use the optional part) an object can define it's own serialization"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]