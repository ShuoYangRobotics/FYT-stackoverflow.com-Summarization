[[{"text": ["The other answers evince a mild confusion as to how import really works."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "import", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This statement:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import foo\n</code>\n</pre>\n", "senID": 2}, {"text": ["is roughly equivalent to this statement:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n foo = __import__('foo', globals(), locals(), [], -1)\n</code>\n</pre>\n", "senID": 4}, {"text": ["That is, it creates a variable in the current scope with the same name as the requested module, and assigns it the result of calling __import__() with that module name and a boatload of default arguments."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "__import__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The __import__() function handles conceptually converts a string ('foo') into a module object.", "Modules are cached in sys.modules, and that's the first place __import__() looks--if sys.modules has an entry for 'foo', that's what __import__('foo') will return, whatever it is.", "It really doesn't care about the type.", "You can see this in action yourself; try running the following code:"], "childNum": 6, "tag": "p", "senID": 6, "childList": [{"text": "__import__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'foo'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sys.modules", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__import__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'foo'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__import__('foo')", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import sys\nsys.modules['boop'] = (1, 2, 3)\nimport boop\nprint boop\n</code>\n</pre>\n", "senID": 7}, {"text": ["Leaving aside stylistic concerns for the moment, having an import statement inside a function works how you'd want.", "If the module has never been imported before, it gets imported and cached in sys.modules.", "It then assigns the module to the local variable with that name.", "It does not not not modify any module-level state.", "It does possibly modify some global state (adding a new entry to sys.modules)."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "not not not", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "does", "childNum": 0, "tag": "em", "pos": 4, "childList": []}]}, {"text": ["That said, I almost never use \"import\" inside a function.", "If importing the module creates a noticeable slowdown in your program--like it performs a long computation in its static initialization, or it's simply a massive module--and your program rarely actually needs the module for anything, it's perfectly fine to have the import only inside the functions in which it's used.", "(If this was distasteful, Guido would jump in his time machine and change Python to prevent us from doing it.", ")  But as a rule, I and the general Python community put all our import statements at the top of the module in module scope."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["I've done this, and then wished I hadn't.", "Ordinarily, if I'm writing a function, and that function needs to use StringIO, I can look at the top of the module, see if it's being imported, and then add it if it's not.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "StringIO", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Suppose I don't do this; suppose I add it locally within my function.", "And then suppose at someone point I, or someone else, adds a bunch of other functions that use StringIO.", "That person is going to look at the top of the module and add import StringIO.", "Now your function contains code that's not only unexpected but redundant."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "StringIO", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "import StringIO", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Also, it violates what I think is a pretty important principle:  don't directly modify module-level state from inside a function."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Actually, it turns out that all of the above is nonsense.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Importing a module doesn't modify module-level state (it initializes the module being imported, if nothing else has yet, but that's not at all the same thing).", "Importing a module that you've already imported elsewhere costs you nothing except a lookup to sys.modules and creating a variable in the local scope."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "doesn't", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "sys.modules", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Knowing this, I feel kind of dumb fixing all of the places in my code where I fixed it, but that's my cross to bear."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Please see PEP 8:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PEP 8", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0008/"}]}, {"text": ["Please note that this is purely a stylistic choice as Python will treat all import statements the same regardless of where they are declared in the source file.", "Still I would recommend that you follow common practice as this will make your code more readable to others."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "import", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Style aside, it is true that an imported module will only be imported once (unless reload is called on said module).", "However, each call to import Foo will have implicitly check to see if that module is already loaded (by checking sys.modules)."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "reload", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "import Foo", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://docs.python.org/library/sys.html#sys.modules", "text": "sys.modules", "childNum": 1, "tag": "a", "childList": [{"text": "sys.modules", "tag": "code"}]}, {"text": "sys.modules", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Consider also the \"disassembly\" of two otherwise equal functions where one tries to import a module and the other doesn't:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def Foo():\n...     import random\n...     return random.randint(1,100)\n... \n&gt;&gt;&gt; dis.dis(Foo)\n  2           0 LOAD_CONST               1 (-1)\n              3 LOAD_CONST               0 (None)\n              6 IMPORT_NAME              0 (random)\n              9 STORE_FAST               0 (random)\n\n  3          12 LOAD_FAST                0 (random)\n             15 LOAD_ATTR                1 (randint)\n             18 LOAD_CONST               2 (1)\n             21 LOAD_CONST               3 (100)\n             24 CALL_FUNCTION            2\n             27 RETURN_VALUE        \n&gt;&gt;&gt; def Bar():\n...     return random.randint(1,100)\n... \n&gt;&gt;&gt; dis.dis(Bar)\n  2           0 LOAD_GLOBAL              0 (random)\n              3 LOAD_ATTR                1 (randint)\n              6 LOAD_CONST               1 (1)\n              9 LOAD_CONST               2 (100)\n             12 CALL_FUNCTION            2\n             15 RETURN_VALUE\n</code>\n</pre>\n", "senID": 2}, {"text": ["I'm not sure how much more the bytecode gets translated for the virtual machine, but if this was an important inner loop to your program, you'd certainly want to put some weight on the Bar approach over the Foo approach."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Bar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Foo", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["A quick and dirty timeit test does show a modest speed improvement when using Bar:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Bar", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n $ python -m timeit -s \"from a import Foo,Bar\" -n 200000 \"Foo()\"\n200000 loops, best of 3: 10.3 usec per loop\n$ python -m timeit -s \"from a import Foo,Bar\" -n 200000 \"Bar()\"\n200000 loops, best of 3: 6.45 usec per loop\n</code>\n</pre>\n", "senID": 5}], [{"text": ["When the python interpreter hits an import statement, it starts reading all the function definitions in the file that is being imported.", "This explains why sometimes, imports can take a while."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The idea behind doing all the importing at the start IS a stylistic convention as Andrew Hare points out.", "However, you have to keep in mind that by doing so, you are implicitly making the interpreter check if this file has already been imported after the first time you import it.", "It also becomes a problem when your code file becomes large and you want to \"upgrade\" your code to remove or replace certain dependencies.", "This will require you to search your whole code file to find all the places where you have imported this module."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I would suggest following convention and keeping the imports at the top of your code file.", "If you really do want to keep track of dependencies for functions, then I would suggest adding them in the docstring for that function."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I can see two ways when you need to import it locally"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Otherwise always put it at top for efficiency and consistency sake."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]