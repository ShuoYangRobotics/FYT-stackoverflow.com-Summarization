[[{"text": ["One reason is to protect against accidentally introducing a conflict when you change the code (or for an external module/library, when someone else changes it) later on.", "For example, in Python you can write"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from foo import *\nfrom bar import *\n</code>\n</pre>\n", "senID": 1}, {"text": ["without conflicts if you know that modules foo and bar don't have any variables with the same names.", "But what if in later versions both foo and bar include variables named rofl?", "Then bar.rofl will cover up foo.rofl without you knowing about it."], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "childList": []}, {"text": "rofl", "childNum": 0, "tag": "code", "childList": []}, {"text": "bar.rofl", "childNum": 0, "tag": "code", "childList": []}, {"text": "foo.rofl", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I also like to be able to look up to the top of the file and see exactly what names are being imported and where they're coming from (I'm talking about Python, of course, but the same reasoning could apply for C++)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python takes the view that 'explicit is better than implicit'.", "(type import this into a python interpreter)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "import this", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Also, say I'm reading someone's code.", "Perhaps it's your code; perhaps it's my code from six months ago.", "I see a reference to bar().", "Where did the function come from?", "I could look through the file for a def bar(), but if I don't find it, what then?", "If python is automatically finding the first bar() available through an import, then I have to search through each file imported to find it.", "What a pain!", "And what if the function-finding recurses through the import heirarchy?"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "bar()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "def bar()", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["I'd rather see zomg.bar(); that tells me where the function is from, and ensures I always get the same one if code changes (unless I change the zomg module)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "zomg.bar()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "zomg", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There have been languages where the compiler tried to \"do the right thing\" - Algol and PL/I come to mind.", "The reason they are not around anymore is that compilers are very bad at doing the right thing, but very good at doing the wrong one, given half a chance!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The problem is about abstraction and reuse : you don't really know if there will not be any future ambiguity. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "you don't really know if there will not be any future ambiguity", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["For example, It's very common to setup different libraries in a project just to discover that they all have their own string class implementation, called \"string\".", "You compiler will then complain that there is ambiguity if the libraries are not encapsulated in separate namespaces."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It's then a delightful pleasure to dodge this kind of ambiguity by specifying wich implementation (like the standard std::string one) you wants to use at each specific instruction or context (read : scope)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["And if you think that it's obvious in a particular context (read : in a particular function or .cpp in c++, .py file in python - NEVER in C++ header files) you just have to express yourself and say that \"it should be obvious\", adding the \"using namespace\" instruction (or import *).", "Until the compiler complain because it is not."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "And if you think that it's obvious in a particular context", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "function or .cpp", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": ".py file", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "you just have to express yourself and say that \"it should be obvious\", adding the \"using namespace\" instruction (or import *)", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["If you use using in specific scopes, you don't break the DRY rule at all."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The ideal this rule strives for is to make creating reusable components easy - and if you reuse your component, you just don't know which symbols will be defined in other namespaces the client uses.", "So the rule forces you to make your intention clear with respect to further definitions you don't know about yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, this ideal has not been reached for C++, mainly because of Koenig lookup."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Is it really the right thing?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What if I have two types ::bat and ::foo::bar"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I want to reference the bat type but accidentally hit the r key instead of t (they're right next to each others)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Is it \"the right thing\" for the compiler to then go searching through every namespace to find ::foo::bar without giving me even a warning?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Or what if I use \"bar\" as shorthand for the \"::foo::bar\" type all over my codebase.", "Then one day I include a library which defines a ::bar datatype.", "Suddenly an ambiguity exists where there was none before.", "And suddenly, \"the right thing\" has become wrong."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The right thing for the compiler to do in this case would be to assume I meant the type I actually wrote.", "If I write bar with no namespace prefix, it should assume I'm referring to a type bar in the global namespace.", "But if it does that in our hypothetical scenario, it'll change what type my code references without even alerting me."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Alternatively, it could give me an error, but come on, that'd just be ridiculous, because even with the current language rules, there should be no ambiguity here, since one of the types is hidden away in a namespace I didn't specify, so it shouldn't be considered."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Another problem is that the compiler may not know what other types exist.", "In C++, the order of definitions matters."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["In C#, types can be defined in separate assemblies, and referenced in your code.", "How does the compiler know that another type with the same name doesn't exist in another assembly, just in a different namespace?", "How does it know that one won't be added to another assembly later on?"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["The right thing is to do what gives the programmer the fewest nasty surprises.", "Second-guessing the programmer based on incomplete data is generally not the right thing to do."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Most languages give you several tools to avoid having to specify the namespace."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["In c++, you have \"using namespace foo\", as well as typedefs.", "If you don't want to repeat the namespace prefix, then don't.", "Use the tools made available by the language so you don't have to."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["This all depends on your definition of \"right thing\".", "Is it the right thing for the compiler to guess your intention if there's only one match?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There are arguments for both sides."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Interesting question.", "In the case of C++, as I see it, provided the compiler flagged an error as soon as there was a conflict, the only problem this could cause would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Auto-lookup of all C++ namespaces would remove the ability to hide the names of internal parts of library code."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Auto-lookup of all C++ namespaces would remove the ability to hide the names of internal parts of library code.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Library code often contains parts (types, functions, global variables) that are never intended to be visible to the \"outside world.", "\"  C++ has unnamed namespaces for exactly this reason -- to avoid \"internal parts\" clogging up the global namespace, even when those library namespaces are explicitly imported with using namespace xyz;."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "using namespace xyz;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Example: Suppose C++ did do auto-lookup, and a particular implementation of the C++ Standard Library contained an internal helper function, std::helper_func().", "Suppose a user Joe develops an application containing a function joe::helper_func() using a different library implementation that does not contain std::helper_func(), and calls his own method using unqualified calls to helper_func().", "Now Joe's code will compile fine in his environment, but any other user who tries to compile that code using the first library implementation will hit compiler error messages.", "So the first thing required to make Joe's code portable is to either insert the appropriate using declarations/directives or use fully qualified identifiers.", "In other words, auto-lookup buys nothing for portable code."], "childNum": 7, "tag": "p", "senID": 3, "childList": [{"text": "did", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "std::helper_func()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "joe::helper_func()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "different", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "std::helper_func()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "helper_func()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "using", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Admittedly, this doesn't seem like a problem that's likely to come up very often.", "But since typing explicit using declarations/directives (e.g.", "using namespace std;) is not a big deal for most people, solves this problem completely, and would be required for portable development anyway, using them (heh) seems like a sensible way to do things."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "using", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "using namespace std;", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["NOTE:  As Klaim pointed out, you would never in any circumstances want to rely on auto-lookup inside a header file, as this would immediately prevent your module from being used at the same time as any module containing a conflicting name.", "(This is just a logical extension of why you don't do using namespace xyz; inside headers in C++ as it stands."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "NOTE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "never in any circumstances", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "using namespace xyz;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]