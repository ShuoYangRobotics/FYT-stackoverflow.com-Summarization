[[{"text": ["You could serialise the function bytecode and then reconstruct it on the caller.", "The marshal module can be used to serialise code objects, which can then be reassembled into a function.", "ie:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "marshal", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.1.1/lib/module-marshal.html"}]}, {"code": "<pre>\n<code>\n import marshal\ndef foo(x): return x*x\ncode_string = marshal.dumps(foo.func_code)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then in the remote process (after transferring code_string):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import marshal, types\n\ncode = marshal.loads(code_string)\nfunc = types.FunctionType(code, globals(), \"some_func_name\")\n\nfunc(10)  # gives 100\n</code>\n</pre>\n", "senID": 3}, {"text": ["A few caveats:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["marshal's format (any python bytecode for that matter) may not be compatable between major python versions."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Will only work for cpython implementation."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["If the function references globals (including imported modules, other functions etc) that you need to pick up, you'll need to serialise these too, or recreate them on the remote side.", "My example just gives it the remote process's global namespace."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["You'll probably need to do a bit more to support more complex cases, like closures or generator functions."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}]}], [{"text": ["The most simple way is probably inspect.getsource(object) (see the inspect module) which returns a String with the source code for a function or a method."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "inspect.getsource(object)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/inspect.html#retrieving-source-code", "text": "inspect module", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Pyro can do this for you."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Pyro", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyro.sourceforge.net/"}, {"href": "http://pyro.sourceforge.net/manual/7-features.html#mobile", "text": "do this for you", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["It all depends on whether you generate the function at runtime or not:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you do - inspect.getsource(object) won't work for dynamically generated functions as it gets object's source from .py file, so only functions defined before execution can be retrieved as source."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "inspect.getsource(object)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".py", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["And if your functions are placed in files anyway, why not give receiver access to them and only pass around module and function names."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The only solution for dynamically created functions that I can think of is to construct function as a string before transmission, transmit source, and then eval() it on the receiver side."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "eval()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: the marshal solution looks also pretty smart, didn't know you can serialize something other thatn built-ins"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "marshal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The basic functions used for this module covers your query, plus you get the best compression over the wire; see the instructive source code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["y_serial.py module :: warehouse Python objects with SQLite"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["\"Serialization + persistance :: in a few lines of code, compress and annotate Python objects into SQLite; then later retrieve them chronologically by keywords without any SQL.", "Most useful \"standard\" module for a database to store schema-less data."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://yserial.sourceforge.net"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://yserial.sourceforge.net", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://yserial.sourceforge.net"}]}], [{"text": ["It will work if you keep it simple.", "Read the section \"What can be pickled and unpickled?", "\" for details."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "What can be pickled and unpickled?", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pickle.html?highlight=pickle#what-can-be-pickled-and-unpickled"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import pickle\n&gt;&gt;&gt;\n&gt;&gt;&gt; def hi():\n...     print 'hello'\n...\n&gt;&gt;&gt;\n&gt;&gt;&gt; hi()\nhello\n&gt;&gt;&gt; p_func = pickle.dumps(hi)\n&gt;&gt;&gt;\n&gt;&gt;&gt; loaded_func = pickle.loads(p_func)\n&gt;&gt;&gt;\n&gt;&gt;&gt; loaded_func()\nhello\n</code>\n</pre>\n", "senID": 1}, {"text": ["As Aaron Digulla pointed at, you may just want to consider sending the source file of the function."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Something like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n transmit(&lt;source file&gt;, &lt;function name in source file&gt;)\ntrasmit('./my_functions.py', 'hi')\n</code>\n</pre>\n", "senID": 4}, {"text": ["As your probably aware you don't want to do this out of a completely controlled environment."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]