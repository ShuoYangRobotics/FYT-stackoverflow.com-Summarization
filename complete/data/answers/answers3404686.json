[[{"code": "<pre>\n<code>\n import datetime\nimport time\n\ndef lines( path_to_file ):\n    '''Open path_to_file and read the lines one at a time, yielding tuples\n    ( date of line, time of line, status before line )'''\n    with open( path_to_file ) as theFile:\n        for line in theFile:\n            line = line.rsplit( \" \", 1 )\n            yield ( \n                datetime.datetime.strptime( line[ 0 ], \"%d/%m/%Y %H:%M:%S\" ),\n                line[ 1 ].split( \"_\" )[ 3 ]\n            )\n\ndef return_status( statDate ):\n    for lineDate, lineStatus in lines( path_to_file ):\n        if statDate &gt; lineDate:\n            continue\n        return lineStatus\n</code>\n</pre>\n", "senID": 0}, {"text": ["Does that make sense, or would you like me to explain any of it?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Did you mean what you said above?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In other words, what should happen if you call return_status( 16/07/2010, &lt;some.time&gt; )?", "Should you get \"Offline\"?"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "return_status( 16/07/2010, &lt;some.time&gt; )", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I have edited it to do sensible datetime comparisons.", "I think you have read the inequality the wrong way around: we loop through lines in the file until the first line after the date we wish to fetch (keep reading while statDate &gt; lineDate).", "Once this test fails, line is the first line after the desired date, so its from value is the status at the time we requested.", "You should call the function with a datetime.datetime."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "after", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "statDate &gt; lineDate", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "line", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "from", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "datetime.datetime", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["I suggest you have a read in the python docs, specifically the time module and the function strptime which can parse textual representation of times into a programmatic representation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "time module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/time.html#time.strptime"}]}, {"text": ["Calling returnstatus the way you wrote in the question will surely fail, you might want to call it with a string representation of the time (i.e.", "\"15/07/2010 15:10:01\") or by passing one of the datatypes defined in the time module."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "returnstatus", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT: obviously if you pass in a string time then finding it in the file is much easier:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if substring in line:\n # do stuff\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As Yoni said, you're probably better served by passing a string argument (if you have one).", "You may also find the types in datetime useful.", "You'll also want to look into the split function."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "datetime", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/datetime.html"}, {"text": "split", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.split"}]}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import datetime\n\nfilein = open(\"filein\", \"r\")\n\nclass Status:   \n    def __init__(self, date, time, status):\n        print date.split('/')\n        day, month, year = map(int, date.split('/'))\n        hour, minute, second = map(int, time.split(':'))\n        self.date_and_time = datetime.datetime(year=year, month=month, day=day, hour=hour, minute=minute, second=second)\n        self.status = status\n\nlist = []\nline = filein.readline().rstrip('\\n')\n\nwhile line != \"\":\n    print line\n    date, time, status = line.split(' ')[:3]\n    status = status.split('_')\n    status.reverse()\n    status = status[0]\n    status_it = Status(date=date, time=time, status=status)\n    line = filein.readline().rstrip('\\n')\n    list.append(status_it)\n\ndef query (date, time):\n    day, month, year = map(int, date.split('/'))\n    hour, minute, second = map(int, time.split(':'))\n    date_and_time = datetime.datetime(year=year, month=month, day=day, hour=hour, minute=minute, second=second)\n\n    for counter, it in enumerate(list):\n        if date_and_time &gt;= it.date_and_time and (date_and_time &lt; list[counter + 1].date_and_time or counter == len(list) - 1):\n            print it.status\n            return\n    print \"I don't know the status\"\n\nquery(\"15/07/2010\", \"15:10:01\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["From the question user392409 most probably wants to pass the parameters as string and wants a single function."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "user392409", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/392409/user392409"}, {"text": "string", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import datetime\nimport time\n\ndef returnstatus(d, t):\n    d = datetime.datetime.strptime(d, \"%d/%m/%Y\")\n    t = time.strptime(t, \"%H:%M:%S\")\n    f = open(\"log.txt\")\n    for line in f:\n        line = line.split(\" \")\n        line_date = datetime.datetime.strptime(line[0], \"%d/%m/%Y\")\n        line_time = time.strptime(line[1], \"%H:%M:%S\")\n        if d != line_date and t &gt;= line_time:\n            continue\n        # Returns the first occurrence. To get all store in a list or print.\n        f.close()\n        return line[2].split(\"_\")[3]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Basically, what you need to do is pull out the dates and times from your log into a easy-to-compare format.", "Enter datetime. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "datetime", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import datetime\n\ndef getStatus(log_list, dt, tm):\n #filter the list\n log_list = [a_log_entry for a_log_entry in log_list if a_log_entry[0] == dt and a_log_entry[1] &lt;= tm]\n\n    #sort it\n log_list.sort(cmp=lambda x,y: cmp(x[1], y[1]))\n if log_list is []:\n     return 'No status available for this day and time.'\n\n    #pull out the status\n status_to_return = log_list[-1][2].split('_')[-1].strip()\n\n return status_to_return\n\nif __name__ == '__main__':\n in_file = open('a.log', 'rU')\n a_list = []\n\n for line in in_file:\n  if line.strip() is not '': #handle whitespace\n   a_list.append(line.split(' '))\n\n #convert string dates and times to datetime objects\n a_list = [ [datetime.datetime.strptime(el[0], '%d/%m/%Y'),\n    datetime.datetime.strptime(el[1], '%H:%M:%S'), \n    el[2]] for el in a_list]\n\n\n a_date = datetime.datetime(2010, 7, 15)\n a_time = datetime.datetime(1900, 1, 1, 16, 1, 0)\n print getStatus(a_list, a_date, a_time)\n</code>\n</pre>\n", "senID": 1}]]