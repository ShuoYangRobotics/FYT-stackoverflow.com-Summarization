[[{"code": "<pre>\n<code>\n # To sort the list in place...\nut.sort(key=lambda x: x.count, reverse=True)\n\n# To return a new list, use the sorted() built-in function...\nnewlist = sorted(ut, key=lambda x: x.count, reverse=True)\n</code>\n</pre>\n", "senID": 0}, {"text": ["More on sorting by keys &raquo; "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "sorting by keys &raquo;", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/HowTo/Sorting#Sortingbykeys"}]}], [{"text": ["A way that can be fastest, especially if your list has a lot of records, is to use operator.attrgetter(\"count\").", "However, this might run on an pre-operator version of Python, so it would be nice to have a fallback mechanism.", "You might want to do the following, then:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "operator.attrgetter(\"count\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n try: import operator\nexcept ImportError: cmpfun= lambda x: x.count # use a lambda if no operator module\nelse: cmpfun= operator.attrgetter(\"count\") # use operator since it's faster than lambda\n\nut.sort(key=cmpfun, reverse=True) # sort in-place\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It looks much like a list of Django ORM model instances."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Why not sort them on query like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n ut = Tag.objects.order_by('-count')\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Readers should notice that the key= method:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ut.sort(key=lambda x: x.count, reverse=True)\n</code>\n</pre>\n", "senID": 1}, {"text": ["is many times faster than adding rich comparison operators to the objects.", "I was surprised to read this (page 485 of \"Python in a Nutshell\").", "You can confirm this by running tests on this little program:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport random\n\nclass C:\n    def __init__(self,count):\n        self.count = count\n\n    def __cmp__(self,other):\n        return cmp(self.count,other.count)\n\nlongList = [C(random.random()) for i in xrange(1000000)] #about 6.1 secs\n\nlongList.sort() #about 52 - 6.1 = 46 secs\nlongList.sort(key = lambda c: c.count) #about 9 - 6.1 = 3 secs\n</code>\n</pre>\n", "senID": 3}, {"text": ["My, very minimal, tests show the first sort is more than 10 times slower, but the book says it is only about 5 times slower in general.", "The reason they say is due to the highly optimizes sort algorithm used in python (timsort)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "timsort", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Still, its very odd that .sort(lambda) is faster than plain old .sort().", "I hope they fix that."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Add rich comparison operators to the object class, then use sort() method of the list.", "See rich comparison in python."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "rich comparison in python", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#object.__lt__"}]}, {"tag": "hr", "senID": 1}, {"text": ["Update: Although this method would work, I think solution from Triptych is better suited to your case because way simpler."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n from operator import attrgetter\nut.sort(key = attrgetter('count'), reverse = True)\n</code>\n</pre>\n", "senID": 0}]]