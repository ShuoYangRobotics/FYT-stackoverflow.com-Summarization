[[{"text": ["This is a very exceptional and often very bad thing to do.", "It's trivially avoidable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["i.e., pass [foo] instead of foo when calling this function."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The only time you can justify doing this is when (1) you have an installed base of software that expects one form (iterable or singleton) and (2) you have to expand it to support the other use case.", "So.", "You only do this when expanding an existing function that has an existing code base."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "only", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If this is new development, Do Not Do This."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["[Only two?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["What?", "Are you saying you provide NO other documentation, and no other training?", "No support?", "No advice?", "Who is the \"someone not used to it\"?", "Talk to them.", "Don't assume or imagine things about them."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Also, don't use Leading Upper Case Names.  "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Terrible.", "Never.", "Do.", "This."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["I looked in the Python library for examples.", "Most of the functions that do this have simple descriptions."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["http://docs.python.org/library/functions.html#isinstance"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "http://docs.python.org/library/functions.html#isinstance", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#isinstance"}]}, {"text": ["isinstance(object, classinfo)"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["They call it \"classinfo\" and it can be a class or a tuple of classes."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["You could do that, too."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["You must consider the common use case and the exceptions.", "Follow the 80/20 rule."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "must", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["It sounds like you're agonizing over the ugliness of code like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def ProcessWidget(widget_thing):\n  # Infer if we have a singleton instance and make it a\n  # length 1 list for consistency\n  if isinstance(widget_thing, WidgetType):\n    widget_thing = [widget_thing]\n\n  for widget in widget_thing:\n    #...\n</code>\n</pre>\n", "senID": 1}, {"text": ["My suggestion is to avoid overloading your interface to handle two distinct cases.", "I tend to write code that favors re-use and clear naming of methods over clever dynamic use of parameters:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def ProcessOneWidget(widget):\n  #...\n\ndef ProcessManyWidgets(widgets):\n  for widget in widgets:\n    ProcessOneWidget(widget)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Often, I start with this simple pattern, but then have the opportunity to optimize the \"Many\" case when there are efficiencies to gain that offset the additional code complexity and partial duplication of functionality.", "If this convention seems overly verbose, one can opt for names like \"ProcessWidget\" and \"ProcessWidgets\", though the difference between the two is a single easily missed character."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I guess I'm a little late to the party, but I'm suprised that nobody suggested a decorator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def withmany(f):\n    def many(many_foos):\n        for foo in many_foos:\n            yield f(foo)\n    f.many = many\n    return f\n\n@withmany\ndef process_foo(foo):\n    return foo + 1\n\n\nprocessed_foo = process_foo(foo)\n\nfor processed_foo in process_foo.many(foos):\n    print processed_foo\n</code>\n</pre>\n", "senID": 1}, {"text": ["I saw a similar pattern in one of Alex Martelli's posts but I don't remember the link off hand."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Can you name your parameter in a very high-level way?", "people who read the code are more interested in knowing what the parameter represents (\"clients\") than what their type is (\"list_of_tuples\"); the type can be defined in the function documentation string, which is a good thing since it might change, in the future (the type is sometimes an implementation detail)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can use *args magic (varargs) to make your params always be iterable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Pass a single item or multiple known items as normal function args like func(arg1, arg2, ...) and pass iterable arguments with an asterisk before, like func(*args)"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "func(arg1, arg2, ...)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "func(*args)", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # magic *args function\ndef foo(*args):\n    print args\n\n# many ways to call it\nfoo(1)\nfoo(1, 2, 3)\n\nargs1 = (1, 2, 3)\nargs2 = [1, 2, 3]\nargs3 = iter((1, 2, 3))\n\nfoo(*args1)\nfoo(*args2)\nfoo(*args3)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I would go with a name explaining that the parameter can be an instance or a list of instances.", "Say  one_or_more_Foo_objects.", "I find it better than the bland param. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "one_or_more_Foo_objects", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "param", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I would do 1 thing, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def myFunc(manyFoos):\n    if not type(manyFoos) in (list,tuple):\n        manyFoos = [manyFoos]\n    #do stuff here\n</code>\n</pre>\n", "senID": 1}, {"text": ["so then you don't need to worry anymore about its name."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["in a function you should try to achieve to have 1 action, accept the same parameter type and return the same type. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Instead of filling the functions with ifs you could have 2 functions."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Since you don't care exactly what kind of iterable you get, you could try to get an iterator for the parameter using iter().", "If iter() raises a TypeError exception, the parameter is not iterable, so you then create a list or tuple of the one item, which is iterable and Bob's your uncle."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def doIt(foos):\n    try:\n        iter(foos)\n    except TypeError:\n        foos = [foos]\n    for foo in foos:\n        pass    # do something here\n</code>\n</pre>\n", "senID": 1}, {"text": ["The only problem with this approach is if foo is a string.", "A string is iterable, so passing in a single string rather than a list of strings will result in iterating over the characters in a string.", "If this is a concern, you could add an if test for it.", "At this point it's getting wordy for boilerplate code, so I'd break it out into its own function."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def iterfy(iterable):\n    if isinstance(iterable, basestring):\n        iterable = [iterable]\n    try:\n        iter(iterable)\n    except TypeError:\n        iterable = [iterable]\n    return iterable\n\ndef doIt(foos):\n    for foo in iterfy(foos):\n        pass    # do something\n</code>\n</pre>\n", "senID": 3}, {"text": ["Unlike some of those answering, I like doing this, since it eliminates one thing the caller could get wrong when using your API.", "\"Be conservative in what you generate but liberal in what you accept."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["To answer your original question, i.e.", "what you should name the parameter, I would still go with \"foos\" even though you will accept a single item, since your intent is to accept a list.", "If it's not iterable, that is technically a mistake, albeit one you will correct for the caller since processing just the one item is probably what they want.", "Also, if the caller thinks they must pass in an iterable even of one item, well, that will of course work fine and requires very little syntax, so why worry about correcting their misapprehension?"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "intent", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "technically", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "thinks", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}], [{"text": ["I'm working on a fairly big project now and we're passing maps around and just calling our parameter map.", "The map contents vary depending on the function that's being called.", "This probably isn't the best situation, but we reuse a lot of the same code on the maps, so copying and pasting is easier."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I would say instead of naming it what it is, you should name it what it's used for.", "Also, just be careful that you can't call use in on a not iterable."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]