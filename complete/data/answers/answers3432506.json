[[{"text": ["If you know the name of the function as a string and the name of module as a string, then you can do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mod = __import__(module_name)\nfn = getattr(mod, fn_name)\nfn()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Another possible solution is to have each of your repetitive files import the functionality from the main file"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from topAndBottom import top, bottom\ntop()\n# do middle stuff\nbottom()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In addition to the several answers already posted, consider the Template Method design pattern: make an abstract class such as"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Template Method", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://books.google.com/books?id=Q0s6Vgb98CQC&pg=PT267&lpg=PT267&dq=martelli+template+method&source=bl&ots=hc5X54RluF&sig=Szn0KupOXlKH4P7DqCcr2N9odOI&hl=en&ei=ThdeTN7aNJD4sAOmt92rCw&sa=X&oi=book_result&ct=result&resnum=2&ved=0CBcQ6AEwAQ#v=onepage&q=martelli%20template%20method&f=false"}]}, {"code": "<pre>\n<code>\n class Base(object):\n    def top(self): ...\n    def bottom(self): ...\n    def middle(self): raise NotImplementedError\n    def doit(self):\n        self.top()\n        self.middle()\n        self.bottom()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Every pluggable module then makes a class which inherits from this Base and must override middle with the relevant code."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Base", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "middle", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Perhaps not warranted for this simple case (you do still have to import the right module in order to instantiate its class and call doit on it), but still worth keeping in mind  (together with its many Pythonic variations, which I have amply explained in many tech talks now available on youtube) for cases where the number or complexity of \"pluggable pieces\" keeps growing -- Template Method (despite its horrid name;-) is a solid, well-proven and highly scalable pattern [[sometimes a tad too rigid, but that's exactly what I address in those many tech talks -- and that problem doesn't apply to this specific use case]]."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "doit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It will work just fine - use __import__ builtin or, if you have very complex layout, imp module to import your script.", "And then you can get the function by module.__dict__[funcname] for example."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "__import__", "tag": "a", "pos": 0, "childList": [{"text": "__import__", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#__import__"}, {"text": "__import__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "imp", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/imp.html"}, {"text": "module.__dict__[funcname]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Importing a module (as explained in other answers) is definitely the cleaner way to do this, but if for some reason that doesn't work, as long as you're not doing anything too weird you can use exec.", "It basically runs the content of another file as if it were included in the current file at the point where exec is called.", "It's the closest thing Python has to a source statement of the kind included in many shells.", "As a bare minimum, something like this should work:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "exec", "tag": "a", "pos": 0, "childList": [{"text": "exec", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/py3k/library/functions.html#exec"}, {"text": "exec", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "exec", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "source", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n exec(open(filename).read(None))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n function do_thing_one():\n   pass\n\nfunction do_thing_two():\n   pass\n\ndispatch = { \"one\" : do_thing_one,\n             \"two\" : do_thing_two,\n           }\n\n# do something to get your string from the command line (optparse, argv, whatever)\n# and put it in variable \"mystring\"\n\n# do top thing\nf = dispatch[mystring]\nf()\n# do bottom thing\n</code>\n</pre>\n", "senID": 1}]]