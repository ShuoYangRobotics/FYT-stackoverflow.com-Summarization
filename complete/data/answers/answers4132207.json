[[{"text": ["Use a bit-array.This will reduce the need for huge space requirement."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bit-array", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/bitarray/0.3.2"}]}, {"text": ["Realted SO Question:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Realted SO Question:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 1, "lis": [{"text": ["Python equivalent to Java's BitSet"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}]}], [{"text": ["You can avoid dependencies on 3rd-party bit-array modules by writing your own -- the functionality required is rather minimal:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import array\n\nBITS_PER_ITEM = array.array('I').itemsize * 8\n\ndef make_bit_array(num_bits, initially=0):\n    num_items = (num_bits + BITS_PER_ITEM - 1) // BITS_PER_ITEM\n    return array.array('I', [initially]) * num_items\n\ndef set_bit(bit_array, offset):\n    item_index = offset // BITS_PER_ITEM\n    bit_index = offset % BITS_PER_ITEM\n    bit_array[item_index] |= 1 &lt;&lt; bit_index\n\ndef clear_bit(bit_array, offset):\n    item_index = offset // BITS_PER_ITEM\n    bit_index = offset % BITS_PER_ITEM\n    bit_array[item_index] &amp;= ~(1 &lt;&lt; bit_index)\n\ndef get_bit(bit_array, offset):\n    item_index = offset // BITS_PER_ITEM\n    bit_index = offset % BITS_PER_ITEM\n    return (bit_array[item_index] &gt;&gt; bit_index) &amp; 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Try to use array module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "array", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Use an array of bits as flags for each integer - the memory needed will be only 50 million bits (about 6 MB).", "There are a few modules that can help.", "This example uses bitstring, another option is bitarray:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "bitstring", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://python-bitstring.googlecode.com"}, {"href": "http://pypi.python.org/pypi/bitarray", "text": "bitarray", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from bitstring import BitArray\ni = BitArray(50000000) # initialise 50 million zero bits\nfor x in xrange(100):\n    v = random.randint(1, 50000000)\n    if not i[v]: # Test if it's already present\n        i.set(1, v) # Set a single bit\n</code>\n</pre>\n", "senID": 1}, {"text": ["Setting and checking bits is very fast and it uses very little memory."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If integers are unique then use bits.", "Example: binary 01011111 means that there are: 1, 3, 4, 5, 6 and 7.", "This way every bit is used to check if its integer index is used (value 1) or not (value 0)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "01011111", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["It was described in one chapter of \"Programming Pearls\" by Jon Bentley (look for \"The file contains at most ten million records; each record is a seven-digit integer.", "\")"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "one chapter of \"Programming Pearls\" by Jon Bentley", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cs.bell-labs.com/cm/cs/pearls/sec014.html"}]}, {"text": ["It seems that there is bitarray module mentioned by Emil that works this way."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "bitarray", "tag": "a", "pos": 0, "childList": [{"text": "bitarray", "tag": "code"}], "childNum": 1, "href": "http://pypi.python.org/pypi/bitarray/"}, {"text": "bitarray", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Depending on your requirements, you might also consider a bloom filter.", "It is a memory-efficient data structure for testing if an element is in a set.", "The catch is that it it can give false-positives, though it will never give false-negatives."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bloom filter", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Bloom_filter"}]}]]