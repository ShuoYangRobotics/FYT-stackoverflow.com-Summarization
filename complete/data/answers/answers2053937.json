[[{"text": ["If you are accepting input from a user, then why are you worried about the speed of comparison?", "Even the slowest technique will be far faster than the user can perceive.", "Use the simplest most understandable code you can, and leave efficiency concerns for tight inner loops."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n cmds = [\n    \"lock\",\n    \"read\",\n    \"write\",\n    \"request\",\n    \"log\",\n    ]\n\ndef match_cmd(s):\n    matched = [c for c in cmds if c.startswith(s)]\n    if matched:\n        return matched[0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This will do what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def select_command(commands, user_input):\n    user_input = user_input.strip().lower()\n    for command in commands:\n        if command.startswith(user_input):\n            return command\n    return None\n</code>\n</pre>\n", "senID": 1}, {"text": ["However:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "However:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You seem overworried about the wrong thing.", "So 50 users means 50 milliseconds -- you're not going to be run out of town for that kind of \"lag\".", "Worry about inefficient database access or problems caused by users typing \"r\" and getting \"read\" when they thought they'd get \"request\".", "Minimising user keystrokes at the risk of errors is so 1960s that it's not funny.", "What are they using?", "ASR33 teletypes?", "At the very least you could insist on a unique match -- \"rea\" for read and \"req\" for request."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This is optimized at runtime like you requested... (although most likely not needed)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This is optimized at runtime like you requested...", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here is a simple bit of code which will take an input dictionary of command mapped to function, and results in an output dictionary of all non-duplicate sub commands mapped to the same function."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So you run this when you start your service, and then you have 100% optimized lookups.", "I am sure there is a more clever way to do this, so feel free to edit."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n commands = {\n  'log': log_function,\n  'exit': exit_function,\n  'foo': foo_function,\n  'line': line_function,\n  }\n\ncmap = {}\nkill = set()\nfor command in commands:\n  for pos in range(len(1,command)):\n    subcommand = command[0:pos]\n    if subcommand in cmap:\n      kill.add(subcommand)\n      del(cmap[subcommand])\n    if subcommand not in kill:\n      cmap[subcommand] = commands[command]\n\n#cmap now is the following - notice the duplicate prefixes removed?\n{\n  'lo': log_function,\n  'log': log_function,\n  'e': exit_function,\n  'ex': exit_function,\n  'exi': exit_function,\n  'exit': exit_function,\n  'f' : foo_function,\n  'fo' : foo_function,\n  'foo' : foo_function,\n  'li' : line_function,\n  'lin' : line_function,\n  'line' : line_function,\n}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["you can use startswith"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["eg"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n myword = \"lock\"\nif myword.startswith(\"lo\"):\n   print \"ok\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["or if you want to find \"lo\" in the word, regardless of position, just use the \"in\" operator"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if \"lo\" in myword\n</code>\n</pre>\n", "senID": 4}, {"text": ["therefore, one way you can do this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for cmd in [\"lock\",\"read\",\"write\",\"request\",\"log\"]:\n    if cmd.startswith(userinput):\n        print cmd\n        break\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I suggest you look at using the readline python library, rather than reinventing the wheel.", "The user will have to hit tab to complete the word, but you can set readline up so that tab matches as far as possible or cycles through all words starting wit the current stub."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This seems to be a fairly decent introduction to readline in python http://www.doughellmann.com/PyMOTW/readline/index.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.doughellmann.com/PyMOTW/readline/index.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.doughellmann.com/PyMOTW/readline/index.html"}]}], [{"text": ["jaro_winkler() in python-Levenshtein might be what you're looking for."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "jaro_winkler()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://www.michael-noll.com/wiki/Python-Levenshtein", "text": "python-Levenshtein", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Replace with your favorite string compare function.", "Fairly fast, and to the point."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n matches = ( x for x in list if x[:len(stringToSearchFor)] == stringToSearchFor )\nprint matches[0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is adapted from J.Tauber's Trie implementation in Python, which you could compare and/or re-adapt with whatever extra features you need.", "See also the Wikipedia entry on tries."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "J.Tauber's Trie implementation in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://jtauber.com/blog/2005/02/10/updated_python_trie_implementation/"}, {"text": "Wikipedia entry on tries", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Trie"}]}, {"code": "<pre>\n<code>\n class Trie:\n    def __init__(self):\n        self.root = [None, {}]\n\n    def add(self, key):\n        curr_node = self.root\n        for ch in key:\n            curr_node = curr_node[1].setdefault(ch, [key, {}])\n        curr_node[0] = key\n\n    def find(self, key):\n        curr_node = self.root\n        for ch in key:\n            try:\n                curr_node = curr_node[1][ch]\n            except KeyError:\n                return None\n        return curr_node[0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Setup (order of addition matters!", "):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n t = Trie()\nfor word in [\n   'lock',\n   'read',\n   'write',\n   'request',\n   'log']:\n   t.add(word)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then call like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; t.find('lo')\n'lock'\n&gt;&gt;&gt; t.find('log')\n'log'\n&gt;&gt;&gt; t.find('req')\n'request'\n&gt;&gt;&gt; t.find('requiem')\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 5}], [{"text": ["If i understand your Q correctly, you want a snippet that will return the answer as soon as it has it, without traversing further through your 'command list.", "' This should do what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import ifilter\n\ndef check_input(some_string, code_book) :\n    for q in ifilter(code_book.__contains__, some_string) :\n        return True\n    return False\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import timeit\n\ncmds = []\nfor i in range(1,10000):\n    cmds.append(\"test\")\n\ndef get_cmds(user_input):\n    return [c for c in cmds if c.startswith(user_input)]\n\nif __name__=='__main__':\n    t = timeit.Timer(\"get_cmds('te')\", \"from __main__ import get_cmds\")\n    print \"%0.3f seconds\" % (t.timeit(number=1))\n\n#&gt;&gt;&gt; 0.008 seconds\n</code>\n</pre>\n", "senID": 0}, {"text": ["So basically, per my comment, you're asking how to optimise an operation that takes no measurable time or CPU.", "I used 10,000 commands here and the test string matches every one just to show that even under extreme circumstances you could still have hundreds of users doing this and they would never see any lag."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]