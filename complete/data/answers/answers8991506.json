[[{"text": ["The grouper()  recipe from the itertools documentation's recipes comes close to what you want:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "grouper()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/itertools.html#recipes", "text": "recipes", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def grouper(n, iterable, fillvalue=None):\n    \"grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx\"\n    args = [iter(iterable)] * n\n    return izip_longest(fillvalue=fillvalue, *args)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It will fill up the last chunk with a fill value, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A less general solution that only works on sequences but does handle the last chunk as desired is"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [my_list[i:i + chunk_size] for i in range(0, len(my_list), chunk_size)]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Finally, a solution that works on general iterators an behaves as desired is"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def grouper(n, iterable):\n    it = iter(iterable)\n    while True:\n       chunk = tuple(itertools.islice(it, n))\n       if not chunk:\n           return\n       yield chunk\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Here's one that returns lazy chunks; use map(list, chunks(...)) if you want lists."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map(list, chunks(...))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import islice, chain\nfrom collections import deque\n\ndef chunks(items, n):\n    items = iter(items)\n    for first in items:\n        chunk = chain((first,), islice(items, n-1))\n        yield chunk\n        deque(chunk, 0)\n\nif __name__ == \"__main__\":\n    for chunk in map(list, chunks(range(10), 3)):\n        print chunk\n\n    for i, chunk in enumerate(chunks(range(10), 3)):\n        if i % 2 == 1:\n            print \"chunk #%d: %s\" % (i, list(chunk))\n        else:\n            print \"skipping #%d\" % i\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A succinct implementation is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n chunker = lambda iterable, n: (ifilterfalse(lambda x: x == (), chunk) for chunk in (izip_longest(*[iter(iterable)]*n, fillvalue=())))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works because [iter(iterable)]*n is a list containing the same iterator n times; zipping over that takes one item from each iterator in the list, which is the same iterator, with the result that each zip-element contains a group of n items. "], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "[iter(iterable)]*n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "which is the same iterator", "childNum": 0, "tag": "em", "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["izip_longest is needed to fully consume the underlying iterable, rather than iteration stopping when the first exhausted iterator is reached, which chops off any remainder from iterable.", "This results in the need to filter out the fill-value.", "A slightly more robust implementation would therefore be:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "izip_longest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "iterable", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def chunker(iterable, n):\n    class Filler(object): pass\n    return (ifilterfalse(lambda x: x is Filler, chunk) for chunk in (izip_longest(*[iter(iterable)]*n, fillvalue=Filler)))\n</code>\n</pre>\n", "senID": 4}, {"text": ["This guarantees that the fill value is never an item in the underlying iterable.", "Using the definition above:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n iterable = range(1,11)\n\nmap(tuple,chunker(iterable, 3))\n[(1, 2, 3), (4, 5, 6), (7, 8, 9), (10,)]\n\nmap(tuple,chunker(iterable, 2))\n[(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]\n\nmap(tuple,chunker(iterable, 4))\n[(1, 2, 3, 4), (5, 6, 7, 8), (9, 10)]\n</code>\n</pre>\n", "senID": 6}, {"text": ["This implementation almost does what you want, but it has issues:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def chunks(it, step):\n  start = 0\n  while True:\n    end = start+step\n    yield islice(it, start, end)\n    start = end\n</code>\n</pre>\n", "senID": 8}, {"text": ["(The difference is that because islice does not raise StopIteration or anything else on calls that go beyond the end of it this will yield forever; there is also the slightly tricky issue that the islice results must be consumed before this generator is iterated)."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "islice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "it", "childNum": 0, "tag": "code", "childList": []}, {"text": "islice", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To generate the moving window functionally:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n izip(count(0, step), count(step, step))\n</code>\n</pre>\n", "senID": 11}, {"text": ["So this becomes:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n (it[start:end] for (start,end) in izip(count(0, step), count(step, step)))\n</code>\n</pre>\n", "senID": 13}, {"text": ["But, that still creates an infinite iterator.", "So, you need takewhile (or perhaps something else might be better) to limit it:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n chunk = lambda it, step: takewhile((lambda x: len(x) &gt; 0), (it[start:end] for (start,end) in izip(count(0, step), count(step, step))))\n\ng = chunk(range(1,11), 3)\n\ntuple(g)\n([1, 2, 3], [4, 5, 6], [7, 8, 9], [10])\n</code>\n</pre>\n", "senID": 15}], [{"text": ["Although OP asks function to return chunks as list or tuple, in case you need to return iterators, then Sven Marnach's solution can be modified:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sven Marnach's", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/279627/sven-marnach"}]}, {"code": "<pre>\n<code>\n def grouper_it(n, iterable):\n    it = iter(iterable)\n    while True:\n        chunk_it = itertools.islice(it, n)\n        try:\n            first_el = next(chunk_it)\n        except StopIteration:\n            return\n        yield itertools.chain((first_el,), chunk_it)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Some benchmarks: http://pastebin.com/YkKFvm8b"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://pastebin.com/YkKFvm8b", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pastebin.com/YkKFvm8b"}]}, {"text": ["It will be slightly more efficient only if your function iterates through elements in every chunk. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["\"Simpler is better than complex\" -\na starigtforward generator a few lines long can do the job.", "Just place it in some utilities module or so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def grouper (iterable, n):\n    iterable = iter(iterable)\n    count = 0\n    group = []\n    while True:\n        try:\n            group.append(iterable.next())\n            count += 1\n            if count % n == 0:\n                yield group\n                group = []\n        except StopIteration:\n            yield group\n            break\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I forget where I found the inspiration for this.", "I've modified it a little to work with MSI GUID's in the Windows Registry:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def nslice(s, n, truncate=False, reverse=False):\n    \"\"\"Splits s into n-sized chunks, optionally reversing the chunks.\"\"\"\n    assert n &gt; 0\n    while len(s) &gt;= n:\n        if reverse: yield s[:n][::-1]\n        else: yield s[:n]\n        s = s[n:]\n    if len(s) and not truncate:\n        yield s\n</code>\n</pre>\n", "senID": 1}, {"text": ["reverse doesn't apply to your question, but it's something I use extensively with this function."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "reverse", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [i for i in nslice([1,2,3,4,5,6,7], 3)]\n[[1, 2, 3], [4, 5, 6], [7]]\n&gt;&gt;&gt; [i for i in nslice([1,2,3,4,5,6,7], 3, truncate=True)]\n[[1, 2, 3], [4, 5, 6]]\n&gt;&gt;&gt; [i for i in nslice([1,2,3,4,5,6,7], 3, truncate=True, reverse=True)]\n[[3, 2, 1], [6, 5, 4]]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here you go."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def chunksiter(l, chunks):\n    i,j,n = 0,0,0\n    rl = []\n    while n &lt; len(l)/chunks:        \n        rl.append(l[i:j+chunks])        \n        i+=chunks\n        j+=j+chunks        \n        n+=1\n    return iter(rl)\n\n\ndef chunksiter2(l, chunks):\n    i,j,n = 0,0,0\n    while n &lt; len(l)/chunks:        \n        yield l[i:j+chunks]\n        i+=chunks\n        j+=j+chunks        \n        n+=1\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n for l in chunksiter([1,2,3,4,5,6,7,8],3):\n    print(l)\n\n[1, 2, 3]\n[4, 5, 6]\n[7, 8]\n\nfor l in chunksiter2([1,2,3,4,5,6,7,8],3):\n    print(l)\n\n[1, 2, 3]\n[4, 5, 6]\n[7, 8]\n\n\nfor l in chunksiter2([1,2,3,4,5,6,7,8],5):\n    print(l)\n\n[1, 2, 3, 4, 5]\n[6, 7, 8]\n</code>\n</pre>\n", "senID": 2}]]