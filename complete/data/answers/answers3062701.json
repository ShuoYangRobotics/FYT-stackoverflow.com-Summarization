[[{"text": ["The interface  as a keyword and artifact was introduced by Java1 ( and C# took it from there ) to describe what the contract an object must adhere was. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "interface", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1", "childNum": 0, "tag": "sup", "childList": []}]}, {"text": ["But, interface has always been a key part of Object Oriented Paradigm and basically it represents the methods an object has to respond.", "Java just enforces this mechanism to provide statically type checking."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, dynamic ( OO ) programming languages do use interfaces, even thought they don't statically check them.", "Just like other data types, for instance in ruby:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "do", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n @i = 1;\n</code>\n</pre>\n", "senID": 3}, {"text": ["You don't have to declare i of type FixNum you just use it.", "Same goes for interfaces, they just flow.", "The trade-off is, you can't have a static check on that and failures are only show at runtime. "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "FixNum", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["In the other hand Structural type ( or static duck type as I call it :P )  used by languages as Go or Scala, gives the best of both worlds. "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Structural type", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Structural_type_system"}]}, {"text": ["1.", "See Daniel Earwicker  comment about CORBAinterfacekeyword"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "1. See Daniel Earwicker  comment about CORBAinterfacekeyword", "childNum": 1, "tag": "sub", "pos": -1, "childList": [{"text": "interface", "tag": "code"}]}, {"text": "interface", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"senID": 7}], [{"text": ["We don't require them, but we do support them.", "Check out Zope Interfaces (which can be and are used outside of Zope)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "require", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "support", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "Zope Interfaces", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://wiki.zope.org/zope3/WhatAreInterfaces"}]}], [{"text": ["Interface constructs are used in statically typed languages to teach the type system which objects are substitutable for each other in a particular method-calling context.", "If two objects implement the same method but aren't related through inheritance from a common base class or implementation of a common interface, the type system will raise an error at compile time if you substitute one for the other."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Dynamic languages use \"duck typing\", which means the method is simply looked up at runtime and if it exists with the right signature, it's used; otherwise a runtime error results.", "If two objects both \"quack like a duck\" by implementing the same method, they are substitutable.", "Thus, there's no explicit need for the language to relate them via base class or interface."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["That being said, interfaces as a concept are still very important in the dynamic world, but they're often just defined in documentation and not enforced by the language.", "Occasionally, I see programmers actually make a base class that sketches out the interface for this purpose as well; this helps formalize the documentation, and is of particular use if part of the interface can be implemented in terms of the rest of the interface."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "concept", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["It's worth noting that, contrary to what many people will say as a first response, interfaces can be used to do more than document \"what methods a class supports\".", "Grzenio touches on this with his wording on \"implement the same behaviour\".", "As a specific example of this, look at the Java interface Serializable.", "It doesn't implement any methods; rather it's used as a \"marker\" to indicate that the class can be serialized safely."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When considered this way, it could be reasonable to have a dynamic language that uses interfaces.", "That being said, something akin to annotations might be a more reasonable approach."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["One key thing about at least some dynamic languages that makes explicit interfaces more than a little awkward is that dynamic languages can often respond to messages (err, \u201cmethod calls\u201d) that they don't know about beforehand, even doing things like creating methods on the fly.", "The only real way to know whether an object will respond to a message correctly is by sending it the message.", "That's OK, because dynamic languages consider it better to be able to support that sort of thing rather than static type checking; an object is considered to be usable in a particular protocol because it is \u201cknown\u201d to be able to participate in that protocol (e.g., by virtue of being given by another message)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Perl has Roles (or traits ), It is more than interfaces unlike java perl roles we can have a implementation check out these links for more on perl roles"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["http://en.wikipedia.org/wiki/Perl_6#Roles"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["http://use.perl.org/~Ovid/journal/38649"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}]}], [{"text": ["Interfaces are used in statically typed languages to describe that two otherwise independent objects \"implement the same behaviour\".", "In dynamically typed languages one implicitly assumes that when two objects have a method with the same name/params it does the same thing, so interfaces are of no use."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In C# and Java, interfaces are just abstract classes with all abstract methods.", "They exist to allow pseudo multiple-inheritance without actually supporting full-blown multiple inheritance and the ambiguity multiple inheritance creates."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python supports multiple inheritance and has its own way of determining which parent's method should be called when a method exists in multiple parents."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "multiple inheritance", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#multiple-inheritance"}]}], [{"text": ["Dynamic languages are Duck Typed"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://en.wikipedia.org/wiki/Duck_typing"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Duck_typing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Duck_typing"}]}, {"text": ["In other words, If you exect an object to suport the Delete() method, than you can just use the"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n obj.Delete()\n</code>\n</pre>\n", "senID": 3}, {"text": ["method but if the object doesn't support Delete() you get a Runtime error.", "Statically typed languages wouldn't allow that and throw a compile time error.", "So you basically trade type safty against faster developement time and flexibility."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Without interfaces you can do something like that in static languages:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n void Save(MyBaseClass item)\n{\n    if (item.HasChanges)\n        item.Save()\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["but that would require every object that you pass to this method to inherit from MyBaseClass.", "Since Java or C# don't support muliinheritance that isn't very flexible because if your class already inherits another class it cannot inherit from MyBaseClass, too.", "So the better choise would be to create a ISavable interface and accept that as a input parameter to ensure that item can be saved.", "Then you have best of both: type safety and flexibility."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n public interface ISavable\n{\n    bool HasChanges {get;set;}\n    void Save();\n}\n\nvoid Save(ISavable item)\n{\n    if (item.HasChanges)\n        item.Save()\n}\n</code>\n</pre>\n", "senID": 8}, {"text": ["The last backdoor is to use object as a parameter if you cannot expect every item that will use your save method to implement the interface."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n void Save(object item)\n{\n    if (item.HasChanges)\n        item.Save()\n}\n</code>\n</pre>\n", "senID": 10}, {"text": ["But than again, you don't have compile time checking and probably get a runtime error if someone uses your method with an incompatible class."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}]]