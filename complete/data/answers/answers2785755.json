[[{"text": ["Most of the answers seem massively over complicated.", "You don't need back references.", "You don't need to depend on whether or not re.findall gives overlapping matches.", "Given that the input cannot be parsed with the csv module so a regular expression is pretty well the only way to go, all you need is to call re.split with a pattern that matches a field."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "don't", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "don't", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["Note that it is much easier here to match a field than it is to match a separator:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\ndata = \"\"\"part 1;\"this is ; part 2;\";'this is ; part 3';part 4;this \"is ; part\" 5\"\"\"\nPATTERN = re.compile(r'''((?:[^;\"']|\"[^\"]*\"|'[^']*')+)''')\nprint PATTERN.split(data)[1::2]\n</code>\n</pre>\n", "senID": 2}, {"text": ["and the output is:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n ['part 1', '\"this is ; part 2;\"', \"'this is ; part 3'\", 'part 4', 'this \"is ; part\" 5']\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here is an annotated pyparsing approach:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}]}, {"code": "<pre>\n<code>\n from pyparsing import (printables, originalTextFor, OneOrMore, \n    quotedString, Word, delimitedList)\n\n# unquoted words can contain anything but a semicolon\nprintables_less_semicolon = printables.replace(';','')\n\n# capture content between ';'s, and preserve original text\ncontent = originalTextFor(\n    OneOrMore(quotedString | Word(printables_less_semicolon)))\n\n# process the string\nprint delimitedList(content, ';').parseString(test)\n</code>\n</pre>\n", "senID": 1}, {"text": ["giving"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['part 1', '\"this is ; part 2;\"', \"'this is ; part 3'\", 'part 4', \n 'this \"is ; part\" 5']\n</code>\n</pre>\n", "senID": 3}, {"text": ["By using pyparsing's provided quotedString, you also get support for escaped quotes."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "quotedString", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You also were unclear how to handle leading whitespace before or after a semicolon delimiter, and none of your fields in your sample text has any.", "Pyparsing would parse \"a; b ; c\" as:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n ['a', 'b', 'c']\n</code>\n</pre>\n", "senID": 6}], [{"text": ["You appears to have a semi-colon seperated string.", "Why not use the csv module to do all the hard work?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "csv", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Off the top of my head, this should work"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import csv \nfrom StringIO import StringIO \n\nline = '''part 1;\"this is ; part 2;\";'this is ; part 3';part 4;this \"is ; part\" 5'''\n\ndata = StringIO(line) \nreader = csv.reader(data, delimiter=';') \nfor row in reader: \n    print row\n</code>\n</pre>\n", "senID": 2}, {"text": ["This should give you something like\n(\"part 1\", \"this is ; part 2;\", 'this is ; part 3', \"part 4\", \"this \\\"is ; part\\\" 5\")"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "(\"part 1\", \"this is ; part 2;\", 'this is ; part 3', \"part 4\", \"this \\\"is ; part\\\" 5\")", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit:\nUnfortunately, this doesn't quite work, (even if you do use StringIO, as I intended), due to the mixed string quotes (both single and double).", "What you actually get is"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"text": ["['part 1', 'this is ; part 2;', \"'this is \", \" part 3'\", 'part 4', 'this \"is ', ' part\" 5']."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "['part 1', 'this is ; part 2;', \"'this is \", \" part 3'\", 'part 4', 'this \"is ', ' part\" 5']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you can change the data to only contain single or double quotes at the appropriate places, it should work fine, but that sort of negates the question a bit."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"code": "<pre>\n<code>\n re.split(''';(?=(?:[^'\"]|'[^']*'|\"[^\"]*\")*$)''', data)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["While it could be done with PCRE via lookaheads/behinds/backreferences, it's not really actually a task that regex is designed for due to the need to match balanced pairs of quotes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Instead it's probably best to just make a mini state machine and parse through the string like that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As it turns out, due to the handy additional feature of Python re.findall which guarantees non-overlapping matches, this can be more straightforward to do with a regex in Python than it might otherwise be.", "See comments for details."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "re.findall", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["However, if you're curious about what a non-regex implementation might look like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n x = \"\"\"part 1;\"this is ; part 2;\";'this is ; part 3';part 4;this \"is ; part\" 5\"\"\"\n\nresults = [[]]\nquote = None\nfor c in x:\n  if c == \"'\" or c == '\"':\n    if c == quote:\n      quote = None\n    elif quote == None:\n      quote = c\n  elif c == ';':\n    if quote == None:\n      results.append([])\n      continue\n  results[-1].append(c)\n\nresults = [''.join(x) for x in results]\n\n# results = ['part 1', '\"this is ; part 2;\"', \"'this is ; part 3'\",\n#            'part 4', 'this \"is ; part\" 5']\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; x = '''part 1;\"this is ; part 2;\";'this is ; part 3';part 4;this \"is ; part\" 5'''\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; re.findall(r'''(?:[^;'\"]+|'(?:[^']|\\\\.)*'|\"(?:[^']|\\\\.)*\")+''', x)\n['part 1', \"this is ';' part 2\", \"'this is ; part 3'\", 'part 4', 'this \"is ; part\" 5']\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This regex will do that: (?:^|;)(\"(?", ":[^\"]+|\"\")*\"|[^;]*)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "(?:^|;)(\"(?:[^\"]+|\"\")*\"|[^;]*)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["since you do not have '\\n', use it to replace any ';' that is not in a quote string"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; new_s = ''\n&gt;&gt;&gt; is_open = False\n\n&gt;&gt;&gt; for c in s:\n...     if c == ';' and not is_open:\n...         c = '\\n'\n...     elif c in ('\"',\"'\"):\n...         is_open = not is_open\n...     new_s += c\n\n&gt;&gt;&gt; result = new_s.split('\\n')\n\n&gt;&gt;&gt; result\n['part 1', '\"this is ; part 2;\"', \"'this is ; part 3'\", 'part 4', 'this \"is ; part\" 5']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This seemed to me an semi-elegant solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["New Solution:"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\nreg = re.compile('(\\'|\").*?\\\\1')\npp = re.compile('.*?;')\ndef splitter(string):\n    #add a last semicolon\n    string += ';'\n    replaces = []\n    s = string\n    i = 1\n    #replace the content of each quote for a code\n    for quote in reg.finditer(string):\n        out = string[quote.start():quote.end()]\n        s = s.replace(out, '**' + str(i) + '**')\n        replaces.append(out)\n        i+=1\n    #split the string without quotes\n    res = pp.findall(s)\n\n    #add the quotes again\n    #TODO this part could be faster.\n    #(lineal instead of quadratic)\n    i = 1\n    for replace in replaces:\n        for x in range(len(res)):\n            res[x] = res[x].replace('**' + str(i) + '**', replace)\n        i+=1\n    return res\n</code>\n</pre>\n", "senID": 2}, {"text": ["Old solution:"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["I choose to match if there was an opening quote and wait it to close, and the match an ending semicolon.", "each \"part\" you want to match needs to end in semicolon.", "so this match things like this : "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "'foobar;.sska'; ", "tag": "none", "senID": 5}, {"text": "\"akjshd;asjkdhkj..,\";", "tag": "none", "senID": 6}, {"text": "asdkjhakjhajsd.jhdf;", "tag": "none", "senID": 7}]}, {"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n mm = re.compile('''((?P&lt;quote&gt;'|\")?.*?(?(quote)\\\\2|);)''')\nres = mm.findall('''part 1;\"this is ; part 2;\";'this is ; part 3';part 4''')\n</code>\n</pre>\n", "senID": 9}, {"text": ["you may have to do some postprocessing to res, but it contains what you want."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Even though I'm certain there is a clean regex solution (so far I like @noiflection's answer), here is a quick-and-dirty non-regex answer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = \"\"\"part 1;\"this is ; part 2;\";'this is ; part 3';part 4;this \"is ; part\" 5\"\"\"\n\ninQuotes = False\ncurrent = \"\"\nresults = []\ncurrentQuote = \"\"\nfor c in s:\n    if not inQuotes and c == \";\":\n        results.append(current)\n        current = \"\"\n    elif not inQuotes and (c == '\"' or c == \"'\"):\n        currentQuote = c\n        inQuotes = True\n    elif inQuotes and c == currentQuote:\n        currentQuote = \"\"\n        inQuotes = False\n    else:\n        current += c\n\nresults.append(current)\n\nprint results\n# ['part 1', 'this is ; part 2;', 'this is ; part 3', 'part 4', 'this is ; part 5']\n</code>\n</pre>\n", "senID": 1}, {"text": ["(I've never put together something of this sort, feel free to critique my form!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["My approach is to replace all non-quoted occurrences of the semi-colon with another character which will never appear in the text, then split on that character.", "The following code uses the re.sub function with a function argument to search and replace all occurrences of a srch string, not enclosed in single or double quotes or parens, brackets or braces, with a repl string:  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "srch", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "repl", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def srchrepl(srch, repl, string):\n    \"\"\"\n    Replace non-bracketed/quoted occurrences of srch with repl in string.\n    \"\"\"\n    resrchrepl = re.compile(r\"\"\"(?P&lt;lbrkt&gt;[([{])|(?P&lt;quote&gt;['\"])|(?P&lt;sep&gt;[\"\"\"\n                          + srch + \"\"\"])|(?P&lt;rbrkt&gt;[)\\]}])\"\"\")\n    return resrchrepl.sub(_subfact(repl), string)\n\n\ndef _subfact(repl):\n    \"\"\"\n    Replacement function factory for regex sub method in srchrepl.\n    \"\"\"\n    level = 0\n    qtflags = 0\n    def subf(mo):\n        nonlocal level, qtflags\n        sepfound = mo.group('sep')\n        if  sepfound:\n            if level == 0 and qtflags == 0:\n                return repl\n            else:\n                return mo.group(0)\n        elif mo.group('lbrkt'):\n            if qtflags == 0:\n                level += 1\n            return mo.group(0)\n        elif mo.group('quote') == \"'\":\n            qtflags ^= 1            # toggle bit 1\n            return \"'\"\n        elif mo.group('quote') == '\"':\n            qtflags ^= 2            # toggle bit 2\n            return '\"'\n        elif mo.group('rbrkt'):\n            if qtflags == 0:\n                level -= 1\n            return mo.group(0)\n    return subf\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you don't care about the bracketed characters, you can simplify this code a lot.", "Say you wanted to use a pipe or vertical bar as the substitute character, you would do:  "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n mylist = srchrepl(';', '|', mytext).split('|')\n</code>\n</pre>\n", "senID": 3}, {"text": ["BTW, this uses nonlocal from Python 3.1, change it to global if you need to. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]