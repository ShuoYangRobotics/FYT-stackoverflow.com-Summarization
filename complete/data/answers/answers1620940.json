[[{"code": "<pre>\n<code>\n for x_ in range(max(0,x-1),min(width,x+2)):\n  for y_ in range(max(0,y-1),min(height,y+2)):\n    if (x,y)==(x_,y_): continue\n    # do stuff with the neighbours\n\n&gt;&gt;&gt; a=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n&gt;&gt;&gt; width=height=3\n&gt;&gt;&gt; x,y=0,2\n&gt;&gt;&gt; for x_ in range(max(0,x-1),min(width,x+2)):\n...   for y_ in range(max(0,y-1),min(height,y+2)):\n...     if (x,y)==(x_,y_): continue\n...     print a[x_][y_]\n... \n2\n5\n6\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n # Size of \"board\"\nX = 10\nY = 10\n\nneighbors = lambda x, y : [(x2, y2) for x2 in range(x-1, x+2) for y2 in range(y-1, y+2) if -1 &lt; x &lt;= X and -1 &lt; y &lt;= Y and (x != x2 or y != y2)]\n\n\n\nprint(neighbors(5, 5))\n\n&gt;&gt;&gt; \n[(4, 4), (4, 5), (4, 6), (5, 4), (5, 6), (6, 4), (6, 5), (6, 6)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["I dont know if this is considered clean :) But, here is a one-liner that gives you all neightbors by iterating them and discarding any edge-cases."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["There's no cleaner way to do this.", "If you really want you could create a function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def top(matrix, x, y):\n     try:\n         return matrix[x][y - 1];\n     except IndexError:\n         return None\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is your list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (x - 1, y - 1) (x, y - 1) (x + 1, y - 1)\n(x - 1, y)     (x, y)     (x + 1, y)\n(x - 1, y + 1) (x, y + 1) (x + 1, y + 1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["So the horizontal neighbors of (x, y) are (x +/- 1, y)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The vertical neighbors are (x, y +/- 1)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Diagonal neighbors are (x +/- 1, y +/- 1)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["These rules apply for an infinite matrix.", "To make sure the neighbors fit into a finite matrix, if the initial (x, y) is at the edge, just apply one more restriction to the coordinates of neighbors - the matrix size."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools\n&gt;&gt;&gt; def sl(lst, i, j):\n    il, iu = max(0, i-1), min(len(lst)-1, i+1)\n    jl, ju = max(0, j-1), min(len(lst[0])-1, j+1)\n    return (il, iu), (jl, ju)\n\n&gt;&gt;&gt; lst = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n&gt;&gt;&gt; tup = 0, 2\n&gt;&gt;&gt; [lst[i][j] for i, j in itertools.product(*sl(lst, *tup)) if (i, j) != tup]\n[2, 5, 6]\n</code>\n</pre>\n", "senID": 0}, {"text": ["I don't know how elegant it seems to you, but it seems to work w/o any hard-coding."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This generates all indices:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def neighboring( array ):\n    nn,mm = len(array), len(array[0])\n    offset = (0,-1,1) # 0 first so the current cell is the first in the gen\n    indices = ( (i,j) for i in range(nn) for j in range(mm) )\n    for i,j in indices:\n        all_neigh =  ( (i+x,j+y) for x in offset for y in offset )\n        valid = ( (i,j) for i,j in all_neigh if (0&lt;=i&lt;nn) and (0&lt;=j&lt;mm) ) # -1 is a valid index in normal lists, but not here so throw it out\n        yield valid.next(), valid ## first is the current cell, next are the neightbors\n\nfor (x,y), neigh in neighboring( l ):\n    print l[x][y], [l[x][y] for x,y in neigh]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["maybe you are checking a sudoku box.", "If the box is n x n and current cell is (x,y) start checking:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n startingRow = x / n * n;\nstartingCol = y/ n * n\n</code>\n</pre>\n", "senID": 1}]]