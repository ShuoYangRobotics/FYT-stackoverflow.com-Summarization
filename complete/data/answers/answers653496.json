[[{"text": ["In SciPy you can use sparse matrices.", "Also note, that there are more efficient ways of multiplying matrix by itself.", "Anyway, what you're trying to do can by done by SVD decomposition. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sparse matrices", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/scipy/reference/sparse.html"}]}, {"text": ["Introduction with useful links. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Introduction with useful links", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://expertvoices.nsdl.org/cornell-cs322/2008/04/06/svd-and-graph-partitioning-can-life-get-more-exciting-than-this/"}]}], [{"text": ["Why not use a real graph library, like Python-Graph?", "It has a function to determine connected components (though no example is provided).", "I'd imagine a dedicated library is going to be faster than whatever ad-hoc graph code you've cooked up."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Python-Graph", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/python-graph/"}, {"text": "function to determine connected components", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.linux.ime.usp.br/~matiello/python-graph/docs/graph.algorithms.accessibility-module.html#connected%5Fcomponents"}]}, {"text": ["EDIT: NetworkX seems like it might be a better choice than python-graph; its documentation (here for the connected components function) certainly is."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "NetworkX", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://networkx.lanl.gov/index.html"}, {"href": "http://networkx.lanl.gov/reference/generated/networkx.connected%5Fcomponents.html#networkx.connected%5Fcomponents", "text": "documentation (here for the connected components function)", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Looks like there is a library PyMetis, which will partition your graph for you, given a list of links.", "It should be fairly easy to extract the list of links from your graph by passing it your original list of linked nodes (not the matrix-multiply-derived one)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PyMetis", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mathema.tician.de/software/pymetis"}]}, {"text": ["Repeatedly performing M' = MM will not be efficient for large orders of M. A full matrix-multiply for matrices of order N will cost N multiplications and N-1 additions per element, of which there are N2, that is O(N3) operations.", "If you are scaling that to \"millions of nodes\", that would be O(1018) operations per matrix-matrix multiplication, of which you want to do several. "], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"text": "3", "childNum": 0, "tag": "sup", "pos": -1, "childList": []}, {"text": "18", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}]}, {"text": ["In short, you don't want to do it this way.", "The SVD suggestion from Vartec would be the only appropriate choice there.", "Your best option is just to use PyMetis, and not try to reinvent graph-partitioning. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "SVD suggestion", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/653496/clustering-a-graph-in-python/653539#653539"}]}], [{"text": ["Here's some naive implementation, which finds the connected components using depth first search, i wrote some time ago.", "Although it's very simple, it scales well to ten thousands of vertices and edges..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "depth first search", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Depth%5Ffirst%5Fsearch"}]}, {"code": "<pre>\n<code>\n import sys\nfrom operator import gt, lt\n\nclass Graph(object):\n    def __init__(self):\n        self.nodes = set()\n        self.edges = {}\n        self.cluster_lookup = {}\n        self.no_link = {}\n\n    def add_edge(self, n1, n2, w):\n        self.nodes.add(n1)\n        self.nodes.add(n2)\n        self.edges.setdefault(n1, {}).update({n2: w})\n        self.edges.setdefault(n2, {}).update({n1: w})\n\n    def connected_components(self, threshold=0.9, op=lt):\n        nodes = set(self.nodes)\n        components, visited = [], set()\n        while len(nodes) > 0:\n            connected, visited = self.dfs(nodes.pop(), visited, threshold, op)\n            connected = set(connected)\n            for node in connected:\n                if node in nodes:\n                    nodes.remove(node)\n\n            subgraph = Graph()\n            subgraph.nodes = connected\n            subgraph.no_link = self.no_link\n            for s in subgraph.nodes:\n                for k, v in self.edges.get(s, {}).iteritems():\n                    if k in subgraph.nodes:\n                        subgraph.edges.setdefault(s, {}).update({k: v})\n                if s in self.cluster_lookup:\n                    subgraph.cluster_lookup[s] = self.cluster_lookup[s]\n\n            components.append(subgraph)\n        return components\n\n    def dfs(self, v, visited, threshold, op=lt, first=None):\n        aux = [v]\n        visited.add(v)\n        if first is None:\n            first = v\n        for i in (n for n, w in self.edges.get(v, {}).iteritems()\n                  if op(w, threshold) and n not in visited):\n            x, y = self.dfs(i, visited, threshold, op, first)\n            aux.extend(x)\n            visited = visited.union(y)\n        return aux, visited\n\ndef main(args):\n    graph = Graph()\n    # first component\n    graph.add_edge(0, 1, 1.0)\n    graph.add_edge(1, 2, 1.0)\n    graph.add_edge(2, 0, 1.0)\n\n    # second component\n    graph.add_edge(3, 4, 1.0)\n    graph.add_edge(4, 5, 1.0)\n    graph.add_edge(5, 3, 1.0)\n\n    first, second = graph.connected_components(op=gt)\n    print first.nodes\n    print second.nodes\n\nif __name__ == '__main__':\n    main(sys.argv)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As others have pointed out, no need to reinvent the wheel.", "A lot of thought has been put into optimal clustering techniques.", "Here is one well-known clustering program."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Here", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.micans.org/mcl/"}]}], [{"text": ["The SVD algorithm is not applicable here, but otherwise Phil H is correct. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Finding an optimal graph partition is an NP-hard problem, so whatever the algorithm, it is going to be a heuristic.", "Not surprisingly, different clustering algorithms produce (wildly) different results. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python implementation of Newman's modularity algorithm:\nmodularity"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "modularity", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://perso.crans.org/aynaud/communities/index.html"}]}, {"text": ["Also: MCL, MCODE, CFinder, NeMo, clusterONE"], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "MCL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.micans.org/mcl/"}, {"href": "http://baderlab.org/Software/MCODE", "text": "MCODE", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://www.cfinder.org/", "text": "CFinder", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://chianti.ucsd.edu/cyto_web/plugins/displayplugininfo.php?name=NeMo", "text": "NeMo", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://www.paccanarolab.org/software/cluster-one/index.html", "text": "clusterONE", "childNum": 0, "tag": "a", "childList": []}]}]]