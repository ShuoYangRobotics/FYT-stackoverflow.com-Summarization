[[{"text": ["Your algorithm is not the Sieve of Eratosthenes.", "You perform trial division (the modulus operator) instead of crossing-off multiples, as Eratosthenes did over two thousand years ago.", "Here is an explanation of the true sieving algorithm, and shown below is my simple, straight forward implementation, which returns a list of primes not exceeding n:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Here", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://programmingpraxis.com/2009/02/19/sieve-of-eratosthenes/"}, {"text": "n", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n def sieve(n):\n    m = (n-1) // 2\n    b = [True]*m\n    i,p,ps = 0,3,[2]\n    while p*p &lt; n:\n        if b[i]:\n            ps.append(p)\n            j = 2*i*i + 6*i + 3\n            while j &lt; m:\n                b[j] = False\n                j = j + 2*i + 3\n        i+=1; p+=2\n    while i &lt; m:\n        if b[i]:\n            ps.append(p)\n        i+=1; p+=2\n    return ps\n</code>\n</pre>\n", "senID": 1}, {"text": ["We sieve only on the odd numbers, stopping at the square root of n. The odd-looking calculations on j map between the integers being sieved 3, 5, 7, 9, ... and indexes 0, 1, 2, 3, ... in the b array of bits."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "n", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "j", "childNum": 0, "tag": "em", "childList": []}, {"text": "b", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["You can see this function in action at http://ideone.com/YTaMB, where it computes the primes to a million in less than a second."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://ideone.com/YTaMB", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ideone.com/YTaMB"}]}], [{"text": ["You can try the same way Eratosthenes did.", "Take an array with all numbers you need to check order ascending, go to number 2 and mark it.", "Now scratch every second number till the end of the array.", "Then go to 3 and mark it.", "After that scratch every third number .", "Then go to 4 - it is already scratched, so skip it.", "Repeat this for every n+1 which is not already scratched."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In the end, the marked numbers are the prime one.", "This algorithm is faster, but sometimes need lots of memory.", "You can optimize it a little by drop all even numbers (cause they are not prime) and add 2 manually to the list.", "This will twist the logic a little, but will take half the memory."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here is an illustration of what I'm talking about: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"}]}], [{"text": ["Warning: removing elements from an iterator while iterating on it can be dengerous... "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could make the "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if(thing % divisor == 0) and thing != divisor:\n</code>\n</pre>\n", "senID": 2}, {"text": ["test lighter by splitting it in the loop that breaks when you arrive to the index of 'divisor' and then the test:  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for thing in numberList_fromDivisorOn:\n    if(thing % divisor == 0):\n        numberList.remove(thing)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I followed this link: Sieve of Eratosthenes - Finding Primes Python as suggested by @MAK and I've found that the accepted answer could be improved with an idea I've found in your code: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sieve of Eratosthenes - Finding Primes Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3939660/sieve-of-eratosthenes-finding-primes-python"}]}, {"code": "<pre>\n<code>\n def primes_sieve2(limit):\n    a = [True] * limit               # Initialize the primality list\n    a[0] = a[1] = False\n    sqrt = int(math.sqrt(limit))+1\n    for i in xrange(sqrt):\n        isprime = a[i]\n        if isprime:\n            yield i\n            for n in xrange(i*i, limit, i):     # Mark factors non-prime\n                a[n] = False\n    for (i, isprime) in enumerate(a[sqrt:]):\n        if isprime:\n            yield i+sqrt\n</code>\n</pre>\n", "senID": 1}], [{"text": ["if given unlimited memory and time, the following code will print all the prime numbers.", "and it'll do it without using trial division.", "it is based on the haskell code in the paper: The Genuine Sieve of Eratosthenes by Melissa E. O'Neill"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "The Genuine Sieve of Eratosthenes by Melissa E. O'Neill", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf"}]}, {"code": "<pre>\n<code>\n from heapq import heappush, heappop, heapreplace\ndef sieve():\n    w = [2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10]\n    for p in [2,3,5,7]: print p\n    n,o = 11,0\n    t = []\n    l = len(w)\n    p = n\n    heappush(t, (p*p, n,o,p))\n    print p\n    while True:\n        n,o = n+w[o],(o+1)%l\n        p = n\n        if not t[0][0] &lt;= p:\n            heappush(t, (p*p, n,o,p))\n            print p\n            continue\n        while t[0][0] &lt;= p:\n            _, b,c,d = t[0]\n            heapreplace(t, (b*d, b+w[c],(c+1)%l,d))\nsieve()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This code takes 2 seconds to generate primes less than 10M\n(it is not mine, i found it somewer on google)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def erat_sieve(bound):\n    if bound &lt; 2:\n        return []\n    max_ndx = (bound - 1) // 2\n    sieve = [True] * (max_ndx + 1)\n    #loop up to square root\n    for ndx in range(int(bound ** 0.5) // 2):\n        # check for prime\n        if sieve[ndx]:\n            # unmark all odd multiples of the prime\n            num = ndx * 2 + 3\n            sieve[ndx+num:max_ndx:num] = [False] * ((max_ndx-ndx-num-1)//num + 1)\n    # translate into numbers\n    return [2] + [ndx * 2 + 3 for ndx in range(max_ndx) if sieve[ndx]]\n</code>\n</pre>\n", "senID": 1}]]