[[{"text": ["Python 2.5 includes an uuid implementation which (in at least one version) needs the mac address.", "You can import the mac finding function into your own code easily:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from uuid import getnode as get_mac\nmac = get_mac()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The return value is the mac address as 48 bit integer."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The pure python solution for this problem under Linux to get the MAC for a specific local interface, originally posted as a comment by vishnubob and improved by  on Ben Mackey in this activestate recipe"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this activestate recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/439094-get-the-ip-address-associated-with-a-network-inter/"}]}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\nimport fcntl, socket, struct\n\ndef getHwAddr(ifname):\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    info = fcntl.ioctl(s.fileno(), 0x8927,  struct.pack('256s', ifname[:15]))\n    return ''.join(['%02x:' % ord(char) for char in info[18:24]])[:-1]\n\nprint getHwAddr('eth0')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One other thing that you should note is that uuid.getnode() can fake the MAC addr by returning a random 48-bit number which may not be what you are expecting.", "Also, there's no explicit indication that the MAC address has been faked, but you could detect it by calling getnode() twice and seeing if the result varies.", "If the same value is returned by both calls, you have the MAC address, otherwise you are getting a faked address."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "uuid.getnode()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "getnode()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print uuid.getnode.__doc__\nGet the hardware address as a 48-bit positive integer.\n\n    The first time this runs, it may launch a separate program, which could\n    be quite slow.  If all attempts to obtain the hardware address fail, we\n    choose a random 48-bit number with its eighth bit set to 1 as recommended\n    in RFC 4122.\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I haven't personally used this, but it looks like it's exactly what you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python netifaces"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Python netifaces", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/netifaces/0.4"}]}], [{"text": ["For Linux you can retrieve the MAC address using a SIOCGIFHWADDR ioctl."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n struct ifreq    ifr;\nuint8_t         macaddr[6];\n\nif ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)) &lt; 0)\n    return -1;\n\nstrcpy(ifr.ifr_name, \"eth0\");\n\nif (ioctl(s, SIOCGIFHWADDR, (void *)&amp;ifr) == 0) {\n    if (ifr.ifr_hwaddr.sa_family == ARPHRD_ETHER) {\n        memcpy(macaddr, ifr.ifr_hwaddr.sa_data, 6);\n        return 0;\n... etc ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["You've tagged the question \"python\".", "I don't know of an existing Python module to get this information.", "You could use ctypes to call the ioctl directly."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "ctypes", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/ctypes/1.0.2"}]}], [{"text": ["Note that you can build your own cross-platform library in python using conditional imports.", "e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import platform\nif platform.system() == 'Linux':\n  import LinuxMac\n  mac_address = LinuxMac.get_mac_address()\nelif platform.system() == 'Windows':\n  # etc\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will allow you to use os.system calls or platform-specific libraries."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I dont know of a unified way, but heres something that you might find useful:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.codeguru.com/Cpp/I-N/network/networkinformation/article.php/c5451"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.codeguru.com/Cpp/I-N/network/networkinformation/article.php/c5451", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codeguru.com/Cpp/I-N/network/networkinformation/article.php/c5451"}]}, {"text": ["What I would do in this case would be to wrap these up into a function, and based on the OS it would run the proper command, parse as required and return only the MAC address formatted as you want.", "Its ofcourse all the same, except that you only have to do it once, and it looks cleaner from the main code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]