[[{"text": ["The only thing I can think of that may surprise some people is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def test():\n    try:\n        return True\n    finally:\n        return False\n\nprint test()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n False\n</code>\n</pre>\n", "senID": 3}, {"text": ["finally clauses really are executed last, even if a return statement precedes them.", "However, this is not specific to Python."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "finally", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Execution of C certainly is sequential, for actual statements.", "There are even rules that define the sequence points, so you can know how individual expressions evaluate. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sequence points", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sequence_point"}]}], [{"text": ["CPython itself is written in such a way that any effects like those you mention are minimized; code always executes top to bottom barring literal evaluation during compilation, objects are GCed as soon as their refcount hits 0, etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Execution in the cpython vm is very linear.", "I do not think whatever problem you have has to do with order of execution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One thing you should be careful about in Python but not C: exceptions can be raised everywhere, so just because you see a close() call below the corresponding open() call does not mean that call is actually reached.", "Use try/finally everywhere (or the with statement in new enough pythons) to make sure opened files are closed (and other kinds of resources that can be freed explicitly are freed)."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "close()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "open()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "try", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "finally", "childNum": 0, "tag": "code", "childList": []}, {"text": "with", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If your problem is with memory usage, not some other kind of resource, debugging it can be harder.", "Memory cannot be freed explicitly in python.", "The cpython vm (which you are most likely using) does release memory as soon as the last reference to it goes away, but sometimes cannot free memory trapped in cycles with objects that have a __del__ method.", "If you have any __del__ methods of your own or use classes that have them this may be part of your problem."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__del__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__del__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Your actual question (the memory one, not the order of execution one) is hard to answer without seeing more code, though.", "It may be something obvious (or there may at least be some obvious way to reduce the amount of memory you need)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["\"if I open a file of data, read in the data, close the file, then do other stuff do I know for sure that the file is closed before the lines after I close the file are executed??"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Closed yes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Released from memory.", "No.", "No guarantees about when garbage collection will occur."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Further, closing a file says nothing about all the other variables you've created and the other objects you've left laying around attached to those variables."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["There's no \"order of operations\" issue."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I'll bet that you have too many global variables with too many copies of the data."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["If the data consists of columns and rows, why not use the built in file iterator to fetch one line at a time?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open('file.txt')\nfirst_line = f.next()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["popen2.py:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "popen2.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/tags/r25/Lib/popen2.py?view=markup#Popen4"}]}, {"code": "<pre>\n<code>\n class Popen4(Popen3):\n    childerr = None\n\n    def __init__(self, cmd, bufsize=-1):\n        _cleanup()\n        self.cmd = cmd\n        p2cread, p2cwrite = os.pipe()\n        c2pread, c2pwrite = os.pipe()\n        self.pid = os.fork()\n        if self.pid == 0:\n            # Child\n            os.dup2(p2cread, 0)\n            os.dup2(c2pwrite, 1)\n            os.dup2(c2pwrite, 2)\n            self._run_child(cmd)\n        os.close(p2cread)\n        self.tochild = os.fdopen(p2cwrite, 'w', bufsize)\n        os.close(c2pwrite)\n        self.fromchild = os.fdopen(c2pread, 'r', bufsize)\n</code>\n</pre>\n", "senID": 1}, {"text": ["man 2 fork:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "man 2 fork", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.opengroup.org/onlinepubs/000095399/functions/fork.html"}]}, {"text": ["os.popen4 eventually calls open2.Popen4.__init__, which must fork in order to create the child process that you try to read from/write to.", "This underlying call is failing, likely due to resource exhaustion."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "os.popen4", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "open2.Popen4.__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fork", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["You may be using too much memory elsewhere, causing fork to attempt to use more than the RLIMIT_DATA or RLIMIT_RSS limit given to your user.", "As recommended by Python memory profiler - Stack Overflow, Heapy can help you determine whether this is the case."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "fork", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "RLIMIT_DATA", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.opengroup.org/onlinepubs/009695399/functions/getrlimit.html"}, {"text": "Python memory profiler - Stack Overflow", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/110259"}, {"href": "http://guppy-pe.sourceforge.net/#Heapy", "text": "Heapy", "childNum": 0, "tag": "a", "childList": []}]}]]