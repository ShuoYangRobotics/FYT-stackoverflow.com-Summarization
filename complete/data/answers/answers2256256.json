[[{"text": ["How about SQLite with Python bindings?", "It has a little more than you need, but it's standard software and well-tested."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "SQLite", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sqlite.org/"}]}], [{"text": ["The old way would be to use a simple key/value data table like gdbm module.", "Python comes with support for that, but it's not built into the default Python installation on my machine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In general, use SQLite.", "As others wrote, it comes standard with Python, and it's used in a lot of embedded systems already."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If the records are fixed length then you can use the bisect module.", "The file size / the record size gives the number of records in the file.", "The bisect search will do an O(log(n)) lookup in the file, and you'll need to write an adapter to test for equality.", "While I haven't tested it, here's a sketch:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import bisect\n\nRECORD_SIZE = 50\n\nclass MatchFirst10Chars(object):\n    def __init__(self, word):\n        self.word = word\n    def __lt__(self, other):\n        return self.word &lt; other[:10]\n\nclass FileLookup(object):\n    def __init__(self, f):\n        self.f = f\n        f.seek(0, 2)\n        self.size = f.tell() // RECORD_SIZE\n    def __len__(self):\n        return self.size\n\n    def __getitem__(self, i):\n        self.f.seek(i*RECORD_SIZE)\n        return self.f.read(RECORD_SIZE)\n\n\nSKU = \"123-56-89 \"\nf = open(\"data_file\")\nfl = FileLookup(f)\ni = bisect.bisect(fl, MatchFirst10Chars(SKU))\n</code>\n</pre>\n", "senID": 3}, {"text": ["You could additionally gzip the file and seek on a gzip'ped file, but that's a tradeoff for space vs. time that you'll have to test."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["How about HDF?", "If you don't need SQL and require fast access to your data, there's nothing faster... in Python... for numerical or structured data."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "HDF", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/h5py/"}]}, {"text": ["Take a look at the DatabaseInterfaces section on the Python wiki.", "It's comprehensive.", "There are a couple of \"pure\" Python options listed (like SnakeSQL), which are a tad nicer to deploy.", "And, of course, there's always Berkeley DB and the like, which are super lean &amp; raw."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "DatabaseInterfaces", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/DatabaseInterfaces"}, {"text": "Python", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.python.org/"}, {"text": "SnakeSQL", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://pythonweb.org/projects/snakesql/"}, {"text": "Berkeley DB", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.jcea.es/programacion/pybsddb.htm"}]}, {"text": ["Honestly, SQLite will probably work fine for you.", "If you really need to eek out more performance, then you'd be looking at a record-based format like BDB."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["May I suggest cdb?", "(Python bindings: python-cdb."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "cdb", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cr.yp.to/cdb.html"}, {"text": "python-cdb", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/python-cdb/"}]}, {"text": ["It's a format used for read-only data, like you have; it's basically 256 giant hash tables, each able to have a different number of buckets.", "The cool thing about cdb is that the file doesn't need to be loaded into memory; it's structured in a way that you can do lookups by just mmaping in the bits you need."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "mmap", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The cdb spec is a good read, not least because the lines are formatted to create a uniform right margin.", ":-D"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "cdb spec", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cr.yp.to/cdb/cdb.txt"}]}], [{"text": ["A simple solution is CPickle.", "You can also find similar questions on SO."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "CPickle", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pickle.html"}, {"text": "similar questions", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/890485/python-how-do-i-write-a-list-to-file-and-then-pull-it-back-into-memory-dict-rep"}]}], [{"text": ["A variation of Andrew Dalke's answer (so you can still use binary search to locate the SKU quickly) which may reduce the space requirements would be to have fixed sized records at the start of the file (one per SKU) and then all the Descriptions and Locations (as null terminated strings say)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You get to save space by not having to pad out the locations and descriptions to fixed length.", "Also you can save space if there are lots of duplicate locations"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here is an example:\nsay you have"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n SKU         16 bytes\nDescription Variable length\nLocation    Variable length\nPrice       4 bytes (up to $42949672.95)\nQuantity    4 bytes (up to 4294967295)\n\n\n\n offset          SKU        desc_off   loc_off      Price      Quantity\n0x00000000 SKU0000000000001 0x01f78a40 0x01f78a47  0x000003e8  0x000f4240\n0x00000020 SKU0000000000002 0x01f78a53 0x01f78a59    ...\n...\n... # 999998 more records\n...\n0x01f78a40 Widget\\x00\n0x01f78a47 Head office\\x00\n0x01f78a53 Table\\x00\n0x01f78a59 Warehouse\\x00\n</code>\n</pre>\n", "senID": 3}]]