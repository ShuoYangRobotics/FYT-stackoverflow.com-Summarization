[[{"text": ["Note: The author disavows a deep expertise in this subject.", "Some assertions may be incorrect."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Note: The author disavows a deep expertise in this subject. Some assertions may be incorrect.", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Python actually is compiled into bytecode, which is what gets run by the python interpreter.", "Whenever you use a Python module, Python will generate a .pyc file with a name corresponding to the module.", "This is the equivalent of the .o file that's generated when you compile a C file."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": ".pyc", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": ".o", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["So if you want something to disassemble, the .pyc file would be it :)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": ".pyc", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The process that Python goes through when compiling a module is pretty similar to what gcc or another C compiler does with C source code.", "The major difference is that it happens transparently as part of execution of the file.", "It's also optional: when running a non-module, i.e.", "an end-user script, Python will just interpret the code rather than compiling it first."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "gcc", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So really your question is \"Why are python programs distributed as source rather than as compiled modules?", "\"  Or, put another way, \"Why are C applications distributed as compiled binaries rather than as source code?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["It used to be very common for C applications to be distributed as source code.", "This was back before operating systems and their various subentities (i.e.", "linux distributions) became more established.", "Some distros, for example gentoo, still distribute apps as source code.", "Apps which are a bit more cutting edge or obscure are still distributed as source code for all platforms they target."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The reason for this is compatibility, and dependencies.", "The reason you can run the precompiled binary Safari on a Mac, or Firefox on Ubuntu Linux, is because it's been specifically built for that operating system, architecture (e.g.", "x86_64), and set of libraries."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Unfortunately, compilation of a large app is pretty slow, and needs to be redone at least partially every time the app is updated.", "Thus the motivation for binary distributions."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["So why not create a binary distribution of Python?", "For one thing, as Aaron mentions, modules would need to be recompiled for each new version of the Python bytecode.", "But this would be similar to rebuilding a C app to link with a newer version of a dynamic library \u2014 Python modules are analogous in this sense to C libraries."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "mentions", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3869435/why-do-c-programs-require-decompilers-but-python-programs-dont/3869455#3869455"}]}, {"text": ["The real reason is that Python compilation is very much quicker than C compilation.", "This is in part, I think, because of the dynamic nature of the language, and also because it's not as thorough of a compilation.", "This has its tradeoffs: in particular, Python apps run much more slowly than do their C counterparts, because Python has to interpret the compiled bytecode into instructions for the processor, whereas the C app already contains such instructions."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["That all being said, there is a program called py2exe that will take a Python module and distribution and build a precompiled windows executable, including in it the logic of the module and its dependencies, including Python itself.", "I guess the point of this is to avoid having to coerce people into installing Python on their Windows system just to run your app.", "Under linux, or I think even OS/X, Python is usually already installed, so precompilation is not really necessary.", "Linux systems also have super-dandy package managers that will transparently install dependencies such as Python if they are not already installed."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "py2exe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://py2exe.org/"}]}], [{"text": ["Python is a script language, runs in a virtual machine through an interpeter.", "C is a compiled language, the code compiled to binary code which the computer can run without all that extra stuff Python needs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This is sorta a big topic.", "You should look into your local friendly Computer Science curriculum, you'll find a lot of great stuff on this subject there."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The short answer is the Python is an \"interpreted\" language, which means that it requires a machine language program (the python interpreter) to run the python program, adding a layer of indirection.", "C or C++ are different.", "They are compiled directly to machine code, which runs directly on your processor."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There is a lot of additional voodoo to be learned here, however.", "Technically Python is compiled to a bytecode, and modern interpreters do more and more \"Just in Time\" compilation, so the boundaries between compiled and interpreted code are getting fuzzier all the time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In several comments you asked: \"Is it then possible to compile python to an executable binary file and then simply distribute that?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["From a theoretical viewpoint, there's no question the answer is yes -- a Python program could be compiled to, and distributed as, fully compiled machine code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["From a practical viewpoint, it's open to a lot more question.", "There are a few things like Unladen Swallow, Psyco, Shed Skin, and PyPy that you might want to know about though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Bottom line: work has been done and is being done with the intent of doing what you asked about, but at least to my knowledge there's not really anything I could reasonably recommend as a finished product that you can really depend on to do the job right now.", "The primary emphasis is really on execution speed, not producing standalone executables."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "intent", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["you can't open up and read the code that actually runs for python either.", "Try"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import dis\n\ndef foo():\n    for i in range(100):\n        print i\n\nprint dis.dis(foo)\n</code>\n</pre>\n", "senID": 1}, {"text": ["That will show you the (human readable) bytcode of the foo program.", "equivalently, you can save the file and import it from the interactive python interpreter.", "This will create a .pyc file with the same basename as the script.", "open that with a hex editor and you are looking at the actually python bytecode."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".pyc", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The reason for the difference is that python changes up it's byte code between releases so that you would either need to distribute a different version of a binary only release for each version of python.", "This would be a pain."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["With C, it's compiled to native code and so the byte code is much more stable making binary only releases possible."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Yes, you can - it's called disassembling, and allows you to look at the code of Safari perfectly well.", "The thing is, C, among other languages, compiles to native code, i.e.", "code that your CPU can \"understand\" and execute. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["More or less obviously, the level of abstraction present in the instruction set of your CPU is much smaller than that of a high level language like Python.", "The CPU instructions are not concerned with \"downloading that URI\", but more \"check if that bit is set in a hardware register\"."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, in conclusion, the level of complexity present in a native application is much higher when looking at the machine code, so many people simply can't make any sense of what is going on there, it's hard to get the big picture.", "With experience and time at your hands, it is possible though - people do it all the time, reversing applications and all."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["because C code is complied to object (machine) code and python code is compiled into an intermediate byte code.", "I am not sure if you are even referring to the byte code of python - you must be referring to the source file itself which is directly executable (hiding the byte code from you!).", "C needs to be compiled and linked."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"tag": "ul", "num": 2, "lis": [{"text": "Python scripts are parsed and converted to binary only when they're run - i.e., they're text files and you can read them with an editor.", "tag": "none", "senID": 0}, {"text": "C code is compiled and linked to an executable binary file before they can be run. Normally, only this executable binary file is distributed - hence you need a decompiler. You can always view the source code, if you've access to it.", "tag": "none", "senID": 1}]}], [{"text": ["Python scripts are analogous to a man looking at a to-do list written in English (or language he understands).", "The man has to do all the work, every time that list of things has to be done."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If the man, instead of doing the steps on his own each time, creates and programs a robot which can carry out those steps again and again (and probably faster than him), that robot is analogous to the C program."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The man in the python case is called the \"interpreter\" and in the C case is called the \"compiler\", and the C robot is called the compiled program/executable."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["When you look at the python program source, you see the to-do list.", "In case of the robot, you see the gears, motors and batteries, etc, which look very different from the to-do list.", "If you could get hold of the C \"to-do\" list, it looks somewhat like the python code, just in a different language."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Not all C programs require decompilers.", "There's lots of C code distributed in source form.", "And some Python programs do require decompilers, if distributed as bytecode (.pyc files)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["But, to the extent that your assumptions are valid, it's because C is a compiled language while Python is an interpreted language."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "compiled language", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Compiled_language"}, {"href": "http://en.wikipedia.org/wiki/Interpreted_language", "text": "interpreted language", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["G-WAN executes ANSI C scripts on the fly -making it just like Python scripts."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This can be server-side scripts (using G-WAN as a Web server) or any general-purpose C program and you can link any existing library."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Oh, and G-WAN C scripts are much faster than Python, PHP or Java..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]