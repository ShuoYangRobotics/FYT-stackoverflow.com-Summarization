[[{"text": ["This might do what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n numpy.array([.3,.4,.3]).cumsum().searchsorted(numpy.random.sample(5))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There are hacks you can do if, for example, your probabilities fit nicely into percentages, etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, if you're fine with percentages, the following will work (at the cost of a high memory overhead):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["But the \"real\" way to do it with arbitrary float probabilities is to sample from the cumulative distribution, after constructing it.", "This is equivalent to subdividing the unit interval [0,1] into 3 line segments labelled 'a','b', and 'c'; then picking a random point on the unit interval and seeing which line segment it it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python3\ndef randomCategory(probDict):\n    \"\"\"\n        &gt;&gt;&gt; dist = {'a':.1, 'b':.2, 'c':.3, 'd':.4}\n\n        &gt;&gt;&gt; [randomCategory(dist) for _ in range(5)]\n        ['c', 'c', 'a', 'd', 'c']\n\n        &gt;&gt;&gt; Counter(randomCategory(dist) for _ in range(10**5))\n        Counter({'d': 40127, 'c': 29975, 'b': 19873, 'a': 10025})\n    \"\"\"\n    r = random.random() # range: [0,1)\n    total = 0           # range: [0,1]\n    for value,prob in probDict.items():\n        total += prob\n        if total&gt;r:\n            return value\n    raise Exception('distribution not normalized: {probs}'.format(probs=probDict))\n</code>\n</pre>\n", "senID": 3}, {"text": ["One has to be careful of methods which return values even if their probability is 0.", "Fortunately this method does not, but just in case, one could insert if prob==0: continue."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "if prob==0: continue", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["For the record, here's the hackish way to do it:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import random\n\ndef makeSampler(probDict):\n    \"\"\"\n        &gt;&gt;&gt; sampler = makeSampler({'a':0.3, 'b':0.4, 'c':0.3})\n        &gt;&gt;&gt; sampler.sample()\n        'a'\n        &gt;&gt;&gt; sampler.sample()\n        'c'\n    \"\"\"\n    oneHundredElements = sum(([val]*(prob*100) for val,prob in probDict.items()), [])\n    def sampler():\n        return random.choice(oneHundredElements)\n    return sampler\n</code>\n</pre>\n", "senID": 6}, {"text": ["However if you don't have resolution issues... this is actually probably the fastest way possible.", "=)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"code": "<pre>\n<code>\n import numpy\n\nn = 1000\npairs = [(.3, 'a'), (.3, 'b'), (.4, 'c')]\nprobabilities = numpy.random.multinomial(n, zip(*pairs)[0])\nresult = zip(probabilities, zip(*pairs)[1])\n# [(299, 'a'), (299, 'b'), (402, 'c')]\n[x[0] * x[1] for x in result]\n# ['aaaaaaaaaa', 'bbbbbbbbbbbbbbbbbbb', 'cccccccccccccccccccc']\n</code>\n</pre>\n", "senID": 0}, {"text": ["How exactly would you like to receive the results?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I reckon the multinomial function is a still fairly easy way to get samples of a distribution in random order.", "This is just one way"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy\nfrom itertools import izip\n\ndef getSamples(input, size):\n    probabilities, items = zip(*input)\n    sampleCounts = numpy.random.multinomial(size, probabilities)\n    samples = numpy.array(tuple(countsToSamples(sampleCounts, items)))\n    numpy.random.shuffle(samples)\n    return samples\n\ndef countsToSamples(counts, items):\n    for value, repeats in izip(items, counts):\n        for _i in xrange(repeats):\n            yield value\n</code>\n</pre>\n", "senID": 1}, {"text": ["Where inputs is as specified [(.2, 'a'), (.4, 'b'), (.3, 'c')] and size is the number of samples you need."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[(.2, 'a'), (.4, 'b'), (.3, 'c')]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Howabout creating 3 \"a\", 4 \"b\" and 3 \"c\" in a list an then just randomly select one.", "With enough iterations you will get the desired probability."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Just inspired of sholte's very straightforward (and correct) answer: I'll just demonstrate how easy it will be to extend it to handle arbitrary items, like:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sholte", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n In []: s= array([.3, .4, .3]).cumsum().searchsorted(sample(54))\nIn []: c, _= histogram(s, bins= arange(4))\nIn []: [item* c[i] for i, item in enumerate('abc')]\nOut[]: ['aaaaaaaaaaaa', 'bbbbbbbbbbbbbbbbbbbbbbbbbb', 'cccccccccccccccc']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update:\nBased on the feedback of phant0m, it turns out that an even more straightforward solution can be implemented based on multinomial, like:"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "phant0m", "childNum": 0, "tag": "code", "childList": []}, {"text": "multinomial", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n In []: s= multinomial(54, [.3, .4, .3])\nIn []: [item* s[i] for i, item in enumerate('abc')]\nOut[]: ['aaaaaaaaaaaaaaa', 'bbbbbbbbbbbbbbbbbbbbbbbbbbb', 'cccccccccccc']\n</code>\n</pre>\n", "senID": 3}, {"text": ["IMHO here we have a nice summary of empirical cdf and multinomial based sampling yielding similar results.", "So, in a summary, pick it up one which suits best for your purposes."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "empirical cdf", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "multinomial", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I'm not sure if this is the pythonic way of doing what you ask, but you could use\n    random.sample(['a','a','a','b','b','b','b','c','c','c'],k)\nwhere k is the number of samples you want. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "random.sample(['a','a','a','b','b','b','b','c','c','c'],k)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For a more robust method, bisect the unit interval into sections based on the cumulative probability and draw from the uniform distribution (0,1) using random.random().", "In this case the subintervals would be (0,.3)(.3,.7)(.7,1).", "You choose the element based on which subinterval it falls into."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]