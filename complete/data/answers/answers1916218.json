[[{"text": ["In Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from os.path import commonprefix\n&gt;&gt;&gt; commonprefix('interspecies interstelar interstate'.split())\n'inters'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's a matter of taste, but this is a simple javascript version:\nIt sorts the array, and then looks just at the first and last items."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n function sharedStart(A){\n    var tem1, tem2, s, A= A.slice(0).sort();\n    tem1= A[0];\n    s= tem1.length;\n    tem2= A.pop();\n    while(s &amp;&amp; tem2.indexOf(tem1)== -1){\n    \ttem1= tem1.substring(0, --s);\n\n    }\n    return tem1;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["var A= ['interspecies', 'interstelar', 'interstate'];"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["alert(sharedStart(A))"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Ruby one-liner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l=strings.inject{|l,s| l=l.chop while l!=s[0...l.length];l}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You just need to traverse all strings until they differ, then take the substring up to this point."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Pseudocode:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n loop for i upfrom 0\n     while all strings[i] are equal\n     finally return substring[0..i]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Common Lisp:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n (defun longest-common-starting-substring (&amp;rest strings)\n  (loop for i from 0 below (apply #'min (mapcar #'length strings))\n     while (apply #'char=\n                  (mapcar (lambda (string) (aref string i))\n                          strings))\n     finally (return (subseq (first strings) 0 i))))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["My Haskell one-liner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import Data.List\n\ncommonPre :: [String] -&gt; String\ncommonPre = map head . takeWhile (\\(x:xs)-&gt; all (==x) xs) . transpose\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: barkmadley gave a good explanation of the code below.", "I'd also add that haskell uses lazy evaluation, so we can be lazy about our use of transpose; it will only transpose our lists as far as necessary to find the end of the common prefix."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "transpose", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Yet another way to do it: use regex greed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n words = %w(interspecies interstelar interstate)\nj = '='\nstr = ['', *words].join(j)\nre = \"[^#{j}]*\"\n\nstr =~ /^\n    (?: #{j} ( #{re} ) #{re} )\n    (?: #{j}    \\1     #{re} )*\n$/x\n\np $1\n</code>\n</pre>\n", "senID": 1}, {"text": ["And the one-liner, courtesy of mislav (50 characters):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "And the one-liner, courtesy of mislav (50 characters):", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n p ARGV.join(' ').match(/^(\\w*)\\w*(?: \\1\\w*)*$/)[1]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is probably not the most concise solution (depends if you already have a library for this), but one elegant method is to use a trie.", "I use tries for implementing tab completion in my Scheme interpreter:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://github.com/jcoglan/heist/blob/master/lib/trie.rb"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://github.com/jcoglan/heist/blob/master/lib/trie.rb", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/jcoglan/heist/blob/master/lib/trie.rb"}]}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n tree = Trie.new\n%w[interspecies interstelar interstate].each { |s| tree[s] = true }\ntree.longest_prefix('')\n#=&gt; \"inters\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["I also use them for matching channel names with wildcards for the Bayeux protocol; see these:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["http://github.com/jcoglan/faye/blob/master/client/channel.js"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://github.com/jcoglan/faye/blob/master/client/channel.js", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/jcoglan/faye/blob/master/client/channel.js"}]}, {"text": ["http://github.com/jcoglan/faye/blob/master/lib/faye/channel.rb"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://github.com/jcoglan/faye/blob/master/lib/faye/channel.rb", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/jcoglan/faye/blob/master/lib/faye/channel.rb"}]}], [{"code": "<pre>\n<code>\n Python 2.6 (r26:66714, Oct  4 2008, 02:48:43) \n\n&gt;&gt;&gt; a = ['interspecies', 'interstelar', 'interstate']\n\n&gt;&gt;&gt; print a[0][:max(\n        [i for i in range(min(map(len, a))) \n            if len(set(map(lambda e: e[i], a))) == 1]\n        ) + 1]\n\ninters\n</code>\n</pre>\n", "senID": 0}, {"tag": "ul", "num": 4, "lis": [{"text": ["i for i in range(min(map(len, a))), number of maximum lookups can't be greater than the length of the shortest string; in this example this would evaluate to [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "i for i in range(min(map(len, a)))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["len(set(map(lambda e: e[i], a))), 1) create an array of the i-thcharacter for each string in the list; 2) make a set out of it; 3) determine the size of the set"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "len(set(map(lambda e: e[i], a)))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i-th", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["[i for i in range(min(map(len, a))) if len(set(map(lambda e: e[i], a))) == 1], include just the characters, for which the size of the set is 1 (all characters at that position were the same ..); here it would evaluate to [0, 1, 2, 3, 4, 5]"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "[i for i in range(min(map(len, a))) if len(set(map(lambda e: e[i], a))) == 1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[0, 1, 2, 3, 4, 5]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["finally take the max, add one, and get the substring ..."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "max", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["Note: the above does not work for a = ['intersyate', 'intersxate', 'interstate', 'intersrate'], but this would:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "a = ['intersyate', 'intersxate', 'interstate', 'intersrate']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; index = len(\n         filter(lambda l: l[0] == l[1], \n             [ x for x in enumerate(\n                 [i for i in range(min(map(len, a))) \n                     if len(set(map(lambda e: e[i], a))) == 1]\n         )]))\n &gt;&gt;&gt; a[0][:index]\n inters\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Doesn't seem that complicated if you're not too concerned about ultimate performance:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def common_substring(data)\n  data.inject { |m, s| s[0,(0..m.length).find { |i| m[i] != s[i] }.to_i] }\nend\n</code>\n</pre>\n", "senID": 1}, {"text": ["One of the useful features of inject is the ability to pre-seed with the first element of the array being interated over.", "This avoids the nil memo check."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n puts common_substring(%w[ interspecies interstelar interstate ]).inspect\n# =&gt; \"inters\"\nputs common_substring(%w[ feet feel feeble ]).inspect\n# =&gt; \"fee\"\nputs common_substring(%w[ fine firkin fail ]).inspect\n# =&gt; \"f\"\nputs common_substring(%w[ alpha bravo charlie ]).inspect\n# =&gt; \"\"\nputs common_substring(%w[ fork ]).inspect\n# =&gt; \"fork\"\nputs common_substring(%w[ fork forks ]).inspect\n# =&gt; \"fork\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["Update: If golf is the game here, then 67 characters:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Update:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def f(d)d.inject{|m,s|s[0,(0..m.size).find{|i|m[i]!=s[i]}.to_i]}end\n</code>\n</pre>\n", "senID": 5}], [{"text": ["This one is very similar to Roberto Bonvallet's solution, except in ruby."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n chars = %w[interspecies interstelar interstate].map {|w| w.split('') }\nchars[0].zip(*chars[1..-1]).map { |c| c.uniq }.take_while { |c| c.size == 1 }.join\n</code>\n</pre>\n", "senID": 1}, {"text": ["The first line replaces each word with an array of chars.", "Next, I use zip to create this data structure:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["[[\"i\", \"i\", \"i\"], [\"n\", \"n\", \"n\"], [\"t\", \"t\", \"t\"], ..."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "[[\"i\", \"i\", \"i\"], [\"n\", \"n\", \"n\"], [\"t\", \"t\", \"t\"], ...", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["map and uniq reduce this to [[\"i\"],[\"n\"],[\"t\"], ..."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "uniq", "childNum": 0, "tag": "code", "childList": []}, {"text": "[[\"i\"],[\"n\"],[\"t\"], ...", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["take_while pulls the chars off the array until it finds one where the size isn't one (meaning not all chars were the same).", "Finally, I join them back together."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "take_while", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "join", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Here's a solution using regular expressions in Ruby:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def build_regex(string)\n  arr = []\n  arr &lt;&lt; string.dup while string.chop!\n  Regexp.new(\"^(#{arr.join(\"|\")})\")\nend\n\ndef substring(first, *strings)\n  strings.inject(first) do |accum, string|\n    build_regex(accum).match(string)[0]\n  end\nend\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would do the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here\u2019s a JavaScript implementation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n var array = [\"interspecies\", \"interstelar\", \"interstate\"],\n    prefix = array[0],\n    len = prefix.length;\nfor (i=1; i&lt;array.length; i++) {\n    for (j=0, len=Math.min(len,array[j].length); j&lt;len; j++) {\n        if (prefix[j] != array[i][j]) {\n            len = j;\n            prefix = prefix.substr(0, len);\n            break;\n        }\n    }\n}\n</code>\n</pre>\n", "senID": 2}], [{"text": ["In Python I wouldn't use anything but the existingcommonprefixfunction I showed in another answer, but I couldn't help to reinvent the wheel :P. This is my iterator-based approach:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "the existingcommonprefixfunction I showed in another answer", "tag": "a", "pos": 0, "childList": [{"text": "commonprefix", "tag": "code"}], "childNum": 1, "href": "#1916632"}, {"text": "commonprefix", "childNum": 0, "tag": "code", "childList": []}, {"text": ":P", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = 'interspecies interstelar interstate'.split()\n&gt;&gt;&gt;\n&gt;&gt;&gt; from itertools import takewhile, chain, izip as zip, imap as map\n&gt;&gt;&gt; ''.join(chain(*takewhile(lambda s: len(s) == 1, map(set, zip(*a)))))\n'inters'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: Explanation of how this works."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["zip generates tuples of elements taking one of each item of a at a time:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n In [6]: list(zip(*a))  # here I use list() to expand the iterator\nOut[6]:\n[('i', 'i', 'i'),\n ('n', 'n', 'n'),\n ('t', 't', 't'),\n ('e', 'e', 'e'),\n ('r', 'r', 'r'),\n ('s', 's', 's'),\n ('p', 't', 't'),\n ('e', 'e', 'a'),\n ('c', 'l', 't'),\n ('i', 'a', 'e')]\n</code>\n</pre>\n", "senID": 4}, {"text": ["By mapping set over these items, I get a series of unique letters:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n In [7]: list(map(set, _))  # _ means the result of the last statement above\nOut[7]:\n[set(['i']),\n set(['n']),\n set(['t']),\n set(['e']),\n set(['r']),\n set(['s']),\n set(['p', 't']),\n set(['a', 'e']),\n set(['c', 'l', 't']),\n set(['a', 'e', 'i'])]\n</code>\n</pre>\n", "senID": 6}, {"text": ["takewhile(predicate, items) takes elements from this while the predicate is True; in this particular case, when the sets have one element, i.e.", "all the words have the same letter at that position:"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "takewhile(predicate, items)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n In [8]: list(takewhile(lambda s: len(s) == 1, _))\nOut[8]:\n[set(['i']),\n set(['n']), \n set(['t']), \n set(['e']), \n set(['r']), \n set(['s'])]\n</code>\n</pre>\n", "senID": 8}, {"text": ["At this point we have an iterable of sets, each containing one letter of the prefix we were looking for.", "To construct the string, we chain them into a single iterable, from which we get the letters to join into the final string."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "chain", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "join", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The magic of using iterators is that all items are generated on demand, so when takewhile stops asking for items, the zipping stops at that point and no unnecessary work is done.", "Each function call in my one-liner has a implicit for and an implicit break."], "childNum": 3, "tag": "p", "senID": 10, "childList": [{"text": "takewhile", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "break", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Just for the fun of it, here's a version written in (SWI-)PROLOG:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n common_pre([[C|Cs]|Ss], [C|Res]) :-\n  maplist(head_tail(C), [[C|Cs]|Ss], RemSs), !,\n  common_pre(RemSs, Res).\ncommon_pre(_, []).\n\nhead_tail(H, [H|T], T).\n</code>\n</pre>\n", "senID": 1}, {"text": ["Running: "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ?- S=[\"interspecies\", \"interstelar\", \"interstate\"], common_pre(S, CP), string_to_list(CPString, CP).\n</code>\n</pre>\n", "senID": 3}, {"text": ["Gives:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n CP = [105, 110, 116, 101, 114, 115],\nCPString = \"inters\".\n</code>\n</pre>\n", "senID": 5}, {"text": ["Explanation: "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["(SWI-)PROLOG treats strings as lists of character codes (numbers).", "All the predicate common_pre/2 does is recursively pattern-match to select the first code (C) from the head of the first list (string, [C|Cs]) in the list of all lists (all strings, [[C|Cs]|Ss]), and appends the matching code C to the result iff it is common to all (remaining) heads of all lists (strings), else it terminates."], "childNum": 6, "tag": "p", "senID": 7, "childList": [{"text": "common_pre/2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "C", "childNum": 0, "tag": "code", "childList": []}, {"text": "[C|Cs]", "childNum": 0, "tag": "code", "childList": []}, {"text": "[[C|Cs]|Ss]", "childNum": 0, "tag": "code", "childList": []}, {"text": "C", "childNum": 0, "tag": "code", "childList": []}, {"text": "iff", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Nice, clean, simple and efficient... :)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["This is by no means elegant, but if you want concise:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Ruby, 71 chars"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def f(a)b=a[0];b[0,(0..b.size).find{|n|a.any?{|i|i[0,n]!=b[0,n]}}-1]end\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you want that unrolled it looks like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def f(words)\n  first_word = words[0];\n  first_word[0, (0..(first_word.size)).find { |num_chars|\n    words.any? { |word| word[0, num_chars] != first_word[0, num_chars] }\n  } - 1]\nend\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Javascript clone of AShelly's excellent answer. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "AShelly", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1916218/find-the-longest-common-starting-substring-in-a-set-of-strings/1916480#1916480"}]}, {"text": ["Requires Array#reduce which is supported only in firefox."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Array#reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n var strings = [\"interspecies\", \"intermediate\", \"interrogation\"]\nvar sub = strings.reduce(function(l,r) { \n    while(l!=r.slice(0,l.length)) {  \n        l = l.slice(0, -1);\n    }\n    return l;\n});\n</code>\n</pre>\n", "senID": 2}], [{"text": ["It's not code golf, but you asked for somewhat elegant, and I tend to think recursion is fun.", "Java."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n /** Recursively find the common prefix. */\npublic String findCommonPrefix(String[] strings) {\n\n    int minLength = findMinLength(strings);\n\n    if (isFirstCharacterSame(strings)) {\n    \treturn strings[0].charAt(0) + findCommonPrefix(removeFirstCharacter(strings));\n    } else {\n    \treturn \"\";\n    }\n}\n\n/** Get the minimum length of a string in strings[]. */\nprivate int findMinLength(final String[] strings) {\n    int length = strings[0].size();\n    for (String string : strings) {\n    \tif (string.size() &lt; length) {\n    \t\tlength = string.size();\n    \t}\n    }\n    return length;\n}\n\n/** Compare the first character of all strings. */\nprivate boolean isFirstCharacterSame(String[] strings) {\n    char c = string[0].charAt(0);\n    for (String string : strings) {\n    \tif (c != string.charAt(0)) return false;\n    }\n\n    return true;\n}\n\n/** Remove the first character of each string in the array, \n    and return a new array with the results. */\nprivate String[] removeFirstCharacter(String[] source) {\n    String[] result = new String[source.length];\n    for (int i=0; i&lt;result.length; i++) {\n    \tresult[i] = source[i].substring(1);\t\n    }\n    return result;\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A ruby version based on @Svante's algorithm.", "Runs ~3x as fast as my first one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def common_prefix set \n   i=0\n   rest=set[1..-1]\n   set[0].each_byte{|c|\n     rest.each{|e|return set[0][0...i] if e[i]!=c}\n     i+=1\n   }\n   set\n end\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A javascript version based on @Svante's algorithm:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@Svante's algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1916218/find-the-longest-common-starting-substring-in-a-set-of-strings/1916492#1916492"}]}, {"code": "<pre>\n<code>\n function commonSubstring(words){\n    var iChar, iWord,\n        refWord = words[0],\n        lRefWord = refWord.length,\n        lWords = words.length;\n    for (iChar = 0; iChar &lt; lRefWord; iChar += 1) {\n        for (iWord = 1; iWord &lt; lWords; iWord += 1) {\n            if (refWord[iChar] !== words[iWord][iChar]) {\n                return refWord.substring(0, iChar);\n            }\n        }\n    }\n    return refWord;\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Instead of sorting, you could just get the min and max of the strings."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To me, elegance in a computer program is a balance of speed and simplicity.", "It should not do unnecessary computation, and it should be simple enough to make its correctness evident."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I could call the sorting solution \"clever\", but not \"elegant\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Combining answers by kennebec, Florian F and jberryman yields the following Haskell one-liner:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "kennebec", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Florian F", "childNum": 0, "tag": "strong", "childList": []}, {"text": "jberryman", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n commonPrefix l = map fst . takeWhile (uncurry (==)) $ zip (minimum l) (maximum l)\n</code>\n</pre>\n", "senID": 1}, {"text": ["With Control.Arrow one can get a point-free form:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Control.Arrow", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n commonPrefix = map fst . takeWhile (uncurry (==)) . uncurry zip . (minimum &amp;&amp;&amp; maximum)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Oftentimes it's more elegant to use a mature open source library instead of rolling your own.", "Then, if it doesn't completely suit your needs, you can extend it or modify it to improve it, and let the community decide if that belongs in the library."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["diff-lcs is a good Ruby gem for least common substring."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "diff-lcs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rubygems.org/gems/diff-lcs"}]}]]