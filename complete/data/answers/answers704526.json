[[{"text": ["Some questions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Are all the letters upper or lower case? (a/A)", "tag": "none", "senID": 1}, {"text": "Is this the only alphabet you'll want to check?", "tag": "none", "senID": 2}, {"text": "Why are you doing this so often?", "tag": "none", "senID": 3}]}, {"text": ["Least lines of code:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # do this once, outside the loop\nalphabet=set(string.ascii_lowercase)\n# inside the loop, just 1 line:\nmissingletter=(alphabet-set(yourlist)).pop()\n</code>\n</pre>\n", "senID": 5}, {"text": ["The advantage of the above is that you can do it without having to sort the list first.", "If, however, the list is always sorted, you can use bisection to get there faster.", "On a simple 26-letter alphabet though, is there much point?"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "always", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Bisection (done in ~4 lookups):"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n frompos, topos = 0, len(str)\nfor i in range(1,100):  #never say forever with bisection...\n    trypos = (frompos+topos+1)/2\n    print \"try:\",frompos,trypos,topos\n    if alphabet[trypos] != str[trypos]:\n        topos = trypos\n    else:\n        frompos = trypos\n    if topos-frompos==1:\n        if alphabet[topos] != str[topos]:\n            print alphabet[frompos]\n        else:\n            print alphabet[topos]\n        break\n</code>\n</pre>\n", "senID": 8}, {"text": ["This code requires fewer lookups, so is by far the better scaling version O(log n), but may still be slower when executed via a python interpreter because it goes via python ifs instead of set operations written in C."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["(Thanks to J.F.Sebastian and Kylotan for their comments)"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Using a list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import string\n&gt;&gt;&gt; sourcelist = 'abcdefghijklmnopqrstuvwx'\n&gt;&gt;&gt; [letter for letter in string.ascii_lowercase if letter not in sourcelist]\n['y', 'z']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["The string module has some predefined constants that are useful."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "string", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/string.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; string.ascii_lowercase\n'abcdefghijklmnopqrstuvwxyz'\n\n&gt;&gt;&gt; string.letters\n'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n&gt;&gt;&gt; string.hexdigits\n'0123456789abcdefABCDEF'\n\n&gt;&gt;&gt; string.octdigits\n'01234567'\n\n&gt;&gt;&gt; string.digits\n'0123456789'\n\n&gt;&gt;&gt; string.printable\n'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In the too clever for it's own good category, and assuming there is exactly one missing letter in a lowercase alphabet:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print chr(2847 - sum(map(ord, theString)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["[Edit]\nI've run some timings on the various solutions to see which is faster.", "Mine turned out to be fairly slow in practice (slightly faster if I use itertools.imap instead)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[Edit]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Surprisingly, the listcomp solution by monkut turned out to be fastest - I'd have expected the set solutions to do better, as this must scan the list each time to find the missing letter.", "I tried first converting the test list to a set in advance of membership checking, expecting this to speed it up  but in fact it made it slower.", "It looks like the constant factor delay in creating the set dwarfs the cost of using an O(n**2) algorithm for such a short string."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "listcomp solution", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/704526/python-finding-a-missing-letter-in-the-alphabet-from-a-list-least-lines-of-cod/704595#704595"}]}, {"text": ["That suggested than an even more basic approach, taking advantage of early exiting, could perform even better.", "The below is what I think currently performs best:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def missing_letter_basic(s):\n    for letter in string.ascii_lowercase:\n        if letter not in s: return letter\n    raise Exception(\"No missing letter\")\n</code>\n</pre>\n", "senID": 5}, {"text": ["The bisection method is probably best when working with larger strings however.", "It is only just edged out by the listcomp here, and has much better asymptotic complexity, so for strings larger than an alphabet, it will clearly win. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["[Edit2]"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "[Edit2]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Actually, cheating a bit, I can get even better than that, abusing the fact that there are only 26 strings to check, behold the ultimate O(1) missing letter finder! "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n find_missing_letter = dict((string.ascii_lowercase[:i]+string.ascii_lowercase[i+1:],\n                            string.ascii_lowercase[i]) for i in range(26)).get\n\n&gt;&gt;&gt; find_missing_letter('abcdefghijklmnoprstuvwxyz')\n'q'\n</code>\n</pre>\n", "senID": 9}, {"text": ["Here are my timings (500000 runs, tested with letters missing near the start, middle and end of the string (b, m and y)"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n \"b\"    \"m\"     \"y\"\n               bisect : 2.762   2.872   2.922  (Phil H)\n             find_gap : 3.388   4.533   5.642  (unwind)\n             listcomp : 2.832   2.858   2.822  (monkut)\n         listcomp_set : 4.770   4.746   4.700  As above, with sourcelist=set(sourcelist) first\n       set_difference : 2.924   2.945   2.880  (Phil H)\n                  sum : 3.815   3.806   3.868\n             sum_imap : 3.284   3.280   3.260\n                basic : 0.544   1.379   2.359 \n          dict_lookup : 0.135   0.133   0.134\n</code>\n</pre>\n", "senID": 11}], [{"text": ["Here's one way of doing it, assuming your \"alphabets\" is integers, and that the list has at least two items:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i in xrange(1, len(a)):\n  if a[i] != a[i - 1] + 1:\n    print a[i - 1] + 1, \"is missing\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["With sorted lists a binary search is usually the fastest alghorythm.", "Could you please provide an example list and an example \"missing alphabet\"?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["if you're talking about alphabet as letters:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n letterSet = set()\nfor word in wordList:\n  letterSet.update(set(word.lower()))\n\nimport string\nalphabet = set(string.lowercase)\nmissingLetters = alphabet.difference(letterSet)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n class MissingFinder(object):\n    \"A simplified missing items locator\"\n    def __init__(self, alphabet):\n        \"Store a set from our alphabet\"\n        self.alphabet= set(alphabet)\n    def missing(self, sequence):\n        \"Return set of missing letters; sequence not necessarily set\"\n        return self.alphabet.difference(sequence)\n\n&gt;&gt;&gt; import string\n&gt;&gt;&gt; finder= MissingFinder(string.ascii_lowercase)\n\n&gt;&gt;&gt; finder.missing(string.ascii_lowercase[:5] + string.ascii_lowercase[6:])\n&gt;&gt;&gt; set(['f'])\n&gt;&gt;&gt; # rinse, repeat calling finder.missing\n</code>\n</pre>\n", "senID": 0}, {"text": ["I'm sure the class and instance names could be improved :)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]