[[{"text": ["You could do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "list all files in the directory", "tag": "none", "senID": 1}, {"text": "create a dictionary where the basename is the key and all the extensions are values", "tag": "none", "senID": 2}, {"text": "then tar all the files by dictionary key", "tag": "none", "senID": 3}]}, {"text": ["Something like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport tarfile\nfrom collections import defaultdict\n\nmyfiles = os.listdir(\".\")   # List of all files\ntotar = defaultdict(list)\n\n# now fill the defaultdict with entries; basename as keys, extensions as values\nfor name in myfiles:\n    base, ext = os.path.splitext(name)\n    totar[base].append(ext)\n\n# iterate through all the basenames\nfor base in totar:\n    files = [base+ext for ext in totar[base]]\n    # now tar all the files in the list \"files\"\n    tar = tarfile.open(base+\".tar\", \"w\")\n    for item in files:    \n        tar.add(item)\n    tar.close()\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The pattern you're describing generalizes to MapReduce.", "I found a simple implementation of MapReduce online, from which an even-simpler version is:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "a simple implementation", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/577676-dirt-simple-mapreduce/"}]}, {"code": "<pre>\n<code>\n def map_reduce(data, mapper, reducer):\n    d = {}\n    for elem in data:\n        key, value = mapper(elem)\n        d.setdefault(key, []).append(value)\n    for key, grp in d.items():\n        d[key] = reducer(key, grp)\n    return d\n</code>\n</pre>\n", "senID": 1}, {"text": ["You want to group all files by their name without the extension, which you can get from os.path.splitext(fname)[0].", "Then, you want to make a tarball out of each group by using the tarfile module.", "In code, that is:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "os.path.splitext(fname)[0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tarfile", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import os\nimport tarfile\n\ndef make_tar(basename, files):\n    tar = tarfile.open(basename + '.tar', 'w')\n    for f in files:\n        tar.add(f)\n    tar.close()\n\nmap_reduce(os.listdir('.'),\n           lambda x: (os.path.splitext(x)[0], x),\n           make_tar)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: If you want to group files in different ways, you just need to modify the second argument to map_reduce.", "The code above groups files that have the same value for the expression os.path.splitext(x)[0].", "So to group by the base file name with all the extensions stripped off, you could replace that expression with strip_all_ext(x) and add:"], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "map_reduce", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "os.path.splitext(x)[0]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "all", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "strip_all_ext(x)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def strip_all_ext(path):\n    head, tail = os.path.split(path)\n    basename = tail.split(os.extsep)[0]\n    return os.path.join(head, basename)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["You have to problems.", "Solve the separately."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So.", "Solve problem 1 first."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Use glob to get all the names.", "Use os.path.basename to split the path and basename.", "Use os.path.splitext to split the name and extension."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "glob", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.path.basename", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "os.path.splitext", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["A dictionary of lists can be used to save all files that have the same name."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Is that what you're doing in part 1?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Part 2 is putting the files into tar archives.", "For that, you've got most of the code you need."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Try using the glob module: http://docs.python.org/library/glob.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/glob.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/glob.html"}]}], [{"code": "<pre>\n<code>\n #! /usr/bin/env python\n\nimport os\nimport tarfile\n\ntarfiles = {}\nfor f in os.listdir ('files'):\n    prefix = f [:f.rfind ('.') ]\n    if prefix in tarfiles: tarfiles [prefix] += [f]\n    else: tarfiles [prefix] = [f]\n\nfor k, v in tarfiles.items ():\n    tf = tarfile.open ('%s.tar.gz' % k, 'w:gz')\n    for f in v: tf.addfile (tarfile.TarInfo (f), file ('files/%s' % f) )\n    tf.close ()\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n import os\nimport tarfile\n\nallfiles = {}\n\nfor filename in os.listdir(\".\"):\n    basename = '.'.join (filename.split(\".\")[:-1] )\n    if not basename in all_files:\n        allfiles[basename] = [filename]\n    else:\n        allfiles[basename].append(filename)\n\nfor basename, filenames in allfiles.items():\n    if len(filenames) &lt; 2:\n        continue\n    tardata = tarfile.open(basename+\".tar\", \"w\")\n    for filename in filenames:\n        tardata.add(filename)\n    tardata.close()\n</code>\n</pre>\n", "senID": 0}]]