[[{"text": ["EDITED:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "EDITED:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Aha!", "Code is in Python 3,\ninspired by tyz:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from functools import reduce # only in Python 3\n\ndef process(old, num):\n    new = set(map(num.__add__, old)) # use itertools.imap for Python 2\n    new.update(map((-num).__add__, old))\n    return new\n\ndef pmv(nums):\n    n = iter(nums)\n    x = next(n)\n    result = {x, -x} # set([x, -x]) for Python 2\n    return reduce(process, n, result)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Instead of split half and recursive, I use reduce to compute it one by one.", "that extremely reduced the times of function calls."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Take less than 1 sec to compute 256 numbers."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Why product then mult?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def pmv(nums):\n    return {sum(i):i for i in itertools.product(*((num, -num) for num in nums))}\n</code>\n</pre>\n", "senID": 6}, {"text": ["Can be faster without how the numbers were produced:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def pmv(nums):\n    return set(map(sum, itertools.product(*((num, -num) for num in nums))))\n</code>\n</pre>\n", "senID": 8}], [{"text": ["If it is ok not to get trace of number producing there is no reasons to recalculate sum of number combination every time.", "You can store intermediate results:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def combine(l,r):\n    res = set()\n    for x in l:\n        for y in r:\n            res.add( x+y )\n            res.add( x-y )\n            res.add( -x+y )\n            res.add( -x-y )\n    return list(res)\n\ndef pmv(nums):\n    if len(nums) &gt; 1:\n        l = pmv( nums[:len(nums)/2] )\n        r = pmv( nums[len(nums)/2:] )\n        return combine( l, r )\n    return nums\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: if the way of number generation is important you can use this variant:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def combine(l,r):\n    res = dict()\n    for x,q in l.iteritems():\n        for y,w in r.iteritems():\n            if not res.has_key(x+y):\n                res[x+y] = w+q\n                res[-x-y] = [-i for i in res[x+y]]\n            if not res.has_key(x-y):\n                res[x-y] = w+[-i for i in q]\n                res[-x+y] = [-i for i in res[x-y]]\n    return res\n\ndef pmv(nums):\n    if len(nums) &gt; 1:\n        l = pmv( nums[:len(nums)/2] )\n        r = pmv( nums[len(nums)/2:] )\n        return combine( l, r )\n    return {nums[0]:[1]}\n</code>\n</pre>\n", "senID": 3}, {"text": ["My tests shows that it is still faster than the other solutions."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["This seems to be significantly faster for large random lists, I guess you could further micro-optimize it, but I prefer readability."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I chunk the list into smaller pieces and create variations for it.", "Since you get a lot less than 2 ** len(chunk) variatons it's going to be faster.", "Chunk length is 6, you can play with it to see what's the optimal chunk length."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "2 ** len(chunk)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def pmv(nums):\n    chunklen=6\n    res = dict()\n    res[0] = ()\n    for i in xrange(0, len(nums), chunklen):\n        part = plus_minus_variations(nums[i:i+chunklen])\n        resnew = dict()\n        for (i,j) in itertools.product(res, part):\n            resnew[i + j] = tuple(list(res[i]) + list(part[j]))\n        res = resnew\n    return res\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You can get something like a 50% speedup (at least for short lists) just by doing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import product, imap\nfrom operator import mul\n\ndef plus_minus_variations(nums):\n    result = {}\n    for ops in product((-1, 1), repeat=len(nums)):\n        result[sum(imap(mul, ops, nums))] = ops\n    return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["imap won't create intermediate lists you don't need.", "Importing into the local namespace saves the time attribute lookup takes.", "Tuples are faster than lists.", "Don't store unneeded intermediate items."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "imap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I tried this with a dict comprehension but it was a bit slower.", "I tried it with a set comprehension (not saving the ops) and it was the same speed."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "ops", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I don't know why you were using zip and xrange at all... you weren't using the result in your calculation."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: I get significant speedups with this version all the way up to the point where your version gives a memory error, not just for short lists."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["From a mathematical point of view you finally arive at all multiples of the greatest common divisor of your startvalues."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "startvalues 2,4. then the gcd(2,4) is 2, so the generated numbers are .. -4, -2, 0, 2, 4, ...", "tag": "none", "senID": 2}, {"text": "startvalues 3,5. then the gcd(3,5) is 1, you get all integers.", "tag": "none", "senID": 3}, {"text": "startvalues 12, 18, 15. the gcd(12,15,18) is 3, you get .. -6, -3, 0, 3, 6, ....", "tag": "none", "senID": 4}]}], [{"text": ["This simple iterative method computes all possible sums.", "It could be about 5 times faster than the recursive method by @tyz."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def pmv(nums):\n    sums = set()\n    sums.add(0)\n    for i in range(0, len(nums)):\n        partialsums = set()\n        for s in sums:\n            partialsums.add(s + nums[i])\n            partialsums.add(s - nums[i])\n        sums = partialsums\n    return sums\n</code>\n</pre>\n", "senID": 1}]]