[[{"text": ["I'm not a Python expert by all means, but as far as I know it has the same operators as C. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If so this should work and it should also be a lot quicker than using modulo and division."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Blue =  RGBint &amp; 255\nGreen = (RGBint &gt;&gt; 8) &amp; 255\nRed =   (RGBint &gt;&gt; 16) &amp; 255\n</code>\n</pre>\n", "senID": 2}, {"text": ["What it does it to mask out the lowest byte in each case (the binary and with 255..", "Equals to a 8 one bits).", "For the green and red component it does the same, but shifts the color-channel into the lowest byte first."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["From a RGB integer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Blue =  RGBint mod 256\nGreen = RGBint / 256 mod 256\nRed =   RGBint / 256 / 256 mod 256\n</code>\n</pre>\n", "senID": 1}, {"text": ["This can be pretty simply implemented once you know how to get it.", ":)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Upd: Added python function.", "Not sure if there's a better way to do it, but this works on Python 3 and 2.4"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def rgb_int2tuple(rgbint):\n    return (rgbint // 256 // 256 % 256, rgbint // 256 % 256, rgbint % 256)\n</code>\n</pre>\n", "senID": 4}, {"text": ["There's also an excellent solution that uses bitshifting and masking that's no doubt much faster that Nils Pipenbrinck posted."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I assume you have a 32-bit integer containing the RGB values (e.g.", "ARGB).", "Then you can unpack the binary data using the struct module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n # Create an example value (this represents your 32-bit input integer in this example).\n# The following line results in exampleRgbValue = binary 0x00FF77F0 (big endian)\nexampleRgbValue = struct.pack(\"&gt;I\", 0x00FF77F0)\n\n# Unpack the value (result is: a = 0, r = 255, g = 119, b = 240)\na, r, g, b = struct.unpack(\"BBBB\", exampleRgbValue)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def unpack2rgb(intcol):\n    tmp, blue= divmod(intcol, 256)\n    tmp, green= divmod(tmp, 256)\n    alpha, red= divmod(tmp, 256)\n    return alpha, red, green, blue\n</code>\n</pre>\n", "senID": 0}, {"text": ["If only the divmod(value, (divider1, divider2, divider3\u2026)) suggestion was accepted, it would have simplified various time conversions too."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "divmod(value, (divider1, divider2, divider3\u2026))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import struct\n&gt;&gt;&gt; str='aabbcc'\n&gt;&gt;&gt; struct.unpack('BBB',str.decode('hex'))\n(170, 187, 204)\n</code>\n</pre>\n", "senID": 0}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; rgb = (50,100,150)\n&gt;&gt;&gt; struct.pack('BBB',*rgb).encode('hex')\n'326496'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["There's probably a shorter way of doing this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dec=10490586\nhex=\"%06x\" % dec\nr=hex[:2]\ng=hex[2:4]\nb=hex[4:6]\nrgb=(r,g,b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: this is wrong - gives the answer in Hex, OP wanted int.", "EDIT2: refined to reduce misery and failure - needed '%06x' to ensure hex is always shown as six digits [thanks to Peter Hansen's comment]."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; r, g, b = (111, 121, 131)\n&gt;&gt;&gt; packed = int('%02x%02x%02x' % (r, g, b), 16)\n</code>\n</pre>\n", "senID": 0}, {"text": ["This produces the following integer:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; packed\n7305603\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can then unpack it either the long explicit way:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; packed % 256\n255\n&gt;&gt;&gt; (packed / 256) % 256\n131\n&gt;&gt;&gt; (packed / 256 / 256) % 256\n121\n&gt;&gt;&gt; (packed / 256 / 256 / 256) % 256\n111\n</code>\n</pre>\n", "senID": 4}, {"text": ["..or in a more compact manner:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; b, g, r = [(packed &gt;&gt; (8*i)) &amp; 255 for i in range(3)]\n&gt;&gt;&gt; r, g, b\n</code>\n</pre>\n", "senID": 6}, {"text": ["Sample applies with any number of digits, e.g an RGBA colour:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; packed = int('%02x%02x%02x%02x' % (111, 121, 131, 141), 16)\n&gt;&gt;&gt; [(packed &gt;&gt; (8*i)) &amp; 255 for i in range(4)]\n[141, 131, 121, 111]\n</code>\n</pre>\n", "senID": 8}]]