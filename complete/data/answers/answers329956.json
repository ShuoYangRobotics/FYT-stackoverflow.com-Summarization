[[{"text": ["Python's crypt() is a wrapper for the system's crypt() function.", "From the Linux crypt() man page:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nchar *crypt(const char *key, const char *salt);\n\nkey is a user\u2019s typed password.\nsalt is a two-character string chosen from the set [a\u2013zA\u2013Z0\u20139./]. \nThis string is used to perturb the algorithm in one of 4096 \ndifferent ways.\n</pre>\n", "senID": 1}, {"text": ["Emphasis is on \"two-character string\".", "Now, if you look at crypt()'s behavior in Python:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "two-character", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; crypt.crypt(\"Hello\", \"World\")\n'Wo5pEi/H5/mxU'\n&gt;&gt;&gt; crypt.crypt(\"Hello\", \"ABCDE\")\n'AB/uOsC7P93EI'\n</code>\n</pre>\n", "senID": 3}, {"text": ["you discover that the first two characters of the result always coincide with the first two characters of the original salt, which indeed form the true two-character-salt itself.", "That is, the result of crypt() has the form 2char-salt + encrypted-pass.", "Hence, there is no difference in the result if instead of passing the two-character-salt or the original many-characters-salt you pass the whole encrypted password."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Note: the set [a\u2013zA\u2013Z0\u20139./] contains 64 characters, and 64&#42;64=4096.", "Here's how two characters relate to \"4096 different ways\"."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "two", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "4096", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["You're misunderstanding the documentation; it says that since the length of the salt may vary depending on the underlying crypt() implementation, you should provide the entire crypted password as the salt value when checking passwords.", "That is, instead of pulling the first two chars off to be the salt, just toss in the whole thing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "when checking passwords", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Your idea of having the initial salt be based on the username seems okay. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For the use of the crypt module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When GENERATING the crypted password, you provide the salt.", "It might as well be random to increase resistance to brute-forcing, as long as it meets the listed conditions.", "When CHECKING a password, you should provide the value from getpwname, in case you are on a system that supports larger salt sizes and didn't generate it yourself."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["General comments:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If this has nothing to do w/ actual system logins, there is nothing preventing you from using a stronger method than crypt.", "You could randomly generate N characters of per-user salt, to be combined with the user's password in a SHA-1 hash."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n string_to_hash = user.stored_salt + entered_password\nsuccessful_login = (sha1(string_to_hash) == user.stored_password_hash)\n</code>\n</pre>\n", "senID": 4}, {"text": ["UPDATE: While this is far more secure against rainbow tables, the method above still has cryptographic weaknesses.", "Correct application of an HMAC algorithm can yet further increase your security, but is beyond my realm of expertise."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Here's some general advice on salting passwords:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would not have the salt be a function of the password.", "An attacker would have to generate a rainbow table to have an instant-lookup database of passwords, but they'd only have to do that once.", "If you choose a random 32-bit integer, they'd have to generate 2^32 tables, which (unlike a deterministic salt) costs way, way too much memory (and time)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "would not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["The password, or anything derived from the password, should never be used as salt.", "The salt for a particular password should be unpredictable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A username or part of the user name is tolerable, but even better would be random bytes from a cryptographic RNG."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Use PBKDF2, see this comment on a different thread (includes Python implementation)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this comment", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/287517/encryptinghashing-plain-text-passwords-in-database#287883"}]}], [{"text": ["Best yet, try to wire your tool into using PAM and don't do crypto yourself unless you plan to spend a lot of time reading.", ":)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As far as I understand things, MD5 and SHA and SHA1 have weaknesses and you are safest moving to a SHA-2 or another hashing method.", "Or, better yet, try linking against PAM.", ":) "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For some added strength, you can get the crypt module to use md5 by using a salt in the format."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $1$ABCDEFGH$\n</code>\n</pre>\n", "senID": 1}, {"text": ["where ABCDEFGH is your salt string. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; p = crypt.crypt('password', '$1$s8Ty3/f$')\n&gt;&gt;&gt; p\nOut: '$1$s8Ty3/f$0H/M0JswK9pl3X/e.n55G1'\n&gt;&gt;&gt; p == crypt.crypt('password', p)\nOut: True\n</code>\n</pre>\n", "senID": 3}, {"text": ["(note that this is a gnu extension to crypt, see \"man crypt\" on a linux system).", "MD5 (and now even SHA1) may be \"broken\", but they are still relatively good for password hashes, and md5 is still the standard for linux local passwords."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Take a look at the article TrueCrypt explained by Bj\u00f6rn Edstr\u00f6m.", "It contains easy to understand explanation of how truecrypt works and a simple Python implementation of some of truecrypt's functionality including password management."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "TrueCrypt explained", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.bjrn.se/2008/01/truecrypt-explained.html"}]}]]