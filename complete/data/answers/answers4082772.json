[[{"text": ["A far quicker approach would be to keep in mind, that the weekdays cycle.", "As such, we just need to get the first day we want to include the list, and add the remaining 6 elements to the end.", "Or in other words, we get the weekday list starting from the starting day, append another full week, and return only the first 7 elements (for the full week)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "cycle", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n days = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')\ndef weekdays ( weekday ):\n    index = days.index( weekday )\n    return list( days[index:] + days )[:7]\n\n&gt;&gt;&gt; weekdays( 'Wednesday' )\n['Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Monday', 'Tuesday']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The reason your code is only returning one day name is because weekday will never match more than one string in the days tuple and therefore won't add any of the days of the week that follow it (nor wrap around to those before it). "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "weekday", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "days", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Python's built-in calendar module can be useful for solving such problems with its days of the week related functions and constants.", "Here's a version of your function based on it which has no hardcoded day name strings within it:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "calendar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import calendar\n\ndef weekdays(weekday):\n    cal = calendar.Calendar(tuple(calendar.day_name).index(weekday))\n    return [calendar.day_name[day] for day in cal.iterweekdays()]\n\nprint weekdays('Wednesday')\n# ['Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Monday', 'Tuesday']\n</code>\n</pre>\n", "senID": 2}, {"text": ["Another advantage to using the calendar module is that properly written code utilizing it will automatically work in other languages.", "This can be illustrated by changing the locale and then calling the function with a day name in the corresponding language.  "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "calendar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For example, although France is not my default locale, but I can simulate it for testing as shown below.", "Note: According to Capitalization of day names, the names of the days of the week are not capitalized in French like they are here in English locales, but that is taken into account automatically, too, which means the weekday name passed to it must be in the language of the current locale."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Capitalization of day names", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://meta.wikimedia.org/wiki/Capitalization#Capitalization_of_day_names"}, {"text": "weekday", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import locale\nlocale.setlocale(locale.LC_ALL, 'french_france')  # force specific locale\n\nprint weekdays('mercredi')  # call function with French equivalent of 'Wednesday'\n# ['mercredi', 'jeudi', 'vendredi', 'samedi', 'dimanche', 'lundi', 'mardi']\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Hmm, you are currently only searching for the given weekday and set as result :)\nYou can use the slice ability in python list to do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = days[days.index(weekday):] + days[:days.index(weekdays)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's more what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def weekdays(weekday):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    index = days.index(weekday)\n    return (days + days)[index:index+7]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def weekdays(day):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    i=days.index(day) # get the index of the selected day\n    d1=days[i:] #get the list from an including this index\n    d1.extend(days[:i]) # append the list form the beginning to this index\n    return d1\n</code>\n</pre>\n", "senID": 0}, {"text": ["And if you want to test that it works: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def test_weekdays():\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    for day in days:\n        print weekdays(day)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Every time you run the for loop, the day variable changes.", "So day is equal to your input only once.", "Using \"Sunday\" as input, it first checked if Monday = Sunday, then if Tuesday = Sunday, then if Wednesday = Sunday, until it finally found that Sunday = Sunday and returned Sunday."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Your result variable is a string and not a list object.", "Also, as others have mentioned, it only gets updated one time which is when it is equal to the passed weekday argument."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "result", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "weekday", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Yet another implementation but does not use indexes:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def weekdays(weekday):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    for day in days:\n        days.insert(0, days[len(days) - 1]) # add last day as new first day of list\n        days.pop()                          # remove the old last day\n        if days[0] == weekday:              # if new first day same as weekday then all done\n            break       \n    return days\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Another approach using the standard library:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday']\ndef weekdays(weekday):\n  n = days.index(weekday)\n  return list(itertools.islice(itertools.cycle(days), n, n + 7))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Itertools is a bit much in this case.", "Since you know at most one extra cycle is needed, you could do that manually:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',\n        'Sunday']\ndays += days\ndef weekdays(weekday):\n  n = days.index(weekday)\n  return days[n:n+7]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Both give the expected output:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; weekdays(\"Wednesday\")\n['Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Monday', 'Tuesday']\n&gt;&gt;&gt; weekdays(\"Sunday\")\n['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n&gt;&gt;&gt; weekdays(\"Monday\")\n['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n</code>\n</pre>\n", "senID": 5}]]