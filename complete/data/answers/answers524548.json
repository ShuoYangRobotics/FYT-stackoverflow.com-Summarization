[[{"text": ["You could write a little, very simple routine that does it, without using a regular expression:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Set a position counter ", "tag": "none", "senID": 1}, {"text": "Set an open brackets counter ", "tag": "none", "senID": 2}, {"text": "Now keep incrementing ", "tag": "none", "senID": 3}, {"text": "So, stop when ", "tag": "none", "senID": 4}]}, {"text": ["The stopping positon is your closing bracket of for(...).", "Now you can check if there is a semicolon following or not."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "for(...)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This is the kind of thing you really shouldn't do with a regular expression.", "Just parse the string one character at a time, keeping track of opening/closing parentheses."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If this is all you're looking for, you definitely don't need a full-blown C++ grammar lexer/parser.", "If you want practice, you can write a little recursive-decent parser, but even that's a bit much for just matching parentheses."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This is a great example of using the wrong tool for the job.", "Regular expressions do not handle arbitrarily nested sub-matches very well.", "What you should do instead is use a real lexer and parser (a grammar for C++ should be easy to find) and look for unexpectedly empty loop bodies."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I wouldn't even pay attention to the contents of the parens."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Just match any line that starts with for and ends with semi-colon:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ^\\t*for.+;$\n</code>\n</pre>\n", "senID": 2}, {"text": ["Unless you've got for statements split over multiple lines, that will work fine?"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Greg is absolutely correct.", "This kind of parsing cannot be done with regular expressions.", "I suppose it is possible to build some horrendous monstrosity that would work for many cases, but then you'll just run across something that does."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You really need to use more traditional parsing techniques.", "For example, its pretty simple to write a recursive decent parser to do what you need. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I don't know that regex would handle something like that very well.", "Try something like this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n line = line.Trim();\nif(line.StartsWith(\"for\") &amp;&amp; line.EndsWith(\";\")){\n    //your code here\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Another thought that ignores parentheses and treats the for as a construct holding three semicolon-delimited values:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for\\s*\\([^;]+;[^;]+;[^;]+\\)\\s*;\n</code>\n</pre>\n", "senID": 1}, {"text": ["This option works even when split over multiple lines (once MULTILINE enabled), but assumes that for ( ... ; ... ; ... ) is the only valid construct, so wouldn't work with a for ( x in y ) construct, or other deviations."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "for ( ... ; ... ; ... )", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for ( x in y )", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also assumes that there are no functions containing semi-colons as arguments, such as:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for ( var i = 0; i &lt; ListLen('a;b;c',';') ; i++ );\n</code>\n</pre>\n", "senID": 4}, {"text": ["Whether this is a likely case depends on what you're actually doing this for."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Try this regexp"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ^\\s*(for|while)\\s*\n\\(\n(?P&lt;balanced&gt;\n[^()]*\n|\n(?P=balanced)\n\\)\n\\s*;\\s\n</code>\n</pre>\n", "senID": 1}, {"text": ["I removed the wrapping \\( \\) around (?P=balanced) and moved the * to behind the any not paren sequence.", "I have had this work with boost xpressive, and rechecked that website (Xpressive) to refresh my memory."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "\\( \\)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(?P=balanced)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Xpressive", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.boost.org/doc/libs/1_37_0/doc/html/xpressive/user_s_guide.html#boost_xpressive.user_s_guide.grammars_and_nested_matches"}]}]]