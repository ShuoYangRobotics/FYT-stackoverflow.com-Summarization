[[{"text": ["You might get good performance for these kinds of operations using blist or a database (such as the sqlite which is in the stdlib)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "blist", "tag": "a", "pos": 0, "childList": [{"text": "blist", "tag": "code"}], "childNum": 1, "href": "http://pypi.python.org/pypi/blist/"}, {"text": "blist", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/sqlite3.html", "text": "sqlite", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I suggest some sort of balanced binary tree such as a red-black tree.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A search on PyPi throws up a couple of implementations.", "Searching on google will give you more."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "search on PyPi", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi?%3Aaction=search&term=red-black+tree&submit=search"}]}, {"text": ["bintrees on PyPi looks very complete and has both Python and C/Cython implementations.", "I have not used it though, so caveat emptor."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "bintrees", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/bintrees/0.3.0"}]}, {"text": ["A red-black tree is kept sorted and most operations (insert, delete, find) are O(log2(N)), so finding an element in a tree of 200,000 entries will take on average 17-18 comparisons."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Sounds like a skip list will fulfill all your requirements.", "It's basically a dynamically-sized sorted linked list, with O(log n) insertions and removals."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "skip list", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Skip_list"}]}, {"text": ["I don't really know Python, but this link seems to be relevant:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://infohost.nmt.edu/tcc/help/lang/python/examples/pyskip/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://infohost.nmt.edu/tcc/help/lang/python/examples/pyskip/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://infohost.nmt.edu/tcc/help/lang/python/examples/pyskip/"}]}], [{"text": ["I presume you need it sorted because you access element by rank in the sorted order? "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can use any implementation of any balanced binary tree, with the additional information at each node which tells you the numbers of descendants of that node (usually called the Order Statistic Binary Tree)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Order Statistic Binary Tree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cs.cornell.edu/courses/cs211/2004su/slides/Topic20b.pdf"}]}, {"text": ["With this structure, given the rank of an element (even min/max), you can access/delete it in O(log n) time. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This makes all operations (access/insert/delete by rank, pop front/back, insert/delete/search by value) O(logn) time, while allowing custom sort methods."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Also, apparently python has an AVL tree (one of the first balanced tree structures) implementation which supports order statistics: http://www.python.org/ftp/python/contrib-09-Dec-1999/DataStructures/avl.README"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://www.python.org/ftp/python/contrib-09-Dec-1999/DataStructures/avl.README", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/ftp/python/contrib-09-Dec-1999/DataStructures/avl.README"}]}, {"text": ["So you won't need a custom implementation."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Except for the hashing, what you're looking for is a double-ended priority queue, aka a priority deque."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If your need for sorting doesn't extend beyond managing the min and max of your data, another structure for you to look at might be an interval heap, which has the advantage of O(1) lookup of both min and max if you need to peek at values (though deleteMin and deleteMax are still O(log(N)) ).", "Unfortunately, I'm not aware of any implementations in Python, so I think you'd have to roll your own."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's an addendum to an algorithms textbook that describes interval heaps if you're interested:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://www.mhhe.com/engcs/compsci/sahni/enrich/c9/interval.pdf"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://www.mhhe.com/engcs/compsci/sahni/enrich/c9/interval.pdf", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.mhhe.com/engcs/compsci/sahni/enrich/c9/interval.pdf"}]}], [{"text": ["If you can really allow O(log n) for pop, dequeue, and insert, then a simple balanced search tree like red-black tree is definitely sufficient."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can optimize this of course by maintaining a direct pointer to the smallest and largest element in the tree, and then updating it when you (1) insert elements into the tree or (2) pop or dequeue, which of course invalidate the resp.", "pointer.", "But because the tree is balanced, there's some shuffling going out anyway, and you can update the corr.", "pointer at the same time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There is also something called min-max heap (see the Wikipedia entry for Binary Heap), which implements exactly a \"double-ended priority queue\", i.e.", "a queue where you can pop both from front end and the rear end.", "However there you can't access the whole list of objects in order, whereas a search tree can be iterated efficiently through in O(n) time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The benefit of a min-max heap however is that the current min and max objects can be read in O(1) time, a search tree requires O(log(n)) just to read the min or max object unless you have the cached pointers as I mentioned above."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "current", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["If this were Java I'd use a TreeSet with the NavigableSet interface."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is implemented as a Red-Black-Tree."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]