[[{"text": ["Use a generator to iterate over the elements of the list, and yield a new one only when it has changed."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["itertools.groupby does exactly this."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "itertools.groupby", "tag": "a", "pos": 0, "childList": [{"text": "itertools.groupby", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.groupby"}, {"text": "itertools.groupby", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can modify the passed-in list if you iterate over a copy:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for elt in theList[ : ]:\n    ...\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's the traditional way, deleting adjacent duplicates in situ, while traversing the list backwards:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Python 1.5.2 (#0, Apr 13 1999, 10:51:12) [MSC 32 bit (Intel)] on win32\nCopyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam\n&gt;&gt;&gt; def dedupe_adjacent(alist):\n...     for i in xrange(len(alist) - 1, 0, -1):\n...         if alist[i] == alist[i-1]:\n...             del alist[i]\n...\n&gt;&gt;&gt; data = [1,2,2,3,2,2,4]; dedupe_adjacent(data); print data\n[1, 2, 3, 2, 4]\n&gt;&gt;&gt; data = []; dedupe_adjacent(data); print data\n[]\n&gt;&gt;&gt; data = [2]; dedupe_adjacent(data); print data\n[2]\n&gt;&gt;&gt; data = [2,2]; dedupe_adjacent(data); print data\n[2]\n&gt;&gt;&gt; data = [2,3]; dedupe_adjacent(data); print data\n[2, 3]\n&gt;&gt;&gt; data = [2,2,2,2,2]; dedupe_adjacent(data); print data\n[2]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update: If you want a generator but (don't have itertools.groupby or (you can type faster than you can read its docs and understand its default behaviour)), here's a six-liner that does the job:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "itertools.groupby", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n Python 2.3.5 (#62, Feb  8 2005, 16:23:02) [MSC v.1200 32 bit (Intel)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; def dedupe_adjacent(iterable):\n...     prev = object()\n...     for item in iterable:\n...         if item != prev:\n...             prev = item\n...             yield item\n...\n&gt;&gt;&gt; data = [1,2,2,3,2,2,4]; print list(dedupe_adjacent(data))\n[1, 2, 3, 2, 4]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Update 2: Concerning the baroque itertools.groupby() and the minimalist object() ..."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Update 2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "itertools.groupby()", "childNum": 0, "tag": "code", "childList": []}, {"text": "object()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To get the dedupe_adjacent effect out of itertools.groupby(), you need to wrap a list comprehension around it to throw away the unwanted groupers:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "itertools.groupby()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [k for k, g in itertools.groupby([1,2,2,3,2,2,4])]\n[1, 2, 3, 2, 4]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 6}, {"text": ["... or muck about with itertools.imap and/or operators.itemgetter, as seen in another answer."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "itertools.imap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "operators.itemgetter", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Expected behaviour with object instances is that none of them compares equal to any other instance of any class, including object itself.", "Consequently they are extremely useful as sentinels."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "object", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "object", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; object() == object()\nFalse\n</code>\n</pre>\n", "senID": 9}, {"text": ["It's worth noting that the Python reference code for itertools.groupby uses object() as a sentinel:"], "childNum": 3, "tag": "p", "senID": 10, "childList": [{"text": "Python reference code", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.groupby"}, {"text": "itertools.groupby", "childNum": 0, "tag": "code", "childList": []}, {"text": "object()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n self.tgtkey = self.currkey = self.currvalue = object()\n</code>\n</pre>\n", "senID": 11}, {"text": ["and that code does the right thing when you run it:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; data = [object(), object()]\n&gt;&gt;&gt; data\n[&lt;object object at 0x00BBF098&gt;, &lt;object object at 0x00BBF050&gt;]\n&gt;&gt;&gt; [k for k, g in groupby(data)]\n[&lt;object object at 0x00BBF098&gt;, &lt;object object at 0x00BBF050&gt;]\n</code>\n</pre>\n", "senID": 13}, {"text": ["Update 3: Remarks on forward-index in-situ operation"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "Update 3:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The OP's revised code:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n def remove_adjacent(nums):\n  i = 1\n  while i &lt; len(nums):    \n    if nums[i] == nums[i-1]:\n      nums.pop(i)\n      i -= 1  \n    i += 1\n  return nums\n</code>\n</pre>\n", "senID": 16}, {"text": ["is better written as:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n def remove_adjacent(seq): # works on any sequence, not just on numbers\n  i = 1\n  n = len(seq)\n  while i &lt; n: # avoid calling len(seq) each time around\n    if seq[i] == seq[i-1]:\n      del seq[i]\n      # value returned by seq.pop(i) is ignored; slower than del seq[i]\n      n -= 1\n    else:\n      i += 1\n  #### return seq #### don't do this\n  # function acts in situ; should follow convention and return None\n</code>\n</pre>\n", "senID": 18}], [{"text": ["Well, katrielalex is right about itertools, but the OP seems to be rather more interested (or should be!", ") in learning to manipulate the basics of the built-in data structures.", "As for manipulating a list in place, it does need thought, but my recommendation would be to read through this section of the documentation and try a few list methods (hint: list.pop(), list.remove(), and learn everything about slices."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "this section of the documentation", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html"}]}, {"text": ["The posted code could be simplified, by the way (you should however add handling of error conditions):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def remove_adjacent(nums):\n  a = nums[:1]\n  for item in nums[1:]:\n    if item != a[-1]:\n      a.append(item)\n  return a\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Just to show one more way here is another single liner version without indexes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def remove_adjacent(nums):\n     return [a for a,b in zip(nums, nums[1:]+[not nums[-1]]) if a != b]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The not part puts the last value to result as only a ends up to result."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["@katrielalex's solution is more pythonic, but if you did need to modify the list in-place without making a copy, you could use a while loop and break when you catch an IndexError.", "e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n nums = [1,1,1,2,2,3,3,3,5,5,1,1,1]\ndef remove_adjacent(nums):\n    \"\"\"Removes adjacent items by modifying \"nums\" in-place. Returns None!\"\"\"\n    i = 0\n    while True:\n        try:\n            if nums[i] == nums[i+1]:\n                # Letting you figure this part out, \n                # as it's a homework question\n        except IndexError:\n            break\nprint nums\nremove_adjacent(nums)\nprint nums\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: pastebin of one way to do it here, in case you get stuck and want to know.."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pastebin of one way to do it here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pastebin.com/U6U7ZE9U"}]}], [{"text": ["You can modify a list you're iterating over if you use indices explicitly:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def remove_adjacent(l):\n  if len(l)&lt;2:\n    return l\n  prev,i = l[0],1\n  while i &lt; len(l):\n    if l[i] == prev:\n      del l[i]\n    else:\n      prev = l[i]\n      i += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["It doesn't work with iterators because iterators don't \"know\" how to modify the index when you remove arbitrary elements, so it's easier to just forbid it.", "Some languages have iterators with functions to remove the \"current item\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can use list comprehension.", "For example something like this should do the job:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def remove_adjacent(L):\n  return [elem for i, elem in enumerate(L) if i == 0 or L[i-1] != elem]\n</code>\n</pre>\n", "senID": 1}, {"text": ["or:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def remove_adjacent(L):\n  return [L[i] for i in xrange(len(L)) if i == 0 or L[i-1] != L[i]]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As usual, I am just here to advertise the impressive recipes in the Python itertools documentation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "recipes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#recipes"}]}, {"text": ["What you are looking for is the function unique_justseen:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "unique_justseen", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import imap, groupby\nfrom operator import itemgetter\n\ndef unique_justseen(iterable, key=None):\n    \"List unique elements, preserving order. Remember only the element just seen.\"\n    # unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B\n    # unique_justseen('ABBCcAD', str.lower) --&gt; A B C A D\n    return imap(next, imap(itemgetter(1), groupby(iterable, key)))\n\nlist(unique_justseen([1,2,2,3])) # [1, 2, 3]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Since you are in a Python class, I'm going to guess that you are new to the language.", "Thus, for you and any other beginners out there, I wrote a simple version of the code to help others get through the logic."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n original= [1, 2, 2, 3]\nnewlist=[]\n\nfor item in original:\n    if item in newlist:\n        print \"You don't need to add \"+str(item)+\" again.\"\n    else:\n        newlist.append(item)\n        print \"Added \"+str(item)\n\nprint newlist\n</code>\n</pre>\n", "senID": 1}]]