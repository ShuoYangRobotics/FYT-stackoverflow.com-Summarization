[[{"text": ["You can use set operations on the keys:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n diff = set(dictb.keys()) - set(dicta.keys())\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is a class to find all the possibilities: what was added, what was removed, which key-value pairs are the same, and which key-value pairs are unchanged."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class DictDiffer(object):\n    \"\"\"\n    Calculate the difference between two dictionaries as:\n    (1) items added\n    (2) items removed\n    (3) keys same in both but changed values\n    (4) keys same in both and unchanged values\n    \"\"\"\n    def __init__(self, current_dict, past_dict):\n    \tself.current_dict, self.past_dict = current_dict, past_dict\n    \tself.set_current, self.set_past = set(current_dict.keys()), set(past_dict.keys())\n    \tself.intersect = self.set_current.intersection(self.set_past)\n    def added(self):\n    \treturn self.set_current - self.intersect \n    def removed(self):\n    \treturn self.set_past - self.intersect \n    def changed(self):\n    \treturn set(o for o in self.intersect if self.past_dict[o] != self.current_dict[o])\n    def unchanged(self):\n    \treturn set(o for o in self.intersect if self.past_dict[o] == self.current_dict[o])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As Alex Martelli wrote, if you simply want to check if any key in B is not in A, any(True  for k in dictB if k not in dictA) would be the way to go."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "any(True  for k in dictB if k not in dictA)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To find the keys that are missing:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n diff = set(dictB)-set(dictA) #sets\n</code>\n</pre>\n", "senID": 2}, {"text": ["C:\\Dokumente und Einstellungen\\thc>python -m timeit -s \"dictA = dict(zip(range(1000),range\n(1000))); dictB = dict(zip(range(0,2000,2),range(1000)))\" \"diff=set(dictB)-set(dictA)\"\n10000 loops, best of 3: 107 usec per loop"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n diff = [ k for k in dictB if k not in dictA ] #lc\n</code>\n</pre>\n", "senID": 4}, {"text": ["C:\\Dokumente und Einstellungen\\thc>python -m timeit -s \"dictA = dict(zip(range(1000),range\n(1000))); dictB = dict(zip(range(0,2000,2),range(1000)))\" \"diff=[ k for k in dictB if k no\nt in dictA ]\"\n10000 loops, best of 3: 95.9 usec per loop"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["So those two solutions are pretty much the same speed. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["If you really mean exactly what you say (that you only need to find out IF \"there are any keys\" in B and not in A, not WHICH ONES might those be if any), the fastest way should be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if any(True for k in dictB if k not in dictA): ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you actually need to find out WHICH KEYS, if any, are in B and not in A, and not just \"IF\" there are such keys, then existing answers are quite appropriate (but I do suggest more precision in future questions if that's indeed what you mean;-)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["not sure whether its \"fast\" or not, but normally, one can do this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dicta = {\"a\":1,\"b\":2,\"c\":3,\"d\":4}\ndictb = {\"a\":1,\"d\":2}\nfor key in dicta.keys():\n    if not key in dictb:\n        print key\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a way that will work, allows for keys that evaluate to False, and still uses a generator expression to fall out early if possible.", "It's not exceptionally pretty though."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "False", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n any(map(lambda x: True, (k for k in b if k not in a)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["THC4k posted a reply to my comment on another answer.", "Here's a better, prettier way to do the above:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n any(True for k in b if k not in a)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Not sure how that never crossed my mind..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["May not 100% fit your question - but you could dump the dictionaries to json and compare the resulting strings.", ";-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Iff on Python \u2265 2.7:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # update different values in dictB\n# I would assume only dictA should be updated,\n# but the question specifies otherwise\n\nfor k in dictA.viewkeys() &amp; dictB.viewkeys():\n    if dictA[k] != dictB[k]:\n        dictB[k]= dictA[k]\n\n# add missing keys to dictA\n\ndictA.update( (k,dictB[k]) for k in dictB.viewkeys() - dictA.viewkeys() )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["what about standart (compare FULL Object)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["PyDev->new PyDev Module->Module: unittest"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import unittest\n\n\nclass Test(unittest.TestCase):\n\n\n    def testName(self):\n        obj1 = {1:1, 2:2}\n        obj2 = {1:1, 2:2}\n        self.maxDiff = None # sometimes is usefull\n        self.assertDictEqual(d1, d2)\n\nif __name__ == \"__main__\":\n    #import sys;sys.argv = ['', 'Test.testName']\n\n    unittest.main()\n</code>\n</pre>\n", "senID": 2}]]