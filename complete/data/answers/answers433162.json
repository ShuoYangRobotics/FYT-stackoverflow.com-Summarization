[[{"text": ["If it's a value you'd like to have for every request &amp; template, using a context processor is more appropriate."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "context processor", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/ref/templates/api/?from=olddocs#writing-your-own-context-processors"}]}, {"text": ["Here's how:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Django provides access to certain, frequently-used settings constants to the template such as settings.MEDIA_URL and some of the language settings if you use django's built in generic views or pass in a context instance keyword argument in the render_to_response shortcut function.", "Here's an example of each case:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "settings.MEDIA_URL", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "render_to_response", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from django.shortcuts import render_to_response\nfrom django.template import RequestContext\nfrom django.views.generic.simple import direct_to_template\n\ndef my_generic_view(request, template='my_template.html'):\n    return direct_to_template(request, template)\n\ndef more_custom_view(request, template='my_template.html'):\n    return render_to_response(template, {}, context_instance=RequestContext(request))\n</code>\n</pre>\n", "senID": 1}, {"text": ["These views will both have several frequently used settings like settings.MEDIA_URL available to the template as {{ MEDIA_URL }}, etc."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "settings.MEDIA_URL", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "{{ MEDIA_URL }}", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you're looking for access to other constants in the settings, then simply unpack the constants you want and add them to the context dictionary you're using in your view function, like so:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from django.conf import settings\nfrom django.shortcuts import render_to_response\n\ndef my_view_function(request, template='my_template.html'):\n    context = {'favorite_color': settings.FAVORITE_COLOR}\n    return render_to_response(template, context)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now you can access settings.FAVORITE_COLOR on your template as {{ favorite_color }}.  "], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "settings.FAVORITE_COLOR", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "{{ favorite_color }}", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Another way to do this is to create a custom template tag which can let you fish values out of the settings."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @register.tag\ndef value_from_settings(parser, token):\n    try:\n        # split_contents() knows not to split quoted strings.\n        tag_name, var = token.split_contents()\n    except ValueError:\n        raise template.TemplateSyntaxError, \"%r tag requires a single argument\" % token.contents.split()[0]\n    return ValueFromSettings(var)\n\nclass ValueFromSettings(template.Node):\n    def __init__(self, var):\n        self.arg = template.Variable(var)\n    def render(self, context):        \n        return settings.__getattr__(str(self.arg))\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can then use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {% value_from_settings \"FQDN\" %}\n</code>\n</pre>\n", "senID": 3}, {"text": ["to print it on any page, without jumping through context-processor hoops."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The example above from bchhun is nice except that you need to explicitly build your context dictionary from settings.py.", "Below is an UNTESTED example of how you could auto-build the context dictionary from all upper-case attributes of settings.py (re: \"^[A-Z0-9_]+$\")."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["At the end of settings.py:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n _context = {} \nlocal_context = locals()\nfor (k,v) in local_context.items():\n    if re.search('^[A-Z0-9_]+$',k):\n        _context[k] = str(v)\n\ndef settings_context(context):\n    return _context\n\nTEMPLATE_CONTEXT_PROCESSORS = (\n...\n'myproject.settings.settings_context',\n...\n)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I improved chrisdew's answer (to create your own tag) a little bit."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "chrisdew's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/433162/can-i-access-constants-in-settings-py-from-templates-in-django/5235614#5235614"}]}, {"text": ["First, create the file yourapp/templatetags/value_from_settings.py in which you define your own new tag value_from_settings:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "yourapp/templatetags/value_from_settings.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "value_from_settings", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from django.template import TemplateSyntaxError, Variable, Node, Variable, Library\nfrom yourapp import settings\n\nregister = Library()\n# I found some tricks in URLNode and url from defaulttags.py:\n# https://code.djangoproject.com/browser/django/trunk/django/template/defaulttags.py\n@register.tag\ndef value_from_settings(parser, token):\n  bits = token.split_contents()\n  if len(bits) &lt; 2:\n    raise TemplateSyntaxError(\"'%s' takes at least one \" \\\n      \"argument (settings constant to retrieve)\" % bits[0])\n  settingsvar = bits[1]\n  settingsvar = settingsvar[1:-1] if settingsvar[0] == '\"' else settingsvar\n  asvar = None\n  bits = bits[2:]\n  if len(bits) &gt;= 2 and bits[-2] == 'as':\n    asvar = bits[-1]\n    bits = bits[:-2]\n  if len(bits):\n    raise TemplateSyntaxError(\"'value_from_settings' didn't recognise \" \\\n      \"the arguments '%s'\" % \", \".join(bits))\n  return ValueFromSettings(settingsvar, asvar)\n\nclass ValueFromSettings(Node):\n  def __init__(self, settingsvar, asvar):\n    self.arg = Variable(settingsvar)\n    self.asvar = asvar\n  def render(self, context):\n    ret_val = getattr(settings,str(self.arg))\n    if self.asvar:\n      context[self.asvar] = ret_val\n      return ''\n    else:\n      return ret_val\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can use this tag in your Template via:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n {% load value_from_settings %}\n[...]\n{% value_from_settings \"FQDN\" %}\n</code>\n</pre>\n", "senID": 4}, {"text": ["or via"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n {% load value_from_settings %}\n[...]\n{% value_from_settings \"FQDN\" as my_fqdn %}\n</code>\n</pre>\n", "senID": 6}, {"text": ["The advantage of the as ... notation is that this makes it easy to use in blocktrans blocks via a simple {{my_fqdn}}."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "as ...", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "blocktrans", "childNum": 0, "tag": "code", "childList": []}, {"text": "{{my_fqdn}}", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I find the simplest approach being a single template tag:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from django import template\nfrom django.conf import settings\n\nregister = template.Library()\n\n# settings value\n@register.simple_tag\ndef settings_value(name):\n    try:\n        return settings.__getattr__(name)\n    except AttributeError:\n        return \"\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {% settings_value \"LANGUAGE_CODE\" %}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Both IanSR and bchhun suggested overriding TEMPLATE_CONTEXT_PROCESSORS in the settings.", "Be aware that this setting has a default that can cause some screwy things if you override it without re-setting the defaults.", "The defaults have also changed in recent versions of Django."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["https://docs.djangoproject.com/en/1.3/ref/settings/#template-context-processors"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "https://docs.djangoproject.com/en/1.3/ref/settings/#template-context-processors", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://docs.djangoproject.com/en/1.3/ref/settings/#template-context-processors"}]}, {"text": ["The default TEMPLATE_CONTEXT_PROCESSORS :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n TEMPLATE_CONTEXT_PROCESSORS = (\"django.contrib.auth.context_processors.auth\",\n\"django.core.context_processors.debug\",\n\"django.core.context_processors.i18n\",\n\"django.core.context_processors.media\",\n\"django.core.context_processors.static\",\n\"django.contrib.messages.context_processors.messages\")\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If we were to compare context vs. template tags on a single variable, then knowing the more efficient option could be benificial.", "However, you might be better off to dip into the settings only from templates that need that variable.", "In that case it doesn't make sense to pass the variable into all templates.", "But if you are sending the variable into a common template such as the base.html template, Then it would not matter as the base.html template is rendered on every request, so you can use either methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you decide to go with the template tags option, then use the following code as it allows you to pass a default value in, just in case the variable in-question was undefined."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "default", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Example: get_from_settings my_variable as my_context_value"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Example: get_from_settings my_variable my_default as my_context_value"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class SettingsAttrNode(Node):\ndef __init__(self, variable, default, as_value):\n    self.variable = getattr(settings, variable, default)\n    self.cxtname = as_value\n\ndef render(self, context):\n    context[self.cxtname] = self.variable\n    return ''\n\ndef get_from_setting(parser, token):\nas_value = variable = default = ''\nbits = token.contents.split()\nif len(bits) == 4 and bits[2] == 'as':\n    variable = bits[1]\n    as_value = bits[3]\nelif len(bits) == 5 and bits[3] == 'as':\n    variable     = bits[1]\n    default  = bits[2]\n    as_value = bits[4]\nelse:\n    raise TemplateSyntaxError, \"usage: get_from_settings variable default as value \" \\\n                \"OR: get_from_settings variable as value\"\n\nreturn SettingsAttrNode(variable=variable, default=default, as_value=as_value)\n\nget_from_setting = register.tag(get_from_setting)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Depending on what the settings constant is for, you may really be looking for feature flipping / feature flags.", "Here are your options for Django; I suggest django-waffle from Mozilla."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Here are your options for Django", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://djangopackages.com/grids/g/feature-flip/"}, {"href": "https://github.com/jsocol/django-waffle", "text": "django-waffle", "childNum": 0, "tag": "a", "childList": []}]}]]