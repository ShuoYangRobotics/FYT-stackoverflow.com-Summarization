[[{"text": ["If you define an alphabet of characters, you can just convert to base 10, do an average, and convert back to base-N where N is the size of the alphabet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\ndef enbase(x):\n    n = len(alphabet)\n    if x &lt; n:\n        return alphabet[x]\n    return enbase(x/n) + alphabet[x%n]\n\ndef debase(x):\n    n = len(alphabet)\n    result = 0\n    for i, c in enumerate(reversed(x)):\n        result += alphabet.index(c) * (n**i)\n    return result\n\ndef average(a, b):\n    a = debase(a)\n    b = debase(b)\n    return enbase((a + b) / 2)\n\nprint average('a', 'z') #m\nprint average('aa', 'zz') #mz\nprint average('cat', 'doggie') #budeel\nprint average('google', 'microsoft') #gebmbqkil\nprint average('microsoft', 'google') #gebmbqkil\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: Based on comments and other answers, you might want to handle strings of different lengths by appending the first letter of the alphabet to the shorter word until they're the same length.", "This will result in the \"average\" falling between the two inputs in a lexicographical sort.", "Code changes and new outputs below."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def pad(x, n):\n    p = alphabet[0] * (n - len(x)) \n    return '%s%s' % (x, p)\n\ndef average(a, b):\n    n = max(len(a), len(b))\n    a = debase(pad(a, n))\n    b = debase(pad(b, n))\n    return enbase((a + b) / 2)\n\nprint average('a', 'z') #m\nprint average('aa', 'zz') #mz\nprint average('aa', 'az') #m (equivalent to ma)\nprint average('cat', 'doggie') #cumqec\nprint average('google', 'microsoft') #jlilzyhcw\nprint average('microsoft', 'google') #jlilzyhcw\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It sounds like what you want, is to treat alphabetical characters as a base-26 value between 0 and 1.", "When you have strings of different length (an example in base 10), say 305 and 4202, your coming out with a midpoint of 3, since you're looking at the characters one at a time.", "Instead, treat them as a floating point mantissa:  0.305 and 0.4202.", "From that, it's easy to come up with a midpoint of .3626 (you can round if you'd like)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Do the same with base 26 (a=0...z=25, ba=26, bb=27, etc.", ") to do the calculations for letters:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["cat becomes 'a.cat' and doggie becomes 'a.doggie', doing the math gives cat a decimal value of 0.078004096, doggie a value of 0.136390697, with an average of 0.107197397 which in base 26 is roughly \"cumcqo\""], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you mean the alphabetically, simply use FogleBird's algorithm but reverse the parameters and the result!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print average('cat'[::-1], 'doggie'[::-1])[::-1]\ncumdec\n</code>\n</pre>\n", "senID": 1}, {"text": ["or rewriting average like so"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def average(a, b):\n...     a = debase(a[::-1])\n...     b = debase(b[::-1])\n...     return enbase((a + b) / 2)[::-1]\n... \n&gt;&gt;&gt; print average('cat', 'doggie')\ncumdec\n&gt;&gt;&gt; print average('google', 'microsoft') \njlvymlupj\n&gt;&gt;&gt; print average('microsoft', 'google') \njlvymlupj\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Based on your proposed usage, consistent hashing ( http://en.wikipedia.org/wiki/Consistent_hashing ) seems to make more sense."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://en.wikipedia.org/wiki/Consistent_hashing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Consistent_hashing"}]}], [{"code": "<pre>\n<code>\n import math\ndef avg(str1,str2):\n    y = ''\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    for i in range(len(str1)):\n        x = s.index(str2[i])+s.index(str1[i])\n        x = math.floor(x/2)\n        y += s[x]\n    return y\n\nprint(avg('z','a')) # m\nprint(avg('aa','az')) # am\nprint(avg('cat','dog')) # chm\n</code>\n</pre>\n", "senID": 0}, {"text": ["Still working on strings with different lengths... any ideas?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This version thinks 'abc' is a fraction like 0.abc.", "In this approach space is zero and a valid input/output."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n MAX_ITER = 10\nletters = \" abcdefghijklmnopqrstuvwxyz\"\ndef to_double(name):\n    d = 0\n    for i, ch in enumerate(name):\n        idx = letters.index(ch)\n        d += idx * len(letters) ** (-i - 1)\n    return d\n\ndef from_double(d):\n    name = \"\"\n    for i in range(MAX_ITER):\n        d *= len(letters)\n        name += letters[int(d)]\n        d -= int(d)\n    return name\n\ndef avg(w1, w2):\n    w1 = to_double(w1)\n    w2 = to_double(w2)\n    return from_double((w1 + w2) * 0.5)\n\nprint avg('a', 'a') # 'a'\nprint avg('a', 'aa') # 'a mmmmmmmm'\nprint avg('aa', 'aa') # 'a zzzzzzzz'\nprint avg('car', 'duck') # 'cxxemmmmmm'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Unfortunately, the na\u00efve algorithm is not able to detect the periodic 'z's, this would be something like 0.99999 in decimal; therefore 'a zzzzzzzz' is actually 'aa' (the space before the 'z' periodicity must be increased by one."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In order to normalise this, you can use the following function"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def remove_z_period(name):\n    if len(name) != MAX_ITER:\n        return name\n    if name[-1] != 'z':\n        return name\n    n = \"\"\n    overflow = True\n    for ch in reversed(name):\n        if overflow:\n            if ch == 'z':\n                ch = ' '\n            else:\n                ch=letters[(letters.index(ch)+1)]\n                overflow = False\n        n = ch + n\n    return n\n\nprint remove_z_period('a zzzzzzzz') # 'aa'\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I haven't programmed in python in a while and this seemed interesting enough to try.", "Bear with my recursive programming.", "Too many functional languages look like python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def stravg_half(a, ln):\n     # If you have a problem it will probably be in here.\n     # The floor of the character's value is 0, but you may want something different\n     f = 0\n     #f = ord('a')\n     L = ln - 1\n     if 0 == L:\n          return ''\n     A = ord(a[0])\n     return chr(A/2) + stravg_half( a[1:], L)\n\ndef stravg_helper(a, b, ln, x):\n    L = ln - 1\n    A = ord(a[0])\n    B = ord(b[0])\n    D = (A + B)/2\n    if 0 == L:\n        if 0 == x:\n             return chr(D)\n        # NOTE: The caller of helper makes sure that len(a)&gt;=len(b)\n        return chr(D) + stravg_half(a[1:], x)\n    return chr(D) + stravg_helper(a[1:], b[1:], L, x)\n\ndef stravg(a, b):\n    la = len(a)\n    lb = len(b)\n    if 0 == la:\n        if 0 == lb:\n            return a # which is empty\n        return stravg_half(b, lb)\n    if 0 == lb:\n        return stravg_half(a, la)\n    x = la - lb\n    if x &gt; 0:\n        return stravg_helper(a, b, lb, x)\n    return stravg_helper(b, a, la, -x) # Note the order of the args\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Thanks for everyone who answered, but I ended up writing my own solution because the others weren't exactly what I needed.", "I am trying to average app engine key names, and after studying them a bit more I discovered they actually allow any 7-bit ASCII characters in the names.", "Additionally I couldn't really rely on the solutions that converted the key names first to floating point, because I suspected floating point accuracy just isn't enough."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To take an average, first you add two numbers together and then divide by two.", "These are both such simple operations that I decided to just make functions to add and divide base 128 numbers represented as lists.", "This solution hasn't been used in my system yet so I might still find some bugs in it.", "Also it could probably be a lot shorter, but this is just something I needed to get done instead of trying to make it perfect."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # Given two lists representing a number with one digit left to decimal point and the\n# rest after it, for example 1.555 = [1,5,5,5] and 0.235 = [0,2,3,5], returns a similar\n# list representing those two numbers added together.\n#\ndef ladd(a, b, base=128):\n        i = max(len(a), len(b))\n        lsum = [0] * i  \n        while i &gt; 1:\n                i -= 1\n                av = bv = 0\n                if i &lt; len(a): av = a[i]\n                if i &lt; len(b): bv = b[i]\n                lsum[i] += av + bv\n                if lsum[i] &gt;= base:\n                        lsum[i] -= base\n                        lsum[i-1] += 1\n        return lsum\n\n# Given a list of digits after the decimal point, returns a new list of digits\n# representing that number divided by two.\n#\ndef ldiv2(vals, base=128):\n        vs = vals[:]\n        vs.append(0)\n        i = len(vs)\n        while i &gt; 0:\n                i -= 1\n                if (vs[i] % 2) == 1:\n                        vs[i] -= 1\n                        vs[i+1] += base / 2\n                vs[i] = vs[i] / 2\n        if vs[-1] == 0: vs = vs[0:-1]\n        return vs\n\n# Given two app engine key names, returns the key name that comes between them.\n#\ndef average(a_kn, b_kn):\n        m = lambda x:ord(x)\n        a = [0] + map(m, a_kn)\n        b = [0] + map(m, b_kn)\n        avg = ldiv2(ladd(a, b))\n        return \"\".join(map(lambda x:chr(x), avg[1:]))\n\nprint average('a', 'z') # m@\nprint average('aa', 'zz') # n-@\nprint average('aa', 'az') # am@\nprint average('cat', 'doggie') # d(mstr@\nprint average('google', 'microsoft') # jlim.,7s:\nprint average('microsoft', 'google') # jlim.,7s:\n</code>\n</pre>\n", "senID": 2}]]