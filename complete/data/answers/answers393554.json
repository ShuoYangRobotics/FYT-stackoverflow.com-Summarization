[[{"text": ["contrary to popular belief, newer versions of sqlite3 do support access from multiple threads."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "do", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["this can be enabled via optional keyword argument check_same_thread"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "check_same_thread", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["e.g"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n sqlite.connect(\":memory:\", check_same_thread = False)\n</code>\n</pre>\n", "senID": 3}, {"text": ["as of the 24th of may 2010, the docs omit this option.", "the omission is listed as a bug here"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://bugs.python.org/issue8129"}]}, {"text": ["as of Jan 1, 2012, the docs contains this option."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["You can use consumer - producer pattern.", "For example you can create queue, that is shared between threads.", "First thread, that fetches data from the web, enqueue this data to the shared queue.", "Another thread, that owns database connection, dequeue data from the queue and pass it to the database. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You shouldn't be using threads at all for this.", "This is a trivial task for twisted and that would likely take you significantly further anyway."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "twisted", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/"}]}, {"text": ["Use only one thread, and have the completion of the request trigger an event to do the write."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["twisted will take care of the scheduling, callbacks, etc... for you.", "It'll hand you the entire result as a string, or you can run it through a stream-processor (I have a twitter API and a friendfeed API that both fire off events to callers as results are still being downloaded)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "twitter API", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "https://github.com/dustin/twitty-twister"}, {"href": "https://github.com/dustin/twisted-friends", "text": "friendfeed API", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Depending on what you're doing with your data, you could just dump the full result into sqlite as it's complete, cook it and dump it, or cook it while it's being read and dump it at the end."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I have a very simple application that does something close to what you're wanting on github.", "I call it pfetch (parallel fetch).", "It grabs various pages on a schedule, streams the results to a file, and optionally runs a script upon successful completion of each one.", "It also does some fancy stuff like conditional GETs, but still could be a good base for whatever you're doing."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "pfetch", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "https://github.com/dustin/pfetch"}]}], [{"text": ["Switch to multiprocessing.", "It is much better, scales good, can go beyond the use of multiple cores by using multiple CPUs, and the interface is the same as using python threading module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/multiprocessing.html"}]}, {"text": ["Or, as Ali suggested, just use SQLAlchemy's thread pooling mechanism.", "It will handle everything for you automatically and has many extra features, just to quote some of them:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "SQLAlchemy's thread pooling mechanism", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sqlalchemy.org/docs/05/reference/sqlalchemy/pooling.html#sqlalchemy.pool.SingletonThreadPool"}]}], [{"text": ["The following found on mail.python.org.pipermail.1239789\n\nI have found the solution.", "I don't know why python documentation has not a single word about this option.", "So we have to add a new keyword argument to connection function \nand we will be able to create cursors out of it in different thread.", "So use:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "mail.python.org.pipermail.1239789", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2010-March/1239789.html"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n sqlite.connect(\":memory:\", check_same_thread = False)\n</code>\n</pre>\n", "senID": 1}, {"text": ["works out perfectly for me.", "Of course from now on I need to take care \nof safe multithreading access to the db.", "Anyway thx all for trying to help."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is an example of what Evgeny Lazin mentioned above."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/526618/"}]}], [{"text": ["I like Evgeny's answer - Queues are generally the best way to implement inter-thread communication.", "For completeness, here are some other options:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Close the DB connection when the spawned threads have finished using it. This would fix your ", "tag": "none", "senID": 1}, {"text": "Don't use child threads. If the once-per-second task is reasonably lightweight, you could get away with doing the fetch and store, then sleeping until the right moment. This is undesirable as fetch and store operations could take >1sec, and you lose the benefit of multiplexed resources you have with a multi-threaded approach.", "tag": "none", "senID": 2}]}], [{"text": ["Or if you are lazy, like me, you can use SQLAlchemy.", "It will handle the threading for you, (using thread local, and some connection pooling) and the way it does it is even configurable."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "SQLAlchemy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sqlalchemy.org/"}, {"text": "using thread local, and some connection pooling", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.sqlalchemy.org/docs/05/reference/sqlalchemy/pooling.html#sqlalchemy.pool.SingletonThreadPool"}, {"href": "http://www.sqlalchemy.org/docs/05/reference/dialects/sqlite.html#threading-behavior", "text": "configurable", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["For added bonus, if/when you realise/decide that using Sqlite for any concurrent application is going to be a disaster, you won't have to change your code to use MySQL, or Postgres, or anything else.", "You can just switch over."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You need to design the concurrency for your program.", "SQLite has clear limitations and you need to obey them, see the FAQ (also the following question)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "FAQ", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://sqlite.org/faq.html#q5"}]}], [{"text": ["Scrapy seems like a potential answer to my question.", "Its home page describes my exact task.", "(Though I'm not sure how stable the code is yet."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Scrapy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://dev.scrapy.org/"}]}], [{"text": ["I would take a look at the y_serial Python module for data persistence: http://yserial.sourceforge.net "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://yserial.sourceforge.net", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://yserial.sourceforge.net"}]}, {"text": ["which handles deadlock issues surrounding a single SQLite database.", "If demand on concurrency gets heavy one can easily set up the class Farm of many databases to diffuse the load over stochastic time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Hope this helps your project... it should be simple enough to implement in 10 minutes."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Use threading.Lock()"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "threading.Lock()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/threading.html#lock-objects"}]}]]