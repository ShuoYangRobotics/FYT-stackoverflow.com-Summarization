[[{"text": ["it's typically referred to as flattening a nested structure."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tupleOfTuples = ((1, 2), (3, 4), (5,))\n&gt;&gt;&gt; [element for tupl in tupleOfTuples for element in tupl]\n[1, 2, 3, 4, 5]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Just to demonstrate efficiency:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import timeit\n&gt;&gt;&gt; it = lambda: list(chain(*tupleOfTuples))\n&gt;&gt;&gt; timeit.timeit(it)\n2.1475738355700913\n&gt;&gt;&gt; lc = lambda: [element for tupl in tupleOfTuples for element in tupl]\n&gt;&gt;&gt; timeit.timeit(lc)\n1.5745135182887857\n</code>\n</pre>\n", "senID": 3}, {"text": ["ETA: Please don't use tuple as a variable name, it shadows built-in."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "ETA", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You're chaining the tuples together:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import chain\nprint list(chain(*listOfTuples))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Should be pretty readable if you're familiar with itertools, and without the explicit list you even have your result in generator form."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Just use sum."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tupleOfTuples = ((1, 2), (3, 4), (5,))\n&gt;&gt;&gt; sum(tupleOfTuples, ())\n(1, 2, 3, 4, 5)\n&gt;&gt;&gt; list(sum(tupleOfTuples, ())) # if you really need a list\n[1, 2, 3, 4, 5]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Micro-benchmarks:"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["Python 2.6"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Python 3.1"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]}, {"text": ["Observation:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["sum"], "childNum": 0, "tag": "code", "senID": 6, "childList": []}, {"text": ["list(chain.from_iterable(x))"], "childNum": 0, "tag": "code", "senID": 7, "childList": []}]}], [{"text": ["I like using 'reduce' in this situation (this is what reduce made for!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lot = ((1, 2), (3, 4), (5,))\nprint list(reduce(lambda t1, t2: t1 + t2, lot))\n\n &gt; [1,2,3,4,5]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Another solution using itertools.chain"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.chain", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.chain"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tupleOfTuples = ((1, 2), (3, 4), (5,))\n&gt;&gt;&gt; from itertools import chain\n&gt;&gt;&gt; [x for x in chain.from_iterable(tupleOfTuples)]\n[1, 2, 3, 4, 5]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Most of these answers will only work for a single level of flattening.", "For a more comprehensive solution, try this (from http://rightfootin.blogspot.com/2006/09/more-on-python-flatten.html):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://rightfootin.blogspot.com/2006/09/more-on-python-flatten.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://rightfootin.blogspot.com/2006/09/more-on-python-flatten.html"}]}, {"code": "<pre>\n<code>\n def flatten(l, ltypes=(list, tuple)):\n    ltype = type(l)\n    l = list(l)\n    i = 0\n    while i &lt; len(l):\n        while isinstance(l[i], ltypes):\n            if not l[i]:\n                l.pop(i)\n                i -= 1\n                break\n            else:\n                l[i:i + 1] = l[i]\n        i += 1\n    return ltype(l)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For multilevel, and readable code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flatten(bla):\n    output = []\n    for item in bla:\n        output += flatten(item) if hasattr (item, \"__iter__\") or hasattr (item, \"__len__\") else [item]\n    return output\n</code>\n</pre>\n", "senID": 1}, {"text": ["I could not get this to fit in one line (and remain readable, even by far) "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]