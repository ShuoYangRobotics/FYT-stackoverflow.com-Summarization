[[{"code": "<pre>\n<code>\n all(any(a &amp; b for a in s if a is not b) for b in s)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here's a very simple solution that's very efficient for large inputs:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def g(s):\n    import collections\n    count = collections.defaultdict(int)\n    for a in s:\n        for x in a:\n            count[x] += 1\n    return all(any(count[x] &gt; 1 for x in a) for a in s)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's a little verbose but I think it's a pretty efficient solution.", "It takes advantage of the fact that when two sets intersect, we can mark them both as connected.", "It does this by keeping a list of flags as long as the list of sets.", "when set i and set j intersect, it sets the flag for both of them.", "It then loops over the list of sets and only tries to find a intersection for sets that haven't already been intersected.", "After reading the comments, I think this is what @Victor was talking about."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "j", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n s0 = [set([16,9,2,10]), set([16,14,22,15]), set([14,7])]   # true, 16 and 14\ns1 = [set([16,9,2,10]), set([16,14,22,15]), set([7,8])]    # false\n\n\ndef connected(sets):\n    L = len(sets)\n\n    if not L: return True\n    if L == 1: return False\n\n    passed = [False] * L\n    i = 0\n    while True:\n        while passed[i]: \n            i += 1\n            if i == L: \n                return True\n\n        for j, s in enumerate(sets):\n            if j == i: continue\n            if sets[i] &amp; s: \n                passed[i] = passed[j] = True\n                break\n        else:\n            return False\n\n\nprint connected(s0)\nprint connected(s1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I decided that an empty list of sets is connected (If you produce an element of the list, I can produce an element that it intersects ;).", "A list with only one element is dis-connected trivially.", "It's one line to change in either case if you disagree."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's a more efficient (if much more complicated) solution, that performs a linear number of intersections and a number of unions of order O( n*log(n) ), where n is the length of s:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def f(s):\n    import math\n    j = int(math.log(len(s) - 1, 2)) + 1\n    unions = [set()] * (j + 1)\n    for i, a in enumerate(s):\n        unions[:j] = [set.union(set(), *s[i+2**k:i+2**(k+1)]) for k in range(j)]\n        if not (a &amp; set.union(*unions)):\n            return False\n        j = int(math.log(i ^ (i + 1), 2))\n        unions[j] = set.union(a, *unions[:j])\n    return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that this solution only works on Python >= 2.6."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As usual I'd like to give the inevitable itertools solution ;-)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import combinations, groupby\nfrom operator import itemgetter\n\n\ndef any_intersects( sets ):\n    # we are doing stuff with combinations of sets\n    combined = combinations(sets,2) \n    # group these combinations by their first set\n    grouped = (g for k,g in groupby( combined, key=itemgetter(0)))\n    # are any intersections in each group\n    intersected = (any((a&amp;b) for a,b in group) for group in grouped)\n    return all( intersected )\n\n\ns0 = [set([16,9,2,10]), set([16,14,22,15]), set([14,7])]\ns1 = [set([16,9,2,10]), set([16,14,22,15]), set([7,8])] \nprint any_intersects( s0 ) # True\nprint any_intersects( s1 ) # False\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is really lazy and will only do the intersections that are required.", "It can also be a very confusing and unreadable oneliner ;-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["To answer your question, no, there isn't a built-in or simple list comprehension that does what you want.", "Here's another itertools based solution that is very efficient -- surprisingly about twice as fast as @THC4k's itertools answer using groupby() in timing tests using your sample input.", "It could probably be optimized a bit further, but is very readable as presented.", "Like @AaronMcSmooth, I arbitrarily decided what to return when there are no or is only one set in the input list."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "itertools", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "groupby()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import combinations\n\ndef all_intersect(sets):\n    N = len(sets)\n    if not N: return True\n    if N == 1: return False\n\n    intersected = [False] * N\n    for i,j in combinations(xrange(N), 2):\n        if not intersected[i] or not intersected[j]:\n            if sets[i] &amp; sets[j]:\n                intersected[i] = intersected[j] = True\n    return all(intersected)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This strategy isn't likely to be as efficient as @Victor's suggestion, but might be more efficient than jchl's answer due to increased use of set arithmetic (union)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "jchl's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3837426/python-set-intersection-question#answer-3837594"}, {"text": "union", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n s0 = [set([16,9,2,10]), set([16,14,22,15]), set([14,7])]\ns1 = [set([16,9,2,10]), set([16,14,22,15]), set([7,8])]\n\ndef freeze(list_of_sets):\n    \"\"\"Transform a list of sets into a frozenset of frozensets.\"\"\"\n    return frozenset(frozenset(set_) for set_ in list_of_sets)\n\ndef all_sets_have_relatives(set_of_sets):\n    \"\"\"Check if all sets have another set that they intersect with.\n\n    &gt;&gt;&gt; all_sets_have_relatives(s0)   # true, 16 and 14\n    True\n    &gt;&gt;&gt; all_sets_have_relatives(s1)   # false\n    False\n    \"\"\"\n    set_of_sets = freeze(set_of_sets)\n    def has_relative(set_):\n        return set_ &amp; frozenset.union(*(set_of_sets - set((set_,))))\n    return all(has_relative(set) for set in set_of_sets)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This may give better performance depending on the distribution of the sets."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def all_intersect(s):\n   count = 0\n   for x, a in enumerate(s):\n      for y, b in enumerate(s):\n         if a &amp; b and x!=y:\n            count += 1\n            break\n   return count == len(s)\n</code>\n</pre>\n", "senID": 1}]]