[[{"text": ["You may find this related answer from Guido:  Sorting a million 32-bit integers in 2MB of RAM using Python"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sorting a million 32-bit integers in 2MB of RAM using Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://neopythonic.blogspot.com/2008/10/sorting-million-32-bit-integers-in-2mb.html"}]}], [{"text": ["What you really want is an ordered container, instead of an unordered one.", "That would implicitly sort the results as they're inserted.", "The standard data structure for this is a tree."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, there doesn't seem to be one of these in Python.", "I can't explain that; this is a core, fundamental data type in any language.", "Python's dict and set are both unordered containers, which map to the basic data structure of a hash table.", "It should definitely have an optimized tree data structure; there are many things you can do with them that are impossible with a hash table, and they're quite tricky to implement well, so people generally don't want to be doing it themselves."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(There's also nothing mapping to a linked list, which also should be a core data type.", "No, a deque is not equivalent."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I don't have an existing ordered container implementation to point you to (and it should probably be implemented natively, not in Python), but hopefully this will point you in the right direction."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["A good tree implementation should support iterating across a range by value (\"iterate all values from [2,100] in order\"), find next/prev value from any other node in O(1), efficient range extraction (\"delete all values in [2,100] and return them in a new tree\"), etc.", "If anyone has a well-optimized data structure like this for Python, I'd love to know about it.", "(Not all operations fit nicely in Python's data model; for example, to get next/prev value from another value, you need a reference to a node, not the value itself."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you have a fixed number of fields, use tuples instead of dictionaries.", "Place the field you want to sort on in first position, and just use mylist.sort()"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mylist.sort()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Others have provided some excellent advices, try them out. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As a general advice, in situations like that you need to profile your code.", "Know exactly where most of the time is spent.", "Bottlenecks hide well, in places you least expect them to be.", "If there is a lot of number crunching involved then psyco might also help.", "When processing takes minutes or hours 2x speed-up really counts."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": ["http://docs.python.org/library/profile.html"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}, {"text": ["http://www.vrplumber.com/programming/runsnakerun/"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["http://psyco.sourceforge.net/"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}]}], [{"text": ["This seems to be pretty fast."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n raw= [ {'id':'id1', 'hits':200, 'misses':300, 'total':400},\n    {'id':'id2', 'hits':300, 'misses':100, 'total':500},\n    {'id':'id3', 'hits':100, 'misses':400, 'total':600}\n]\n\nhits= [ (r['hits'],r['id']) for r in raw ]\nhits.sort()\n\nmisses = [ (r['misses'],r['id']) for r in raw ]\nmisses.sort()\n\ntotal = [ (r['total'],r['id']) for r in raw ]\ntotal.sort()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Yes, it makes three passes through the raw data.", "I think it's faster than pulling out the data in one pass."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Instead of trying to keep your list ordered, maybe you can get by with a heap queue.", "It lets you push any item, keeping the 'smallest' one at h[0], and popping this item (and 'bubbling' the next smallest) is an O(nlogn) operation."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "h[0]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "O(nlogn)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["so, just ask yourself: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["do i need the whole list ordered all the time?", ": use an ordered structure (like Zope's BTree package, as mentioned by Ealdwulf)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "mentioned", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1180240/best-way-to-sort-1m-records-in-python/1180367#1180367"}]}, {"text": ["or the whole list ordered but only after a day's work of random insertions?", ": use sort like you're doing, or like S.Lott's answer"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "S.Lott's answer", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1180240/best-way-to-sort-1m-records-in-python/1180373#1180373"}]}, {"text": ["or just a few 'smallest' items at any moment?", ": use heapq"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "heapq", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]}], [{"code": "<pre>\n<code>\n sorted(myLists[key], key=mylists[key].get, reverse=True)\n</code>\n</pre>\n", "senID": 0}, {"text": ["should save you some time, though not a lot."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I would look into using a different sorting algorithm.", "Something like a Merge Sort might work.", "Break the list up into smaller lists and sort them individually.", "Then loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Pseudo code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n list1 = []  // sorted separately\nlist2 = []  // sorted separately\n\n// Recombine sorted lists\nresult = []\nwhile (list1.hasMoreElements || list2.hasMoreElements):\n   if (! list1.hasMoreElements):\n       result.addAll(list2)\n       break\n   elseif (! list2.hasMoreElements):\n       result.AddAll(list1)\n       break\n\n   if (list1.peek &lt; list2.peek):\n      result.add(list1.pop)\n   else:\n      result.add(list2.pop)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Glenn Maynard is correct that a sorted mapping would be appropriate here.", "This is one for python: http://wiki.zope.org/ZODB/guide/node6.html#SECTION000630000000000000000"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://wiki.zope.org/ZODB/guide/node6.html#SECTION000630000000000000000", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://wiki.zope.org/ZODB/guide/node6.html#SECTION000630000000000000000"}]}], [{"text": ["I've done some quick profiling of both the original way and SLott's proposal.", "In neither case does it take 5-10 minutes per field.", "The actual sorting is not the problem.", "It looks like most of the time is spent in slinging data around and transforming it.", "Also, my memory usage is skyrocketing - my python is over 350 megs of ram!", "are you sure you're not using up all your ram and paging to disk?", "Even with my crappy 3 year old power saving processor laptop, I am seeing results way less than 5-10 minutes per key sorted for a million items.", "What I can't explain is the variability in the actual sort() calls.", "I know python sort is extra good at sorting partially sorted lists, so maybe his list is getting partially sorted in the transform from the raw data to the list to be sorted."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's the results for slott's method:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n done creating data\ndone transform.  elapsed: 16.5160000324\nsorting one key slott's way takes 1.29699993134\n</code>\n</pre>\n", "senID": 2}, {"text": ["here's the code to get those results:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n starttransform = time.time()\nhits= [ (r['hits'],r['id']) for r in myList ]\nendtransform = time.time()\nprint \"done transform.  elapsed: \" + str(endtransform - starttransform)\nhits.sort()\nendslottsort = time.time()\nprint \"sorting one key slott's way takes \" + str(endslottsort - endtransform)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now the results for the original method, or at least a close version with some instrumentation added:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n done creating data\ndone transform.  elapsed: 8.125\nabout to get stuff to be sorted \ndone getting data. elapsed time: 37.5939998627\nabout to sort key hits\ndone  sorting on key &lt;hits&gt; elapsed time: 5.54699993134\n</code>\n</pre>\n", "senID": 6}, {"text": ["Here's the code:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n for k, v in myLists.iteritems():\n    time1 = time.time()\n    print \"about to get stuff to be sorted \"\n    tobesorted = myLists[k].items()\n    time2 = time.time()\n    print \"done getting data. elapsed time: \" + str(time2-time1)\n    print \"about to sort key \" + str(k) \n    mysorted[k] = tobesorted.sort( key=itemgetter(1))\n    time3 = time.time()\n    print \"done  sorting on key &lt;\" + str(k) + \"&gt; elapsed time: \" + str(time3-time2)\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Honestly, the best way is to not use Python.", "If performance is a major concern for this, use a faster language."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]