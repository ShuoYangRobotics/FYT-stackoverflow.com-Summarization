[[{"text": ["Use this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if mystr == '':\n    mystr = latestValue\nelse:\n    mystr = mystr[mystr.find(\",\")+1:] + \",\" + latestValue\n</code>\n</pre>\n", "senID": 1}, {"text": ["This should be much faster than any solution which splits the list.", "It only finds the first occurrence of , and \"removes\" the beginning of the string.", "Also, if the list is empty, then mystr will be just latestValue (insignificant overhead added by this) -- thanks Paulo Scardine for pointing that out."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": ",", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "mystr", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "latestValue", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n mystr = mystr.partition(\",\")[2]+\",\"+latestValue\n</code>\n</pre>\n", "senID": 0}, {"text": ["improvement suggested by Paulo to work if mystr has &lt; 2 elements.", "In the case of 0 elements, it does extend mystr to hold one element. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n _,_,mystr = (mystr+','+latestValue).partition(',')\n\n$ python -m timeit -s \"mystr = '5,22,7,814,3,4';latestValue='1'\" \"mystr[mystr.find(',')+1:]+','+latestValue\"\n1000000 loops, best of 3: 0.847 usec per loop\n$ python -m timeit -s \"mystr = '5,22,7,814,3,4';latestValue='1'\" \"mystr = mystr.partition(',')[2]+','+latestValue\"\n1000000 loops, best of 3: 0.703 usec per loop\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n _, sep, rest = mystr.partition(\",\")\nmystr = rest + sep + latestValue\n</code>\n</pre>\n", "senID": 0}, {"text": ["It also works without any changes if mystr is empty or a single item (without comma after it) due to str.partition returns empty sep if there is no sep in mystr."], "childNum": 7, "tag": "p", "senID": 1, "childList": [{"text": "also", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "mystr", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/stdtypes.html#str.partition", "text": "str.partition", "childNum": 1, "tag": "a", "childList": [{"text": "str.partition", "tag": "code"}]}, {"text": "str.partition", "childNum": 0, "tag": "code", "childList": []}, {"text": "sep", "childNum": 0, "tag": "code", "childList": []}, {"text": "sep", "childNum": 0, "tag": "code", "childList": []}, {"text": "mystr", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You could use mystr.rstrip(\",\") before calling partition() if there might be a trailing comma in the mystr."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "mystr.rstrip(\",\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "partition()", "childNum": 0, "tag": "code", "childList": []}, {"text": "mystr", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["best version: gnibbler's answer"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "best version", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/4111711/what-is-the-most-efficient-way-to-concatenate-two-strings-and-remove-everything-b/4112015#4112015", "text": "gnibbler's answer", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Since you need speed (millions of times is a lot), I profiled.", "This one is about twice as fast as splitting the list:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n i = 0\nwhile 1:\n    if mystr[i] == ',': break\n    i += 1\nmystr = mystr[i+1:] + ', ' + latest_value\n</code>\n</pre>\n", "senID": 2}, {"text": ["It assumes that there is one space after each comma.", "If that's a problem, you can use:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n i = 0\nwhile 1:\n    if mystr[i] == ',': break\n    i += 1\nmystr = mystr[i+1:].strip() + ', ' + latest_value\n</code>\n</pre>\n", "senID": 4}, {"text": ["which is only slightly slower than the original but much more robust.", "It's really up to you to decide how much speed you need to squeeze out of it.", "They both assume that there will be a comma in the string and will raise an IndexError if one fails to appear.", "The safe version is:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "IndexError", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n i = 0\nwhile 1:\n    try:\n        if mystr[i] == ',': break\n    except IndexError:\n        i = -1\n        break\n    i += 1\nmystr = mystr[i+1:].strip() + ', ' + latest_value\n</code>\n</pre>\n", "senID": 6}, {"text": ["Again, this is still significantly faster than than splitting the string but does add robustness at the cost of speed."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Here's the timeit results.", "You can see that the fourth method is noticeably faster than the third (most robust) method, but slightly slower than the first two methods.", "It's the fastest of the two robust solutions though so unless you are sure that your strings will have commas in them (i.e.", "it would already be considered an error if they didn't) then I would use it anyway."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["$ python -mtimeit -s'from strings import tests, method1' 'method1(tests[0], \"10\")' \n1000000 loops, best of 3: 1.34 usec per loop"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["$ python -mtimeit -s'from strings import tests, method2' 'method2(tests[0], \"10\")' \n1000000 loops, best of 3: 1.34 usec per loop"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["$ python -mtimeit -s'from strings import tests, method3' 'method3(tests[0], \"10\")' \n1000000 loops, best of 3: 1.5 usec per loop"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["$ python -mtimeit -s'from strings import tests, method4' 'method4(tests[0], \"10\")' \n1000000 loops, best of 3: 1.38 usec per loop"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["$ python -mtimeit -s'from strings import tests, method5' 'method5(tests[0], \"10\")' \n100000 loops, best of 3: 1.18 usec per loop"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["This is gnibbler's answer"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "gnibbler's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4111711/what-is-the-most-efficient-way-to-concatenate-two-strings-and-remove-everything-b/4112015#4112015"}]}], [{"code": "<pre>\n<code>\n mylist = mystr.split(',')\nmylist.append(latestValue);\nmystr = \",\".join(mylist[1:])\n</code>\n</pre>\n", "senID": 0}, {"text": ["String concatenation in python isn't very efficient (since strings are immutable).", "It's easier to work with them as lists (and more efficient).", "Basically in your code you are copying your string over and over again each time you concatenate to it.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Edited:\nNot the best, but I love one-liners.", ":-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mystr = ','.join(mystr.split(',')[1:]+[latestValue])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Before testing I would bet it would perform better."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt; python -m timeit \"mystr = '5,22,7,814,3,4'\" \"latestValue='1'\" \\\n\"mylist = mystr.split(',')\" \"mylist.append(latestValue);\" \\\n\"mystr = ','.join(mylist[1:])\"\n1000000 loops, best of 3: 1.37 usec per loop\n&gt; python -m timeit \"mystr = '5,22,7,814,3,4'\" \"latestValue='1'\"\\\n\"','.join(mystr.split(',')[1:]+[latestValue])\"\n1000000 loops, best of 3: 1.5 usec per loop\n&gt; python -m timeit \"mystr = '5,22,7,814,3,4'\" \"latestValue='1'\"\\\n'mystr=mystr[mystr.find(\",\")+1:]+\",\"+latestValue'\n1000000 loops, best of 3: 0.625 usec per loop\n</code>\n</pre>\n", "senID": 3}]]