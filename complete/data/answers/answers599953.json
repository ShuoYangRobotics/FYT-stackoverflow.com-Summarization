[[{"text": ["If the string is fixed you can simply use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if line.startswith(\"Path=\"):\n    return line[5:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["which gives you everything from position 5 on in the string (a string is also a sequence so these sequence operators work here, too)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Or you can split the line at the first =:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if \"=\" in line:\n    param, value = line.split(\"=\",1)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then param is \"Path\" and value is the rest after the first =."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n # ...\nif line.startswith(prefix):\n   return line[len(prefix):]\n</code>\n</pre>\n", "senID": 0}, {"code": "<pre>\n<code>\n def findvar(filename, varname=\"Path\", sep=\"=\") :\n    for line in open(filename):\n        if line.startswith(varname + sep):\n           head, sep_, tail = line.partition(sep) # instead of `str.split()`\n           assert head == varname\n           assert sep_ == sep\n           return tail\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n from ConfigParser import SafeConfigParser\nconfig = SafeConfigParser()\nconfig.read(filename) # requires section headers to be present\n\npath = config.get(section, 'path', raw=1) # case-insensitive, no interpolation\n</code>\n</pre>\n", "senID": 2}, {"tag": "ul", "num": 2, "lis": [{"text": ["str.split()"], "childNum": 1, "tag": "a", "senID": 3, "childList": [{"text": "str.split()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["re.match()"], "childNum": 1, "tag": "a", "senID": 4, "childList": [{"text": "re.match()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}], [{"text": ["The simplest way I can think of is with slicing-  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def findPath( i_file): \n    lines = open( i_file ).readlines() \n    for line in lines: \n        if line.startswith( \"Path=\" ) : \n            return line[5:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["A quick note on slice notation, it uses two indices instead of the usual one.", "The first index indicates the first element of the sequence you want to include in the slice and the last index is the index immediately after the last element you wish to include in the slice.", "Eg: "], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "slice", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "Eg:", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n sequenceObj[firstIndex:lastIndex]\n</code>\n</pre>\n", "senID": 3}, {"text": ["The slice consists of all the elements between firstIndex and lastIndex, including firstIndex and not lastIndex.", "If the first index is omitted, it defaults to the start of the sequence.", "If the last index is omitted, it includes all elements upto the lsdt element in the sequence.", "Negative indices are also allowed.", "Use Google to learn more about the topic."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["line[5:] will give the substring you want.", "Search the introduction and look for 'slice notation'"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "line[5:]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "introduction", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/introduction.html"}]}], [{"code": "<pre>\n<code>\n line[5:]\n</code>\n</pre>\n", "senID": 0}, {"text": ["gives you characters after the first five."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n\n&gt;&gt;&gt; p = re.compile(r'path=(.*)', re.IGNORECASE)\n\n&gt;&gt;&gt; path = \"path=c:\\path\"\n\n&gt;&gt;&gt; re.match(p, path).group(1)\n'c:\\\\path'\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I prefer the looks of pop to indexing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n value = line.split(\"Path=\").pop()\n</code>\n</pre>\n", "senID": 1}, {"text": ["to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n value = line.split(\"Path=\")[1]\nparam, value = line.split(\"Path=\")\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n def removePrefix(str, prefix):\n    return str[len(prefix):] if str.startswith(prefix) else str\n</code>\n</pre>\n", "senID": 0}, {"text": ["Couldn't resist doing this in one line.", "Requires Python 2.5+."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For slicing (conditional or non-conditional) in general I prefer what a colleague suggested recently; Use replacement with an empty string.", "Easier to read the code, less code (sometimes) and less risk of specifying the wrong number of characters.", "Ok; I do not use Python, but in other languages I do prefer this approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n rightMost = fullPath.replace('Path=','',1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or - to follow up to the first comment to this post - if this should only be done if the line starts with Path:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "if the line starts", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "Path", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n rightmost = re.compile('^Path=').sub('',fullPath)\n</code>\n</pre>\n", "senID": 3}, {"text": ["The main difference to some of what has been suggested above is that there is no \"magic number\" (5) involved, nor any need to specify both '5' and the string 'Path=', In other words I prefer this approach from a code maintenance point of view."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "5", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "em", "childList": []}, {"text": "Path=", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If you know list comprehensions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lines = [line[5:] for line in file.readlines() if line[:5] == \"Path=\"]\n</code>\n</pre>\n", "senID": 1}]]