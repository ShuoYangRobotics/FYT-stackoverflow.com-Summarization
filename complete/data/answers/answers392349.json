[[{"text": ["I don't think there is any way to do that in Python.", "When the closure is defined, the current state of variables in the enclosing scope is captured and no longer has a directly referenceable name (from outside the closure).", "If you were to call foo() again, the new closure would have a different set of variables from the enclosing scope."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "foo()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["In your simple example, you might be better off using a class:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class foo:\n        def __init__(self):\n                self.var_a = 2\n                self.var_b = 3\n\n        def __call__(self, x):\n                return self.var_a + self.var_b + x\n\nlocalClosure = foo()\n\n# Local closure is now \"return 2 + 3 + x\"\na = localClosure(1) # 2 + 3 + 1 == 6\n\n# DO SOME MAGIC HERE TO TURN \"var_a\" of the closure into 0\n# ...but what magic? Is this even possible?\nlocalClosure.var_a = 0\n\n# Local closure is now \"return 0 + 3 + x\"\nb = localClosure(1) # 0 + 3 +1 == 4\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you do use this technique I would no longer use the name localClosure because it is no longer actually a closure.", "However, it works the same as one."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "localClosure", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I've found an alternate answer answer to Greg's, slightly less verbose because it uses Python 2.1's custom function attributes (which conveniently enough can be accessed from inside their own function)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n\tvar_b = 3\n\n\tdef _closure(x):\n\t\treturn _closure.var_a + var_b + x\n\n\t_closure.func_dict['var_a'] = 2\n\treturn _closure\n\n\nlocalClosure = foo()\n\n# Local closure is now \"return 2 + 3 + x\"\na = localClosure(1) # 2 + 3 + 1 == 6\n\n# DO SOME MAGIC HERE TO TURN \"var_a\" of the closure into 0\n# ...but what magic? Is this even possible?\n# apparently, it is\nlocalClosure.var_a = 0\n\n# Local closure is now \"return 0 + 3 + x\"\nb = localClosure(1) # 0 + 3 +1 == 4\n</code>\n</pre>\n", "senID": 1}, {"text": ["Thought I'd post it for completeness.", "Cheers anyways."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It is quite possible in python 3 thanks to the magic of nonlocal."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "nonlocal", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://jeremyhylton.blogspot.com/2007/02/nonlocal-implemented.html"}]}, {"code": "<pre>\n<code>\n def foo():\n        var_a = 2\n        var_b = 3\n\n        def _closure(x, magic = None):\n                nonlocal var_a\n                if magic is not None:\n                        var_a = magic\n\n                return var_a + var_b + x\n\n        return _closure\n\n\nlocalClosure = foo()\n\n# Local closure is now \"return 2 + 3 + x\"\na = localClosure(1) # 2 + 3 + 1 == 6\nprint(a)\n\n# DO SOME MAGIC HERE TO TURN \"var_a\" of the closure into 0\nlocalClosure(0, 0)\n\n# Local closure is now \"return 0 + 3 + x\"\nb = localClosure(1) # 0 + 3 +1 == 4\nprint(b)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["We've done the following.", "I think it's simpler than other solutions here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class State:\n    pass\n\ndef foo():\n    st = State()\n    st.var_a = 2\n    st.var_b = 3\n\n    def _closure(x):\n        return st.var_a + st.var_b + x\n    def _set_a(a):\n        st.var_a = a\n\n    return _closure, _set_a\n\n\nlocalClosure, localSetA = foo()\n\n# Local closure is now \"return 2 + 3 + x\"\na = localClosure(1) # 2 + 3 + 1 == 6\n\n# DO SOME MAGIC HERE TO TURN \"var_a\" of the closure into 0\nlocalSetA(0)\n\n# Local closure is now \"return 0 + 3 + x\"\nb = localClosure(1) # 0 + 3 +1 == 4\n\nprint a, b\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I worked around a similar limitation by using one-item lists instead of a plain variable.", "It's ugly but it works because modifying a list item doesn't get treated as a binding operation by the interpreter. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def my_function()\n    max_value = [0]\n\n    def callback (data)\n\n        if (data.val &gt; max_value[0]):\n            max_value[0] = data.val\n\n        # more code here\n        # . . . \n\n    results = some_function (callback)\n\n    store_max (max_value[0])\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Why not make var_a and var_b arguments of the function foo?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(var_a = 2, var_b = 3):\n    def _closure(x):\n        return var_a + var_b + x\n    return _closure\n\nlocalClosure = foo() # uses default arguments 2, 3\nprint localClosure(1) # 2 + 3 + 1 = 6\n\nlocalClosure = foo(0, 3)\nprint localClosure(1) # 0 + 3 + 1 = 4\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def foo():\n    var_a = 2\n    var_b = 3\n\n    def _closure(x):\n            return var_a + var_b + x\n\n    return _closure\n\ndef bar():\n        var_a = [2]\n        var_b = [3]\n\n        def _closure(x):\n                return var_a[0] + var_b[0] + x\n\n\n        def _magic(y):\n            var_a[0] = y\n\n        return _closure, _magic\n\nlocalClosureFoo = foo()\na = localClosureFoo(1)\nprint a\n\n\n\nlocalClosureBar, localClosureBarMAGIC = bar()\nb = localClosureBar(1)\nprint b\nlocalClosureBarMAGIC(0)\nb = localClosureBar(1)\nprint b\n</code>\n</pre>\n", "senID": 0}]]