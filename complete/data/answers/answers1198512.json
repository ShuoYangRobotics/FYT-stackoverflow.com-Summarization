[[{"text": ["This is the simplest and most pythonic solution I can think of:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def partition(alist, indices):\n    return [alist[i:j] for i, j in zip([0]+indices, indices+[None])]\n</code>\n</pre>\n", "senID": 1}, {"text": ["if the inputs are very large, then the iterators solution should be more convenient:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip, chain\ndef partition(alist, indices):\n    pairs = izip(chain([0], indices), chain(indices, [None]))\n    return (alist[i:j] for i, j in pairs)\n</code>\n</pre>\n", "senID": 3}, {"text": ["and of course, the very, very lazy guy solution (if you don't mind to get arrays instead of lists, but anyway you can always revert them to lists):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import numpy\npartition = numpy.split\n</code>\n</pre>\n", "senID": 5}], [{"text": ["My solution is similar to Il-Bhima's."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def parts(list_, indices):\n...     indices = [0]+indices+[len(list_)]\n...     return [list_[v:indices[k+1]] for k, v in enumerate(indices[:-1])]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Alternative approach"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"text": ["If you're willing to slightly change the way you input indices, from absolute indices to relative (that is, from [5, 12, 17] to [5, 7, 5], the below will also give you the desired output, while it doesn't create intermediary lists."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "[5, 12, 17]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[5, 7, 5]", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import islice\n&gt;&gt;&gt; def parts(list_, indices):\n...     i = iter(list_)\n...     return [list(islice(i, n)) for n in chain(indices, [None])]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I would be interested in seeing a more Pythonic way of doing this also.", "But this is a crappy solution.", "You would need to add checking for an empry index list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Something along the lines of:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n indexes = [5, 12, 17]\nlist = range(20)\n\noutput = []\nprev = 0\n\nfor index in indexes:\n    output.append(list[prev:index])\n    prev = index\n\noutput.append(list[indexes[-1]:])\n\nprint output\n</code>\n</pre>\n", "senID": 2}, {"text": ["produces"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16], [17, 18, 19]]\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; def burst_seq(seq, indices):\n...    startpos = 0\n...    for index in indices:\n...       yield seq[startpos:index]\n...       startpos = index\n...    yield seq[startpos:]\n...\n&gt;&gt;&gt; list(burst_seq(range(20), [5, 12, 17]))\n[[0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16], [17, 18, 19]]\n&gt;&gt;&gt; list(burst_seq(range(20), []))\n[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]\n&gt;&gt;&gt; list(burst_seq(range(0), [5, 12, 17]))\n[[], [], [], []]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}, {"text": ["Maxima mea culpa: it uses a for statement, and it's not using whizzbang stuff like itertools, zip(), None as a sentinel, list comprehensions, ... "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": [";-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is all that I could think of"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def partition(list_, indexes):\n    if indexes[0] != 0:\n    \tindexes = [0] + indexes\n    if indexes[-1] != len(list_):\n    \tindexes = indexes + [len(list_)]\n    return [ list_[a:b] for (a,b) in zip(indexes[:-1], indexes[1:])]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Cide's makes three copies of the array: [0]+indices copies, ([0]+indices)+[] copies again, and indices[:-1] will copy a third time.", "Il-Bhima makes five copies.", "(I'm not counting the return value, of course."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Those could be reduced (izip, islice), but here's a zero-copy version:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def iterate_pairs(lst, indexes):\n    prev = 0\n    for i in indexes:\n        yield prev, i\n        prev = i\n    yield prev, len(lst)\n\ndef partition(lst, indexes):\n    for first, last in iterate_pairs(lst, indexes):\n        yield lst[first:last]\n\nindexes = [5, 12, 17]\nlst = range(20)\n\nprint [l for l in partition(lst, indexes)]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Of course, array copies are fairly cheap (native code) compared to interpreted Python, but this has another advantage: it's easy to reuse, to mutate the data directly:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for first, last in iterate_pairs(lst, indexes):\n    for i in range(first, last):\n        lst[i] = first\nprint lst\n# [0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 12, 12, 12, 12, 12, 17, 17, 17]\n</code>\n</pre>\n", "senID": 4}, {"text": ["(That's why I passed indexes to iterate_pairs.", "If you don't care about that, you can remove that parameter and just have the final line be \"yield prev, None\", which is all partition() needs."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n indices = [5, 12, 17]\ninput = range(20)\noutput = []\n\nreduce(lambda x, y: output.append(input[x:y]) or y, indices + [len(input)], 0)\nprint output\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here's yet another answer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def partition(l, indexes):\n    result, indexes = [], indexes+[len(l)]\n    reduce(lambda x, y: result.append(l[x:y]) or y, indexes, 0)\n    return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["It supports negative indexes and such."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; partition([1,2,3,4,5], [1, -1])\n[[1], [2, 3, 4], [5]]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The plural of index is indices.", "Going for simplicity/readability."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n indices = [5, 12, 17]\ninput = range(20)\noutput = []\n\nfor i in reversed(indices):\n    output.append(input[i:])\n    input[i:] = []\noutput.append(input)\n\nwhile len(output):\n    print output.pop()\n</code>\n</pre>\n", "senID": 1}]]