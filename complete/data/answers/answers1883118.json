[[{"text": ["'Universal newline support' (as descrived in PEP278) can come in handy for portability reasons.", "It makes sure python code only gets \\n:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "'Universal newline support'", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://polyphrase.blogspot.com/2008/09/do-you-know-universal-newline-support.html"}, {"text": "PEP278", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0278/"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n christophe@orion:~$ printf 'testing pep278\\r\\n' &gt; test.txt\nchristophe@orion:~$ python\nPython 2.6.2 (release26-maint, Apr 19 2009, 01:56:41) \n[GCC 4.3.3] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; open('test.txt').read()\n'testing pep278\\r\\n'\n&gt;&gt;&gt; open('test.txt','U').read()\n'testing pep278\\n'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Getting away from the syntax side of things, I think the biggest thing to watch out for is that typically when people think of python, they might not think of all the libraries it is composed of. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Many python packages depend on C libraries which may or may not be cross platform compatible.", "In addition, Python runs under Java through Jython, and .Net through IronPython.", "Unless libraries are written in pure python, they will not, in many cases, work on anything other than the C based version of python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you deal with binary file formats in Python, note that the struct and array modules uses machine dependent size and endianness.", "struct can be used portably by always using &lt; or &gt; in the format string.", "array can't.", "It will probably be portable for arrays of bytes, but the documentation makes no such guarantee."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "array", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "struct", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "&lt;", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "&gt;", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "array", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["Some modules are not cross-platform.", "Two that come to mind are both curses (Linux) and msvcrt (Windows).", "The fix to this simple problem is simply not to use them but find an alternative instead."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "curses", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "msvcrt", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I'll start off:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Windows uses backslashes for path separators --> '\\'"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Unix uses forward slashes for path separators --> '/'"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The os module comes with os.sep, which contains the path separator for the current platform that the script is being run on.", "Use os.sep instead of forward or back slashes.", "os.path.join will join two or more path components this way."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "os.sep", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.sep", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "os.path.join", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["There are subtle differences in UCS2  and UCS4 (Windows and Linux, for example) builds of Python due to bugs, conflicting or deprecated standards, etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["unicodetest.py:   "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "unicodetest.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bugs.python.org/file10880/unicodetest.py"}]}, {"code": "<pre>\n<code>\n #-*- coding: utf-8 -*-\nprint 'Result:', u'&#65827;' == u'\\U00010123'\nprint 'Len:', len(u'&#65827;'), len(u'\\U00010123')\nprint 'Repr:', repr(u'&#65827;'), repr(u'\\U00010123')\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output (Python 2.6, Linux):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Result: False\nLen: 2 1\nRepr: u'\\ud800\\udd23' u'\\U00010123'\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Unix vs. Windows:  Using Popen in the subprocess module will exhibit different behavior when shell=True.", "I won't offer a fix because the discussion is covered so well here, but it's one of those areas that can unexpectedly bite you."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "Popen", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "subprocess", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "shell=True", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1253122/why-does-subprocess-popen-with-shelltrue-work-differently-on-linux-vs-windows"}]}]]