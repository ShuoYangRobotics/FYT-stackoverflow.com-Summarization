[[{"text": ["You've perhaps got a memory leak bounded by some resource limit (RLIMIT_DATA, RLIMIT_AS?", ") inherited by your python script.", "Check your ulimit(1)s before you run your script, and profile the script's memory usage, as others have suggested."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "resource limit", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.opengroup.org/onlinepubs/9699919799/functions/getrlimit.html"}, {"text": "RLIMIT_DATA", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "RLIMIT_AS", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ulimit(1)", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["What do you do with the variablepsafter the code snippet you show us?", "Do you keep a reference to it, never to be freed?", "Quoting the subprocessmodule docs:"], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "What do you do with the variablepsafter the code snippet you show us?", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "ps", "tag": "code"}]}, {"text": "ps", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "subprocessmodule docs", "tag": "a", "pos": 2, "childList": [{"text": "subprocess", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/subprocess.html#subprocess.Popen.communicate"}, {"text": "subprocess", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["... and ps aux can be verbose on a busy system..."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "ps aux", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Update"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You can check rlimits from with your python script using the resource module:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "resource", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/resource.html#resource.getrlimit"}]}, {"code": "<pre>\n<code>\n import resource\nprint resource.getrlimit(resource.RLIMIT_DATA) # =&gt; (soft_lim, hard_lim)\nprint resource.getrlimit(resource.RLIMIT_AS)\n</code>\n</pre>\n", "senID": 5}, {"text": ["If these return \"unlimited\" -- (-1, -1) -- then my hypothesis is incorrect and you may move on!"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "(-1, -1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See also resource.getrusage, esp.", "the ru_?", "?rss fields, which can help you to instrument for memory consumption from with the python script, without shelling out to an external program."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "resource.getrusage", "tag": "a", "pos": 0, "childList": [{"text": "resource.getrusage", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/resource.html#resource.getrusage"}, {"text": "resource.getrusage", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ru_??rss", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["That swap space answer is bogus.", "Historically Unix systems wanted swap space available like that, but they don't work that way anymore (and Linux never worked that way).", "You're not even close to running out of memory, so that's not likely the actual problem - you're running out of some other limited resource."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Given where the error is occuring (_get_handles calls os.pipe() to create pipes to the child), the only real problem you could be running into is not enough free file descriptors.", "I would instead look for unclosed files (lsof -p on the PID of the process doing the popen).", "If your program really needs to keep a lot of files open at one time, then increase the user limit and/or the system limit for open file descriptors."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You might want to actually wait for all of those PS processes to finish before adding swap space."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's not at all clear what \"running as a background process executing every 60 seconds\" means."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["But your call to subprocess.Popen is forking a new process each time. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Update."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I'd guess that you're somehow leaving all those processes running or hung in a zombie state.", "However, the communicate method should clean up the spawned subprocesses."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "communicate", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "should", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["If you're running a background process, chances are that you've redirected your processes stdin/stdout/stderr."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In that case, append the option \"close_fds=True\" to your Popen call, which will prevent the child process from inheriting your redirected output.", "This may be the limit you're bumping into."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I don't think that the circumstances given in the Zenoss article you linked to is the only cause of this message, so it's not clear yet that swap space is definitely the problem.", "I would advise logging some more information even around successful calls, so that you can see the state of free memory every time just before you do the ps call."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ps", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["One more thing - if you specify shell=True in the Popen call, do you see different behaviour?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "shell=True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Update: If not memory, the next possible culprit is indeed file handles.", "I would advise running the failing command under strace to see exactly which system calls are failing."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "strace", "tag": "a", "pos": 1, "childList": [{"text": "strace", "tag": "code"}], "childNum": 1, "href": "http://en.wikipedia.org/wiki/Strace"}, {"text": "strace", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Have you watched your process over time? "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "lsof ", "tag": "none", "senID": 1}, {"text": "ps -aux | grep -i pname ", "tag": "none", "senID": 2}, {"text": "top", "tag": "none", "senID": 3}]}, {"text": ["All should give interesting information.", "I am thinking that the process is tying up resources that should be freed up.", "Is there a chance that it is tying up resource handles (memory blocks, streams, file handles, thread or process handles)?", "stdin, stdout, stderr from the spawned \"ps\".", "Memory handles, ... from many small incremental allocations.", "I would be very interested in seeing what the above commands display for your process when it has just finished launching and running for the first time and after 24 hours of \"sitting\" there launching the sub-process regularly."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Since it dies after a few days, you could have it run for only a few loops, and then restart it once a day as a workaround.", "That would help you in the meantime."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Jacob"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["You need to"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ps = subprocess.Popen([\"sleep\", \"1000\"])\nos.waitpid(ps.pid, 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["to free resources."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note: this does not work on Windows."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["when you use popen you need to hand in close_fds=True if you want it to close extra file descriptors.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["creating a new pipe, which occurs in the _get_handles function from the back trace, creates 2 file descriptors, but your current code never closes them and your eventually hitting your systems max fd limit.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Not sure why the error your getting is indicating an out of memory condition, it should be a file descriptor error as the return value of pipe() has an error code for this problem."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]