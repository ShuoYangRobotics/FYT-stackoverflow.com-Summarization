[[{"text": ["This tries to be a little more race-free than the other solutions.", "(The with keyword is new in Python 2.5."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "with", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import os\ndef touch(fname, times = None):\n    with file(fname, 'a'):\n        os.utime(fname, times)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Roughly equivalent to this."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import os\ndef touch(fname, times = None):\n    fhandle = file(fname, 'a')\n    try:\n        os.utime(fname, times)\n    finally:\n        fhandle.close()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now, to really make it race-free, you need to use futimes and change the timestamp of the open filehandle, instead of opening the file and then changing the timestamp on the filename (which may have been renamed).", "Unfortunately, Python doesn't seem to provide a way to call futimes without going through ctypes or similar..."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "futimes", "tag": "a", "pos": 0, "childList": [{"text": "futimes", "tag": "code"}], "childNum": 1, "href": "http://www.kernel.org/doc/man-pages/online/pages/man3/lutimes.3.html"}, {"text": "futimes", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "futimes", "childNum": 0, "tag": "code", "childList": []}, {"text": "ctypes", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n def touch(fname):\n    if os.path.exists(fname):\n        os.utime(fname, None)\n    else:\n        open(fname, 'w').close()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here's some code that uses ctypes (only tested on Linux):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from ctypes import *\nlibc = CDLL(\"libc.so.6\")\n\n#  struct timespec {\n#             time_t tv_sec;        /* seconds */\n#             long   tv_nsec;       /* nanoseconds */\n#         };\n# int futimens(int fd, const struct timespec times[2]);\n\nclass c_timespec(Structure):\n    _fields_ = [('tv_sec', c_long), ('tv_nsec', c_long)]\n\nclass c_utimbuf(Structure):\n    _fields_ = [('atime', c_timespec), ('mtime', c_timespec)]\n\nutimens = CFUNCTYPE(c_int, c_char_p, POINTER(c_utimbuf))\nfutimens = CFUNCTYPE(c_int, c_char_p, POINTER(c_utimbuf)) \n\n# from /usr/include/i386-linux-gnu/bits/stat.h\nUTIME_NOW  = ((1l &lt;&lt; 30) - 1l)\nUTIME_OMIT = ((1l &lt;&lt; 30) - 2l)\nnow  = c_timespec(0,UTIME_NOW)\nomit = c_timespec(0,UTIME_OMIT)\n\n# wrappers\ndef update_atime(fileno):\n        assert(isinstance(fileno, int))\n        libc.futimens(fileno, byref(c_utimbuf(now, omit)))\ndef update_mtime(fileno):\n        assert(isinstance(fileno, int))\n        libc.futimens(fileno, byref(c_utimbuf(omit, now)))\n\n# usage example:\n#\n# f = open(\"/tmp/test\")\n# update_mtime(f.fileno())\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Why not try this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def touch(fname):\n    try:\n        os.utime(fname, None)\n    except:\n        open(fname, 'a').close()\n</code>\n</pre>\n", "senID": 1}, {"text": ["I believe this eliminates any race condition that matters.", "If the file does not exist then an exception will be thrown."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The only possible race condition here is if the file is created before open() is called but after os.utime().", "But this does not matter because in this case the modification time will be as expected since it must have happened during the call to touch()."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Simplistic:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def touch(fname):\n    open(fname, 'a').close()\n    os.utime(fname, None)\n</code>\n</pre>\n", "senID": 1}, {"tag": "ul", "num": 2, "lis": [{"text": "The ", "tag": "none", "senID": 2}, {"text": "the ", "tag": "none", "senID": 3}]}, {"text": ["Theoretically, it's possible someone will delete the file after the open, causing utime to raise an exception.", "But arguably that's OK, since something bad did happen."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "open", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Complex (possibly buggy):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def utime(fname, atime=None, mtime=None)\n    if type(atime) is tuple:\n        atime, mtime = atime\n\n    if atime is None or mtime is None:\n        statinfo = os.stat(fname)\n        if atime is None:\n            atime = statinfo.st_atime\n        if mtime is None:\n            mtime = statinfo.st_mtime\n\n    os.utime(fname, (atime, mtime))\n\n\ndef touch(fname, atime=None, mtime=None):\n    if type(atime) is tuple:\n        atime, mtime = atime\n\n    open(fname, 'a').close()\n    utime(fname, atime, mtime)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This tries to also allow setting the access or modification time, like GNU touch."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]