[[{"text": ["There are a couple of small optimizations for your version.", "By reversing the roles of True and False, you can change \"if flags[i] is False:\" to \"if flags[i]:\".", "And the starting value for the second range statement can be i*i instead of i*3.", "Your original version takes 0.166 seconds on my system.", "With those changes, the version below takes 0.156 seconds on my system."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "if flags[i] is False:", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "if flags[i]:", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "i*i", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "i*3", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def prime_numbers(limit=1000000):\n    '''Prime number generator. Yields the series\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ...\n    using Sieve of Eratosthenes.\n    '''\n    yield 2\n    sub_limit = int(limit**0.5)\n    flags = [True, True] + [False] * (limit - 2)\n    # Step through all the odd numbers\n    for i in range(3, limit, 2):\n        if flags[i]:\n            continue\n        yield i\n        # Exclude further multiples of the current prime number\n        if i &lt;= sub_limit:\n            for j in range(i*i, limit, i&lt;&lt;1):\n                flags[j] = True\n</code>\n</pre>\n", "senID": 1}, {"text": ["This doesn't help your memory issue, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Moving into the world of C extensions, I used the development version of gmpy.", "(Disclaimer: I'm one of the maintainers.", ") The development version is called gmpy2 and supports mutable integers called xmpz.", "Using gmpy2 and the following code, I have a running time of 0.140 seconds.", "Running time for a limit of 1,000,000,000 is 158 seconds."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "gmpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/gmpy/"}]}, {"code": "<pre>\n<code>\n import gmpy2\n\ndef prime_numbers(limit=1000000):\n    '''Prime number generator. Yields the series\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ...\n    using Sieve of Eratosthenes.\n    '''\n    yield 2\n    sub_limit = int(limit**0.5)\n    # Actual number is 2*bit_position + 1.\n    oddnums = gmpy2.xmpz(1)\n    current = 0\n    while True:\n        current += 1\n        current = oddnums.bit_scan0(current)\n        prime = 2 * current + 1\n        if prime &gt; limit:\n            break\n        yield prime\n        # Exclude further multiples of the current prime number\n        if prime &lt;= sub_limit:\n            for j in range(2*current*(current+1), limit&gt;&gt;1, prime):\n                oddnums.bit_set(j)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Pushing optimizations, and sacrificing clarity, I get running times of 0.107 and 123 seconds with the following code:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import gmpy2\n\ndef prime_numbers(limit=1000000):\n    '''Prime number generator. Yields the series\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ...\n    using Sieve of Eratosthenes.\n    '''\n    yield 2\n    sub_limit = int(limit**0.5)\n    # Actual number is 2*bit_position + 1.\n    oddnums = gmpy2.xmpz(1)\n    f_set = oddnums.bit_set\n    f_scan0 = oddnums.bit_scan0\n    current = 0\n    while True:\n        current += 1\n        current = f_scan0(current)\n        prime = 2 * current + 1\n        if prime &gt; limit:\n            break\n        yield prime\n        # Exclude further multiples of the current prime number\n        if prime &lt;= sub_limit:\n            list(map(f_set,range(2*current*(current+1), limit&gt;&gt;1, prime)))\n</code>\n</pre>\n", "senID": 6}, {"text": ["Edit: Based on this exercise, I modified gmpy2 to accept xmpz.bit_set(iterator).", "Using the following code, the run time for all primes less 1,000,000,000 is 56 seconds for Python 2.7 and 74 seconds for Python 3.2.", "(As noted in the comments, xrange is faster than range."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "xmpz.bit_set(iterator)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import gmpy2\n\ntry:\n    range = xrange\nexcept NameError:\n    pass\n\ndef prime_numbers(limit=1000000):\n    '''Prime number generator. Yields the series\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ...\n    using Sieve of Eratosthenes.\n    '''\n    yield 2\n    sub_limit = int(limit**0.5)\n    oddnums = gmpy2.xmpz(1)\n    f_scan0 = oddnums.bit_scan0\n    current = 0\n    while True:\n        current += 1\n        current = f_scan0(current)\n        prime = 2 * current + 1\n        if prime &gt; limit:\n            break\n        yield prime\n        if prime &lt;= sub_limit:\n            oddnums.bit_set(iter(range(2*current*(current+1), limit&gt;&gt;1, prime)))\n</code>\n</pre>\n", "senID": 8}, {"text": ["Edit #2: One more try!", "I modified gmpy2 to accept xmpz.bit_set(slice).", "Using the following code, the run time for all primes less 1,000,000,000 is about 40 seconds for both Python 2.7 and Python 3.2."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "xmpz.bit_set(slice)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from __future__ import print_function\nimport time\nimport gmpy2\n\ndef prime_numbers(limit=1000000):\n    '''Prime number generator. Yields the series\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ...\n    using Sieve of Eratosthenes.\n    '''\n    yield 2\n    sub_limit = int(limit**0.5)\n    flags = gmpy2.xmpz(1)\n    # pre-allocate the total length\n    flags.bit_set((limit&gt;&gt;1)+1)\n    f_scan0 = flags.bit_scan0\n    current = 0\n    while True:\n        current += 1\n        current = f_scan0(current)\n        prime = 2 * current + 1\n        if prime &gt; limit:\n            break\n        yield prime\n        if prime &lt;= sub_limit:\n            flags.bit_set(slice(2*current*(current+1), limit&gt;&gt;1, prime))\n\nstart = time.time()\nresult = list(prime_numbers(1000000000))\nprint(time.time() - start)\n</code>\n</pre>\n", "senID": 10}, {"text": ["Edit #3: I've updated gmpy2 to properly support slicing at the bit level of an xmpz.", "No change in performance but a much nice API.", "I have done a little tweaking and I've got the time down to about 37 seconds. "], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import print_function\nimport time\nimport gmpy2\n\ndef prime_numbers(limit=1000000):\n    '''Prime number generator. Yields the series\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ...\n    using Sieve of Eratosthenes.\n    '''\n    sub_limit = int(limit**0.5)\n    flags = gmpy2.xmpz(1)\n    flags[(limit&gt;&gt;1)+1] = True\n    f_scan0 = flags.bit_scan0\n    current = 0\n    prime = 2\n    while prime &lt;= sub_limit:\n        yield prime\n        current += 1\n        current = f_scan0(current)\n        prime = 2 * current + 1\n        flags[2*current*(current+1):limit&gt;&gt;1:prime] = True\n    while prime &lt;= limit:\n        yield prime\n        current += 1\n        current = f_scan0(current)\n        prime = 2 * current + 1\n\nstart = time.time()\nresult = list(prime_numbers(1000000000))\nprint(time.time() - start)\n</code>\n</pre>\n", "senID": 12}], [{"text": ["OK, so this is my second answer, but as speed is of the essence I thought that I had to mention the bitarray module - even though it's bitstring's nemesis :).", "It's ideally suited to this case as not only is it a C extension (and so faster than pure Python has a hope of being), but it also supports slice assignments.", "It's not yet available for Python 3 though."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "bitarray", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/bitarray/"}, {"text": "bitstring", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://python-bitstring.googlecode.com"}]}, {"text": ["I haven't even tried to optimise this, I just rewrote the bitstring version.", "On my machine I get 0.16 seconds for primes under a million."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For a billion, it runs perfectly well and completes in 2 minutes 31 seconds."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import bitarray\n\ndef prime_bitarray(limit=1000000):\n    yield 2\n    flags = bitarray.bitarray(limit)\n    flags.setall(False)\n    sub_limit = int(limit**0.5)\n    for i in xrange(3, limit, 2):\n        if not flags[i]:\n            yield i\n            if i &lt;= sub_limit:\n                flags[3*i:limit:i*2] = True\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Okay, here's a (near complete) comprehensive benchmarking I've done tonight to see which code runs the fastest.", "Hopefully someone will find this list useful.", "I omitted anything that takes more than 30 seconds to complete on my machine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would like to thank everyone that put in an input.", "I've gained a lot of insight from your efforts, and I hope you have too."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["My machine: AMD ZM-86, 2.40 Ghz Dual-Core, with 4GB of RAM.", "This is a HP Touchsmart Tx2 laptop.", "Note that while I may have linked to a pastebin, I benchmarked all of the following on my own machine."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "I benchmarked all of the following on my own machine.", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["I will add the gmpy2 benchmark once I am able to build it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["All of the benchmarks are tested in Python 2.6 x86"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Related question.", "Fastest way to list all primes below N in python "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "Fastest way to list all primes below N in python", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python"}]}, {"text": ["Hi, i am  too looking for a code in python to generate primes up to 10*9 as fast as i can,  which is difficult because of the memory problem.", "up to now i came up with this to generate primes up to 10*6 &amp; 10*7 (0,171s &amp; 1,764s respectively in my old machine), which seems to be slightly faster(at least in my computer) than \"My improved version with slicing\" from previous post,probably because i use n//i-i +1 (see below)instead of the analogous len(flags[i2::i&lt;&lt;1]) in the other code.", "please correct me if i am wrong.", "Any suggestion for improvement are very welcome."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "9 as fast as i can,  which is difficult because of the memory problem. up to now i came up with this to generate primes up to 10", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def primes(n):\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * n\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)\n    return [2] + [i for i in xrange(3,n,2) if sieve[i]]\n</code>\n</pre>\n", "senID": 2}, {"text": ["In one of his codes Xavier uses flags[i2::i&lt;&lt;1] and len(flags[i2::i&lt;&lt;1]), i computed the size explicit using the fact that between i*i..n we have (n-i*i)//2*i multiples of 2*i because we want to count i*i also we sum 1 so len(sieve[i*i::2*i]) equal (n-i*i)//(2*i) +1 This make the code faster.", "A basic generator based on the code above would be:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def primesgen(n):\n    \"\"\" Generates all primes &lt;= n \"\"\"\n    sieve = [True] * n\n    yield 2\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            yield i\n            sieve[i*i::2*i] = [False]*((n-i*i-1)/(2*i)+1)\n    for i in xrange(i+2,n,2):\n        if sieve[i]: yield i\n</code>\n</pre>\n", "senID": 4}, {"text": ["with a bit of modification one can write a slightly slower version of the code above that start with a sieve half of the size sieve = [True] * (n//2) and works for the same n. not sure how that you reflect in the memory issue.", "As an example of implementation here is the\nmodified version of the numpy rosetta code (maybe faster) starting with a sieve half of the size."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import numpy\ndef primesfrom3to(n):\n    \"\"\" Returns a array of primes, 3 &lt;= p &lt; n \"\"\"\n    sieve = numpy.ones(n/2, dtype=numpy.bool)\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i/2]: sieve[i*i/2::i] = False\n    return 2*numpy.nonzero(sieve)[0][1::]+1\n</code>\n</pre>\n", "senID": 6}, {"text": ["A Faster &amp; more memory-wise generator would be:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import numpy\ndef primesgen1(n):\n\"\"\" Input n&gt;=6, Generates all primes &lt; n \"\"\"\nsieve1 = numpy.ones(n/6+1, dtype=numpy.bool)\nsieve5 = numpy.ones(n/6  , dtype=numpy.bool)\nsieve1[0] = False\nyield 2; yield 3;\nfor i in xrange(int(n**0.5)/6+1):\n    if sieve1[i]:\n        k=6*i+1; yield k;\n        sieve1[ ((k*k)/6) ::k] = False\n        sieve5[(k*k+4*k)/6::k] = False\n    if sieve5[i]:\n        k=6*i+5; yield k;\n        sieve1[ ((k*k)/6) ::k] = False\n        sieve5[(k*k+2*k)/6::k] = False\nfor i in xrange(i+1,n/6):\n        if sieve1[i]: yield 6*i+1\n        if sieve5[i]: yield 6*i+5\nif n%6 &gt; 1:\n    if sieve1[i+1]: yield 6*(i+1)+1\n</code>\n</pre>\n", "senID": 8}, {"text": ["or with a bit more code:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n import numpy\ndef primesgen(n):\n    \"\"\" Input n&gt;=30, Generates all primes &lt; n \"\"\"\n    size = n/30 + 1\n    sieve01 = numpy.ones(size, dtype=numpy.bool)\n    sieve07 = numpy.ones(size, dtype=numpy.bool)\n    sieve11 = numpy.ones(size, dtype=numpy.bool)\n    sieve13 = numpy.ones(size, dtype=numpy.bool)\n    sieve17 = numpy.ones(size, dtype=numpy.bool)\n    sieve19 = numpy.ones(size, dtype=numpy.bool)\n    sieve23 = numpy.ones(size, dtype=numpy.bool)\n    sieve29 = numpy.ones(size, dtype=numpy.bool)\n    sieve01[0] = False\n    yield 2; yield 3; yield 5;\n    for i in xrange(int(n**0.5)/30+1):\n        if sieve01[i]:\n            k=30*i+1; yield k;\n            sieve01[     (k*k)/30::k] = False\n            sieve07[(k*k+ 6*k)/30::k] = False\n            sieve11[(k*k+10*k)/30::k] = False\n            sieve13[(k*k+12*k)/30::k] = False\n            sieve17[(k*k+16*k)/30::k] = False\n            sieve19[(k*k+18*k)/30::k] = False\n            sieve23[(k*k+22*k)/30::k] = False\n            sieve29[(k*k+28*k)/30::k] = False\n        if sieve07[i]:\n            k=30*i+7; yield k;\n            sieve01[(k*k+ 6*k)/30::k] = False\n            sieve07[(k*k+24*k)/30::k] = False\n            sieve11[(k*k+16*k)/30::k] = False\n            sieve13[(k*k+12*k)/30::k] = False\n            sieve17[(k*k+ 4*k)/30::k] = False\n            sieve19[     (k*k)/30::k] = False\n            sieve23[(k*k+22*k)/30::k] = False\n            sieve29[(k*k+10*k)/30::k] = False\n        if sieve11[i]:\n            k=30*i+11; yield k;\n            sieve01[     (k*k)/30::k] = False\n            sieve07[(k*k+ 6*k)/30::k] = False\n            sieve11[(k*k+20*k)/30::k] = False\n            sieve13[(k*k+12*k)/30::k] = False\n            sieve17[(k*k+26*k)/30::k] = False\n            sieve19[(k*k+18*k)/30::k] = False\n            sieve23[(k*k+ 2*k)/30::k] = False\n            sieve29[(k*k+ 8*k)/30::k] = False\n        if sieve13[i]:\n            k=30*i+13; yield k;\n            sieve01[(k*k+24*k)/30::k] = False\n            sieve07[(k*k+ 6*k)/30::k] = False\n            sieve11[(k*k+ 4*k)/30::k] = False\n            sieve13[(k*k+18*k)/30::k] = False\n            sieve17[(k*k+16*k)/30::k] = False\n            sieve19[     (k*k)/30::k] = False\n            sieve23[(k*k+28*k)/30::k] = False\n            sieve29[(k*k+10*k)/30::k] = False\n        if sieve17[i]:\n            k=30*i+17; yield k;\n            sieve01[(k*k+ 6*k)/30::k] = False\n            sieve07[(k*k+24*k)/30::k] = False\n            sieve11[(k*k+26*k)/30::k] = False\n            sieve13[(k*k+12*k)/30::k] = False\n            sieve17[(k*k+14*k)/30::k] = False\n            sieve19[     (k*k)/30::k] = False\n            sieve23[(k*k+ 2*k)/30::k] = False\n            sieve29[(k*k+20*k)/30::k] = False\n        if sieve19[i]:\n            k=30*i+19; yield k;\n            sieve01[     (k*k)/30::k] = False\n            sieve07[(k*k+24*k)/30::k] = False\n            sieve11[(k*k+10*k)/30::k] = False\n            sieve13[(k*k+18*k)/30::k] = False\n            sieve17[(k*k+ 4*k)/30::k] = False\n            sieve19[(k*k+12*k)/30::k] = False\n            sieve23[(k*k+28*k)/30::k] = False\n            sieve29[(k*k+22*k)/30::k] = False\n        if sieve23[i]:\n            k=30*i+23; yield k;\n            sieve01[(k*k+24*k)/30::k] = False\n            sieve07[(k*k+ 6*k)/30::k] = False\n            sieve11[(k*k+14*k)/30::k] = False\n            sieve13[(k*k+18*k)/30::k] = False\n            sieve17[(k*k+26*k)/30::k] = False\n            sieve19[     (k*k)/30::k] = False\n            sieve23[(k*k+ 8*k)/30::k] = False\n            sieve29[(k*k+20*k)/30::k] = False\n        if sieve29[i]:\n            k=30*i+29; yield k;\n            sieve01[     (k*k)/30::k] = False\n            sieve07[(k*k+24*k)/30::k] = False\n            sieve11[(k*k+20*k)/30::k] = False\n            sieve13[(k*k+18*k)/30::k] = False\n            sieve17[(k*k+14*k)/30::k] = False\n            sieve19[(k*k+12*k)/30::k] = False\n            sieve23[(k*k+ 8*k)/30::k] = False\n            sieve29[(k*k+ 2*k)/30::k] = False\n    for i in xrange(i+1,n/30):\n            if sieve01[i]: yield 30*i+1\n            if sieve07[i]: yield 30*i+7\n            if sieve11[i]: yield 30*i+11\n            if sieve13[i]: yield 30*i+13\n            if sieve17[i]: yield 30*i+17\n            if sieve19[i]: yield 30*i+19\n            if sieve23[i]: yield 30*i+23\n            if sieve29[i]: yield 30*i+29\n    i += 1\n    mod30 = n%30\n    if mod30 &gt; 1:\n        if sieve01[i]: yield 30*i+1\n    if mod30 &gt; 7:\n        if sieve07[i]: yield 30*i+7\n    if mod30 &gt; 11:\n        if sieve11[i]: yield 30*i+11\n    if mod30 &gt; 13:\n        if sieve13[i]: yield 30*i+13\n    if mod30 &gt; 17:\n        if sieve17[i]: yield 30*i+17\n    if mod30 &gt; 19:\n        if sieve19[i]: yield 30*i+19\n    if mod30 &gt; 23:\n        if sieve23[i]: yield 30*i+23\n</code>\n</pre>\n", "senID": 10}, {"text": ["Ps: If you have any suggestions about how to speed up this code, anything from change order of operations to pre-computing anything, please comment."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["One speed improvement you can make using bitstring is to use the 'set' method when you exclude multiples of the current number."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So the vital section becomes"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for i in range(3, limit, 2):\n    if flags[i]:\n        yield i\n        if i &lt;= sub_limit:\n            flags.set(1, range(i*3, limit, i*2))\n</code>\n</pre>\n", "senID": 2}, {"text": ["On my machine this runs about 3 times faster than the original."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["My other thought was to use the bitstring to represent only the odd numbers.", "You could then find the unset bits using flags.findall([0]) which returns a generator.", "Not sure if that would be much faster (finding bit patterns isn't terribly easy to do efficiently)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "flags.findall([0])", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["[Full disclosure: I wrote the bitstring module, so I've got some pride at stake here!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["As a comparison I've also taken the guts out of the bitstring method so that it's doing it in the same way, but without range checking etc.", "I think this gives a reasonable lower limit for pure Python that works for a billion elements (without changing the algorithm, which I think is cheating!"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def prime_pure(limit=1000000):\n    yield 2\n    flags = bytearray((limit + 7) // 8)\n    sub_limit = int(limit**0.5)\n    for i in xrange(3, limit, 2):\n        byte, bit = divmod(i, 8)\n        if not flags[byte] &amp; (128 &gt;&gt; bit):\n            yield i\n            if i &lt;= sub_limit:\n                for j in xrange(i*3, limit, i*2):\n                    byte, bit = divmod(j, 8)\n                    flags[byte] |= (128 &gt;&gt; bit)\n</code>\n</pre>\n", "senID": 7}, {"text": ["On my machine this runs in about 0.62 seconds for a million elements, which means it's about a quarter of the speed of the bitarray answer.", "I think that's quite reasonable for pure Python. "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Here's a version that I wrote a while back;  it might be interesting to compare with yours for speed.", "It doesn't do anything about the space problems, though (in fact, they're probably worse than with your version)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from math import sqrt\n\ndef basicSieve(n):\n    \"\"\"Given a positive integer n, generate the primes &lt; n.\"\"\"\n    s = [1]*n\n    for p in xrange(2, 1+int(sqrt(n-1))):\n        if s[p]:\n            a = p*p\n            s[a::p] = [0] * -((a-n)//p)\n    for p in xrange(2, n):\n        if s[p]:\n            yield p\n</code>\n</pre>\n", "senID": 1}, {"text": ["I have faster versions, using a wheel, but they're much more complicated.", "Original source is here."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2008-November/567609.html"}]}, {"text": ["Okay, here's the version using a wheel.", "wheelSieve is the main entry point."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "wheelSieve", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from math import sqrt\nfrom bisect import bisect_left\n\ndef basicSieve(n):\n    \"\"\"Given a positive integer n, generate the primes &lt; n.\"\"\"\n    s = [1]*n\n    for p in xrange(2, 1+int(sqrt(n-1))):\n        if s[p]:\n            a = p*p\n            s[a::p] = [0] * -((a-n)//p)\n    for p in xrange(2, n):\n        if s[p]:\n            yield p\n\nclass Wheel(object):\n    \"\"\"Class representing a wheel.\n\n    Attributes:\n       primelimit -&gt; wheel covers primes &lt; primelimit.\n       For example, given a primelimit of 6\n       the wheel primes are 2, 3, and 5.\n       primes -&gt; list of primes less than primelimit\n       size -&gt; product of the primes in primes;  the modulus of the wheel\n       units -&gt; list of units modulo size\n       phi -&gt; number of units\n\n    \"\"\"\n    def __init__(self, primelimit):\n        self.primelimit = primelimit\n        self.primes = list(basicSieve(primelimit))\n\n        # compute the size of the wheel\n        size = 1\n        for p in self.primes:\n            size *= p\n        self.size = size\n\n        # find the units by sieving\n        units = [1] * self.size\n        for p in self.primes:\n            units[::p] = [0]*(self.size//p)\n        self.units = [i for i in xrange(self.size) if units[i]]\n\n        # number of units\n        self.phi = len(self.units)\n\n    def to_index(self, n):\n        \"\"\"Compute alpha(n), where alpha is an order preserving map\n        from the set of units modulo self.size to the nonnegative integers.\n\n        If n is not a unit, the index of the first unit greater than n\n        is given.\"\"\"\n        return bisect_left(self.units, n % self.size) + n // self.size * self.phi\n\n    def from_index(self, i):\n        \"\"\"Inverse of to_index.\"\"\"\n\n        return self.units[i % self.phi] + i // self.phi * self.size\n\ndef wheelSieveInner(n, wheel):\n    \"\"\"Given a positive integer n and a wheel, find the wheel indices of\n    all primes that are less than n, and that are units modulo the\n    wheel modulus.\n    \"\"\"\n\n    # renaming to avoid the overhead of attribute lookups\n    U = wheel.units\n    wS = wheel.size\n    # inverse of unit map\n    UI = dict((u, i) for i, u in enumerate(U))\n    nU = len(wheel.units)\n\n    sqroot = 1+int(sqrt(n-1)) # ceiling of square root of n\n\n    # corresponding index (index of next unit up)\n    sqrti = bisect_left(U, sqroot % wS) + sqroot//wS*nU\n    upper = bisect_left(U, n % wS) + n//wS*nU\n    ind2 = bisect_left(U, 2 % wS) + 2//wS*nU\n\n    s = [1]*upper\n    for i in xrange(ind2, sqrti):\n        if s[i]:\n            q = i//nU\n            u = U[i%nU]\n            p = q*wS+u\n            u2 = u*u\n            aq, au = (p+u)*q+u2//wS, u2%wS\n            wp = p * nU\n            for v in U:\n                # eliminate entries corresponding to integers\n                # congruent to p*v modulo p*wS\n                uvr = u*v%wS\n                m = aq + (au &gt; uvr)\n                bot = (m + (q*v + u*v//wS - m) % p) * nU + UI[uvr]\n                s[bot::wp] = [0]*-((bot-upper)//wp)\n    return s\n\ndef wheelSieve(n, wheel=Wheel(10)):\n    \"\"\"Given a positive integer n, generate the list of primes &lt;= n.\"\"\"\n    n += 1\n    wS = wheel.size\n    U = wheel.units\n    nU = len(wheel.units)\n    s = wheelSieveInner(n, wheel)\n    return (wheel.primes[:bisect_left(wheel.primes, n)] +\n            [p//nU*wS + U[p%nU] for p in xrange(bisect_left(U, 2 % wS)\n             + 2//wS*nU, len(s)) if s[p]])\n</code>\n</pre>\n", "senID": 4}, {"text": ["As to what a wheel is:  well, you know that (apart from 2), all primes are odd, so most sieves miss out all the even numbers.", "Similarly, you can go a bit further and notice that all primes (except 2 and 3) are congruent to 1 or 5 modulo 6 (== 2 * 3), so you can get away with only storing entries for those numbers in your sieve.", "The next step up is to note that all primes (except 2, 3 and 5) are congruent to one of 1, 7, 11, 13, 17, 19, 23, 29 (modulo 30) (here 30 == 2*3*5), and so on."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Python's integer types can be of arbitrary size, so you shouldn't need a clever bitstring library to represent a set of bits, just a single number."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's the code.", "It handles a limit of 1,000,000 with ease, and can even handle 10,000,000 without complaining too much:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def multiples_of(n, step, limit):\n    bits = 1 &lt;&lt; n\n    old_bits = bits\n    max = 1 &lt;&lt; limit\n    while old_bits &lt; max:\n        old_bits = bits\n        bits += bits &lt;&lt; step\n        step *= 2\n    return old_bits\n\ndef prime_numbers(limit=10000000):\n    '''Prime number generator. Yields the series                                                                        \n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ...                                                                              \n    using Sieve of Eratosthenes.                                                                                        \n    '''\n    yield 2\n    sub_limit = int(limit**0.5)\n    flags = ((1 &lt;&lt; (limit - 2)) - 1) &lt;&lt; 2\n    # Step through all the odd numbers                                                                                  \n    for i in xrange(3, limit, 2):\n        if not (flags &amp; (1 &lt;&lt; i)):\n            continue\n        yield i\n        # Exclude further multiples of the current prime number                                                         \n        if i &lt;= sub_limit:\n            flags &amp;= ~multiples_of(i * 3, i &lt;&lt; 1, limit)\n</code>\n</pre>\n", "senID": 2}, {"text": ["The multiples_of function avoids the cost of setting every single multiple individually.", "It sets the initial bit, shifts it by the initial step (i &lt;&lt; 1) and adds the result to itself.", "It then doubles the step, so that the next shift copies both bits, and so on until it reaches the limit.", "This sets all the multiples of a number up to the limit in O(log(limit)) time."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "multiples_of", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i &lt;&lt; 1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["One option you may want to look at is just compiling a C/C++ module so you have direct access to the bit-twiddling features.", "AFAIK you could write something of that nature and only return the results on completion of the calculations performed in C/C++.", "Now that I'm typing this you may also look at numpy which does store arrays as native C for speed.", "I don't know if that will be any faster than the bitstring module, though!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Another really stupid option, but that can be of help if you really need a large list of primes number available very fast.", "Say, if you need them as a tool to answer project Euler's problems (if the problem is just optimizing your code as a mind game it's irrelevant)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use any slow solution to generate list and save it to a python source file, says primes.py that would just contain:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "primes.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n primes = [ a list of a million primes numbers here ]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now to use them you just have to do import primes and you get them with minimal memory footprint at the speed of disk IO.", "Complexity is number of primes :-)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "import primes", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Even if you used a poorly optimized solution to generate this list, it will only be done once and it does not matter much. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You could probably make it even faster using pickle/unpickle, but you get the idea..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["You could use a segmented Sieve of Eratosthenes.", "The memory used for each segment is reused for the next segment."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]