[[{"text": ["Trickery will bite you.", "Just use Queue to communicate between threads."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Yes this will work in the way that you described:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I don't see a \"del\" here.", "If a del happens in consume_item then the del may occur in the producer thread.", "I don't think this would be a \"problem\"."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "del", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Don't bother using this though.", "You will end up using up CPU on pointless polling cycles, and it is not any faster than using a queue with locks since Python already has a global lock."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is not really thread safe because producer could overwrite QUEUE_ITEM before consumer has consumed it and consumer could consume QUEUE_ITEM twice.", "As you mentioned, you're OK with that but most people aren't."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "QUEUE_ITEM", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "QUEUE_ITEM", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Someone with more knowledge of cpython internals will have to answer you more theoretical questions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I think it's possible that a thread is interrupted while producing/consuming, especially if the items are big objects.", "Edit: this is just a wild guess.", "I'm no expert."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also the threads may produce/consume any number of items before the other one starts running."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You can use a list as the queue as long as you stick to append/pop since both are atomic."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n QUEUE = []\n\n# this is executed in one threading.Thread object\ndef producer():\n    global QUEUE\n    while True:\n        i = produce_item()\n        QUEUE.append(i)\n\n# this is executed in another threading.Thread object\ndef consumer():\n    global QUEUE\n    while True:\n        try:\n            i = QUEUE.pop(0)\n        except IndexError:\n            # queue is empty\n            continue\n\n        consume_item(i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In a class scope like below, you can even clear the queue."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Atomic(object):\n    def __init__(self):\n        self.queue = []\n\n    # this is executed in one threading.Thread object\n    def producer(self):\n        while True:\n            i = produce_item()\n            self.queue.append(i)\n\n    # this is executed in another threading.Thread object\n    def consumer(self):\n        while True:\n            try:\n                i = self.queue.pop(0)\n            except IndexError:\n                # queue is empty\n                continue\n\n            consume_item(i)\n\n    # There's the possibility producer is still working on it's current item.\n    def clear_queue(self):\n        self.queue = []\n</code>\n</pre>\n", "senID": 3}, {"text": ["You'll have to find out which list operations are atomic by looking at the bytecode generated."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The __del__ could be a problem as You said.", "It could be avoided, if only there was a way to prevent the garbage collector from invoking the __del__ method on the old object before We finish assigning the new one to the QUEUE_ITEM.", "We would need something like:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__del__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__del__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "QUEUE_ITEM", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n increase the reference counter on the old object\nassign a new one to `QUEUE_ITEM`\ndecrease the reference counter on the old object\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm afraid, I don't know if it is possible, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]