[[{"text": ["Calling string on a python list calls the __repr__ method on each element inside.", "For some items, __str__ and __repr__ are the same.", "If you want that behavior, do:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__repr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__str__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__repr__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def __str__(self):\n    ...\ndef __repr__(self):\n    return self.__str__()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can use a list comprehension to generate a new list with each item str()'d automatically:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}, {"code": "<pre>\n<code>\n print([str(item) for item in mylist])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Depending on what you want to use that output for, perhaps __repr__ might be more appropriate:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__repr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import unittest\n\nclass A(object):\n    def __init__(self, val):\n        self.val = val\n\n    def __repr__(self):\n        return repr(self.val)\n\nclass Test(unittest.TestCase):\n    def testMain(self):\n        l = [A('a'), A('b')]\n        self.assertEqual(repr(l), \"['a', 'b']\")\n\nif __name__ == '__main__':\n    unittest.main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Two easy things you can do, use the map function or use a comprehension."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["But that gets you a list of strings, not a string.", "So you also have to join the strings together."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n s= \",\".join( map( str, myList ) )\n</code>\n</pre>\n", "senID": 2}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n s= \",\".join( [ str(element) for element in myList ] )\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then you can print this composite string object."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n print 'my list is %s'%( s )\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Something like this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [1, 2 ,3]\n[str(x) for x in a]\n# ['1', '2', '3']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I agree with the previous answer about using list comprehensions to do this, but you could certainly hide that behind a function, if that's what floats your boat."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_list(value):\n    if type(value) in (list, tuple): return True\n    return False\n\ndef list_str(value):\n    if not is_list(value): return str(value)\n    return [list_str(v) for v in value]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Just for fun, I made list_str() recursively str() everything contained in the list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]