[[{"text": ["By the time your decorator gets the function object f, it's already been compiled -- specifically, it's been compiled with the knowledge that x is local (because it's assigned with the += assignment), the normal optimization (in 2.", "* you can defeat the optimization, at a staggering price in performance, by starting f with exec ''; in 2.", "*, you cannot defeat the optimization).", "Essentially, to use the syntax you crave, you have to recompile f (by recovering its sources, if you know they'll be available at runtime, or, much harder, by bytecode hacks) with somehow-modified sources -- once you've decided to go that way, the simplest approach is probably to change x into f.x throughout the body of f."], "childNum": 11, "tag": "p", "senID": 0, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "2.*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "exec ''", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "2.*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "f.x", "childNum": 0, "tag": "code", "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Personally, if and when I find myself fighting so hard against the language (or other technology) that I'm trying to bend to my will to impose my desires, I acknowledge that I'm either using the wrong language (or other technology), if those desires are absolutely crucial, and then the solution must be to change technology; or, if those desires are not that crucial, give up on them."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Either way, I give up trying to distort the language too far away from its obvious design intentions: even if I did come up with some hacky, fragile kludge, it would no doubt be unmaintainable.", "In this case, Python's desire intentions are very clear: barenames that get re-bound within a functions are locals of that function unless explicitly designated as globals -- period.", "So, your attempt to make barenames (that get re-bound within a function) mean something completely different than \"locals\" is exactly this kind of fight."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: If you're willing to give up on the insistence on using barenames for your \"statics\", then suddenly you're not fighting against Python any more, but rather \"going with the grain\" of the language (despite the design glitch of global [and nonlocal], but, that's a separate rant;-).", "So, for example:"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "barenames", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "nonlocal", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class _StaticStuff(object):\n  _static_stack = []\n  def push(self, d):\n    self._static_stack.append(d)\n  def pop(self):\n    self._static_stack.pop()\n  def __getattr__(self, n):\n    return self._static_stack[-1][n]\n  def __setattr__(self, n, v):\n    self._static_stack[-1][n] = v\nimport __builtin__\n__builtin__.static = _StaticStuff()\n\ndef with_static(**variables):\n  def dowrap(f):\n    def wrapper(*a, **k):\n      static.push(variables)\n      try: return f(*a, **k)\n      finally: static.pop()\n    return wrapper\n  return dowrap\n\n@with_static(x=0)\ndef f():\n    static.x += 1\n    print static.x\n\nf()\nf()\n</code>\n</pre>\n", "senID": 4}, {"text": ["This works just like you desire, printing 1 and then 2.", "(I'm using __builtin__ to make it simplest to use with_static to decorate functions living in any module whatsoever, of course).", "You could have several different implementations, but the key point of any good implementation is that \"static variables\" will be qualified names, not barenames -- making it explicit that they're not local variables, playing with the grain of the language, and so forth.", "(Similar built-in containers, and qualified names based on them, should have been used in Python's design, instead of the global and nonlocal design glitches, to indicate other kinds of variables that aren't local ones and therefore should not be using barenames... ah well, you can implement yourself a globvar special container on the same lines of the above static ones, without even needing decoration, though I'm not so sure that is entirely feasible for the nonlocal case [perhaps with some decoration and the tiniest amount of black magic...;=)])."], "childNum": 12, "tag": "p", "senID": 5, "childList": [{"text": "__builtin__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "with_static", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "good", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "qualified", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "childList": []}, {"text": "should", "childNum": 0, "tag": "em", "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "childList": []}, {"text": "nonlocal", "childNum": 0, "tag": "code", "childList": []}, {"text": "globvar", "childNum": 0, "tag": "code", "childList": []}, {"text": "static", "childNum": 0, "tag": "code", "childList": []}, {"text": "nonlocal", "childNum": 0, "tag": "code", "childList": []}, {"text": "with", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Edit: a comments points out that the code as given doesn't work when you only decorate a function that returns a closure (instead of decorating the closure itself).", "That's right: of course, you have to decorate the specific function that uses the static (and there can be only one, by definition of function-static variables!", "), not a random function that doesn't in fact use the static but rather just happens to be in some lexical connection with the one that does.", "For example:"], "childNum": 5, "tag": "p", "senID": 6, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "static", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "static", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "static", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "does", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def f():\n  @with_static(x=0)\n  def g():\n    static.x += 1\n    print static.x\n  return g\n\nx = f()\nx()\nx()\n</code>\n</pre>\n", "senID": 7}, {"text": ["this works, while moving the decorator to f instead of g doesn't (and couldn't possibly)."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "g", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the actual desiderata are not about static variables (visible and usable only within a single function) but some hybrid thing that's usable throughout a certain peculiar bundle of functions, that needs to be specified very precisely (and no doubt implemented very differently, depending on what the actual specs are) -- and ideally that needs to happen in a new and separate SO questions, because this one (which is specifically about static instead), and this answer to this specific question, are already plenty big enough."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "are", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "static", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Here is a decorator that seems to work.", "Note that this requires return locals() at the end of the function due to being unable to set locals from the outside (I don't have much experience programming so if there is a way, I don't know it)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Static(object):\ndef __init__(self, **kwargs):\n    self.kwargs = kwargs\n\ndef __call__(self, f):\n    def wrapped_f():\n        try:\n            new_kwargs = {}\n            for key in self.kwargs:\n                i = getattr(f, key)\n                new_kwargs[key] = i\n            self.kwargs = new_kwargs\n        except:\n            pass\n        for key, value in f(**self.kwargs).items():\n            setattr(f, key, value)\n    return wrapped_f\n\n@Static(x=0, y=5, z='...')\ndef f(x, y, z):\n    x += 1\n    y += 5\n    print x, y, z\n    return locals()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The output would be:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f()\n1 10 ...\n&gt;&gt;&gt; f()\n2 15 ...\n&gt;&gt;&gt; f()\n3 20 ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["EDIT:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I found something at http://code.activestate.com/recipes/410698/ and decided to try adding it to this.", "It works without the return now."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://code.activestate.com/recipes/410698/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/410698/"}]}, {"text": ["EDIT again: Changed to to make it a few seconds faster.", "Edit 3; changed to function instead of class"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def static(**kwargs):\n    def wrap_f(function):\n        def probeFunc(frame, event, arg):\n            if event == 'call':\n                frame.f_locals.update(kwargs)\n                frame.f_globals.update(kwargs)\n            elif event == 'return':\n                for key in kwargs:\n                    kwargs[key] = frame.f_locals[key]\n                sys.settrace(None)\n            return probeFunc\n        def traced():\n            sys.settrace(probeFunc)\n            function()\n        return traced\n    return wrap_f\n</code>\n</pre>\n", "senID": 7}, {"text": ["tested:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n @static(x=1)\ndef f():\n    x += 1\n\nglobal_x = 1\ndef test_non_static():\n    global global_x\n    global_x += 1\n\n\nprint 'Timeit static function: %s' % timeit.timeit(f)\nprint 'Timeit global variable: %s' % timeit.timeit(test_non_static)\n</code>\n</pre>\n", "senID": 9}, {"text": ["output:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n Timeit static function: 5.10412869535\nTimeit global variable: 0.242917510783\n</code>\n</pre>\n", "senID": 11}, {"text": ["Using settrace slows it down quite drastically."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["You could do something like that (but I haven't tested this extensively; used CPython 2.6):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import types\n\ndef static(**dict):\n    def doWrap(func):\n        scope = func.func_globals\n        scope.update(dict)\n        return types.FunctionType(func.func_code, scope)\n    return doWrap\n\n# if foo() prints 43, then it's wrong\nx = 42\n\n@static(x = 0)\ndef foo():\n   global x\n   x += 1\n   print(x)\n\nfoo() # =&gt; 1\nfoo() # =&gt; 2\n</code>\n</pre>\n", "senID": 1}, {"text": ["It requires declaring those variables as global and shadows top-level global variables, but otherwise should work.", "Not sure about performance, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is a really simple solution that works just like normal python static variables."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def static(**kwars):\n  def wrap(f):\n    for key, value in kwargs.items():\n      setattr(f, key, value)\n    return f\n  return wrap\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @static(a=0)\ndef foo(x):\n  foo.a += 1\n  return x+foo.a\n\nfoo(1)  # =&gt; 2\nfoo(2)  # =&gt; 4\nfoo(14) # =&gt; 17\n</code>\n</pre>\n", "senID": 3}, {"text": ["This more closely matches the normal way of doing python static variables"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def foo(x):\n  foo.a += 1\n  return x+foo.a\nfoo.a = 10\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here's something that might be much clearer.", "It doesn't involve any decorators or hacking."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class F( object ):\n    def __init__( self ):\n        self.x= 0\n    def __call__( self ):\n        self.x += 1\n        print self.x\n\nf= F()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now you have your function f with a static variable."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n f() #prints 1\nf() #prints 2\n</code>\n</pre>\n", "senID": 3}], [{"text": ["How about this, without decorators?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class State(dict):\n    \"\"\"Object interface to dict.\"\"\"\n    def __getattr__(self, name):\n        try:\n            return self[name]\n        except KeyError:\n            raise AttributeError, name\n\ndef f(d=State(x=0)):\n    d.x += 1\n    return d.x\n</code>\n</pre>\n", "senID": 1}, {"text": ["And here is it in action:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f()\n1\n&gt;&gt;&gt; f()\n2\n&gt;&gt;&gt; f()\n3\n</code>\n</pre>\n", "senID": 3}], [{"text": ["When you need to save state between invocations of a function, you are almost always better off using a generator/coroutine or an object.", "Since you want to use \"bare\" variable names, then you'll want the coroutine version."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # the coroutine holds the state and yields rather than returns values\ndef totalgen(x=0, y=0, z=0):\n    while True:\n       a, b, c = (yield x, y, z)\n       x += a\n       y += b\n       z += c\n\n# the function provides the expected interface to callers\ndef runningtotal(a, b, c, totalgen=totalgen()):\n    try:\n        return totalgen.send((a, b, c))    # conveniently gives TypeError 1st time\n    except TypeError:\n        totalgen.next()                    # initialize, discard results\n        return totalgen.send((a, b, c))\n</code>\n</pre>\n", "senID": 1}, {"text": ["The result is a function that accumulates totals of the three values passed to it, exactly as if it had static variables, but the accumulators are plain old local variables in what is essentially an infinite generator."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]