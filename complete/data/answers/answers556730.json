[[{"text": ["I would guess cPickle will be fastest if you really need the thing in a list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you can use an array, which is a built-in sequence type, I timed this at a quarter of a second for 1 million integers:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from array import array\nfrom datetime import datetime\n\ndef WriteInts(theArray,filename):\n    f = file(filename,\"wb\")\n    theArray.tofile(f)\n    f.close()\n\ndef ReadInts(filename):\n    d = datetime.utcnow()\n    theArray = array('i')\n    f = file(filename,\"rb\")\n    try:\n        theArray.fromfile(f,1000000000)\n    except EOFError:\n        pass\n    print \"Read %d ints in %s\" % (len(theArray),datetime.utcnow() - d)\n    return theArray\n\nif __name__ == \"__main__\":\n    a = array('i')\n    a.extend(range(0,1000000))\n    filename = \"a_million_ints.dat\"\n    WriteInts(a,filename)\n    r = ReadInts(filename)\n    print \"The 5th element is %d\" % (r[4])\n</code>\n</pre>\n", "senID": 2}], [{"text": ["For benchmarking, see the timeit module in the Python standard library.", "To see what is the fastest way, implement all the ways you can think of and measure them with timeit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Random thought: depending on what you're doing exactly, you may find it fastest to store \"sets of integers\" in the style used in .newsrc files:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": ".newsrc", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 1, 3-1024, 11000-1200000\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you need to check whether something is in that set, then loading and matching with such a representation should be among the fastest ways.", "This assumes your sets of integers are reasonably dense, with long consecutive sequences of adjacent values."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["\"how can one benchmark such things reliably?", "\"  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I don't get the question."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You write a bunch of little functions to create and save your list in various forms."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You write a bunch of little functions to load your lists in their various forms."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You write a little timer function to get start time, execute the load procedure a few dozen times (to get a solid average that's long enough that OS scheduling noise doesn't dominate your measurements)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You summarize your data in a little report.  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["What's unreliable about this?"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Here are some unrelated questions that shows how to measure and compare performance.  "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["http://stackoverflow.com/questions/489999/python-convert-list-of-ints-to-one-number"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "http://stackoverflow.com/questions/489999/python-convert-list-of-ints-to-one-number", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/489999/python-convert-list-of-ints-to-one-number"}]}, {"text": ["http://stackoverflow.com/questions/376461/string-concatenation-vs-string-substitution-in-python"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "http://stackoverflow.com/questions/376461/string-concatenation-vs-string-substitution-in-python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/376461/string-concatenation-vs-string-substitution-in-python"}]}], [{"text": ["Do you need to always load the whole file?", "If not, upack_from() might be the best solution.", "Suppose, that you have 1000000 integers, but you'd like to load just the ones from 50000 to 50099, you'd do:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "upack_from()", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/struct.html"}]}, {"code": "<pre>\n<code>\n import struct\nintSize = struct.calcsize('i') #this value would be constant for a given arch\nintFile = open('/your/file.of.integers')\nintTuple5K100 = struct.unpack_from('i'*100,intFile,50000*intSize)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["To help you with timing, the Python Library provides the timeit module:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "timeit", "tag": "a", "pos": 0, "childList": [{"text": "timeit", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/timeit.html#module-timeit"}, {"text": "timeit", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["An example (from the manual) that compares the cost of using hasattr() vs. try/except to test for missing and present object attributes:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "hasattr()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "try/except", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n % timeit.py 'try:' '  str.__nonzero__' 'except AttributeError:' '  pass'\n100000 loops, best of 3: 15.7 usec per loop\n% timeit.py 'if hasattr(str, \"__nonzero__\"): pass'\n100000 loops, best of 3: 4.26 usec per loop\n% timeit.py 'try:' '  int.__nonzero__' 'except AttributeError:' '  pass'\n1000000 loops, best of 3: 1.43 usec per loop\n% timeit.py 'if hasattr(int, \"__nonzero__\"): pass'\n100000 loops, best of 3: 2.23 usec per loop\n</code>\n</pre>\n", "senID": 2}], [{"text": ["cPickle will be the fastest since it is saved in binary and no real python code has to be parsed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Other advantates are that it is more secure (since it does not execute commands) and you have no problems with setting $PYTHONPATH correctly."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "$PYTHONPATH", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]