[[{"text": ["I suggest a repeated use of k-means clustering -- let's call it KMC for short.", "KMC is a simple and powerful clustering algorithm... but it needs to \"be told\" how many clusters, k, you're aiming for.", "You don't know that in advance (if I understand you correctly) -- you just want the smallest k such that no two items \"clustered together\" are more than X% apart from each other.", "So, start with k equal 1 -- everything bunched together, no clustering pass needed;-) -- and check the diameter of the cluster (a cluster's \"diameter\", from the use of the term in geometry, is the largest distance between any two members of a cluster)."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "k-means clustering", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/K-means_clustering"}, {"text": "k", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "X%", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the diameter is &gt; X%, set k += 1, perform KMC with k as the number of clusters, and repeat the check, iteratively."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "&gt; X%", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "k += 1", "childNum": 0, "tag": "code", "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In pseudo-code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def markCluster(items, threshold):\n    k = 1\n    clusters = [items]\n    maxdist = diameter(items)\n    while maxdist &gt; threshold:\n        k += 1\n        clusters = Kmc(items, k)\n        maxdist = max(diameter(c) for c in clusters)\n    return clusters\n</code>\n</pre>\n", "senID": 3}, {"text": ["assuming of course we have suitable diameter and Kmc Python functions."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "diameter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Kmc", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Does this sound like the kind of thing you want?", "If so, then we can move on to show you how to write diameter and Kmc (in pure Python if you have a relatively limited number of items to deal with, otherwise maybe by exploiting powerful third-party add-on frameworks such as numpy) -- but it's not worthwhile to go to such trouble if you actually want something pretty different, whence this check!-)"], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "diameter", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Kmc", "childNum": 0, "tag": "code", "childList": []}, {"text": "items", "childNum": 0, "tag": "code", "childList": []}, {"text": "numpy", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["A stock s belong in a group G if for each stock t in G, s * 1.05 >= t and s / 1.05 &lt;= t, right?"], "childNum": 8, "tag": "p", "senID": 0, "childList": [{"text": "s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "G", "childNum": 0, "tag": "code", "childList": []}, {"text": "t", "childNum": 0, "tag": "code", "childList": []}, {"text": "G", "childNum": 0, "tag": "code", "childList": []}, {"text": "s", "childNum": 0, "tag": "code", "childList": []}, {"text": "t", "childNum": 0, "tag": "code", "childList": []}, {"text": "s", "childNum": 0, "tag": "code", "childList": []}, {"text": "t", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["How do we add the stocks to each group?", "If we have the stocks 95, 100, 101, and 105, and we start a group with 100, then add 101, we will end up with {100, 101, 105}.", "If we did 95 after 100, we'd end up with {100, 95}."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Do we just need to consider all possible permutations?", "If so, your algorithm is going to be inefficient. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You need to specify your problem in more detail.", "Just what does \"put the stockprices into groups when they are within 0.5% of each other\" mean?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Possibilities:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(1) each member of the group is within 0.5% of every other member of the group"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(2) sort the list and split it where the gap is more than 0.5% "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Note that 116.23 is within 0.5% of 115.93 --  abs((116.23 / 115.93 - 1) * 100) &lt; 0.5 -- but you have put one number in Group A and one in Group C."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "abs((116.23 / 115.93 - 1) * 100) &lt; 0.5", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Simple example: a, b, c = (0.996, 1, 1.004) ...", "Note that a and b fit, b and c fit, but a and c don't fit.", "How do you want them grouped, and why?", "Is the order in the input list relevant? "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "a, b, c = (0.996, 1, 1.004)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Possibility (1) produces ab,c or a,bc ... tie-breaking rule, please\nPossibility (2) produces abc (no big gaps, so only one group)"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["You won't be able to classify them into hard \"groups\".", "If you have prices (1.0,1.05, 1.1) then the first and second should be in the same group, and the second and third should be in the same group, but not the first and third."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A quick, dirty way to do something that you might find useful:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def make_group_function(tolerance = 0.05):\n    from math import log10, floor\n    # I forget why this works. \n    tolerance_factor = -1.0/(-log10(1.0 + tolerance))\n    # well ... since you might ask\n    # we want: log(x)*tf - log(x*(1+t))*tf = -1, \n    # so every 5% change has a different group. The minus is just so groups \n    # are ascending .. it looks a bit nicer.\n    #\n    # tf = -1/(log(x)-log(x*(1+t)))\n    # tf = -1/(log(x/(x*(1+t))))\n    # tf = -1/(log(1/(1*(1+t)))) # solved .. but let's just be more clever\n    # tf = -1/(0-log(1*(1+t)))\n    # tf = -1/(-log((1+t))\n    def group_function(value):\n        # don't just use int - it rounds up below zero, and down above zero\n        return int(floor(log10(value)*tolerance_factor))\n    return group_function\n</code>\n</pre>\n", "senID": 2}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n group_function = make_group_function()\nimport random\ngroups = {}\nfor i in range(50):\n    v = random.random()*500+1000\n    group = group_function(v)\n    if group in groups:\n        groups[group].append(v)\n    else:\n        groups[group] = [v]\n\nfor group in sorted(groups):\n    print 'Group',group\n    for v in sorted(groups[group]):\n        print v\n    print\n</code>\n</pre>\n", "senID": 4}], [{"text": ["For a given set of stock prices, there is probably more than one way to group stocks that are within 0.5% of each other.", "Without some additional rules for grouping the prices, there's no way to be sure an answer will do what you really want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["apart from the proper way to pick which values fit together, this is a problem where a little Object Orientation dropped in can make it a lot easier to deal with."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I made two classes here, with a minimum of desirable behaviors, but which can make the classification a lot easier -- you get a single point to play with it on the Group class."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I can see the code bellow is incorrect, in the sense the limtis for group inclusion varies as new members are added -- even it the separation crieteria remaisn teh same, you  heva e torewrite the get_groups method to use a multi-pass approach.", "It should nto be hard -- but the code would be too long to be helpfull here, and i think this snipped is enoguh to get you going:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from copy import copy\n\nclass Group(object):\n    def __init__(self,data=None, name=\"\"):\n        if data:\n            self.data = data\n        else:\n            self.data = []\n        self.name = name\n\n    def get_mean_stock(self):\n        return sum(item[0] for item in self.data) / len(self.data)\n\n    def fits(self, item):\n        if 0.995 &lt; abs(item[0]) / self.get_mean_stock() &lt; 1.005:\n            return True\n        return False\n\n    def get_weight(self):\n        return sum(item[1] for item in self.data)\n\n    def __repr__(self):\n        return \"Group-%s\\n%s\\n---\\nTotalWeight: %d\\n\\n\" % (\n            self.name,\n            \"\\n\".join(\"%.02f, %d\" % tuple(item) for item in self.data ),\n            self.get_weight())\n\n\nclass StockGrouper(object):\n    def __init__(self, data=None):\n        if data:\n            self.floor_levels = data\n        else:\n            self.floor_levels = []\n\n    def get_groups(self):\n        groups = []\n        floor_levels = copy(self.floor_levels)\n        name_ord = ord(\"A\") - 1\n        while floor_levels:\n            seed = floor_levels.pop(0)\n            name_ord += 1\n            group = Group([seed], chr(name_ord))\n            groups.append(group)\n            to_remove = []\n            for i, item in enumerate(floor_levels):\n                if group.fits(item):\n                    group.data.append(item)\n                    to_remove.append(i)\n            for i in reversed(to_remove):\n                floor_levels.pop(i)\n        return groups\n</code>\n</pre>\n", "senID": 3}, {"text": ["testing:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n floor_levels = [  [stock. weight] ,... &lt;paste the data above&gt; ]\ns = StockGrouper(floor_levels)\ns.get_groups()\n</code>\n</pre>\n", "senID": 5}], [{"text": ["For the grouping element, could you use itertools.groupby()?", "As the data is sorted, a lot of the work of grouping it is already done, and then you could test if the current value in the iteration was different to the last by &lt;0.5%, and have itertools.groupby() break into a new group every time your function returned false."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]