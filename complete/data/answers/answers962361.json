[[{"text": ["The usual way I do these things in pg is: load raw data matching target table into temp table (no constraints) using copy, merge(the fun part), profit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I wrote a merge_by_key function specifically for these situations:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://mbk.projects.postgresql.org/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://mbk.projects.postgresql.org/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mbk.projects.postgresql.org/"}]}, {"text": ["The docs aren't terribly friendly, but I'd suggest giving it a good look."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "good", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I had a similar situation a few months ago and ended up getting the largest speed boost from a tuned chunk/transaction size.", "You may also want to check the log for a checkpoint warning during the test and tune appropriately. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Sounds like you'd see benefits from using WAL (Write Ahead Logging) with a UPS to cache your updates between disk writes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.varlena.com/GeneralBits/Tidbits/perf.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.varlena.com/GeneralBits/Tidbits/perf.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.varlena.com/GeneralBits/Tidbits/perf.html"}]}], [{"text": ["In your insert_or_replace.", "try this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "insert_or_replace", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n WHERE EXISTS(SELECT 1 FROM item WHERE key=NEW.key LIMIT 1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["instead of"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n WHERE EXISTS(SELECT 1 FROM item WHERE key=NEW.key)\n</code>\n</pre>\n", "senID": 3}, {"text": ["As noted in comments, that will probably do nothing.", "All I have to add, then, is that you can always speed up INSERT/UPDATE performance by removing indexes.", "This will likely not be something you want to do unless you find your table is overindexed, but that should at least be checked out."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["In Oracle, locking the table would definitely help.", "You might want to try that with PostgreSQL, too."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I am working with a database of a million rows approx.. using python to parse documents and populate the table with terms..", "The insert statements work fine but the update statements get extremely time consuming as the  table size grows.. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Is it normal for the update statement to take significantly longer than the insert statement?", "In my case updates are slowing the program many times"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For updates, you can lower your fillfactor for the tables and the indexes and that might help"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.postgresql.org/docs/current/static/sql-createtable.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.postgresql.org/docs/current/static/sql-createtable.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.postgresql.org/docs/current/static/sql-createtable.html"}]}, {"text": ["http://www.postgresql.org/docs/current/static/sql-createindex.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.postgresql.org/docs/current/static/sql-createindex.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.postgresql.org/docs/current/static/sql-createindex.html"}]}]]