[[{"text": ["I agree with Pavel, what is intuitive is subjective.", "Because I'm (slowly) starting to grok Haskell, I can tell what the Clojure code does, even though I've never written a line of Clojure in my life.", "So I would consider the Clojure line fairly intuitive, because I've seen it before and I'm adapting to a more functional mindset."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Let's consider the mathematical definition, shall we?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n { 0                   if x = 0 }\nF(x) = { 1                   if x = 1 }\n       { F(x - 1) + F(x - 2) if x &gt; 1 }\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is less than ideal, formatting wise - those three brackets lined up should be one giant bracket - but who's counting?", "This is a pretty clear definition of the Fibonacci sequence to most people with a mathematical background.", "Let's look at the same thing in Haskell, because I know it better than Clojure:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n fib 0 = 0\nfib 1 = 1\nfib n = fibs (n - 1) + fibs (n - 2)\n</code>\n</pre>\n", "senID": 4}, {"text": ["This is a function, fib, that returns the nth Fibonacci number.", "Not exactly what we had in Python or Clojure, so let's fix that:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "fib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n fibs = map fib [0..]\n</code>\n</pre>\n", "senID": 6}, {"text": ["This makes fibs an infinite list of Fibonacci numbers.", "fibs !!", "1 is 1, fibs !!", "2 is 1, fibs !!", "10 is 55, and so on.", "However, this is probably quite inefficient, even in a language that relies on heavily optimized recursion such as Haskell.", "Let's look at the Clojure definition in Haskell:"], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "fibs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fibs !! 1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fibs !! 2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fibs !! 10", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n fibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n</code>\n</pre>\n", "senID": 8}, {"text": ["The first couple of characters are pretty simple: 0 : 1 : makes a list with elements 0 and 1, and then some more.", "But what's all the rest of that?", "Well, fibs is the list we've already got, and tail fibs calls the tail function on our list so far, which returns the list starting at the 2nd element (sort of like in Python saying fibs[1:]).", "So we take these two lists - fibs and tail fibs - and we zip them together with the + function (operator) - that is, we add the matching elements of each.", "Let's look:"], "childNum": 8, "tag": "p", "senID": 9, "childList": [{"text": "0 : 1 :", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fibs", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "tail fibs", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "tail", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fibs[1:]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fibs", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "tail fibs", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "+", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n fibs       = 0 : 1 : ...\ntail fibs  = 1 : ...\nzip result = 1 : ...\n</code>\n</pre>\n", "senID": 10}, {"text": ["So our next element is 1!", "But then we add that back onto our fibs list, and look what we get:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "fibs", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n fibs       = 0 : 1 : 1 : ...\ntail fibs  = 1 : 1 : ...\nzip result = 1 : 2 : ...\n</code>\n</pre>\n", "senID": 12}, {"text": ["What we have here is a recursive list definition.", "As we add more elements to the end of fibs with our zipWith (+) fibs (tail fibs) bit, more elements become avaliable for us to work with when adding elements.", "Note that Haskell by default is lazy, so just making an infinite list like that won't crash anything (just don't try to print it)."], "childNum": 3, "tag": "p", "senID": 13, "childList": [{"text": "recursive list definition", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "fibs", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "zipWith (+) fibs (tail fibs)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["So while this is perhaps theoretically the same as our mathematical definition before, it saves the results in our fibs list (sort of an auto-memoization) and we rarely have the problems that might be experienced in a naive solution.", "For completeness, let's define our fib function in terms of our new fibs list:"], "childNum": 3, "tag": "p", "senID": 14, "childList": [{"text": "fibs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fib", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "fibs", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n fib n = fibs !! n\n</code>\n</pre>\n", "senID": 15}, {"text": ["If I didn't lose you yet, that's good, because that means you understand the Clojure code.", "Look:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n (def fib-seq (lazy-cat [0 1]\n (map + fib-seq (rest fib-seq))))\n</code>\n</pre>\n", "senID": 17}, {"text": ["We make a list, fib-seq.", "It starts with two elements, [0 1], just like our Haskell example.", "We do a lazy concatenation of these two initial elements with (map + fib-seq (rest fib-seq)) - assuming rest does the same thing that tail does in Haskell, we're just combining our list with itself at a lower offset, and then combining these two lists with the + operator/function."], "childNum": 6, "tag": "p", "senID": 18, "childList": [{"text": "fib-seq", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[0 1]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(map + fib-seq (rest fib-seq))", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "rest", "childNum": 0, "tag": "code", "childList": []}, {"text": "tail", "childNum": 0, "tag": "code", "childList": []}, {"text": "+", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["After working this through your head a few times, and exploring some other examples, this method of generating factorials becomes at least semi-intuitive.", "It's at least intuitive enough for me to spot it in a language I don't know."], "childNum": 0, "tag": "p", "senID": 19, "childList": []}], [{"text": ["It's not.", "It's \"more imperative\", and for a lot of people imperative tends to be more obvious because that's what they're used to, but that is a matter of perception, and is strictly subjective."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (def fibs \n  (map first \n       (iterate \n           (fn [[ a, b       ]]  \n                [ b, (+ a b) ]) \n           [0, 1])))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which seems to have some similarities to the python/generator version."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The wiki has an in depth treatment of various Fibonacci implementations in Clojure which may interest you if you haven't seen it already."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "wiki", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikibooks.org/wiki/Clojure%5FProgramming/Examples/Lazy%5FFibonacci"}]}], [{"text": ["The Clojure code is intuitive to me (because I know Clojure).", "If you want something that might look more like something you're familiar with, you can try this, an efficient and overly-verbose recursive version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (use 'clojure.contrib.def)   ; SO's syntax-highlighting still sucks\n(defn-memo fib [n]\n  (cond (= n 0) 0\n        (= n 1) 1\n        :else   (+ (fib (- n 1))\n                   (fib (- n 2)))))\n\n(def natural-numbers (iterate inc 0))\n\n(def all-fibs\n  (for [n natural-numbers]\n    (fib n)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["But to someone who doesn't know what recursion or memoization are, that isn't going to be intuitive either.", "The very idea of \"infinite lazy sequences\" probably isn't intuitive to the majority of programmers.", "I can't guess what's in your brain so I don't know what a more intuitive Clojure function would look like to you, other than \"looks more like Python\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["To someone who doesn't know programming, all of this stuff is going to look like gibberish.", "What's a loop?", "What's a function?", "What is this yield thing?", "That's where we all start.", "Intuitiveness is a function of what you've learned so far.", "Non-intuitive code is code you aren't familiar with yet.", "Extrapolating from \"I know this\" to \"It's inherently more intuitive\" is wrong."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["If you didn't know any imperative languages, would this be intuitive for you?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = a + 5\n</code>\n</pre>\n", "senID": 1}, {"text": ["WTF?", "a clearly isn't the same as a + 5."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "clearly", "childNum": 0, "tag": "em", "childList": []}, {"text": "a + 5", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["if a = a + 5, is a + 5 = a?"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "a = a + 5", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a + 5 = a", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Why doesn't this work??"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if (a = 5) { // should be == in most programming languages\n    // do something\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["There are a lot of things that aren't clear unless you've seen it before somewhere else and understood its purpose.", "For a long time I haven't known the yield keyword and in effect I couldn't figure out what it did."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You think the imperative approach is more legible because you are used to it."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Here is one solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (defn fib-seq [a b]\n  (cons (+ a b) (lazy-seq (fib-seq (+ a b) a))))\n\n(def fibs (concat [1 1] (fib-seq 1 1)))\n\nuser=&gt; (take 10 fibs)\n(1 1 2 3 5 8 13 21 34 55)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You should always use a language that fits the problem*.", "Your Python example is just lower level than the Clojure one -- easier to understand for beginners, but more tedious to write and parse for someone who knows the fitting higher level concepts."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "*", "childNum": 1, "tag": "sup", "pos": 0, "childList": [{"text": "*", "tag": "code"}]}, {"text": "*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["* By the way, this also means that it is always nice to have a language that you can grow to fit."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "*", "childNum": 1, "tag": "sup", "pos": 0, "childList": [{"text": "*", "tag": "code"}]}, {"text": "*", "childNum": 0, "tag": "code", "childList": []}, {"text": "By the way, this also means that it is always nice to have a language that you can grow to fit.", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Think about how would you write lazy-cat with recur in clojure. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n (take 5 fibs)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Seems about as intuitive as it could possibly get.", "I mean, that is exactly what you're doing.", "You don't even need to understand anything about the language, or even know what language that is, in order to know what should happen."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]