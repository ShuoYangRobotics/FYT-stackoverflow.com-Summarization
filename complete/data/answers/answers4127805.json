[[{"text": ["This is already implemented as a class method, datetime.datetime.combine:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "datetime.datetime.combine", "tag": "a", "pos": 0, "childList": [{"text": "datetime.datetime.combine", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/datetime#datetime.datetime.combine"}, {"text": "datetime.datetime.combine", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import datetime\nd = datetime.date(2010, 12, 5)\nt = datetime.time(10, 22, 15)\ndt = datetime.datetime.combine(d, t)\nprint dt\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 2010-12-05 10:22:15\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This would generally be frowned upon because you're really combining rather than adding; this is why the actual datetime library has a combine method rather than using addition in this way."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "combine", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/datetime.html#datetime.datetime.combine"}]}, {"text": ["I'm not aware of any other cases in Python where &lt;instance of TypeA&gt; + &lt;instance of TypeB&gt; produces &lt;instance of TypeC&gt;.", "Thus, the Principle of least astonishment suggests that you should simply provide a combine method rather than overload addition."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "&lt;instance of TypeA&gt; + &lt;instance of TypeB&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&lt;instance of TypeC&gt;", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Principle of least astonishment", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Principle_of_least_astonishment"}, {"text": "combine", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Yes, there is at least one good reason not to:  the resulting instance is completely different from the two input instances.", "Is this important?", "I don't think so -- consider that date - date yields timedelta."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "date - date", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "timedelta", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The way I see it:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "Does adding two dates together make sense?  No.", "tag": "none", "senID": 2}, {"text": "Does adding two times together make sense?  No.", "tag": "none", "senID": 3}, {"text": "Does adding a date and a time together make sense?  Yup!", "tag": "none", "senID": 4}, {"text": "Does adding a date and a timedelta togethor make sense?  Maybe.", "tag": "none", "senID": 5}, {"text": "Does adding a time and a timedelta together make sense?  Maybe.", "tag": "none", "senID": 6}]}, {"text": ["and for subtraction"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "Does subtracting two dates make sense?  Yes.", "tag": "none", "senID": 8}, {"text": "Does subtracting two times make sense?  Yes.", "tag": "none", "senID": 9}, {"text": "Does subtracting a time from a date make sense?  Nope.", "tag": "none", "senID": 10}, {"text": "Does subtracting a timedelta from a date make sense?  Maybe.", "tag": "none", "senID": 11}, {"text": "Does subtracting a timedelta from a time make sense?  Maybe.", "tag": "none", "senID": 12}]}, {"text": ["Developing along the lines of what makes sense:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n date + time      =&gt; datetime\ndate + timedelta =&gt; date | datetime or exception or silently drop time portion\n\ntime + date =&gt; datetime\ntime + timedelta =&gt; time | wrap-around or exception\n\ndate - date      =&gt; timedelta\ndate - timedelta =&gt; date | datetime or exception or silently drop time portion\n\ntime - time      =&gt; timedelta\ntime - timedelta =&gt; time | wrap-around or exception\n\ndatetime + timedelta =&gt; datetime\ndatetime - timedelta =&gt; datetime\n</code>\n</pre>\n", "senID": 14}, {"text": ["So, if it were me and I were designing a Date, Time, DateTime, TimeDelta framework, I would allow:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n date + time\ndate - date\ntime - time\ndatetime + timedelta\ndatetime - timedelta\n</code>\n</pre>\n", "senID": 16}, {"text": ["and for these:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n date +/- timedelta\ntime +/- timedelta\n</code>\n</pre>\n", "senID": 18}, {"text": ["I would default to returning the same type if the timedelta had none of the other type, and raising an exception if the timedelta did have some of the other type, but there would be a setting that would control that.", "The other possible behavior would be to drop the unneeded portion -- so a date combined with a timedelta that had hours would drop the hours and return a date."], "childNum": 0, "tag": "p", "senID": 19, "childList": []}], [{"text": ["Due to the existence of the date, time, and datetime cross-type addition and subtraction operators, I would think that this is fine, so long as it is well defined."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Currently (2.7.2):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n date = date + timedelta\ndate = date - timedelta\ntimedelta = date - date\n\ndatetime = datetime + timedelta\ndatetime = datetime - timedelta\ntimedelta = datetime - datetime\n</code>\n</pre>\n", "senID": 2}, {"text": ["I believe the following is also reasonable for an extension:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n timedelta = time - time\ndatetime = date + time\n</code>\n</pre>\n", "senID": 4}, {"text": ["I was going to suggest the following as well, but time has very specific min and max values for hour, minute, second, and microsecond, thus requiring a silent wraparound of values or returning of a different type:"], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "time", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "hour", "childNum": 0, "tag": "code", "childList": []}, {"text": "minute", "childNum": 0, "tag": "code", "childList": []}, {"text": "second", "childNum": 0, "tag": "code", "childList": []}, {"text": "microsecond", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n time = time + timedelta\ntime = time - timedelta\n</code>\n</pre>\n", "senID": 6}, {"text": ["Similarly, date cannot handle a timedelta of less than a day being added to it.", "Often I have been told to simply use Duck Typing with Python, because that's the intent.", "If that is true, then I would propose the following completed interface:"], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "date", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "timedelta", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "use Duck Typing with Python", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "If that is true", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n [date|datetime] = date + timedelta\n[date|datetime] = date - timedelta\ntimedelta = date - date\n\n[time|timedelta] = time + timedelta\n[time|timedelta] = time - timedelta\ntimedelta = time - time\n\ndatetime = datetime + timedelta\ndatetime = datetime - timedelta\ndatetime = date + time\ndatetime = date - time\ntimedelta = datetime - datetime\ntimedelta = datetime - date\n\ntimedelta = timedelta + timedelta\ntimedelta = timedelta - timedelta\n</code>\n</pre>\n", "senID": 8}, {"text": ["In which, given the case that date has precision loss (for timedelta's with partial days), it is promoted to datetime.", "Similarly, given the case that time has precision loss (for timedelta's that yield a result of more than one day, or negative time), it is promoted to timedelta.", "However, I'm not fully comfortable with [time|timedelta].", "It makes sense given the rest of the interface from parallelism and precision views, but I do think it might be more elegant to just wraparound the time to the proper hour, thus changing all the [time|timedelta]'s to simply time, but unfortunately that leaves us with lost precision. "], "childNum": 10, "tag": "p", "senID": 9, "childList": [{"text": "date", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "timedelta", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "datetime", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "time", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "timedelta", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "timedelta", "childNum": 0, "tag": "code", "childList": []}, {"text": "However", "childNum": 0, "tag": "strong", "childList": []}, {"text": "[time|timedelta]", "childNum": 0, "tag": "code", "childList": []}, {"text": "[time|timedelta]", "childNum": 0, "tag": "code", "childList": []}, {"text": "time", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["In my opinion, the most valuable uses of operator overloading are situations where many input values can be combined.", "You'd never want to deal with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n concat(concat(concat(\"Hello\", \", \"), concat(\"World\", \"!\")), '\\n');\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n distance = sqrt(add(add(x*x, y*y), z*z));\n</code>\n</pre>\n", "senID": 3}, {"text": ["So we overload math symbols to create a more intuitive syntax.", "Another way to deal with this problem is variadic functions, like + in Scheme."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["With your date + time = datetime, it doesn't make sense to add datetime + datetime, datetime + time, or datetime + date, so you could never encounter a situation like those above."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "date + time = datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "datetime + datetime", "childNum": 0, "tag": "code", "childList": []}, {"text": "datetime + time", "childNum": 0, "tag": "code", "childList": []}, {"text": "datetime + date", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In my opinion, once again, the right thing is to use a constructor method.", "In a language with strong typing like C++, you'd have DateTime(const Date &amp;d, const Time &amp;t).", "With Python's dynamic typing, I guess they gave the function a name, datetime.combine(date, time), to make the code clearer when the types of the input variables are not visible in the code."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "DateTime(const Date &amp;d, const Time &amp;t)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "datetime.combine(date, time)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I guess most important things are functionality and efficiency.", "Of course using a simple + operator will be easier to use, but i am not sure about functionality."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If we compare it to datetime.combine, What combine do is:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "datetime.combine", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "combine", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n dt = date(2011,01,01)\ntm = time(20,00)\ndtm = datetime.combine(dt, tm)\n</code>\n</pre>\n", "senID": 2}, {"text": ["For dtm"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dtm", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "If ", "tag": "none", "senID": 4}, {"text": "if ", "tag": "none", "senID": 5}]}, {"text": ["From that point of view, working with datetime objects do not seem to be simple objects, but more compex structures with diffrent attributes, like timezone info."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "timezone info", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Probably thats why datetime objects have some additional functions that is used for formatting object type and data structure of the object."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Python have a motto (something like that):"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["So, in my opinion, it is better you use combine that overloading + operator "], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "combine", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "+", "childNum": 0, "tag": "code", "childList": []}]}]]