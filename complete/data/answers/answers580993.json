[[{"text": ["The two things will give slightly different results, unless it is guaranteed that a match will match one and only one regex.", "Otherwise if something matches 2 it will be counted twice."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In theory your solution ought to be quicker (if the expression are mutually exclusive) because the regex compiler ought to be able to make a more efficient search state machine, so only one pass is needed.", "I would expect the difference to be tiny though, unless the expressions are very similar. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also, if it were a huge string (bigger than 700k) there might be gains from doing one pass, and so a factor of n fewer memory swaps would be needed (to disk or cpu cache)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["My bet is in your tests it isn't really noticeable though.", "I'm interested in the actual result - please do post the results."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["To understand how re module works - compile _sre.c in debug mode (put #define VERBOSE at 103 line in _sre.c and recompile python).", "After this you ill see something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n >>> import re\n>>> p = re.compile('(a)|(b)|(c)')\n>>> p.search('a'); print '\\n\\n'; p.search('b')\n|0xb7f9ab10|(nil)|SEARCH\nprefix = (nil) 0 0\ncharset = (nil)\n|0xb7f9ab1a|0xb7fb75f4|SEARCH\n|0xb7f9ab1a|0xb7fb75f4|ENTER\nallocating sre_match_context in 0 (32)\nallocate/grow stack 1064\n|0xb7f9ab1c|0xb7fb75f4|BRANCH\nallocating sre_match_context in 32 (32)\n|0xb7f9ab20|0xb7fb75f4|MARK 0\n|0xb7f9ab24|0xb7fb75f4|LITERAL 97\n|0xb7f9ab28|0xb7fb75f5|MARK 1\n|0xb7f9ab2c|0xb7fb75f5|JUMP 20\n|0xb7f9ab56|0xb7fb75f5|SUCCESS\ndiscard data from 32 (32)\nlooking up sre_match_context at 0\n|0xb7f9ab1c|0xb7fb75f4|JUMP_BRANCH\ndiscard data from 0 (32)\n|0xb7f9ab10|0xb7fb75f5|END\n\n\n\n\n|0xb7f9ab10|(nil)|SEARCH\nprefix = (nil) 0 0\ncharset = (nil)\n|0xb7f9ab1a|0xb7fb7614|SEARCH\n|0xb7f9ab1a|0xb7fb7614|ENTER\nallocating sre_match_context in 0 (32)\nallocate/grow stack 1064\n|0xb7f9ab1c|0xb7fb7614|BRANCH\nallocating sre_match_context in 32 (32)\n|0xb7f9ab20|0xb7fb7614|MARK 0\n|0xb7f9ab24|0xb7fb7614|LITERAL 97\ndiscard data from 32 (32)\nlooking up sre_match_context at 0\n|0xb7f9ab1c|0xb7fb7614|JUMP_BRANCH\nallocating sre_match_context in 32 (32)\n|0xb7f9ab32|0xb7fb7614|MARK 2\n|0xb7f9ab36|0xb7fb7614|LITERAL 98\n|0xb7f9ab3a|0xb7fb7615|MARK 3\n|0xb7f9ab3e|0xb7fb7615|JUMP 11\n|0xb7f9ab56|0xb7fb7615|SUCCESS\ndiscard data from 32 (32)\nlooking up sre_match_context at 0\n|0xb7f9ab2e|0xb7fb7614|JUMP_BRANCH\ndiscard data from 0 (32)\n|0xb7f9ab10|0xb7fb7615|END\n\n>>>\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I suspect that the regex will also do what you are trying to do ... only much better :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["so the \"|\" would win"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I agree with amartynov but I wanted to add that you also might consider compiling the regex first (re.compile()), esp.", "in the second variant as then you might save some setup time in the loop.", "Maybe you can measure this as well while you are on it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The reason I think the one shot performs better is that I assume that it's fully done in C space and not so much python code needs to be interpreted."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["But looking forward to numbers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A single compile and search should yield faster results, on a lower scale of expressions the gain could be negligible but the more you run through the greater gain.", "Think of it as compiling once and matching vs compiling 10 times and matching."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I believe your first implementation will be faster:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "One of the key principles for Python performance is \"move logic to the C level\" -- meaning built-in functions (written in C) are faster than pure-Python implementations. So, when the loop is performed by the built-in Regex module, it should be faster", "tag": "none", "senID": 1}, {"text": "One regex can search for multiple pattens in one pass, meaning it only has to run through your file contents once, whereas multiple regex will have to read the whole file multiple times.", "tag": "none", "senID": 2}]}], [{"text": ["The fewer passes the better:  It'll just use more memory, which is typically not an issue."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If anything can be left to the interpreter to handle, it will always find a faster solution (both in time to implement and time to execute) than the typical human counterpart."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]