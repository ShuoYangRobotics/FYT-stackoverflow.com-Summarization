[[{"text": ["Python 3.1 has an ordered dict.", "use the class collections.OrderedDict to keep the elements in their order of insertions.", "beware that if you are overwriting an element, it keeps its place in the order, you need to delete and re-insert an element to make it last."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collections.OrderedDict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["if you are using an older release, a patch may be available to get OrderedDict. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["anyway, if it is not available, you may simply use a list of tuples: it can be easily converted to and from a dictionary, keeps its ordering, can be used like a queue with append and pop, ..."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "append", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pop", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Dictionaries don't preserve order, so you can't tell which element had been added first.", "You could combine the dictionary with a list of it's keys to preserve order."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's an activestate recipe for an ordered dict that does just this."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "activestate recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/496761/"}]}, {"text": ["There's also PEP-0372 with this patch for an odict class."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "PEP-0372", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0372/"}, {"href": "http://bugs.python.org/issue5397", "text": "patch", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Unless you had some kind of set number of elements, where you know which one is the oldest, then you could simply delete it.", "Otherwise, you're using the wrong data structure for what you're doing I think."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["EDIT: Though, according to a quick google, I've come across this.", "Oh I do like the collections module :)"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "EDIT", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "this.", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0372/"}, {"text": "collections", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I believe LRU dict-like container will suite your needs the best."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "LRU dict-like container", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/252524/"}]}], [{"text": ["One way to do this would be to store the keys in an array, which will preserve your order for you.", "Something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n MAXSIZE = 4\ndict = {}\nhistory = []\ndef add(key,value):\n    print len(dict)\n    if len(dict) == MAXSIZE:\n        old = history.pop(0) # returns the key to the oldest item\n        del dict[old]\n    history.append(key)\n    dict[key] = value\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, keep in mind that len() will always lag one item behind.", "When you are adding your fifth item, len(dict) is 4, not 5.", "You should use == instead of &gt;. "], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "len()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "len(dict)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "4", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "5", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "==", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "&gt;", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Alternatively a list of tuples could be used for this as well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n MAXSIZE = 4\nstack = []\n\ndef add(key, value):\n stack.append((key, value))\n if len(stack) &gt; MAXSIZE:\n  stack.pop(0)\n\n print stack\n\nadd('a','1')\nadd('b','2')\nadd('c','3')\nadd('d','4')\nadd('e','5')\n</code>\n</pre>\n", "senID": 1}, {"text": ["results in"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [('a', '1')]\n[('a', '1'), ('b', '2')]\n[('a', '1'), ('b', '2'), ('c', '3')]\n[('a', '1'), ('b', '2'), ('c', '3'), ('d', '4')]\n[('b', '2'), ('c', '3'), ('d', '4'), ('e', '5')]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note you do loose the speed of a dictionary lookup with this method.", "So if you need that a custom ordered dictionary may be in order. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You can find a implementation by the pocoo team here.", "I've always found their work to be excellent."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://dev.pocoo.org/hg/sandbox/raw-file/tip/odict.py"}]}], [{"text": ["Without knowing what you're really trying to use this structure for, here's\nsomething that may work for you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class DictCache:\n    def __init__(self, maxcount=4):\n        self.data = {}\n        self.lru = []\n        self.maxcount = maxcount\n    def add(self, key, value):\n        self.data[key] = value\n        self.lru.append(key)\n        if len(self.lru) &gt; self.maxcount:\n            dead = self.lru.pop(0)\n            del(self.data[dead])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Combine this with a get method that rearranges self.lru\nwhen they are accessed, and you can change your caching strategy to suit your\nusecase."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.lru", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["how about like this?", "put order in array and when its reach limit, pop it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n MAXSIZE = 4\ndict,order= {},[]\n\ndef add(key,value):\n    if len(dict) &gt; MAXSIZE:\n    \told = order.pop() # returns the key to the oldest item\n    \tdel dict[old]\n    order.insert(0,key)\n    dict[key] = value\n</code>\n</pre>\n", "senID": 1}]]