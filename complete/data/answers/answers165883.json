[[{"text": ["With regards to the single and double-leading underscores: both indicate the same concept of 'privateness'.", "That is to say, people will know the attribute (be it a method or a 'normal' data attribute or anything else) is not part of the public API of the object.", "People will know that to touch it directly is to invite disaster."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On top of that, the double-leading underscore attributes (but not the single-leading underscore attributes) are name-mangled to make accessing them by accident from subclasses or anywhere else outside the current class less likely.", "You can still access them, but not as trivially.", "For example:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "name-mangled", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "by accident", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class ClassA:\n...     def __init__(self):\n...         self._single = \"Single\"\n...         self.__double = \"Double\"\n...     def getSingle(self):\n...         return self._single\n...     def getDouble(self):\n...         return self.__double\n... \n&gt;&gt;&gt; class ClassB(ClassA):\n...     def getSingle_B(self):\n...         return self._single\n...     def getDouble_B(self):\n...         return self.__double\n... \n&gt;&gt;&gt; a = ClassA()\n&gt;&gt;&gt; b = ClassB()\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can now trivially access a._single and b._single and get the _single attribute created by ClassA:"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "a._single", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b._single", "childNum": 0, "tag": "code", "childList": []}, {"text": "_single", "childNum": 0, "tag": "code", "childList": []}, {"text": "ClassA", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a._single, b._single\n('Single', 'Single')\n&gt;&gt;&gt; a.getSingle(), b.getSingle(), b.getSingle_B()\n('Single', 'Single', 'Single')\n</code>\n</pre>\n", "senID": 4}, {"text": ["But trying to access the __double attribute on the a or b instance directly won't work:"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "__double", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a.__double\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: ClassA instance has no attribute '__double'\n&gt;&gt;&gt; b.__double\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: ClassB instance has no attribute '__double'\n</code>\n</pre>\n", "senID": 6}, {"text": ["And though methods defined in ClassA can get at it directly (when called on either instance):"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "ClassA", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a.getDouble(), b.getDouble()\n('Double', 'Double')\n</code>\n</pre>\n", "senID": 8}, {"text": ["Methods defined on ClassB can not:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "ClassB", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; b.getDouble_B()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 5, in getDouble_B\nAttributeError: ClassB instance has no attribute '_ClassB__double'\n</code>\n</pre>\n", "senID": 10}, {"text": ["And right in that error you get a hint about what's happening.", "The __double attribute name, when accessed inside a class, is being name-mangled to include the name of the class that it is being accessed in.", "When ClassA tries to access self.__double, it actually turns -- at compiletime -- into an access of self._ClassA__double, and likewise for ClassB.", "(If a method in ClassB were to assign to __double, not included in the code for brevity, it would therefor not touch ClassA's __double but create a new attribute.", ") There is no other protection of this attribute, so you can still access it directly if you know the right name:"], "childNum": 10, "tag": "p", "senID": 11, "childList": [{"text": "__double", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "in", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "ClassA", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "self.__double", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "self._ClassA__double", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ClassB", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ClassB", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__double", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ClassA", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__double", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a._ClassA__double, b._ClassA__double\n('Double', 'Double')\n</code>\n</pre>\n", "senID": 12}, {"text": ["So why is this a problem?"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "So why is this a problem?", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Well, it's a problem any time you want to inherit and change the behaviour of any code dealing with this attribute.", "You either have to reimplement everything that touches this double-underscore attribute directly, or you have to guess at the class name and mangle the name manually.", "The problem gets worse when this double-underscore attribute is actually a method: overriding the method or calling the method in a subclass means doing the name-mangling manually, or reimplementing all the code that calls the method to not use the double-underscore name.", "Not to mention accessing the attribute dynamically, with getattr(): you will have to manually mangle there, too."], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "or calling the method in a subclass", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "getattr()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["On the other hand, because the attribute is only trivially rewritten, it offers only superficial 'protection'.", "Any piece of code can still get at the attribute by manually mangling, although that will make their code dependant on the name of your class, and efforts on your side to refactor your code or rename your class (while still keeping the same user-visible name, a common practice in Python) would needlessly break their code.", "They can also 'trick' Python into doing the name-mangling for them by naming their class the same as yours: notice how there is no module name included in the mangled attribute name.", "And lastly, the double-underscore attribute is still visible in all attribute lists and all forms of introspection that don't take care to skip attributes starting with a (single) underscore."], "childNum": 3, "tag": "p", "senID": 15, "childList": [{"text": "their", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "your", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "single", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["So, if you use double-underscore names, use them exceedingly sparingly, as they can turn out quite inconvenient, and never use them for methods or anything else a subclass may ever want to reimplement, override or access directly.", "And realize that double-leading underscore name-mangling offers no real protection.", "In the end, using a single leading underscore wins you just as much and gives you less (potential, future) pain.", "Use a single leading underscore."], "childNum": 3, "tag": "p", "senID": 16, "childList": [{"text": "if", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "or anything else a subclass may ever want to reimplement, override or access directly", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "no real protection", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["The generally accepted way of doing things is just using simple attributes, like so"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n >>> class MyClass:\n...     myAttribute = 0\n... \n>>> c = MyClass()\n>>> c.myAttribute \n0\n>>> c.myAttribute = 1\n>>> c.myAttribute\n1\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you do find yourself needing to be able to write getters and setters, then what you want to look for is \"python class properties\" and this article is a great place to start (albeit a little long)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://tomayko.com/writings/getters-setters-fuxors"}]}], [{"text": ["Single underscore doesn't mean anything special to python, it is just best practice, to tell \"hey you probably don't want to access this unless you know what you are doing\".", "Double underscore however makes python mangle the name internally making it accessible only from the class where it is defined."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Double leading AND trailing underscore denotes a special function, such as __add__ which is called when using the + operator."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__add__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Read more in PEP 8, especially the \"Naming Conventions\" section."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "PEP 8", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0008/"}]}], [{"text": ["I think most just access them directly, no need for get/set methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class myclass:\n...     x = 'hello'\n...\n&gt;&gt;&gt;\n&gt;&gt;&gt; class_inst = myclass()\n&gt;&gt;&gt; class_inst.x\n'hello'\n&gt;&gt;&gt; class_inst.x = 'world'\n&gt;&gt;&gt; class_inst.x\n'world'\n</code>\n</pre>\n", "senID": 1}, {"text": ["BTW, you can use the dir() function to see what attributes/methods are attached to your instance:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dir(class_inst)\n['__doc__', '__module__', 'x']\n</code>\n</pre>\n", "senID": 3}, {"text": ["Two leading underbars, \"__\" are used to make a attribute or function private.", "For other conventions refer to PEP 08:\nhttp://www.python.org/dev/peps/pep-0008/"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://www.python.org/dev/peps/pep-0008/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0008/"}]}], [{"text": ["Python does not need to define accessors right from the beginning, since converting attributes into properties is quick and painless.", "See the following for a vivid demonstration:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Recovery from Addiction"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Recovery from Addiction", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.archive.org/details/SeanKellyRecoveryfromAddiction"}]}], [{"text": ["There is no real point of doing getter/setters in python, you can't protect stuff anyway and if you need to execute some extra code when getting/setting the property look at the property() builtin (python -c 'help(property)')"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Some people use getters and setters.", "Depending on which coding style you use you can name them getSpam and seteggs.", "But you can also make you attributes readonly or assign only.", "That's  a bit awkward to do.", "One way is overriding the "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt; __getattr__\n</code>\n</pre>\n", "senID": 1}, {"text": ["and "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt; __setattr__\n</code>\n</pre>\n", "senID": 3}, {"text": ["methods."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit:"], "childNum": 0, "tag": "h2", "senID": 5, "childList": []}, {"text": ["While my answer is still true, it's not right, as I came to realize.", "There are better ways to make accessors in python and are not very awkward."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]