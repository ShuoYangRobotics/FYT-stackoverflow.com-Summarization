[[{"text": ["Remove the 'while True' line and this bit:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n elif line=='':\n    break\n</code>\n</pre>\n", "senID": 1}, {"text": ["and then replace this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for line in filename:\n    line=f.readline()\n</code>\n</pre>\n", "senID": 3}, {"text": ["with this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for line in f:\n</code>\n</pre>\n", "senID": 5}, {"text": ["Now you'll be looping over the lines in the file."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Next, replace all of these sorts of things:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n if line=='(':\n    c1=line.count('(')\n</code>\n</pre>\n", "senID": 8}, {"text": ["with:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n c1+=line.count('(')\n</code>\n</pre>\n", "senID": 10}, {"text": ["The if and elif lines are just preventing you from counting when you should.", "If the line doesn't have what you're looking for the count will be 0, which is fine."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["That should at least get you closer to a solution."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["I believe, You are looking for balanced symbol checker.", "It is better to use stack."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["hth."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Do you want to ensure that they parens &amp; braces are matched?", "That \"[(])\" fails?", "If not, you're along the right path, except that you need to change your \"=\" to \"+=\".", "You're discarding the values of previous lines."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think if you change the:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if line=='(':\n                 c1=line.count('(')\n            elif line==')':\n                 c2=line.count(')')\n            elif line=='[':\n                 c3=line.count('[')\n            elif line==']':\n                 c4=line.count(']')\n            elif line=='':\n                break\n</code>\n</pre>\n", "senID": 1}, {"text": ["to something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n SearchFor = ['(', ')', '[', ']']\nd = {}\nfor itm in SearchFor:\n    d[itm] = line.count(itm)\n\n\n# Then do the comparison\nif d['['] == d[']'] and  d['('] == d[')']:\n     print \"Valid Syntax\"\nelse:\n     print \"Invalid Syntax\" #You could look at each to find the exact cause.\n</code>\n</pre>\n", "senID": 3}, {"text": ["and the While True: as mentioned by others.", "I had missed that.", ":0)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "While True:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["My solution will try to help you understand a bit more precise way of doing this, and hopefully you'll learn a bit about data structures in the process."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To properly do this, you're going to want to use a stack.", "You'll want to pull out all instances of (, ), [, and ] (perhaps using a regular expression... hint) and go through the array that that generates:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "properly", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "stack", "tag": "a", "pos": -1, "childList": [{"text": "stack", "tag": "strong"}], "childNum": 1, "href": "http://en.wikipedia.org/wiki/Stack%5F%28data%5Fstructure%29"}, {"text": "stack", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Say your file is like this: "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (this [is] foobar)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Your regular expression will yield this array:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n ['(', '[', ']', ')']\n</code>\n</pre>\n", "senID": 5}, {"text": ["You will pop(0) off of this array into a stack. "], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "pop(0)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Algorithmically:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Algorithmically", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["1) Put all tags {(,),[,]} in an array."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["2) For each element in the array, pop(0) from it and push it onto your stack.", "Test it against the element before it.", "If it closes the element before it, then pop() twice from the array (eg, if you have '(' on the stack, and the next element to be pushed onto the stack is a ')', ')' closes '(', so you pop them both.", ") If it doesn't, continue. "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["3) If your array is empty and your stack is empty when this is over, then your file is well formed.", "If it's not, then you have a poorly formed file {something like (foo[bar)] }."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Bonus: regular expression: REGEX = re.compile(r\"\\)\\(\\[\\]\"), REGEX.findall(your string to search).", "See more about regexes in Python here."], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "Bonus:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/howto/regex.html"}]}], [{"text": ["Ok, why should you be doing this on your own??", "you should get a syntax checker.", "I am sure you can search for one in PyPi. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["All of these answers are wrong and will not work in all cases, so either use python parser e.g.", "tokenize etc or just use this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["count = min(text.count(\"(\"), text.count(\")\"))"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Please excuse the length of this reply."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If I understand you correctly, you want to do simple syntax\nchecking of parentheses to make sure they are balanced correctly.", "In your question you specify a test based on simple counting, but\nas others have pointed out, this does not catch things like\n\"([)]\"."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I'd also like to offer some constructive criticism on other\naspects of your code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["To start with, it is better to get the filename from the command\nline, and not to prompt for it.", "This is so that you can easily\nrun the program repeatedly, when developing it, without having\nto type in the filename all the time.", "This is your way:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You need to type in the filename every time.", "You don't need to type\nin the command to run the program more than once.", "After the first\ntime, you can use the arrow key to get it from the shell's command\nhistory.", "If you get the filename from the command line, you can do\nthis instead:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["This way, when you test the second time, you don't need to type more\nthan the up arrow and Enter keys.", "This is a small convenience, but\nit is important: when you're developing software, even small \nthings can start annoying.", "It's like a large grain of sand under your\nfoot when going on a long walk: you won't even notice it for the first\ncouple of kilometers, but after a few more, you're bleeding."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["In Python, to access the command line arguments, you need the\nsys.argv list.", "The relevant changes to your program:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "sys.argv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import sys\nfilename = sys.argv[1]\n</code>\n</pre>\n", "senID": 7}, {"text": ["If you do want to prompt, you should use something else than the\nbuilt-in input function.", "It interprets whatever the user types\nas a Python expression, and that causes all sorts of problems.", "You could read using sys.stdin.readline."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "input", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sys.stdin.readline", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Anyway, we've now got the name of the file safely stored in\nthe filename variable.", "It's time to do something with it.", "Your parentheses function does pretty much everything, and\nexperience has shown that that's often not the best way of\ndoing things.", "Every function should, instead, do just one\nthing, but do that well."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "filename", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "parentheses", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["I suggest that you should keep the parts of actually opening\nand closing a file separate from the actual counting.", "This\nwill simplify the logic of the counting, since it does not\nneed to worry about the rest.", "In code:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\ndef check_parentheses(f):\n    pass # we'll come to this later\n\ndef main():\n    filename = sys.argv[1]\n    try:\n        f = file(filename)\n    except IOError:\n        sys.stderr.write('Error: Cannot open file %s' % filename)\n        sys.exit(1)\n    check_parentheses(f)\n    f.close()\n\nmain()\n</code>\n</pre>\n", "senID": 11}, {"text": ["I changed a couple of other things, too, in addition to rearranging\nthings.", "First, I write the error message to the standard error output.", "This is the proper way to do it, and means fewer surprises to shell\nusers to redirect the output.", "(If that doesn't make any sense to you,\ndon't worry about it, just accept it as a given for now."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Second, if there's an error, I exit the program with sys.exit(1).", "This tells whoever started the program that it failed.", "In Unix\nshell, this lets you do things like the following:"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "sys.exit(1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if python foo.py inputfile\nthen\n    echo \"inputfile is OK!\"\nelse\n    echo \"inputfile is BAD!\"\nfi\n</code>\n</pre>\n", "senID": 14}, {"text": ["The shell script might do something more interesting than just reporting\nsuccess or failure, of course.", "It might, for example, remove all\nbroken files, or e-mail whoever wrote them to ask them to fix them.", "The beauty is that you, who write the checker program, do not need\nto care.", "You just set the program exit code properly, and let whoever\nwrites the shell script to worry about the rest."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["The next step is to actually read the contents of the file.", "This\ncan be done in various ways.", "The easiest way is to do it line-by-line,\nlike this:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n for line in f:\n    # do something with the line\n</code>\n</pre>\n", "senID": 17}, {"text": ["We then need to look at each character in the line:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n for line in f:\n    for c in line:\n        # do something with the character\n</code>\n</pre>\n", "senID": 19}, {"text": ["We're now ready to actually start checking parentheses.", "As suggested\nby others, a stack is the appropriate data structure for this.", "A stack is basically a list (or array) where you add items to one\nend, and take them out in reverse order.", "Think of it as a stack of\ncoins: you can add a coin to the top, and you can remove the topmost\ncoin, but you can't remove one from the middle or bottom. "], "childNum": 1, "tag": "p", "senID": 20, "childList": [{"text": "stack", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["(Well, you can, and it's a neat trick if you do, but computers are\nsimple beasts and get upset by magic tricks."], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"text": ["We will use a Python list as a stack.", "To add an item, we use\nthe list's append method, and to remove we use the pop method.", "An example:"], "childNum": 2, "tag": "p", "senID": 22, "childList": [{"text": "append", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "pop", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n stack = list()\nstack.append('(')\nstack.append('[')\nstack.pop() # this will return '['\nstack.pop() # this will return '('\n</code>\n</pre>\n", "senID": 23}, {"text": ["To look at the topmost item in the stack, we use stack[-1] (in\nother words, the last item in the list)."], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "stack[-1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["We use the stack as follows: when we find an opening parentheses ('('),\nbracket ('['), or brace ('{'), we put it on the stack.", "When we\nfind a closing one, we check the topmost item on the stack, and\nmake sure that it matches the closing one.", "If not, we print an\nerror.", "Like this:"], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"code": "<pre>\n<code>\n def check_parentheses(f):\n    stack = list()\n    for line in f:\n        for c in line:\n            if c == '(' or c == '[' or c == '{':\n                stack.append(c)\n            elif c == ')':\n                if stack[-1] != '(':\n                    print 'Error: unmatched )'\n                else:\n                    stack.pop()\n            elif c == ']':\n                if stack[-1] != '[':\n                    print 'Error: unmatched ]'\n                else:\n                    stack.pop()\n            elif c == '}':\n                if stack[-1] != '{':\n                    print 'Error: unmatched }'\n                else:\n                    stack.pop()\n</code>\n</pre>\n", "senID": 26}, {"text": ["This now does find unmatched parentheses of various kinds.", "We\ncan improve it a little bit by reporting the line and column \nwhere we find the problem.", "We need a line number and column number\ncounter."], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"code": "<pre>\n<code>\n def error(c, line_number, column_number):\n    print 'Error: unmatched', c, 'line', line_number, 'column', column_number\n\ndef check_parentheses(f):\n    stack = list()\n    line_number = 0\n    for line in f:\n        line_number = line_number + 1\n        column_number = 0\n        for c in line:\n            column_number = column_number + 1\n            if c == '(' or c == '[' or c == '{':\n                stack.append(c)\n            elif c == ')':\n                if stack[-1] != '(':\n                    error(')', line_number, column_number)\n                else:\n                    stack.pop()\n            elif c == ']':\n                if stack[-1] != '[':\n                    error(']', line_number, column_number)\n                else:\n                    stack.pop()\n            elif c == '}':\n                if stack[-1] != '{':\n                    error('}', line_number, column_number)\n                else:\n                    stack.pop()\n</code>\n</pre>\n", "senID": 28}, {"text": ["Note also how I added a helper function, error, to do the actual\nprinting of the error message.", "If you want to change the error message,\nyou now only need to do it in one place."], "childNum": 1, "tag": "p", "senID": 29, "childList": [{"text": "error", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Another thing to notice is that the cases for handling the closing\nsymbols are all very similar.", "We could make that to a function, too."], "childNum": 0, "tag": "p", "senID": 30, "childList": []}, {"code": "<pre>\n<code>\n def check(stack, wanted, c, line_number, column_number):\n    if stack[-1] != wanted:\n        error(c, line_number, column_number)\n    else:\n        stack.pop()\n\ndef check_parentheses(f):\n    stack = list()\n    line_number = 0\n    for line in f:\n        line_number = line_number + 1\n        column_number = 0\n        for c in line:\n            column_number = column_number + 1\n            if c == '(' or c == '[' or c == '{':\n                stack.append(c)\n            elif c == ')':\n                check(stack, '(', ')', line_number, column_number)\n            elif c == ']':\n                check(stack, '[', ']', line_number, column_number)\n            elif c == '}':\n                check(stack, '{', '}', line_number, column_number)\n</code>\n</pre>\n", "senID": 31}, {"text": ["The program can be refined further, but this should suffice for now.", "I'll include the whole code at the end."], "childNum": 0, "tag": "p", "senID": 32, "childList": []}, {"text": ["Note that this program only cares about parentheses of various kinds.", "If you really want to check a whole Python program for syntactic\ncorrectness, you'll need to parse all of Python's syntax, and that\nis pretty complicated, and too much for one Stack Overflow answer.", "If that's what you really do want, please ask a followup question."], "childNum": 0, "tag": "p", "senID": 33, "childList": []}, {"text": ["The whole program:"], "childNum": 0, "tag": "p", "senID": 34, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\ndef error(c, line_number, column_number):\n    print 'Error: unmatched', c, 'line', line_number, 'column', column_number\n\ndef check(stack, wanted, c, line_number, column_number):\n    if stack[-1] != wanted:\n        error(c, line_number, column_number)\n    else:\n        stack.pop()\n\ndef check_parentheses(f):\n    stack = list()\n    line_number = 0\n    for line in f:\n        line_number = line_number + 1\n        column_number = 0\n        for c in line:\n            column_number = column_number + 1\n            if c == '(' or c == '[' or c == '{':\n                stack.append(c)\n            elif c == ')':\n                check(stack, '(', ')', line_number, column_number)\n            elif c == ']':\n                check(stack, '[', ']', line_number, column_number)\n            elif c == '}':\n                check(stack, '{', '}', line_number, column_number)\n\ndef main():\n    filename = sys.argv[1]\n    try:\n        f = file(filename)\n    except IOError:\n        sys.stderr.write('Error: Cannot open file %s' % filename)\n        sys.exit(1)\n    check_parentheses(f)\n    f.close()\n\nmain()\n</code>\n</pre>\n", "senID": 35}]]