[[{"text": ["There is an usage scenario where you might need this.", "I'm not implying there are not better ways or achieving the same functionality."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This would be useful in order to 'dump' an arbitrary list of dictionaries in case of error, in debug modes and other similar situations."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["What would be needed, is the reverse of the eval() function:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "eval()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n get_indentifier_name_missing_function()\n</code>\n</pre>\n", "senID": 3}, {"text": ["which would take an identifier name ('variable','dictionary',etc) as an argument, and return a \nstring containing the identifier\u2019s name."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Consider the following current state of affairs:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n random_function(argument_data)\n</code>\n</pre>\n", "senID": 6}, {"text": ["If one is passing an identifier name ('function','variable','dictionary',etc) argument_data to a random_function() (another identifier name), one actually passes an identifier (e.g.", ": &lt;argument_data object at 0xb1ce10&gt;) to another identifier  (e.g.", ": &lt;function random_function at 0xafff78&gt;):"], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "argument_data", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "random_function()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "&lt;argument_data object at 0xb1ce10&gt;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "&lt;function random_function at 0xafff78&gt;", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &lt;function random_function at 0xafff78&gt;(&lt;argument_data object at 0xb1ce10&gt;)\n</code>\n</pre>\n", "senID": 8}, {"text": ["From my understanding, only the memory address is passed to the function:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &lt;function at 0xafff78&gt;(&lt;object at 0xb1ce10&gt;)\n</code>\n</pre>\n", "senID": 10}, {"text": ["Therefore, one would need to pass a string as an argument to random_function() in order for that function to have the argument's identifier name:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "random_function()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n random_function('argument_data')\n</code>\n</pre>\n", "senID": 12}, {"text": ["Inside the random_function()"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n def random_function(first_argument):\n</code>\n</pre>\n", "senID": 14}, {"text": [", one would use the already supplied string 'argument_data' to:"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "'argument_data'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Unfortunately, this doesn't work in all cases.", "It only works if the random_function() can resolve the 'argument_data' string to an actual identifier.", "I.e.", "If argument_data identifier name is available in the random_function()'s namespace."], "childNum": 4, "tag": "p", "senID": 16, "childList": [{"text": "random_function()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'argument_data'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "argument_data", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "random_function()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This isn't always the case:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n # main1.py\nimport some_module1\n\nargument_data = 'my data'\n\nsome_module1.random_function('argument_data')\n\n\n# some_module1.py\ndef random_function(first_argument):\n    print(\"Currently working on\", first_argument)\n    some_internal_var = eval(first_argument)\n    print(\"here comes the data: \" + str(some_internal_var))\n######\n</code>\n</pre>\n", "senID": 18}, {"text": ["Expected results would be:"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n Currently working on: argument_data\nhere comes the data: my data\n</code>\n</pre>\n", "senID": 20}, {"text": ["Because argument_data identifier name is not available in the random_function()'s namespace, this would yield instead:"], "childNum": 2, "tag": "p", "senID": 21, "childList": [{"text": "argument_data", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "random_function()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n Currently working on argument_data\nTraceback (most recent call last):\n  File \"~/main1.py\", line 6, in &lt;module&gt;\n    some_module1.random_function('argument_data')\n  File \"~/some_module1.py\", line 4, in random_function\n    some_internal_var = eval(first_argument)\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\nNameError: name 'argument_data' is not defined\n</code>\n</pre>\n", "senID": 22}, {"text": ["Now, consider the hypotetical usage of a get_indentifier_name_missing_function() which would behave as described above."], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "get_indentifier_name_missing_function()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here's a dummy Python 3.0 code: ."], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"code": "<pre>\n<code>\n # main2.py\nimport some_module2\nsome_dictionary_1       = { 'definition_1':'text_1',\n                            'definition_2':'text_2',\n                            'etc':'etc.' }\nsome_other_dictionary_2 = { 'key_3':'value_3',\n                            'key_4':'value_4', \n                            'etc':'etc.' }\n#\n# more such stuff\n#\nsome_other_dictionary_n = { 'random_n':'random_n',\n                            'etc':'etc.' }\n\nfor each_one_of_my_dictionaries in ( some_dictionary_1,\n                                     some_other_dictionary_2,\n                                     ...,\n                                     some_other_dictionary_n ):\n    some_module2.some_function(each_one_of_my_dictionaries)\n\n\n# some_module2.py\ndef some_function(a_dictionary_object):\n    for _key, _value in a_dictionary_object.items():\n        print( get_indentifier_name_missing_function(a_dictionary_object)    +\n               \"    \" +\n               str(_key) +\n               \"  =  \" +\n               str(_value) )\n######\n</code>\n</pre>\n", "senID": 25}, {"text": ["Expected results would be:"], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"code": "<pre>\n<code>\n some_dictionary_1    definition_1  =  text_1\nsome_dictionary_1    definition_2  =  text_2\nsome_dictionary_1    etc  =  etc.\nsome_other_dictionary_2    key_3  =  value_3\nsome_other_dictionary_2    key_4  =  value_4\nsome_other_dictionary_2    etc  =  etc.\n......\n......\n......\nsome_other_dictionary_n    random_n  =  random_n\nsome_other_dictionary_n    etc  =  etc.\n</code>\n</pre>\n", "senID": 27}, {"text": ["Unfortunately, get_indentifier_name_missing_function() would not see the 'original' identifier names (some_dictionary_,some_other_dictionary_2,some_other_dictionary_n).", "It would only see the a_dictionary_object identifier name."], "childNum": 5, "tag": "p", "senID": 28, "childList": [{"text": "get_indentifier_name_missing_function()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "some_dictionary_", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "some_other_dictionary_2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "some_other_dictionary_n", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a_dictionary_object", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Therefore the real result would rather be:"], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"code": "<pre>\n<code>\n a_dictionary_object    definition_1  =  text_1\na_dictionary_object    definition_2  =  text_2\na_dictionary_object    etc  =  etc.\na_dictionary_object    key_3  =  value_3\na_dictionary_object    key_4  =  value_4\na_dictionary_object    etc  =  etc.\n......\n......\n......\na_dictionary_object    random_n  =  random_n\na_dictionary_object    etc  =  etc.\n</code>\n</pre>\n", "senID": 30}, {"text": ["So, the reverse of the eval() function won't be that useful in this case."], "childNum": 1, "tag": "p", "senID": 31, "childList": [{"text": "eval()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Currently, one would need to do this:"], "childNum": 0, "tag": "p", "senID": 32, "childList": []}, {"code": "<pre>\n<code>\n # main2.py same as above, except:\n\n    for each_one_of_my_dictionaries_names in ( 'some_dictionary_1',\n                                               'some_other_dictionary_2',\n                                               '...',\n                                               'some_other_dictionary_n' ):\n        some_module2.some_function( { each_one_of_my_dictionaries_names :\n                                     eval(each_one_of_my_dictionaries_names) } )\n\n\n    # some_module2.py\n    def some_function(a_dictionary_name_object_container):\n        for _dictionary_name, _dictionary_object in a_dictionary_name_object_container.items():\n            for _key, _value in _dictionary_object.items():\n                print( str(_dictionary_name) +\n                       \"    \" +\n                       str(_key) +\n                       \"  =  \" +\n                       str(_value) )\n    ######\n</code>\n</pre>\n", "senID": 33}, {"text": ["In conclusion:"], "childNum": 0, "tag": "h2", "senID": 34, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Python passes only memory addresses as arguments to functions.", "tag": "none", "senID": 35}, {"text": "Strings representing the name of an identifier, can only be referenced back to the actual identifier by the ", "tag": "none", "senID": 36}, {"text": "A hypothetical reverse of the ", "tag": "none", "senID": 37}, {"text": "Currently one needs to pass to a function:\n", "tag": "none", "senID": 38}]}, {"text": ["This can be achieved by passing both the 'string' and eval('string') to the called function at the same time.", "I think this is the most 'general' way of solving this egg-chicken problem across arbitrary functions, modules, namespaces, without using corner-case solutions.", "The only downside is the use of the eval() function which may easly lead to unsecured code.", "Care must be taken to not feed the eval() fuction with just about anything, especially unfiltered external-input data."], "childNum": 4, "tag": "p", "senID": 39, "childList": [{"text": "'string'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "eval('string')", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "eval()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "eval()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["This is not possible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In Python, there really isn't any such thing as a \"variable\".", "What Python really has are \"names\" which can have objects bound to them.", "It makes no difference to the object what names, if any, it might be bound to.", "It might be bound to dozens of different names, or none."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Consider this example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n foo = 1\nbar = 1\nbaz = 1\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now, suppose you have the integer object with value 1, and you want to work backwards and find its name.", "What would you print?", "Three different names have that object bound to them, and all are equally valid."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In Python, a name is a way to access an object, so there is no way to work with names directly.", "There might be some clever way to hack the Python bytecodes or something to get the value of the name, but that is at best a parlor trick."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["If you know you want print foo to print \"foo\", you might as well just execute print \"foo\" in the first place."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "print foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"foo\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "print \"foo\"", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["EDIT: I have changed the wording slightly to make this more clear.", "Also, here is an even better example:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n foo = 1\nbar = foo\nbaz = foo\n</code>\n</pre>\n", "senID": 8}, {"text": ["In practice, Python reuses the same object for integers with common values like 0 or 1, so the first example should bind the same object to all three names.", "But this example is crystal clear: the same object is bound to foo, bar, and baz."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["You somehow have to refer to the variable you want to print the name of.", "So it would look like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print varname(something_else)\n</code>\n</pre>\n", "senID": 1}, {"text": ["There is no such function, but if there were it would be kind of pointless.", "You have to type out something_else, so you can as well just type quotes to the left and right of it to print the name as a string:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "something_else", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n print \"something_else\"\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Technically the information is available to you, but as others have asked, how would you make use of it in a sensible way?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = 52\n&gt;&gt;&gt; globals()\n{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__name__': '__main__', \n'x': 52, '__doc__': None, '__package__': None}\n</code>\n</pre>\n", "senID": 1}, {"text": ["This shows that the variable name is present as a string in the globals() dictionary."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; globals().keys()[2]\n'x'\n</code>\n</pre>\n", "senID": 3}, {"text": ["In this case it happens to be the third key, but there's no reliable way to know where a given variable name will end up"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for k in globals().keys():\n...   if not k.startswith(\"_\"):\n...     print k\n...\nx\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 5}, {"text": ["You could filter out system variables like this, but you're still going to get all of your own items.", "Just running that code above created another variable \"k\" that changed the position of \"x\" in the dict."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["But maybe this is a useful start for you.", "If you tell us what you want this capability for, more helpful information could possibly be given."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["What are you trying to achieve?", "There is absolutely no reason to ever do what you describe, and there is likely a much better solution to the problem you're trying to solve.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The most obvious alternative to what you request is a dictionary.", "For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; my_data = {'var': 'something'}\n&gt;&gt;&gt; my_data['something_else'] = 'something'\n&gt;&gt;&gt; print my_data.keys()\n['var', 'something_else']\n&gt;&gt;&gt; print my_data['var']\nsomething\n</code>\n</pre>\n", "senID": 2}, {"text": ["Mostly as a.. challenge, I implemented your desired output.", "Do not use this code, please!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python2.6\nclass NewLocals:\n    \"\"\"Please don't ever use this code..\"\"\"\n    def __init__(self, initial_locals):\n        self.prev_locals = list(initial_locals.keys())\n\n    def show_new(self, new_locals):\n        output = \", \".join(list(set(new_locals) - set(self.prev_locals)))\n        self.prev_locals = list(new_locals.keys())\n        return output\n# Set up\neww = None\neww = NewLocals(locals())\n\n# \"Working\" requested code\n\nvar = {}\n\nprint eww.show_new(locals())  # Outputs: var\n\nsomething_else = 3\nprint eww.show_new(locals()) # Outputs: something_else\n\n# Further testing\n\nanother_variable = 4\nand_a_final_one = 5\n\nprint eww.show_new(locals()) # Outputs: another_variable, and_a_final_one\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n print \"var\"\nprint \"something_else\"\n</code>\n</pre>\n", "senID": 0}, {"text": ["Or did you mean something_else?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Does Django not do this when generating field names?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.djangoproject.com/en/dev//topics/db/models/#verbose-field-names"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.djangoproject.com/en/dev//topics/db/models/#verbose-field-names", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev//topics/db/models/#verbose-field-names"}]}, {"text": ["Seems reasonable to me."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This will work for simnple data types (str, int, float, list etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["a: 5"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["b: ['hello', ',world!", "']"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I searched for this question because I wanted a Python program to print assignment statements for some of the variables in the program.", "For example, it might print \"foo = 3, bar = 21, baz = 432\".", "The print function would need the variable names in string form.", "I could have provided my code with the strings \"foo\",\"bar\", and \"baz\", but that felt like repeating myself.", "After reading the previous answers, I developed the solution below."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The globals() function behaves like a dict with variable names (in the form of strings) as keys.", "I wanted to retrieve from globals() the key corresponding to the value of each variable.", "The method globals().items() returns a list of tuples; in each tuple the first item is the variable name (as a string) and the second is the variable value.", "My variablename() function searches through that list to find the variable name(s) that corresponds to the value of the variable whose name I need in string form."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The function itertools.ifilter() does the search by testing each tuple in the globals().items() list with the function lambda x: var is globals()[x[0]].", "In that function x is the tuple being tested; x[0] is the variable name (as a string) and x[1] is the value.", "The lambda function tests whether the value of the tested variable is the same as the value of the variable passed to variablename().", "In fact, by using the is operator, the lambda function tests whether the name of the tested variable is bound to the exact same object as the variable passed to variablename().", "If so, the tuple passes the test and is returned by ifilter()."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "lambda x: var is globals()[x[0]]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "is", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The itertools.ifilter() function actually returns an iterator which doesn't return any results until it is called properly.", "To get it called properly, I put it inside a list comprehension [tpl[0] for tpl ... globals().items())].", "The list comprehension saves only the variable name tpl[0], ignoring the variable value.", "The list that is created contains one or more names (as strings) that are bound to the value of the variable passed to variablename()."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "[tpl[0] for tpl ... globals().items())]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "tpl[0]", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["In the uses of variablename() shown below, the desired string is returned as an element in a list.", "In many cases, it will be the only item in the list.", "If another variable name is assigned the same value, however, the list will be longer."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def variablename(var):\n...     import itertools\n...     return [tpl[0] for tpl in \n...     itertools.ifilter(lambda x: var is x[1], globals().items())]\n... \n&gt;&gt;&gt; var = {}\n&gt;&gt;&gt; variablename(var)\n['var']\n&gt;&gt;&gt; something_else = 3\n&gt;&gt;&gt; variablename(something_else)\n['something_else']\n&gt;&gt;&gt; yet_another = 3\n&gt;&gt;&gt; variablename(something_else)\n['yet_another', 'something_else']\n</code>\n</pre>\n", "senID": 5}]]