[[{"text": ["If you don't want to have 2 problems:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for word in file('myfile.txt').read().split():\n    if 'x' in word and 'z' in word:\n        print word\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Assuming you have the entire file as one large string in memory, and that the definition of a word is \"a contiguous sequence of letters\", then you could do something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nfor word in re.findall(r\"\\w+\", mystring):\n    if 'x' in word and 'z' in word:\n        print word\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I just want to point out how heavy-handed some of these regular expressions can be, in comparison to the simple string methods-based solution provided by Wooble."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "string methods-based solution provided by Wooble", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3962846/how-to-display-all-words-that-contain-these-characters/3962943#3962943"}]}, {"text": ["Let's do some timings, shall we?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\nimport timeit\nimport re\nimport sys\n\nWORD_RE_COMPILED = re.compile(r'\\w+')\nZ_RE_COMPILED = re.compile(r'(\\b\\w*z\\w*\\b)')\nXZ_RE_COMPILED = re.compile(r'\\b(\\w*z\\w*x\\w*|\\w*x\\w*z\\w*)\\b')\n\n##########################\n# Tim Pietzcker's solution\n# http://stackoverflow.com/questions/3962846/how-to-display-all-words-that-contain-these-characters/3962876#3962876\n#\ndef xz_re_word_find(text):\n    for word in re.findall(r'\\w+', text):\n        if 'x' in word and 'z' in word:\n            print word\n\n\n# Tim's solution, compiled\ndef xz_re_word_compiled_find(text):\n    pattern = re.compile(r'\\w+')\n    for word in pattern.findall(text):\n        if 'x' in word and 'z' in word:\n            print word\n\n\n# Tim's solution, with the RE pre-compiled so compilation doesn't get\n# included in the search time\ndef xz_re_word_precompiled_find(text):\n    for word in WORD_RE_COMPILED.findall(text):\n        if 'x' in word and 'z' in word:\n            print word\n\n\n################################\n# Steven Rumbalski's solution #1\n# (provided in the comment)\n# http://stackoverflow.com/questions/3962846/how-to-display-all-words-that-contain-these-characters/3963285#3963285\ndef xz_re_z_find(text):\n    for word in re.findall(r'(\\b\\w*z\\w*\\b)', text):\n        if 'x' in word:\n            print word\n\n\n# Steven's solution #1 compiled\ndef xz_re_z_compiled_find(text):\n    pattern = re.compile(r'(\\b\\w*z\\w*\\b)')\n    for word in pattern.findall(text):\n        if 'x' in word:\n            print word\n\n\n# Steven's solution #1 with the RE pre-compiled\ndef xz_re_z_precompiled_find(text):\n    for word in Z_RE_COMPILED.findall(text):\n        if 'x' in word:\n            print word\n\n\n################################\n# Steven Rumbalski's solution #2\n# http://stackoverflow.com/questions/3962846/how-to-display-all-words-that-contain-these-characters/3962934#3962934\ndef xz_re_xz_find(text):\n    for word in re.findall(r'\\b(\\w*z\\w*x\\w*|\\w*x\\w*z\\w*)\\b', text):\n        print word\n\n\n# Steven's solution #2 compiled\ndef xz_re_xz_compiled_find(text):\n    pattern = re.compile(r'\\b(\\w*z\\w*x\\w*|\\w*x\\w*z\\w*)\\b')\n    for word in pattern.findall(text):\n        print word\n\n\n# Steven's solution #2 pre-compiled\ndef xz_re_xz_precompiled_find(text):\n    for word in XZ_RE_COMPILED.findall(text):\n        print word\n\n\n#################################\n# Wooble's simple string solution\ndef xz_str_find(text):\n    for word in text.split():\n        if 'x' in word and 'z' in word:\n            print word\n\n\nfunctions = [\n        'xz_re_word_find',\n        'xz_re_word_compiled_find',\n        'xz_re_word_precompiled_find',\n        'xz_re_z_find',\n        'xz_re_z_compiled_find',\n        'xz_re_z_precompiled_find',\n        'xz_re_xz_find',\n        'xz_re_xz_compiled_find',\n        'xz_re_xz_precompiled_find',\n        'xz_str_find'\n]\n\nimport_stuff = functions + [\n        'text',\n        'WORD_RE_COMPILED',\n        'Z_RE_COMPILED',\n        'XZ_RE_COMPILED'\n]\n\n\nif __name__ == '__main__':\n\n    text = open(sys.argv[1]).read()\n    timings = {}\n    setup = 'from __main__ import ' + ','.join(import_stuff)\n    for func in functions:\n        statement = func + '(text)'\n        timer = timeit.Timer(statement, setup)\n        min_time = min(timer.repeat(3, 10))\n        timings[func] = min_time\n\n\n    for func in functions:\n        print func + \":\", timings[func], \"seconds\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["Running this script on a plaintext copy of Moby Dick obtained from Project Gutenberg, on Python 2.6, I get the following timings:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "plaintext copy of Moby Dick", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.gutenberg.org/ebooks/2701.txt.utf8"}, {"href": "http://www.gutenberg.org/", "text": "Project Gutenberg", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n xz_re_word_find: 1.21829485893 seconds\nxz_re_word_compiled_find: 1.42398715019 seconds\nxz_re_word_precompiled_find: 1.40110301971 seconds\nxz_re_z_find: 0.680151939392 seconds\nxz_re_z_compiled_find: 0.673038005829 seconds\nxz_re_z_precompiled_find: 0.673489093781 seconds\nxz_re_xz_find: 1.11700701714 seconds\nxz_re_xz_compiled_find: 1.12773990631 seconds\nxz_re_xz_precompiled_find: 1.13285303116 seconds\nxz_str_find: 0.590088844299 seconds\n</code>\n</pre>\n", "senID": 4}, {"text": ["In Python 3.1 (after using 2to3 to fix the print statements), I get the following timings:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "2to3", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/2to3.html"}]}, {"code": "<pre>\n<code>\n xz_re_word_find: 2.36110496521 seconds\nxz_re_word_compiled_find: 2.34727501869 seconds\nxz_re_word_precompiled_find: 2.32607793808 seconds\nxz_re_z_find: 1.32204890251 seconds\nxz_re_z_compiled_find: 1.34104800224 seconds\nxz_re_z_precompiled_find: 1.34424304962 seconds\nxz_re_xz_find: 2.33851099014 seconds\nxz_re_xz_compiled_find: 2.29653286934 seconds\nxz_re_xz_precompiled_find: 2.32416701317 seconds\nxz_str_find: 0.656699895859 seconds\n</code>\n</pre>\n", "senID": 6}, {"text": ["We can see that the regular expression-based functions tend to take twice as long to run as the string methods-based function in Python 2.6, and over 3 times as long in Python 3.", "The time difference is trivial for one-off parsing (nobody's going to miss those milliseconds), but for cases where the function must be called many times, the string methods-based approach is both simpler and faster."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; pattern = re.compile('\\b(\\w*z\\w*x\\w*|\\w*x\\w*z\\w*)\\b')\n&gt;&gt;&gt; document = '''Here is some data that needs\n... to be searched for words that contain both z\n... and x.  Blah xz zx blah jal akle asdke asdxskz\n... zlkxlk blah bleh foo bar'''\n&gt;&gt;&gt; print pattern.findall(document)\n['xz', 'zx', 'asdxskz', 'zlkxlk']\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I do not know the performance of this generator, but for me this is the way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import print_function\nimport string\n\nbookfile = '11.txt' # Alice in Wonderland\nhunted = 'az' # in your case xz but there is none of those in this book\n\nwith open(bookfile) as thebook:\n    # read text of book and split from white space\n    print('\\n'.join(set(word.lower().strip(string.punctuation)\n                    for word in thebook.read().split()\n                    if all(c in word.lower() for c in hunted))))\n\"\"\" Output:\nzealand\ncrazy\ngrazed\nlizard's\norganized\nlazy\nzigzag\nlizard\nlazily\ngazing\n\"\"\n</code>\n</pre>\n", "senID": 1}, {"text": [], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Sounds like a job for Regular Expressions.", "Read that and try it out.", "If you run into problems, update your question and we can help you with the specifics."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Regular Expressions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/howto/regex.html"}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; print re.findall('(\\w*x\\w*z\\w*|\\w*z\\w*x\\w*)', 'axbzc azb axb abc axzb')\n['axbzc', 'axzb']\n</code>\n</pre>\n", "senID": 0}]]