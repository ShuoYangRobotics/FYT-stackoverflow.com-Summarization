[[{"text": ["There are many things you can try after optimizing your Python code for speed.", "If this program doesn't need C extensions, you can run it under PyPy to benefit from its JIT compiler.", "You can try making a C extension for possibly huge speedups.", "Shed Skin will even allow you to convert your Python program to a standalone C++ binary."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "PyPy", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypy.org/download.html"}, {"text": "C extension", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4616129/in-python-why-is-a-module-implemented-in-c-faster-than-a-pure-python-module-and/4619520#4619520"}, {"text": "huge speedups", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4650243/convert-python-program-to-c-c-code"}, {"text": "Shed Skin", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://code.google.com/p/shedskin/"}]}, {"text": ["I'm willing to time your program under these different optimization scenarios if you can provide enough code for benchmarking,"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: First of all, I have to agree with everyone else: are you sure you're measuring the time correctly?", "The example code runs 100 times in under 0.1 seconds here, so there is a good chance the either the time is wrong or you have a bottleneck (IO?", ") that isn't present in the code sample."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["That said, I made it 300000 people so times were consistent.", "Here's the adapted code, shared by CPython (2.5), PyPy and Shed Skin:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from time import time\nimport random\nimport sys\n\n\nclass person(object):\n    def __init__(self, util):\n        self.utility = util\n        self.customer = 0\n\n\nclass population(object):\n    def __init__(self, numpeople, util):\n        self.people = []\n        self.cus = []\n        self.noncus = []\n        for u in util:\n            per = person(u)\n            self.people.append(per)\n\n\ndef f_w_append(popn):\n    '''Function with append'''\n    P = 75\n    cus = []\n    noncus = []\n    # Help CPython a bit\n    # cus_append, noncus_append = cus.append, noncus.append\n    for per in popn.people:\n        if  per.utility &gt;= P:\n            per.customer = 1\n            cus.append(per)\n        else:\n            per.customer = 0\n            noncus.append(per)\n    return len(cus)\n\n\ndef f_wo_append(popn):\n    '''Function without append'''\n    P = 75\n    for per in popn.people:\n        if  per.utility &gt;= P:\n            per.customer = 1\n        else:\n            per.customer = 0\n\n    numcustomers = 0\n    for per in popn.people:\n        if per.customer == 1:\n            numcustomers += 1\n    return numcustomers\n\n\ndef main():\n    try:\n        numpeople = int(sys.argv[1])\n    except:\n        numpeople = 300000\n\n    print \"Running for %s people, 100 times.\" % numpeople\n\n    begin = time()\n    random.seed(1)\n    # Help CPython a bit\n    uniform = random.uniform\n    util = [uniform(0.0, 300.0) for _ in xrange(numpeople)]\n    # util = [random.uniform(0.0, 300.0) for _ in xrange(numpeople)]\n\n    popn1 = population(numpeople, util)\n    start = time()\n    for _ in xrange(100):\n        r = f_wo_append(popn1)\n    print r\n    print \"Without append: %s\" % (time() - start)\n\n\n    popn2 = population(numpeople, util)\n    start = time()\n    for _ in xrange(100):\n        r = f_w_append(popn2)\n    print r\n    print \"With append: %s\" % (time() - start)\n\n    print \"\\n\\nTotal time: %s\" % (time() - begin)\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 4}, {"text": ["Running with PyPy is as simple as running with CPython, you just type 'pypy' instead of 'python'.", "For Shed Skin, you must convert to C++, compile and run:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n shedskin -e makefaster.py &amp;&amp; make \n\n# Check that you're using the makefaster.so file and run test\npython -c \"import makefaster; print makefaster.__file__; makefaster.main()\"\n</code>\n</pre>\n", "senID": 6}, {"text": ["And here is the Cython-ized code:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n from time import time\nimport random\nimport sys\n\n\ncdef class person:\n    cdef readonly int utility\n    cdef public int customer\n\n    def __init__(self, util):\n        self.utility = util\n        self.customer = 0\n\n\nclass population(object):\n    def __init__(self, numpeople, util):\n        self.people = []\n        self.cus = []\n        self.noncus = []\n        for u in util:\n            per = person(u)\n            self.people.append(per)\n\n\ncdef int f_w_append(popn):\n    '''Function with append'''\n    cdef int P = 75\n    cdef person per\n    cus = []\n    noncus = []\n    # Help CPython a bit\n    # cus_append, noncus_append = cus.append, noncus.append\n\n    for per in popn.people:\n        if  per.utility &gt;= P:\n            per.customer = 1\n            cus.append(per)\n        else:\n            per.customer = 0\n            noncus.append(per)\n    cdef int lcus = len(cus)\n    return lcus\n\n\ncdef int f_wo_append(popn):\n    '''Function without append'''\n    cdef int P = 75\n    cdef person per\n    for per in popn.people:\n        if  per.utility &gt;= P:\n            per.customer = 1\n        else:\n            per.customer = 0\n\n    cdef int numcustomers = 0\n    for per in popn.people:\n        if per.customer == 1:\n            numcustomers += 1\n    return numcustomers\n\n\ndef main():\n\n    cdef int i, r, numpeople\n    cdef double _0, _300\n    _0 = 0.0\n    _300 = 300.0\n\n    try:\n        numpeople = int(sys.argv[1])\n    except:\n        numpeople = 300000\n\n    print \"Running for %s people, 100 times.\" % numpeople\n\n    begin = time()\n    random.seed(1)\n    # Help CPython a bit\n    uniform = random.uniform\n    util = [uniform(_0, _300) for i in xrange(numpeople)]\n    # util = [random.uniform(0.0, 300.0) for _ in xrange(numpeople)]\n\n    popn1 = population(numpeople, util)\n    start = time()\n    for i in xrange(100):\n        r = f_wo_append(popn1)\n    print r\n    print \"Without append: %s\" % (time() - start)\n\n\n    popn2 = population(numpeople, util)\n    start = time()\n    for i in xrange(100):\n        r = f_w_append(popn2)\n    print r\n    print \"With append: %s\" % (time() - start)\n\n    print \"\\n\\nTotal time: %s\" % (time() - begin)\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 8}, {"text": ["For building it, it's nice to have a setup.py like this one:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n from distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Distutils import build_ext\n\next_modules = [Extension(\"cymakefaster\", [\"makefaster.pyx\"])]\n\nsetup(\n  name = 'Python code to speed up',\n  cmdclass = {'build_ext': build_ext},\n  ext_modules = ext_modules\n)\n</code>\n</pre>\n", "senID": 10}, {"text": ["You build it with:\n    python setupfaster.py build_ext --inplace"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Then test:\n    python -c \"import cymakefaster; print cymakefaster.file; cymakefaster.main()\"  "], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "file", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Timings were run five times for each version, with Cython being the fastest and easiest of the code generators to use (Shed Skin aims to be simpler, but cryptic error messages and implicit static typing made it harder here).", "As for best value, PyPy gives impressive speedup in the counter version with no code changes. "], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n #Results (time in seconds for 30000 people, 100 calls for each function):\n                  Mean      Min  Times    \nCPython 2.5.2\nWithout append: 35.037   34.518  35.124, 36.363, 34.518, 34.620, 34.559\nWith append:    29.251   29.126  29.339, 29.257, 29.259, 29.126, 29.272\nTotal time:     69.288   68.739  69.519, 70.614, 68.746, 68.739, 68.823\n\nPyPy 1.4.1\nWithout append:  2.672    2.655   2.655,  2.670,  2.676,  2.690,  2.668\nWith append:    13.030   12.672  12.680, 12.725, 14.319, 12.755, 12.672\nTotal time:     16.551   16.194  16.196, 16.229, 17.840, 16.295, 16.194\n\nShed Skin 0.7 (gcc -O2)\nWithout append:  1.601    1.599   1.599,  1.605,  1.600,  1.602,  1.599\nWith append:     3.811    3.786   3.839,  3.795,  3.798,  3.786,  3.839\nTotal time:      5.704    5.677   5.715,  5.705,  5.699,  5.677,  5.726\n\nCython 0.14 (gcc -O2)\nWithout append:  1.692    1.673   1.673,  1.710,  1.678,  1.688,  1.711\nWith append:     3.087    3.067   3.079,  3.080,  3.119,  3.090,  3.067\nTotal time:      5.565    5.561   5.562,  5.561,  5.567,  5.562,  5.572\n</code>\n</pre>\n", "senID": 14}, {"text": ["Edit: Aaaand more meaningful timings, for 80000 calls with 300 people each:"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Results (time in seconds for 300 people, 80000 calls for each function):\n                  Mean      Min  Times\nCPython 2.5.2\nWithout append: 27.790   25.827  25.827, 27.315, 27.985, 28.211, 29.612\nWith append:    26.449   24.721  24.721, 27.017, 27.653, 25.576, 27.277\nTotal time:     54.243   50.550  50.550, 54.334, 55.652, 53.789, 56.892\n\n\nCython 0.14 (gcc -O2)\nWithout append:  1.819    1.760   1.760,  1.794,  1.843,  1.827,  1.871\nWith append:     2.089    2.063   2.100,  2.063,  2.098,  2.104,  2.078\nTotal time:      3.910    3.859   3.865,  3.859,  3.944,  3.934,  3.951\n\nPyPy 1.4.1\nWithout append:  0.889    0.887   0.894,  0.888,  0.890,  0.888,  0.887\nWith append:     1.671    1.665   1.665,  1.666,  1.671,  1.673,  1.681\nTotal time:      2.561    2.555   2.560,  2.555,  2.561,  2.561,  2.569\n\nShed Skin 0.7 (g++ -O2)\nWithout append:  0.310    0.301   0.301,  0.308,  0.317,  0.320,  0.303\nWith append:     1.712    1.690   1.733,  1.700,  1.735,  1.690,  1.702\nTotal time:      2.027    2.008   2.035,  2.008,  2.052,  2.011,  2.029\n</code>\n</pre>\n", "senID": 16}, {"text": ["Shed Skin becomes fastest, PyPy surpasses Cython.", "All three speed things up a lot compared to CPython."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}], [{"text": ["Please consider trimming down your f_wo_append function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "f_wo_append", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def f_wo_append():\n    '''Function without append'''\n    P = 75\n    numcustomers = 0\n    for person in popn.people:\n        person.customer = iscust = person.utility &gt;= P\n        numcustomers += iscust\n    return numcustomers\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit in response to OP's comment \"\"\"This made it a lot worse!", "The trimmed version takes 4 times more time than the version I have posted above.", "\"\"\""], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["There is no way that that could take \"4 times more\" (5 times?", ") ... here is my code, which demonstrates a significant reduction in the \"without append\" case, as I suggested, and also introduces a significant improvement in the \"with append\" case."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import random # instead of numpy\nimport time\ntimer_func = time.clock # better on Windows, use time.time on *x platform\n\nclass Person(object):\n    def __init__(self, util):\n        self.utility = util\n        self.customer = 0\n\nclass Population(object):\n    def __init__(self, numpeople):\n        random.seed(1)\n        self.people = [Person(random.uniform(0, 300)) for i in xrange(numpeople)]\n        self.cus = []\n        self.noncus = []        \n\ndef f_w_append(popn):\n    '''Function with append'''\n    P = 75\n    cus = []\n    noncus = []\n    for per in popn.people:\n        if  per.utility &gt;= P:\n            per.customer = 1\n            cus.append(per)\n        else:\n            per.customer = 0\n            noncus.append(per)\n    popn.cus = cus # omitted from OP's code\n    popn.noncus = noncus # omitted from OP's code\n    return len(cus)\n\ndef f_w_append2(popn):\n    '''Function with append'''\n    P = 75\n    popn.cus = []\n    popn.noncus = []\n    cusapp = popn.cus.append\n    noncusapp = popn.noncus.append\n    for per in popn.people:\n        if  per.utility &gt;= P:\n            per.customer = 1\n            cusapp(per)\n        else:\n            per.customer = 0\n            noncusapp(per)\n    return len(popn.cus)    \n\ndef f_wo_append(popn):\n    '''Function without append'''\n    P = 75\n    for per in popn.people:\n        if  per.utility &gt;= P:\n            per.customer = 1\n        else:\n            per.customer = 0\n\n    numcustomers = 0\n    for per in popn.people:\n        if per.customer == 1:\n            numcustomers += 1                \n    return numcustomers\n\ndef f_wo_append2(popn):\n    '''Function without append'''\n    P = 75\n    numcustomers = 0\n    for person in popn.people:\n        person.customer = iscust = person.utility &gt;= P\n        numcustomers += iscust\n    return numcustomers    \n\nif __name__ == \"__main__\":\n    import sys\n    popsize, which, niter = map(int, sys.argv[1:4])\n    pop = Population(popsize)\n    func = (f_w_append, f_w_append2, f_wo_append, f_wo_append2)[which]\n    t0 = timer_func()\n    for _unused in xrange(niter):\n        nc = func(pop)\n    t1 = timer_func()\n    print \"popsize=%d func=%s niter=%d nc=%d seconds=%.2f\" % (\n        popsize, func.__name__, niter, nc, t1 - t0)\n</code>\n</pre>\n", "senID": 4}, {"text": ["and here are the results of running it (Python 2.7.1, Windows 7 Pro, \"Intel Core i3 CPU 540 @ 3.07 GHz\"):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n C:\\junk&gt;\\python27\\python ncust.py 300 0 80000\npopsize=300 func=f_w_append niter=80000 nc=218 seconds=5.48\n\nC:\\junk&gt;\\python27\\python ncust.py 300 1 80000\npopsize=300 func=f_w_append2 niter=80000 nc=218 seconds=4.62\n\nC:\\junk&gt;\\python27\\python ncust.py 300 2 80000\npopsize=300 func=f_wo_append niter=80000 nc=218 seconds=5.55\n\nC:\\junk&gt;\\python27\\python ncust.py 300 3 80000\npopsize=300 func=f_wo_append2 niter=80000 nc=218 seconds=4.29\n</code>\n</pre>\n", "senID": 6}, {"text": ["Edit 3 Why numpy takes longer:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Edit 3", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy\n&gt;&gt;&gt; utils = numpy.random.uniform(0, 300, 10)\n&gt;&gt;&gt; print repr(utils[0])\n42.777972538362874\n&gt;&gt;&gt; type(utils[0])\n&lt;type 'numpy.float64'&gt;\n</code>\n</pre>\n", "senID": 8}, {"text": ["and here's why my f_wo_append2 function took 4 times longer:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = utils[0]\n&gt;&gt;&gt; type(x)\n&lt;type 'numpy.float64'&gt;\n&gt;&gt;&gt; type(x &gt;= 75) \n&lt;type 'numpy.bool_'&gt; # iscust refers to a numpy.bool_\n&gt;&gt;&gt; type(0 + (x &gt;= 75)) \n&lt;type 'numpy.int32'&gt; # numcustomers ends up referring to a numpy.int32\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 10}, {"text": ["The empirical evidence is that these custom types aren't so fast when used as scalars ... perhaps because they need to reset the floating-point hardware each time they are used.", "OK for big arrays, not for scalars."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Are you using any other numpy functionality?", "If not, just use the random module.", "If you have other uses for numpy, you may wish to coerce the numpy.float64 to float during the population setup."], "childNum": 3, "tag": "p", "senID": 12, "childList": [{"text": "random", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "numpy.float64", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can eliminate some lookups by using local function aliases:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def qtyDemanded(self, timePd, priceVector):\n    '''Returns quantity demanded in period timePd. In addition,\n    also updates the list of customers and non-customers.\n\n    Inputs: timePd and priceVector\n    Output: count of people for whom priceVector[-1] &lt; utility\n    '''\n    price = priceVector[-1]\n    self.customers = []\n    self.nonCustomers = []\n\n    # local function aliases\n    addCust = self.customers.append\n    addNonCust = self.nonCustomers.append\n\n    for person in self.people:\n        if person.utility &gt;= price:             \n            person.customer = 1\n            addCust(person)\n        else:\n            person.customer = 0\n            addNonCust(person)\n\n    return len(self.customers)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Depending on how often you add new elements to self.people or change person.utility, you could consider sorting self.people by the utility field."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "self.people", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "person.utility", "childNum": 0, "tag": "code", "childList": []}, {"text": "self.people", "childNum": 0, "tag": "code", "childList": []}, {"text": "utility", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Then you could use a bisect function to find the lower index i_pivot where the person[i_pivot].utility &gt;= price condition is met.", "This would have a lower complexity ( O(log N) ) than your exhaustive loop ( O(N) )"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "bisect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i_pivot", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "person[i_pivot].utility &gt;= price", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["With this information, you could then update your people list if needed :"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "people", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Do you really need to update the utility field each time ?", "In the sorted case, you could easily deduce this value while iterating : for example, considering your list sorted in incresing order, utility = (index &gt;= i_pivot)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "utility", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "utility = (index &gt;= i_pivot)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Same question with customers and nonCustomers lists.", "Why do you need them?", "They could be replaced by slices of the original sorted list : for example, customers = self.people[0:i_pivot]"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "customers", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "nonCustomers", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "customers = self.people[0:i_pivot]", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["All this would allow you to reduce the complexity of your algorithm, and use more built-in (fast) Python functions, this could speedup your implementation."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["This comment rings alarm bells:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n '''Returns quantity demanded in period timePd. In addition,\nalso updates the list of customers and non-customers.\n</code>\n</pre>\n", "senID": 1}, {"text": ["Aside from the fact that timePd is not used in the function, if you really want just to return the quantity, do just that in the function.", "Do the \"in addition\" stuff in a separate function. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "timePd", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Then profile again and see which of these two functions you are spending most of your time in."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I like to apply SRP to methods as well as classes: it makes them easier to test."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "SRP", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Single_responsibility_principle"}]}], [{"text": ["Some curious things I noted:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["timePd is passed as a parameter but never used"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["price is an array but you only ever use the last entry - why not pass the value there instead of passing the list?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["count is initialized and never used"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["self.people contains multiple person objects which are then copied to either self.customers or self.noncustomers as well as having their customer flag set.", "Why not skip the copy operation and, on return, just iterate over the list, looking at the customer flag?", "This would save the expensive append."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Alternatively, try using psyco which can speed up pure Python, sometimes considerably."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["It's surprising that the function shown is such a bottleneck because it's so relatively simple.", "For that reason, I'd double check my profiling procedure and results.", "However, if they're correct, the most time consuming part of your function has to be the for loop it contains, of course, so it makes sense to focus on speeding that up.", "One way to do this is by replacing the if/else with straight-line code.", "You can also reduce the attribute lookup for the append list method slightly.", "Here's how both of those things could be accomplished:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "if/else", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "append", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"code": "<pre>\n<code>\n def qtyDemanded(self, timePd, priceVector):\n    '''Returns quantity demanded in period timePd. In addition,\n    also updates the list of customers and non-customers.\n\n    Inputs: timePd and priceVector\n    Output: count of people for whom priceVector[-1] &lt; utility\n    '''\n\n    price = priceVector[-1] # last price\n    kinds = [[], []] # initialize sublists of noncustomers and customers\n    kindsAppend = [kinds[b].append for b in (False, True)] # append methods\n\n    for person in self.people:\n        person.customer = person.utility &gt;= price  # customer test\n        kindsAppend[person.customer](person)  # add to proper list\n\n    self.nonCustomers = kinds[False]\n    self.customers = kinds[True]\n\n    return len(self.customers)\n</code>\n</pre>\n", "senID": 1}, {"text": ["That said, I must add that it seems a little redundant to have both a customer flag in each person object and also put each of them into a separate list depending on that attribute.", "Not creating these two lists would of course speed the loop up further."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "customer", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["You're asking for guesses, and mostly you're getting guesses."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There's no need to guess.", "Here's an example."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Here's an example.", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4295799/how-to-improve-performance-of-this-code/4299378#4299378"}]}]]