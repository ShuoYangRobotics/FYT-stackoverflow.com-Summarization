[[{"text": ["It's an algorithm selection problem, rather than a library/language selection problem!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "an algorithm selection problem", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["There appears to be two points to consider primarily:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "how much would the ", "tag": "none", "senID": 2}, {"text": "what is the expected ", "tag": "none", "senID": 3}]}, {"text": ["Apparently, the answer to the second question is something like 'some false negative allowed' since the reliability of any 32 bits hash, relative to a 4Gb message, even in a moderately noisy channel, is not going to be virtually absolute."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "some false negative allowed", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "any", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Assuming that I/O can be improved through multithreading, we may choose a hash that doesn't require a sequential scan of the complete message.", "Instead we can maybe work the file in parallel, hashing individual sections and either combining the hash values or appending them, to form a longer, more reliable error detection device."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The next step  could be to formalize this handling of files as ordered sections, and to transmit them as such (to be re-glued together at the recipient's end).", "This approach, along  additional information about the way the files are produced (for ex.", "they may be exclusively modified by append, like log files),  may even allow to limit the amount of hash calculation required.", "The added complexity of this approach needs to weighted against the desire to have zippy fast CRC calculation."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Side note: Alder32 is not limited to message sizes below a particular threshold.", "It may just be a limit of the zlib API.", "(BTW, the reference I found about zlib.adler32 used a buffer, and well... this approach is to be avoided in the context of our huge messages, in favor of streamed processes: read a little from file, calculate, repeat..)"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["First, there is nothing inherent in any of the CRC algorithms that would prevent them working on an arbitrary length of data (however, a particular implementation might well impose a limit)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, in a file syncing application, that probably doesn't matter, as you may not want to hash the entire file when it gets large, just chunks anyway.", "If you hash the entire file, and the hashes at each end differ, you have to copy the entire file.", "If you hash fixed sized chunks, then you only have to copy the chunks whose hash has changed.", "If most of the changes to the files are localized (e.g.", "database) then this will likely require much less copying (and it' easier to spread per chunk calculations across multiple cores)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As for the hash algorithm itself, the basic tradeoff is speed vs. lack of collisions (two different data chunks yielding the same hash).", "CRC-32 is fast, but with only 2^32 unique values, collisions may be seen.", "MD5 is much slower, but has 2^128 unique values, so collisions will almost never be seen (but are still theoretically possible).", "The larger hashes (SHA1, SHA256, ...) have even more unique values, but are slower still: I doubt you need them: you're worried about accidental collisions, unlike digital signature applications, where you're worried about deliberately (malicously) engineered collisions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It sounds like you're trying to do something very similar to what the rsync utility does.", "Can you just use rsync?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You cannot possibly use more than one core to calculate MD5 hash of a large file because of the very nature of MD5: it expects a message to be broken up in chunks and fed into hashing function in strict sequence.", "However, you can use one thread to read a file into internal queue, and then calculate hash in a separate thread so that.", "I do not think though that this will give you any significant performance boost."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The fact that it takes so long to process a big file might be due to \"unbuffered\" reads.", "Try reading, say, 16 Kb at a time and then feed the content in chunks to hashing function."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["md5 itself can't be run in parallel.", "However you can md5 the file in sections (in parallel) and the take an md5 of the list of hashes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However that assumes that the hashing is not IO-limited, which I would suspect it is.", "As Anton Gogolev suggests - make sure that you're reading the file efficiently (in large power-of-2 chunks).", "Once you've done that, make sure the file isn't fragmented."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also a hash such as sha256 should be selected rather than md5 for new projects."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Are the zlib checksums much faster than md5 for 4Gb files?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Did you try the crc-generator module?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "crc-generator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/crcmod/"}]}], [{"text": ["You might be hitting a size limit for files in XP.", "The 64-bit gives you more addressing space (removing the 2GB (or so) addressing space per application), but probably does nothing for the file size problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]