[[{"text": ["You have managers in Django."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use a customized manager to do creates and maintain the FK relationships."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The manager can update the counts as the sets of children are updated."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you don't want to make customized managers, just extend the save method.", "Everything you want to do for denormalizing counts and sums can be done in save."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "save", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "save", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You don't need signals.", "Just extend save."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "save", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I found django-denorm to be useful.", "It uses database-level triggers instead of signals, but as far as I know, there is also branch based on different approach."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "django-denorm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/initcrash/django-denorm"}]}], [{"text": ["definitely use signals"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "signals", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/topics/signals/#topics-signals"}]}], [{"text": ["The first approach (signals) has the advantage to loose the coupling between models.", "However, signals are somehow more difficult to maintain, because dependencies are less explicit (at least, in my opinion).", "If the correctness of the comment count is not so important, you could also think of a cron job that will update it every n minutes."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["However, no matter the solution, denormalizing will make maintenance more difficult; for this reason I would try to avoid it as much as possible, resolving instead to using caches or other techniques -- for example, using with comments.count as cnt in templates may improve performance quite a lot.", "Then, if everything else fails, and only in that case, think about what could be the best approach for the specific problem."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "denormalizing will make maintenance more difficult", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "avoid it", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "with comments.count as cnt", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["Django offers a great and efficient (though not very known) alternative to counter denormalization."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "counter denormalization", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["It will save your many lines of code and it's really slow since you retrieve the count in the same SQL query."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I will suppose you have these classes:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class BlogEntry(models.Model):\n     title = models.CharField()\n     ...\n\n\nclass Comment(models.Model):\n     body = models.TextField()\n     blog_entry = models.ForeignKey(BlogEntry)\n</code>\n</pre>\n", "senID": 3}, {"text": ["In your views.py, use annotations:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "annotations", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://docs.djangoproject.com/en/dev/topics/db/aggregation/#generating-aggregates-for-each-item-in-a-queryset"}]}, {"code": "<pre>\n<code>\n from django.db.models import Count\n\ndef blog_entry_list(Request):\n    blog_entries = BlogEntry.objects.annotate(count=Count('comment_set')).all()\n    ...\n</code>\n</pre>\n", "senID": 5}, {"text": ["And you will have an extra field per each BlogEntry, that contains the count of comments, plus the rest of fields of BlobEntry."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["You can use this extra field in the templates too:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n {% for blog_entry in blog_entries %}\n  {{ blog_entry.title }} has {{ blob_entry.count }} comments!\n{% endfor %}\n</code>\n</pre>\n", "senID": 8}, {"text": ["This will not only save you coding and maintenance time but it is really efficient (the query takes only a bit longer to be executed)."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Why not just get the set of comments, and find the number of elements, using the count() method:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "count()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n count = blog_entry.comment_set.count()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can pass that into your template."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Or, alternative, in the template itself, you can do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n {{ blog_entry.comment_set.count }}\n</code>\n</pre>\n", "senID": 4}, {"text": ["to get the number of comments."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]