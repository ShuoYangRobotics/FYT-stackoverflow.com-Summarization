[[{"text": ["The following will work even if you don't know which is longer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; zip(a[-len(b):], b[-len(a):])\n[(1, 5), (2, 6), (3, 7)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is an example of what happens with the smaller list:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; range(5)[-10:]\n[0, 1, 2, 3, 4]\n</code>\n</pre>\n", "senID": 3}, {"text": ["So even though the slice looks kind of funky, if you have a negative start value that is larger than the length of the list, it will give you the entire list."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I would suggest:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = [4,5,6,7]\n&gt;&gt;&gt; k = min(len(a),len(b))\n&gt;&gt;&gt; zip(a[-k:], b[-k:])\n[(1, 5), (2, 6), (3, 7)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The following is faster and clearer than the other posted solutions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = zip(reversed(a), reversed(b))\ns.reverse()                       # in-place\n</code>\n</pre>\n", "senID": 1}, {"text": ["The reversed built-in creates an iterator those loops backwards at the same speed as forward iteration.", "No additional memory (full copies of the input) are produced and there are no slow trips around the Python eval-loop (present in the other solutions that use indicies)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "reversed", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n zip(a[len(a)-min(len(a), len(b)):], b[len(b)-min(len(a), len(b)):])\n</code>\n</pre>\n", "senID": 0}, {"text": ["but it does not look very \"pythonic\" :P"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["[Updated to add possibility of reversed ordering (because I thought I might use this one day)]"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "[Updated to add possibility of reversed ordering (because I thought I might use this one day)]", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["As a generator, you could try,"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def reversed_zip(*l, from_right=False):\n\n    i = min(len(l) for l in l)\n    i, j, k = (1, i+1, 1) if from_right else (i, 0, -1) \n\n    while i != j:\n        yield tuple( x[-i] for x in l ) \n        i += k\n</code>\n</pre>\n", "senID": 2}, {"text": ["This doesn't have to take copies of the lists, and gives,"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = [4,5,6,7]\n\n&gt;&gt;&gt; list(reversed_zip(a, b))\n[(1, 5), (2, 6), (3, 7)]\n\n&gt;&gt;&gt; list(reversed_zip(a, b, from_right=True))\n[(3, 7), (2, 6), (1, 5)]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["In the following solution, no copy of any of the input lists is done."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def rzip(a,b):\n    m = min(len(a),len(b))\n    for i in xrange(m):\n        yield a[-m+i],b[-m+i]\n\n\nfor a,b in (([1,2,3,4,5,6,7],[8,9,10]),\n            ([1,2,3],[8,9,10]),\n            ([1,2,3,4],[1,2,3,4,5,6,7,8,9,10])):\n    print list(rzip(a,b))\n</code>\n</pre>\n", "senID": 1}, {"text": ["m being the length of the shortest list, -m+0 is always transformed into index 0 for this shortest list,\nwhile -m+0 is transfomed in an index >= 0 for the longest list"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "m", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "-m+0", "childNum": 0, "tag": "strong", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "-m+0", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["result:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [(5, 8), (6, 9), (7, 10)]\n[(1, 8), (2, 9), (3, 10)]\n[(1, 7), (2, 8), (3, 9), (4, 10)]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Despite the fact the function rzip() isn't a one-liner, I think it is simple and I bet it is the faster solution"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "rzip()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Edit"], "childNum": 0, "tag": "h2", "senID": 7, "childList": []}, {"text": ["At first, in the function rzip()  above (and eyquem1 in the following code)  , I thought that creating the list of zipped elements by runing from correct position in each list from left to right would be a good procedure too.", "In the following code, eyquem1bis is the function rzip() slightly improved by a pre-calculation of the starting positions."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "rzip()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "rzip()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["But I was interested by the Raymond Hettinger's claim that the exclusive use of zip() and iterator reversed() is the clearer and faster solution.", "So I imagined that using other iterators from left to right would be better than my function rzip() and I used iter() and islice() to write functions eyquem2 and eyquem3 in the following code."], "childNum": 5, "tag": "p", "senID": 9, "childList": [{"text": "zip()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "reversed()", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "rzip()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "iter()", "childNum": 0, "tag": "strong", "childList": []}, {"text": "islice()", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["I compared the execution's times of the diverse solutions proposed in most of the answers.   "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n import random\nfrom time import clock\n\nlima,limb = 20000 , 50000\n\na = list(range(lima))\nb = list(range(limb))\nrandom.shuffle(a)\nrandom.shuffle(b)\n\n\nA,B,C,D,E,F,G,H,I = [],[],[],[],[],[],[],[],[],\n\nn = 10\nfor essays in range(100):\n\n    te = clock()\n    for rep in range(n):\n        k = min(len(a),len(b)) \n        sam1 = list(zip(a[-k:], b[-k:]))\n    tref= (clock()-te)/100\n    A.append((clock()-te,\n              'Sam Hocevar, deducted normal slicing and zip'\n              '\\nk = min(len(a),len(b))'\n              '\\nlist(zip(a[-k:], b[-k:]))'))\n\n\n    te = clock()\n    for rep in range(n):\n        k = min(len(a),len(b)) \n        sam2 = list(zip(a[len(a)-k:], b[len(b)-k:]))\n    tref= (clock()-te)/100\n    B.append((clock()-te,\n              'Sam Hocevar, exactly normal slicing and zip'\n              '\\nk = min(len(a),len(b))'\n              '\\nlist(zip(a[len(a)-k:], b[len(b)-k:]))'))\n\n\n    te = clock()\n    for rep in range(n):\n        fj = list(zip(a[-len(b):], b[-len(a):]))\n    C.append((clock()-te,\n              'F.J. , deducted tricky slicing and zip'\n              '\\nlist(zip(a[-len(b):], b[-len(a):]))'))\n\n\n    te = clock()\n    for rep in range(n):\n        m = min(len(a),len(b))\n        sleep = list(zip(a[len(a)-m:],b[len(b)-m:]))\n    D.append((clock()-te,\n              'sleeplessnerd, exactly normal slicing and zip'\n              '\\nm = min(len(a),len(b))'\n              '\\nlist(zip(a[len(a)-m:],b[len(b)-m:]))'))\n\n\n    te = clock()\n    for rep in range(n):\n        m = min(len(a),len(b))\n        ey1 = [ (a[-m+i],b[-m+i]) for i in range(m) ]\n    E.append((clock()-te,\n              'eyquem 1, deducted normal slicing and listcomp'\n              '\\nm = min(len(a),len(b))'\n              '\\n[ (a[-m+i],b[-m+i]) for i in range(m) ]'))\n\n\n    te = clock()\n    for rep in range(n):\n        m = min(len(a),len(b))\n        x,y = len(a)-m , len(b)-m\n        ey1bis = [ (a[x+i],b[y+i]) for i in range(m)]\n    F.append((clock()-te,\n              'eyquem 1 improved, exactly normal slicing and listcomp'\n              '\\nm = min(len(a),len(b)'\n              '\\nx,y = len(a)-m , len(b)-m'\n              '\\n[(a[x+i],b[y+i]) for i in range(m)]'))\n\n\n    te = clock()\n    for rep in range(n):\n        ita = iter(a)\n        itb = iter(b)\n        if len(b)&gt;len(a):\n            for av in range(len(b)-len(a)):\n                itb.__next__()\n        else:\n            for av in range(len(a)-len(b)):\n                itb.__next__()\n        ey2 = list(zip(ita,itb))\n    G.append((clock()-te,\n              'eyquem 2, use of zip and iterator iter'\n              '\\nlist(zip(ita,itb))'))\n\n\n    from itertools import islice\n    te = clock()\n    for rep in range(n):\n        if len(b)&gt;len(a):\n            ey3 = list(zip(iter(a) , islice(b,len(b)-len(a),None)))\n        else:\n            ey3 = list(zip(islice(a,len(a)-len(b),None),iter(b)))\n    H.append((clock()-te,\n              'eyquem 3, use of zip and iterators iter AND islice'\n              '\\nlist(zip(iter(a),islice(b,len(b)-len(a),None)))'))\n\n\n    te = clock()\n    for rep in range(n):\n        ray = list(reversed(list(zip(reversed(a),reversed(b)))))\n    I.append((clock()-te,\n              'Raymond Hettinger, use of zip and iterator reversed'\n              '\\nlist(reversed(list(zip(reversed(a),reversed(b)))))'))\n\n\nprint( 'len(a) == %d\\nlen(b) == %d\\n' % (len(a),len(b)) )\n\ntempi = [min(x) for x in (A,B,C,D,E,F,G,H,I)]\ntempi.sort(reverse=True)\ntref = tempi[0][0]/100\nprint( '\\n\\n'.join('%.2f %%     %s' % (t/tref,ch) for t,ch in tempi) )\n\n\nprint('\\nsam1==sam2==fj==sleep==ey1==ey1bis==ey2==ey3==ray  is ',sam1==sam2==fj==sleep==ey1==ey1bis==ey2==ey3==ray)\n</code>\n</pre>\n", "senID": 11}, {"text": ["A result with lists of very different lengths:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n len(a) == 20000\nlen(b) == 50000\n\n100.00 %     Sam Hocevar, exactly normal slicing and zip\nk = min(len(a),len(b))\nlist(zip(a[len(a)-k:], b[len(b)-k:]))\n\n99.80 %     Sam Hocevar, deducted normal slicing and zip\nk = min(len(a),len(b))\nlist(zip(a[-k:], b[-k:]))\n\n98.02 %     sleeplessnerd, exactly normal slicing and zip\nm = min(len(a),len(b))\nlist(zip(a[len(a)-m:],b[len(b)-m:]))\n\n97.98 %     F.J. , deducted tricky slicing and zip\nlist(zip(a[-len(b):], b[-len(a):]))\n\n82.30 %     eyquem 2, use of zip and iterator iter\nlist(zip(ita,itb))\n\n69.61 %     eyquem 1, deducted normal slicing and listcomp\nm = min(len(a),len(b))\n[ (a[-m+i],b[-m+i]) for i in range(m) ]\n\n67.62 %     eyquem 1 improved, exactly normal slicing and listcomp\nm = min(len(a),len(b)\nx,y = len(a)-m , len(b)-m\n[(a[x+i],b[y+i]) for i in range(m)]\n\n61.23 %     eyquem 3, use of zip and iterators iter AND islice\nlist(zip(iter(a),islice(b,len(b)-len(a),None)))\n\n60.92 %     Raymond Hettinger, use of zip and iterator reversed\nlist(reversed(list(zip(reversed(a),reversed(b)))))\n\nsam1==sam2==fj==sleep==ey1==ey1bis==ey2==ey3==ray  is  True\n</code>\n</pre>\n", "senID": 13}, {"text": ["Result with two lists of similar lengths:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n len(a) == 49500\nlen(b) == 50000\n\n100.00 %     Sam Hocevar, deducted normal slicing and zip\nk = min(len(a),len(b))\nlist(zip(a[-k:], b[-k:]))\n\n99.39 %     F.J. , deducted tricky slicing and zip\nlist(zip(a[-len(b):], b[-len(a):]))\n\n99.12 %     sleeplessnerd, exactly normal slicing and zip\nm = min(len(a),len(b))\nlist(zip(a[len(a)-m:],b[len(b)-m:]))\n\n98.10 %     Sam Hocevar, exactly normal slicing and zip\nk = min(len(a),len(b))\nlist(zip(a[len(a)-k:], b[len(b)-k:]))\n\n69.91 %     eyquem 1, deducted normal slicing and listcomp\nm = min(len(a),len(b))\n[ (a[-m+i],b[-m+i]) for i in range(m) ]\n\n66.54 %     eyquem 1 improved, exactly normal slicing and listcomp\nm = min(len(a),len(b)\nx,y = len(a)-m , len(b)-m\n[(a[x+i],b[y+i]) for i in range(m)]\n\n58.94 %     Raymond Hettinger, use of zip and iterator reversed\nlist(reversed(list(zip(reversed(a),reversed(b)))))\n\n51.29 %     eyquem 2, use of zip and iterator iter\nlist(zip(ita,itb))\n\n51.17 %     eyquem 3, use of zip and iterators iter AND islice\nlist(zip(iter(a),islice(b,len(b)-len(a),None)))\n\nsam1==sam2==fj==sleep==ey1==ey1bis==ey2==ey3==ray  is  True\n</code>\n</pre>\n", "senID": 15}, {"text": ["I conclude that there are 3 groups of solutions:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["the solutions of Sam Hocevar, FJ and sleeplessnerd have the longest executions.", "They use different combinations of slicing and function zip().", "By the way the overwhelmingly approved Sam's solution is the longest."], "childNum": 2, "tag": "p", "senID": 17, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"text": ["my function rzip() and rzip()-improved execute in 68 % of the time taken by the ones of the above group.", "They use only a list comprehension of elements obtained by their indices"], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["my solutions eyquem2 and eyquem3 , and the Raymond Hettinger's solution, take less than 61 % of the said preceding times.", "They use iterators."], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}]}, {"text": ["The execution's times of my solutions depend on the relative lengths of the list:\nfor lists of similar lengths, solutions eyquem2 and eyquem3 have execution's times divided by 2 !", "But for very different lists , eyquem2 surprisingly takes as much as 82 % of the reference time."], "childNum": 2, "tag": "p", "senID": 20, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"text": ["Constant execution's time around 60 % of reference time of Raymond Hettinger's solution confirms his claim.", "My solution eyquem3 with iter() and islice() is not so bad too, but it isn't so clear than Raymond Hettinger's one, though this latter is a little obscure too at first glance. "], "childNum": 3, "tag": "p", "senID": 21, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "iter()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "islice()", "childNum": 0, "tag": "strong", "childList": []}]}]]