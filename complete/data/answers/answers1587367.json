[[{"text": ["accumulate is designed to do what you seem to want; that is, to proprigate an operation along an array.", "Here's an example:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "accumulate", "tag": "a", "pos": 0, "childList": [{"text": "accumulate", "tag": "strong"}], "childNum": 1, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.ufunc.accumulate.html"}, {"text": "accumulate", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from numpy import *\n\na = array([1,0,0,0])\na[1:] = add.accumulate(a[0:3])\n# a = [1, 1, 1, 1]\n\nb = array([1,1,1,1])\nb[1:] = multiply.accumulate(2*b[0:3])\n# b = [1 2 4 8]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Another way to do this is to explicitly specify the result array as the input array.", "Here's an example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n c = array([2,0,0,0])\nmultiply(c[:3], c[:3], c[1:])\n# c = [  2   4  16 256]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Late answer, but this turned up on Google so I probably point to the doc the OP wanted.", "Your problem is clear: when using NumPy slices, temporaries are created.", "Wrap your code in a quick call to weave.blitz to get rid of the temporaries and have the behaviour your want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Read PerformancePython tutorial for full details."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PerformancePython tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scipy.org/PerformancePython#head-cafc55bbf8fd74071b2c2ebcfb6f24ed1989d540"}]}], [{"text": ["Just use a loop.", "I can't immediately think of any way to make the slice operator behave the way you're saying you want it to, except maybe by subclassing numpy's array and overriding the appropriate method with some sort of Python voodoo... but more importantly, the idea that a[1:] = a[0:3] should copy the first value of a into the next three slots seems completely nonsensical to me.", "I imagine that it could easily confuse anyone else who looks at your code (at least the first few times)."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "maybe", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "array", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a[1:] = a[0:3]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["i would suggest cython instead of looping in c.  there might be some fancy numpy way of getting your example to work using a lot of intermediate steps... but since you know how to write it in c already, just write that quick little bit as a cython function and let cython's magic make the rest of the work easy for you."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "might", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["It must have something to do with assigning a slice.", "Operators, however, as you may already know, do follow your expected behavior:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = numpy.array([1,0,0,0])\n&gt;&gt;&gt; a[1:]+=a[:3]\n&gt;&gt;&gt; a\narray([1, 1, 1, 1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you already have zeros in your real-world problem where your example does, then this solves it.", "Otherwise, at added cost, set them to zero either by multiplying by zero or assigning to zero, (whichever is faster)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["edit:\nI had another thought.", "You may prefer this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n numpy.put(a,[1,2,3],a[:3])\n</code>\n</pre>\n", "senID": 4}], [{"text": ["It is not the correct logic.", "I'll try to use letters to explain it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Image array = abcd with a,b,c,d as elements.", "Now, array[1:] means from the element in position 1 (starting from 0) on.", "In this case:bcd and array[0:3] means from the character in position 0 up to the third character (the one in position 3-1) in this case: 'abc'."], "childNum": 11, "tag": "p", "senID": 1, "childList": [{"text": "array = abcd", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "array[1:]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "bcd", "childNum": 0, "tag": "code", "childList": []}, {"text": "array[0:3]", "childNum": 0, "tag": "code", "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}, {"text": "3-1", "childNum": 0, "tag": "code", "childList": []}, {"text": "'abc'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Writing something like:\narray[1:] = array[0:3]"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "array[1:] = array[0:3]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["means: replace bcd with abc"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "bcd", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "abc", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To obtain the output you want, now in python, you should use something like:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a[1:] = a[0]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Numpy must be checking if the target array is the same as the input array when doing the setkey call.", "Luckily, there are ways around it.", "First, I tried using numpy.put instead"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "numpy.put", "tag": "a", "pos": 2, "childList": [{"text": "numpy.put", "tag": "code"}], "childNum": 1, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.put.html"}, {"text": "numpy.put", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n In [46]: a = numpy.array([1,0,0,0])\n\nIn [47]: numpy.put(a,[1,2,3],a[0:3])\n\nIn [48]: a\nOut[48]: array([1, 1, 1, 1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["And then from the documentation of that, I gave using flatiters a try (a.flat)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "a.flat", "tag": "a", "pos": 0, "childList": [{"text": "a.flat", "tag": "code"}], "childNum": 1, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html"}, {"text": "a.flat", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n In [49]: a = numpy.array([1,0,0,0])\n\nIn [50]: a.flat[1:] = a[0:3]\n\nIn [51]: a\nOut[51]: array([1, 1, 1, 1])\n</code>\n</pre>\n", "senID": 3}, {"text": ["But this doesn't solve the problem you had in mind"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n In [55]: a = np.array([1,0,0,0])\n\nIn [56]: a.flat[1:] = 2*a[0:3]\n\nIn [57]: a\nOut[57]: array([1, 2, 0, 0])\n</code>\n</pre>\n", "senID": 5}, {"text": ["This fails because the multiplication is done before the assignment, not in parallel as you would like."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Numpy is designed for repeated application of the exact same operation in parallel across an array.", "To do something more complicated, unless you can find decompose it in terms of functions like numpy.cumsum and numpy.cumprod, you'll have to resort to something like scipy.weave or writing the function in C.  (See the PerfomancePython page for more details.", ")  (Also, I've never used weave, so I can't guarantee it will do what you want."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "numpy.cumsum", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "numpy.cumprod", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "PerfomancePython", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.scipy.org/PerformancePython"}]}], [{"text": ["You could have a look at np.lib.stride_tricks."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is some information in these excellent slides:\nhttp://mentat.za.net/numpy/numpy_advanced_slides/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://mentat.za.net/numpy/numpy_advanced_slides/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mentat.za.net/numpy/numpy%5Fadvanced%5Fslides/"}]}, {"text": ["with stride_tricks starting at slide 29."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I'm not completely clear on the question though so can't suggest anything more concrete - although I would probably do it in cython or fortran with f2py or with weave.", "I'm liking fortran more at the moment because by the time you add all the required type annotations in cython I think it ends up looking less clear than the fortran."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["There is a comparison of these approaches here:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["www.", "scipy.", "org/ PerformancePython"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["(can't post more links as I'm a new user)\nwith an example that looks similar to your case."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]