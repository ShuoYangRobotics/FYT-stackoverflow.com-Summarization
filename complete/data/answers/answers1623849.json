[[{"text": ["This is a typical job for NumPy, which is very fast for these kinds of operations:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "NumPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scipy.org/Tentative_NumPy_Tutorial"}]}, {"code": "<pre>\n<code>\n array_np = numpy.array(array)\nlow_values_indices = array_np &lt; lowValY  # Where values are low\narray_np[low_values_indices] = 0  # All low values set to 0\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now, if you only need the highCountX largest elements, you can even \"forget\" the small elements (instead of setting them to 0) and only sort the list of large elements:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n array_np = numpy.array(array)\nprint numpy.sort(array_np[array_np &gt;= lowValY])[-highCountX:]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course, sorting the whole array if you only need a few elements might not be optimal.", "Depending on your needs, you might want to consider the standard heapq module."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "heapq", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/heapq.html"}]}], [{"text": ["The simplest way would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n topX = sorted([x for x in array if x &gt; lowValY], reverse=True)[highCountX-1]\nprint [x if x &gt;= topX else 0 for x in array]\n</code>\n</pre>\n", "senID": 1}, {"text": ["In pieces, this selects all the elements greater than lowValY:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "lowValY", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [x for x in array if x &gt; lowValY]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This array only contains the number of elements greater than the threshold.", "Then, sorting it so the largest values are at the start:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n sorted(..., reverse=True)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Then a list index takes the threshold for the top highCountX elements:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "highCountX", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n sorted(...)[highCountX-1]\n</code>\n</pre>\n", "senID": 7}, {"text": ["Finally, the original array is filled out using another list comprehension:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n [x if x &gt;= topX else 0 for x in array]\n</code>\n</pre>\n", "senID": 9}, {"text": ["There is a boundary condition where there are two or more equal elements that (in your example) are 3rd highest elements.", "The resulting array will contain that element more than once."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["There are other boundary conditions as well, such as if len(array) &lt; highCountX.", "Handling such conditions is left to the implementor."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "len(array) &lt; highCountX", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["There's a special MaskedArray class in NumPy that does exactly that.", "You can \"mask\" elements based on any precondition.", "This better represent your need than assigning zeroes: numpy operations will ignore masked values when appropriate (for example, finding mean value)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from numpy import ma\n&gt;&gt;&gt; x = ma.array([.06, .25, 0, .15, .5, 0, 0, 0.04, 0, 0])\n&gt;&gt;&gt; x1 = ma.masked_inside(0, 0.1) # mask everything in 0..0.1 range\n&gt;&gt;&gt; x1\nmasked_array(data = [-- 0.25 -- 0.15 0.5 -- -- -- -- --],\n         mask = [ True False True False False True True True True True],\n   fill_value = 1e+20)\n&gt;&gt;&gt; print x.filled(0) # Fill with zeroes\n[ 0 0.25 0 0.15 0.5 0 0 0 0 0 ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["As an addded benefit, masked arrays are well supported in matplotlib visualisation library if you need this."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Docs on masked arrays in numpy"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Docs on masked arrays in numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/reference/maskedarray.html#maskedarray"}]}], [{"text": ["Using numpy:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # assign zero to all elements less than or equal to `lowValY`\na[a&lt;=lowValY] = 0 \n# find n-th largest element in the array (where n=highCountX)\nx = partial_sort(a, highCountX, reverse=True)[:highCountX][-1]\n# \na[a&lt;x] = 0 #NOTE: it might leave more than highCountX non-zero elements\n           # . if there are duplicates\n</code>\n</pre>\n", "senID": 1}, {"text": ["Where partial_sort could be:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "partial_sort", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def partial_sort(a, n, reverse=False):\n    #NOTE: in general it should return full list but in your case this will do\n    return sorted(a, reverse=reverse)[:n]\n</code>\n</pre>\n", "senID": 3}, {"text": ["The expression a[a&lt;value] = 0 can be written without numpy as follows:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "a[a&lt;value] = 0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "numpy", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for i, x in enumerate(a):\n    if x &lt; value:\n       a[i] = 0\n</code>\n</pre>\n", "senID": 5}], [{"text": ["You can use map and lambda, it should be fast enough."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n new_array = map(lambda x: x if x&gt;y else 0, array)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Settings elements below some threshold to zero is easy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n array = [ x if x &gt; threshold else 0.0 for x in array ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["(plus the occasional abs() if needed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The requirement of the N highest numbers is a bit vague, however.", "What if there are e.g.", "N+1 equal numbers above the threshold?", "Which one to truncate?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You could sort the array first, then set the threshold to the value of the Nth element:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n threshold = sorted(array, reverse=True)[N]\narray = [ x if x &gt;= threshold else 0.0 for x in array ]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Note: this solution is optimized for readability not performance."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Use a heap."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "heap", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-heapq.html"}]}, {"text": ["This works in time O(n*lg(HighCountX))."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "O(n*lg(HighCountX))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import heapq\n\nheap = []\narray =  [.06, .25, 0, .15, .5, 0, 0, 0.04, 0, 0]\nhighCountX = 3\nlowValY = .1\n\nfor i in range(1,highCountX):\n    heappush(heap, lowValY)\n    heappop(heap)\n\nfor i in range( 0, len(array) - 1)\n    if array[i] &gt; heap[0]:\n    \theappush(heap, array[i])\n\nmin = heap[0]\n\narray = [x if x &gt;= min else 0 for x in array]\n</code>\n</pre>\n", "senID": 2}, {"text": ["deletemin works in heap O(lg(k)) and insertion O(lg(k)) or O(1) depending on which heap type you use."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "O(lg(k))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(lg(k))", "childNum": 0, "tag": "code", "childList": []}, {"text": "O(1)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Using a heap is a good idea, as egon says.", "But you can use the heapq.nlargest function to cut down on some effort:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "heapq.nlargest", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import heapq \n\narray =  [.06, .25, 0, .15, .5, 0, 0, 0.04, 0, 0]\nhighCountX = 3\nlowValY = .1\n\nthreshold = max(heapq.nlargest(highCountX, array)[-1], lowValY)\narray = [x if x &gt;= threshold else 0 for x in array]\n</code>\n</pre>\n", "senID": 1}]]