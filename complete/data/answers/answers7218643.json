[[{"text": ["I guess by \"poorly functioning\" you mean speed wise?", "Because I tested and it does appear to work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could make things more efficient by making a set of the words in file2:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n word_set = set(ls_stripped)\n</code>\n</pre>\n", "senID": 2}, {"text": ["And then instead of findall you'd see if it's in the set:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "findall", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n in_set = just_word in word_set\n</code>\n</pre>\n", "senID": 4}, {"text": ["Also feels cleaner than a regex."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["It seems like this may simply be a special case of grep.", "If file2 is essentially a list of patterns, and the output format is the same as file1, then you might be able to just do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n grep -wf file2 file1\n</code>\n</pre>\n", "senID": 1}, {"text": ["The -w tells grep to match only whole words."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "-w", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If file2 is not humongous, slurp them into a set:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "file2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n file2=set(open(\"file2\").read().split())\nfor line in open(\"file1\"):\n    if line.split(\":\")[0].strip(\"'\") in file2:\n        print line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is how I'd do this.", "I don't have a python interpreter on hand, so there may be a couple typos."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One of the main things you should remember when coming to Python (especially if coming from Perl) is that regular expressions are usually a bad idea: the string methods are powerful and very fast."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def GetCounts(file1, file2):\n    data = {}\n    for line in open(file1):\n        try:\n            word, n = line.rsplit(':', 1)\n        except ValueError: # not enough values\n            #some kind of input error, go to next line\n            continue\n        n = int(n.strip())\n        if word[0] == word[-1] == \"'\":\n            word = word[1:-1]\n        data[word] = n\n\n    for line in open(file2):\n        word = line.strip()\n        if word[0] == word[-1] == \"'\":\n            word = word[1:-1]\n        if word in data:\n            print word, data[word]\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n import re, methodcaller\n\nre_target = re.compile(r\"^'([a-z]+)': +(\\d+)\", re.M|re.I)\nmatch_me_contents = open(file2).read().splitlines()\nmatch_me_contents = set(map(methodcaller('strip', \"'\"), match_me_contents))\n\nres = []\nfor match in re_target.finditer(open(file1).read()):\n    word, value = match.groups()\n    if word in match_me_contents:\n        res.append((word, value))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["My two input files:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["file1.txt:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "file1.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 'WORD': 1\n'MULTIPLE WORDS': 1\n'OTHER': 2\n</code>\n</pre>\n", "senID": 2}, {"text": ["file2.txt:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "file2.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 'WORD'\n'NONEXISTENT'\n</code>\n</pre>\n", "senID": 4}, {"text": ["If file2.txt is guaranteed not to have multiple words on a line, then there is no need to explicitly filter these from the first file.", "This will be done by the membership test:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "file2.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "guaranteed", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n # Build a set of what words we can return a count for.\nwith open('file2.txt', 'r') as f:\n    allowed_words = set(word.strip() for word in f)\n\n# See which of them exist in the first file.\nwith open('file1.txt', 'r') as f:\n    for line in f:\n        word, count = line.strip().split(':')\n\n        # This assumes that strings with a space (multiple words) do not exist in\n        # the second file.\n        if word in allowed_words:\n            print word, count\n</code>\n</pre>\n", "senID": 6}, {"text": ["And running this gives:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n $ python extract.py\n'WORD' 1\n</code>\n</pre>\n", "senID": 8}, {"text": ["If file2.txt might contain multiple words, simply modify the test in the loop:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "file2.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # Build a set of what words we can return a count for.\nwith open('file2.txt', 'r') as f:\n    allowed_words = set(word.strip() for word in f)\n\n# See which of them exist in the first file.\nwith open('file1.txt', 'r') as f:\n    for line in f:\n        word, count = line.strip().split(':')\n\n        # This prevents multiple words from being selected.\n        if word in allowed_words and not ' ' in word:\n            print word, count\n</code>\n</pre>\n", "senID": 10}, {"text": ["Note I haven't bothered stripping the quotes from the words.", "I'm not sure if this is necessary - it depends on whether the input is guaranteed to have them or not.", "It would be trivial to add them."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Something else you should consider is case-sensitivity.", "If lowercase and uppercase words should be treated as the same, then you should convert all input to uppercase (or lowercase, it does not matter which) prior to doing any testing."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["EDIT: It would probably be more efficient to remove multiple words from the set of allowed words, rather than doing the check on every line of file1:"], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "file1", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n # Build a set of what words we can return a count for.\nwith open('file2.txt', 'r') as f:\n    allowed_words = set(word.strip() for word in f if not ' ' in f)\n\n# See which of them exist in the first file.\nwith open('file1.txt', 'r') as f:\n    for line in f:\n        word, count = line.strip().split(':')\n\n        # Check if the word is allowed.\n        if word in allowed_words:\n            print word, count\n</code>\n</pre>\n", "senID": 14}], [{"text": ["This is what I came up with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-python prettyprint-override\">\n<code>\n def GetCounts(file1, file2):\n    target_contents  = open(file1).readlines()  #file 1 as list--&gt; 'WORD': n\n    match_me_contents = set(open(file2).read().split('\\n'))   #file 2 as list -&gt; 'WORD'  \n    for line in target_contents:\n        word = line.split(': ')[0]  #get the first item in line.split\n        if \" \" not in word:\n            number = line.split(': ')[1]   #get the number associated with the word\n            if word in match_me_contents:  \n                print word, number\n</code>\n</pre>\n", "senID": 1}, {"text": ["Changes from your version:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "Moved to set from a regex", "tag": "none", "senID": 3}, {"text": "Went to split instead of readlines to get rid of newlines without extra processing", "tag": "none", "senID": 4}, {"text": "Changed from splitting the word into words and checking if the length of that is one to simply checking if a space is in the \"word\" directly\n", "tag": "none", "senID": 5}, {"text": "Added a space into line.split(': ') so that that way number won't be prefixed with a space\n", "tag": "none", "senID": 6}, {"text": "Moved ", "tag": "none", "senID": 7}]}, {"text": ["The potential bugs would only occur however if the actual input is not in the format you presented."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Let's exploit the similarity of the file format to Python expression syntax:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from ast import literal_eval\nwith file(\"file1\") as f:\n  word_values = ast.literal_eval('{' + ','.join(line for line in f) + '}')\nwith file(\"file2\") as f:\n  expected_words = set(ast.literal_eval(line) for line in f)\nword_values = {k: v for (k, v) in word_values if k in expected_words}\n</code>\n</pre>\n", "senID": 1}]]