[[{"text": ["You can add the 'default' parameter to json.dumps to handle this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dthandler = lambda obj: obj.isoformat() if isinstance(obj, datetime.datetime) else None\n&gt;&gt;&gt; json.dumps(datetime.datetime.now(), default=dthandler)\n'\"2010-04-20T20:08:21.634121\"'\n</code>\n</pre>\n", "senID": 1}, {"text": ["A more comprehensive default handler function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def handler(obj):\n    if hasattr(obj, 'isoformat'):\n        return obj.isoformat()\n    elif isinstance(obj, ...):\n        return ...\n    else:\n        raise TypeError, 'Object of type %s with value of %s is not JSON serializable' % (type(obj), repr(obj))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Update:  Added output of type as well as value.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["For cross language projects I found out that strings containing RfC 3339 dates are the best way to go.", "A RfC 3339 date looks like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "RfC 3339", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ietf.org/rfc/rfc3339.txt"}]}, {"code": "<pre>\n<code>\n 1985-04-12T23:20:50.52Z\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think most of the format is obvious.", "The only somewhat unusual thing may be the \"Z\" at the end.", "It stands for GMT/UTC.", "You could also add a timezone offset like +02:00 for CEST (Germany in summer).", "I personally prefer to keep everything in UTC until it is displayed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For displaying, comparisons and storage you can leave it in string format across all languages.", "If you need the date for calculations easy to convert it back to a native date object in most language."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["So generate the JSON like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n json.dump(datetime.now().strftime('%Y-%m-%dT%H:%M:%S'))\n</code>\n</pre>\n", "senID": 5}, {"text": ["Unfortunately Javascripts Date constructor doesn't accept RfC 3339 strings but there are many parsers available on the Internet."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "parsers", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.dansnetwork.com/2008/11/01/javascript-iso8601rfc3339-date-parser/"}]}, {"text": ["huTools.hujson tries to handle the most common encoding issues you might come across in Python code including date/datetime objects while handling timezones correctly."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "huTools.hujson", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/hudora/huTools/blob/master/huTools/hujson.py"}]}], [{"text": ["If you're certain that only Javascript will be consuming the JSON, I prefer to pass Javascript Date objects directly."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Date", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The ctime() method on datetime objects will return a string that the Javascript Date object can understand."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "ctime()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "datetime", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import datetime\ndate = datetime.datetime.today()\njson = '{\"mydate\":new Date(\"%s\")}' % date.ctime()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Javascript will happily use that as an object literal, and you've got your Date object built right in."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you are using simplejson, you can subclass JSONEncoder and override the default() method to provide your own custom serializers:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class JSONEncoder(simplejson.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, datetime.datetime):\n            return obj.strftime('%Y-%m-%dT%H:%M:%S')\n        else:\n            return simplejson.JSONEncoder.default(self, obj)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then, you can call it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; JSONEncoder().encode([datetime.datetime.now()])\n'[\"2010-06-15T14:42:28\"]'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's a fairly complete solution for recursively encoding and decoding datetime.datetime and datetime.date objects using the standard library json module.", "This needs Python >= 2.6 since the %f format code in the datetime.datetime.strptime() format string is only supported in since then.", "For Python 2.5 support, drop the %f and strip the microseconds from the ISO date string before trying to convert it, but you'll loose microseconds precision, of course.", "For interoperability with ISO date strings from other sources, which may include a time zone name or UTC offset, you may also need to strip some parts of the date string before the conversion.", "For a complete parser for ISO date strings (and many other date formats) see the third-party dateutil module."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "json", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "%f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "%f", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "dateutil", "tag": "a", "pos": 4, "childList": [], "childNum": 0, "href": "http://labix.org/python-dateutil"}]}, {"text": ["Decoding only works when the ISO date strings are values in a JavaScript\nliteral object notation or in nested structures within an object.", "ISO date\nstrings, which are items of a top-level array will not be decoded."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I.e.", "this works:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n date = datetime.datetime.now()\n&gt;&gt;&gt; json = dumps(dict(foo='bar', innerdict=dict(date=date)))\n&gt;&gt;&gt; json\n'{\"innerdict\": {\"date\": \"2010-07-15T13:16:38.365579\"}, \"foo\": \"bar\"}'\n&gt;&gt;&gt; loads(json)\n{u'innerdict': {u'date': datetime.datetime(2010, 7, 15, 13, 16, 38, 365579)},\nu'foo': u'bar'}\n</code>\n</pre>\n", "senID": 3}, {"text": ["And this too:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; json = dumps(['foo', 'bar', dict(date=date)])\n&gt;&gt;&gt; json\n'[\"foo\", \"bar\", {\"date\": \"2010-07-15T13:16:38.365579\"}]'\n&gt;&gt;&gt; loads(json)\n[u'foo', u'bar', {u'date': datetime.datetime(2010, 7, 15, 13, 16, 38, 365579)}]\n</code>\n</pre>\n", "senID": 5}, {"text": ["But this doesn't work as expected:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; json = dumps(['foo', 'bar', date])\n&gt;&gt;&gt; json\n'[\"foo\", \"bar\", \"2010-07-15T13:16:38.365579\"]'\n&gt;&gt;&gt; loads(json)\n[u'foo', u'bar', u'2010-07-15T13:16:38.365579']\n</code>\n</pre>\n", "senID": 7}, {"text": ["Here's the code:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n __all__ = ['dumps', 'loads']\n\nimport datetime\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\nclass JSONDateTimeEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, (datetime.date, datetime.datetime)):\n            return obj.isoformat()\n        else:\n            return json.JSONEncoder.default(self, obj)\n\ndef datetime_decoder(d):\n    if isinstance(d, list):\n        pairs = enumerate(d)\n    elif isinstance(d, dict):\n        pairs = d.items()\n    result = []\n    for k,v in pairs:\n        if isinstance(v, basestring):\n            try:\n                # The %f format code is only supported in Python &gt;= 2.6.\n                # For Python &lt;= 2.5 strip off microseconds\n                # v = datetime.datetime.strptime(v.rsplit('.', 1)[0],\n                #     '%Y-%m-%dT%H:%M:%S')\n                v = datetime.datetime.strptime(v, '%Y-%m-%dT%H:%M:%S.%f')\n            except ValueError:\n                try:\n                    v = datetime.datetime.strptime(v, '%Y-%m-%d').date()\n                except ValueError:\n                    pass\n        elif isinstance(v, (dict, list)):\n            v = datetime_decoder(v)\n        result.append((k, v))\n    if isinstance(d, list):\n        return [x[1] for x in result]\n    elif isinstance(d, dict):\n        return dict(result)\n\ndef dumps(obj):\n    return json.dumps(obj, cls=JSONDateTimeEncoder)\n\ndef loads(obj):\n    return json.loads(obj, object_hook=datetime_decoder)\n\nif __name__ == '__main__':\n    mytimestamp = datetime.datetime.utcnow()\n    mydate = datetime.date.today()\n    data = dict(\n        foo = 42,\n        bar = [mytimestamp, mydate],\n        date = mydate,\n        timestamp = mytimestamp,\n        struct = dict(\n            date2 = mydate,\n            timestamp2 = mytimestamp\n        )\n    )\n\n    print repr(data)\n    jsonstring = dumps(data)\n    print jsonstring\n    print repr(loads(jsonstring))\n</code>\n</pre>\n", "senID": 9}], [{"text": ["I've worked it out."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Let's say you have a Python datetime object, d, created with datetime.now().", "Its value is:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "d", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n datetime.datetime(2011, 5, 25, 13, 34, 5, 787000)\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can serialize it to JSON as an ISO 8601 datetime string:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import json    \njson.dumps(d.isoformat())\n</code>\n</pre>\n", "senID": 4}, {"text": ["The example datetime object would be serialized as:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n '\"2011-05-25T13:34:05.787000\"'\n</code>\n</pre>\n", "senID": 6}, {"text": ["This value, once received in the Javascript layer, can construct a Date object:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n var d = new Date(\"2011-05-25T13:34:05.787000\");\n</code>\n</pre>\n", "senID": 8}, {"text": ["As of Javascript 1.8.5, Date objects have a toJSON method, which returns a string in a standard format.", "To serialize the above Javascript object back to JSON, therefore, the command would be:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n d.toJSON()\n</code>\n</pre>\n", "senID": 10}, {"text": ["Which would give you:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n '2011-05-25T20:34:05.787Z'\n</code>\n</pre>\n", "senID": 12}, {"text": ["This string, once received in Python, could be deserialized back to a datetime object:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n datetime.strptime('2011-05-25T20:34:05.787Z', '%Y-%m-%dT%H:%M:%S.%fZ')\n</code>\n</pre>\n", "senID": 14}, {"text": ["This results in the following datetime object, which is the same one you started with and therefore correct:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n datetime.datetime(2011, 5, 25, 20, 34, 5, 787000)\n</code>\n</pre>\n", "senID": 16}], [{"text": ["I can address you to eGenix Python extension, containing a lot of functions for handling date and time.", "Plus, i've found this article with some code to deal with Python to Javascript marshaling."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "extension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.egenix.com/products/python/mxBase/mxDateTime/"}, {"text": "this", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/200839/"}]}]]