[[{"code": "<pre>\n<code>\n import re\n\nwords = ('apple', 'plepe', 'leoran', 'lemon')\ns = 'bananaappleorangestrawberryapplepear'\n\nx = set()\n\nfor w in words:\n    for m in re.finditer(w, s):\n        i = m.start()\n        for j in range(i, i+len(w)):\n            x.add(j)\n\nresult = ''.join(('x' if i in x else s[i]) for i in range(len(s)))\nprint result\n</code>\n</pre>\n", "senID": 0}, {"text": ["produces:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n bananaxxxxxxxxxgestrawberryxxxxxxxar\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Here's another answer.", "There might be a faster way to replace the letters with x's, but I don't think that it is necessary because this is already pretty fast."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef do_xs(s,pats):\n    pat = re.compile('('+'|'.join(pats)+')')\n\n    sout = list(s)\n    i = 0\n    match = pat.search(s)\n    while match:\n        span = match.span()\n        sout[span[0]:span[1]] = ['x']*(span[1]-span[0])\n        i = span[0]+1\n        match = pat.search(s,i)\n    return ''.join(sout)\n\ntxt = 'bananaappleorangestrawberryapplepear'\npats = ('apple', 'plepe', 'leoran', 'lemon')\nprint do_xs(txt,pats)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Basically, I create a regex pattern that will match any of the input patterns.", "Then I just keep restarting the search starting 1 after the starting position of the most recent match.", "There might be a problem though if you have one of the input patterns is a prefix of another input pattern."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Assuming we're restricted to working without stdlib and other imports:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s1 = 'bananaappleorangestrawberryapplepear'\nt = ('apple', 'plepe', 'leoran', 'lemon')\ns2 = s1\n\nsolution = 'bananaxxxxxxxxxgestrawberryxxxxxxxar'\n\nfor word in t:\n    if word not in s1: continue\n    index = -1 # Start at -1 so our index search starts at 0\n    for iteration in range(s1.count(word)):\n        index = s1.find(word, index+1)\n        length = len(word)\n        before = s2[:index]\n        after = s2[index+length:]\n        s2 = before + 'x'*length + after\n\nprint s2 == solution\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; string_ = 'bananaappleorangestrawberryapplepear'\n&gt;&gt;&gt; words = ('apple', 'plepe', 'leoran', 'lemon')\n&gt;&gt;&gt; xes = [(string_.find(w), len(w)) for w in words]\n&gt;&gt;&gt; xes\n[(6, 5), (29, 5), (9, 6), (-1, 5)]\n&gt;&gt;&gt; for index, len_ in xes:\n...   if index == -1: continue\n...   string_ = string_.replace(string_[index:index+len_], 'x'*len_)\n...\n&gt;&gt;&gt; string_\n'bananaxxxxxxxxxgestrawberryxxxxxxxar'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}, {"text": ["There are surely more effective ways, but the premature optimisation is the root of all evil."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n a = ('apple', 'plepe', 'leoran', 'lemon')\nb = 'bananaappleorangestrawberryapplepear'\n\nfor fruit in a:\n    if a in b:\n        b = b.replace(fruit, numberofx's)\n</code>\n</pre>\n", "senID": 0}, {"text": ["The only thing you have to do now his determine how many X's to replace with."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n def mask_words(s, words):\n    mask = [False] * len(s)\n    for word in words:\n        pos = 0\n        while True:\n            idx = s.find(word, pos)\n            if idx == -1:\n                break\n\n            length = len(word)\n            for i in xrange(idx, idx+length):\n                mask[i] = True\n            pos = idx+length\n\n    # Sanity check:\n    assert len(mask) == len(s)\n\n    result = []\n    for masked, c in zip(mask, s):\n        result.append('x' if masked else c)\n\n    return \"\".join(result)\n</code>\n</pre>\n", "senID": 0}]]