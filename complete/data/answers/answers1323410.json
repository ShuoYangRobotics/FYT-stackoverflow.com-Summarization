[[{"text": ["in is definitely more pythonic, in fact has_key() was removed in python 3.x: http://docs.python.org/3.1/whatsnew/3.0.html#builtins"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "has_key()", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/3.1/whatsnew/3.0.html#builtins", "text": "http://docs.python.org/3.1/whatsnew/3.0.html#builtins", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["in wins hands-down, not just in elegance (and not being deprecated;-) but also in performance, e.g."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'd=dict.fromkeys(range(99))' '12 in d'\n10000000 loops, best of 3: 0.0983 usec per loop\n$ python -mtimeit -s'd=dict.fromkeys(range(99))' 'd.has_key(12)'\n1000000 loops, best of 3: 0.21 usec per loop\n</code>\n</pre>\n", "senID": 1}, {"text": ["While the following observation is not always true, you'll notice that usually, in Python, the faster solution is more elegant and Pythonic; that's why -mtimeit is SO helpful -- it's not just about saving a hundred nanoseconds here and there!-)"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "always", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "usually", "childNum": 0, "tag": "em", "childList": []}, {"text": "-mtimeit", "childNum": 0, "tag": "code", "childList": []}, {"text": "just", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["According to python docs:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#dict.has%5Fkey"}]}], [{"text": ["My $0.02: the more Pythonic answer would be to use in."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Use dict.has_key() if (and only if) your code is required to be runnable by Python versions earlier than 2.3 (when key in dict was introduced). "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "dict.has_key()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "key in dict", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["has_key is a dictionary method, but in will work on any collection, and even when __contains__ is missing, in will use any other method to iterate the collection to find out."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "has_key", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "childList": []}, {"text": "__contains__", "childNum": 0, "tag": "code", "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There is one example where in actually kills your performance."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you use in on a O(1) container that only implements __getitem__ and has_key() but not __contains__ you will turn an O(1) search into an O(N) search (as in falls back to a linear search via __getitem__)."], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__getitem__", "childNum": 0, "tag": "code", "childList": []}, {"text": "has_key()", "childNum": 0, "tag": "code", "childList": []}, {"text": "__contains__", "childNum": 0, "tag": "code", "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "childList": []}, {"text": "__getitem__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Fix is obviously trivial:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def __contains__(self, x):\n    return self.has_key(x)\n</code>\n</pre>\n", "senID": 3}]]