[[{"text": ["itertools and collections modules got just the stuff you need (flatten the nested lists with itertools.chain and count with collections.Counter"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "collections", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/dev/library/itertools.html#itertools.chain", "text": "itertools.chain", "childNum": 1, "tag": "a", "childList": [{"text": "itertools.chain", "tag": "code"}]}, {"text": "itertools.chain", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/dev/library/collections.html#collections.Counter", "text": "collections.Counter", "childNum": 1, "tag": "a", "childList": [{"text": "collections.Counter", "tag": "code"}]}, {"text": "collections.Counter", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools, collections\n\ndata = [[1,2,3],[1,1,1]]\ncounter = collections.Counter(itertools.chain(*data))\nprint counter[1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Use a recursive flatten function instead of itertools.chain to flatten nested lists of arbitrarily level depth"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "itertools.chain", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import operator, collections\n\ndef flatten(lst):\n    return reduce(operator.iadd, (flatten(i) if isinstance(i, collections.Sequence) else [i] for i in lst))\n</code>\n</pre>\n", "senID": 3}, {"text": ["reduce with operator.iadd has been used instead of sum so that the flattened is built only once and updated in-place"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "operator.iadd", "childNum": 0, "tag": "code", "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; L = [[1, 2, 3], [1, 1, 1]]\n&gt;&gt;&gt; sum(x.count(1) for x in L)\n4\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here is yet another approach to flatten a nested sequence.", "Once the sequence is flattened it is an easy check to find count of items."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "code", "senID": 1}, {"code": "<pre>\n<code>\n def flatten(seq,container=None):\n    if container is None:\n        container = []\n    for s in seq:\n        if hasattr(s,'__iter__'):\n            flatten(s,container)\n        else:\n            container.append(s)\n    return container\n\n\nc = flatten([(1,2),(3,4),(5,[6,7,['a','b']]),['c','d',('e',['f','g','h'])]])\nprint c\nprint c.count('g')\n\nd = flatten([[[1,(1,),((1,(1,))), [1,[1,[1,[1]]]], 1, [1, [1, (1,)]]]]])\nprint d\nprint d.count(1)\n</code>\n</pre>\n", "senID": 2}, {"senID": 3}, {"text": ["The above code prints:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n[1, 2, 3, 4, 5, 6, 7, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n1\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n12\n</pre>\n", "senID": 5}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n reduce(lambda x,y: x+y,list,[]).count(1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Basically, you start with an empty list [] and add each element of the list list to it.", "In this case the elements are lists themselves and you get a flattened list."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "[]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["PS: Just got downvoted for a similar answer in another question!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["PPS: Just got downvoted for this solution as well!"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["For the heck of it: count to any arbitrary nesting depth, handling tuples, lists and arguments:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n hits = lambda num, *n: ((1 if e == num else 0)\n    for a in n\n        for e in (hits(num, *a) if isinstance(a, (tuple, list)) else (a,)))\n\nlst = [[[1,(1,),((1,(1,))), [1,[1,[1,[1]]]], 1, [1, [1, (1,)]]]]]\nprint sum(hits(1, lst, 1, 1, 1))\n\n15\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If there is only one level of nesting flattening can be done with this list comprenension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; L = [[1,2,3],[1,1,1]]\n&gt;&gt;&gt; [ item for sublist in L for item in sublist ].count(1)\n4\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def nested_count(lst, x):\n    return lst.count(x) + sum(\n        nested_count(l,x) for l in lst if isinstance(l,list))\n</code>\n</pre>\n", "senID": 0}, {"text": ["This function returns the number of occurrences, plus the recursive nested count in all contained sub-lists."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; data = [[1,2,3],[1,1,[1,1]]]\n&gt;&gt;&gt; print nested_count(data, 1)\n5\n</code>\n</pre>\n", "senID": 2}]]