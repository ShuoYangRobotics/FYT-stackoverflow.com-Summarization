[[{"text": ["You cant override the built-in comparison functions.", "In some sense the comparison operators are already returning int.", "bool is a subclass of int, so you can do anything to it that you can do to a int.", "The question then becomes why would you want to have comparisons return int objects, not bool objects?"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "bool", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["You can have the comparison operators of your custom classes return whatever you like -- simply implement the relevant methods (__eq__, __ne__, __gt__, __lt__, __ge__, __le__) to return what you want.", "For objects that you don't control you cannot change this, but there should be no need to: bools are ints, because of the Liskov substitution principle.", "Code that notices a difference between the bool returned by the builtin types' __eq__ methods and any other integer is using the result wrong."], "childNum": 9, "tag": "p", "senID": 0, "childList": [{"text": "__eq__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__ne__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__gt__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__lt__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__ge__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__le__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "are", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "the Liskov substitution principle", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Liskov_substitution_principle"}, {"text": "__eq__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The __future__ module isn't relevant here; you can't use it to do whatever you want, you can only use it to change specific settings that were added to Python.", "You can turn division into true division with the __future__ import because that's what was added to Python.", "The only way to add more __future__ imports is by modifying Python itself."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "__future__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__future__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__future__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Based on your clarification, you might change your comparison operator to something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n stack.push(1 if stack.pop() &gt; stack.pop() else 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will convert the boolean result of &gt; to 1 or 0 as you would like."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also, be careful about calling stack.pop() twice in the same expression.", "You don't know (for sure) what order the arguments will be evaluated in, and different implementations of Python may very well pop the arguments in a different order.", "You will need to use temporary variables:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "stack.pop()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n x = stack.pop()\ny = stack.pop()\nstack.push(1 if x &gt; y else 0)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["On your own objects, it is easy to override each comparison operator.", "For built-ins, the override methods are \"read only\" so all my attempts to set them don't pan out. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class foo:\n   def __lt__(self, other):\n      return cmp(5, other)\n\n&gt;&gt;&gt; f = foo()\n&gt;&gt;&gt; f&lt;3\n1\n&gt;&gt;&gt; f&lt;7\n-1\n&gt;&gt;&gt; f&lt;5\n0\n\n&gt;&gt;&gt; j=\"\"\n&gt;&gt;&gt; j.__lt__=lambda other: cmp(5, other)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in ?\nAttributeError: 'str' object attribute '__lt__' is read-only\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Cast your bool to an int?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["&gt;&gt;&gt; int(True)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "&gt;&gt;&gt; int(True)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": [], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["&gt;&gt;&gt; int(False)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "&gt;&gt;&gt; int(False)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": [], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Or cast that to a str?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["&gt;&gt;&gt; str(int(True))"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "&gt;&gt;&gt; str(int(True))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["'1'"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "'1'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["&gt;&gt;&gt; str(int(False))"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "&gt;&gt;&gt; str(int(False))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["'0'"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "'0'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["No, you can't.", "When Guido unified types and classes, he found a way to override the behavior of built-in types (due to the way he implemented things), but he declared it a bug and plugged the loophole.", "Changing the behavior of built-in types (except for your example - importing division from future, which is there for a good reason) is forbidden."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Sorry, but I can't find the mailing list post.", "I remember it though, as it was quite interesting."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]