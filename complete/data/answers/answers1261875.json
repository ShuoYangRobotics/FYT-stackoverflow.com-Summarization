[[{"text": ["Compare this, without using nonlocal:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def outer():\n       x = 1\n       def inner():\n           x = 2\n           print(\"inner:\", x)\n       inner()\n       print(\"outer:\", x)\n\n\n&gt;&gt;&gt; outer()\ninner: 2\nouter: 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["To this, using nonlocal:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def outer():\n       x = 1\n       def inner():\n           nonlocal x\n           x = 2\n           print(\"inner:\", x)\n       inner()\n       print(\"outer:\", x)\n\n\n&gt;&gt;&gt; outer()\ninner: 2\nouter: 2\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It's documented in the Language Reference here."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/3.1/reference/simple%5Fstmts.html#the-nonlocal-statement"}]}], [{"text": ["In short, it lets you assign values to a variable in an outer (but non-global) scope.", "See PEP 3104 for all the gory details. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PEP 3104", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3104/"}]}], [{"text": ["A google search for \"python nonlocal\" turned up the Proposal, PEP 3104, which fully describes the syntax and reasoning behind the statement.", "in short, it works in exactly the same way as the global statement, except that it is used to refer to variables that are neither global nor local to the function. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PEP 3104", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3104/"}, {"text": "global", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Here's a brief example of what you can do with this.", "The counter generator can be rewritten to use this so that it looks more like the idioms of languages with closures."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def make_counter():\n    count = 0\n    def counter():\n        nonlocal count\n        count += 1\n        return count\n    return counter\n</code>\n</pre>\n", "senID": 2}, {"text": ["Obviously, you could write this as a generator, like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def counter_generator():\n    count = 0\n    while True:\n        count += 1\n        yield count\n</code>\n</pre>\n", "senID": 4}, {"text": ["But while this is perfectly idiomatic python, it seems that the first version would be a bit more obvious for beginners.", "Properly using generators, by calling the returned function, is a common point of confusion.", "The first version explicitly returns a function."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "But", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["@ooboo:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It takes the one \"closest\" to the point of reference in the source code.", "This is called \"Lexical Scoping\" and is standard for >40 years now."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Python's class members are really in a dictionary called __dict__ and will never be reached by lexical scoping."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you don't specify nonlocal but do x = 7, it will create a new local variable \"x\".", "If you do specify nonlocal, it will find the \"closest\" \"x\" and assign to that.", "If you specify nonlocal and there is no \"x\", it will give you an error message."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x = 7", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The keyword global has always seemed strange to me since it will happily ignore all the other \"x\" except for the outermost one.", "Weird."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "global", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["My personal understanding of the \"nonlocal\" statement (and do excuse me as I am new to Python and Programming in general) is that the \"nonlocal\" is a way to use the Global functionality within iterated functions rather than the body of the code itself.", "A Global statement between functions if you will."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["help('nonlocal')\nThe nonlocal statement"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["nonlocal_stmt ::= \"nonlocal\" identifier (\",\" identifier)*"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The nonlocal statement causes the listed identifiers to refer to\npreviously bound variables in the nearest enclosing scope.", "This is\nimportant because the default behavior for binding is to search the\nlocal namespace first.", "The statement allows encapsulated code to\nrebind variables outside of the local scope besides the global\n(module) scope."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Names listed in a nonlocal statement, unlike to those listed in a\nglobal statement, must refer to pre-existing bindings in an\nenclosing scope (the scope in which a new binding should be created\ncannot be determined unambiguously)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Names listed in a nonlocal statement must not collide with pre-\nexisting bindings in the local scope."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See also:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["PEP 3104 - Access to Names in Outer Scopes\n      The specification for the nonlocal statement."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "PEP 3104", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "nonlocal", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Related help topics: global, NAMESPACES"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]