[[{"text": ["Here's the complete regexp to parse a URL."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-none prettyprint-override\">\n<code>\n (?:http://(?:(?:(?:(?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?)\\.\n)*(?:[a-zA-Z](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:(?:\\d+)(?:\\.(?:\\d+)\n){3}))(?::(?:\\d+))?)(?:/(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\n\\d]{2}))|[;:@&amp;=])*)(?:/(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{\n2}))|[;:@&amp;=])*))*)(?:\\?(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{\n2}))|[;:@&amp;=])*))?)?)|(?:ftp://(?:(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?\n:%[a-fA-F\\d]{2}))|[;?&amp;=])*)(?::(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-\nfA-F\\d]{2}))|[;?&amp;=])*))?@)?(?:(?:(?:(?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]|-\n)*[a-zA-Z\\d])?)\\.)*(?:[a-zA-Z](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:(?\n:\\d+)(?:\\.(?:\\d+)){3}))(?::(?:\\d+))?))(?:/(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+!\n*'(),]|(?:%[a-fA-F\\d]{2}))|[?:@&amp;=])*)(?:/(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'()\n,]|(?:%[a-fA-F\\d]{2}))|[?:@&amp;=])*))*)(?:;type=[AIDaid])?)?)|(?:news:(?:\n(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[;/?:&amp;=])+@(?:(?:(\n?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?)\\.)*(?:[a-zA-Z](?:(?:[\na-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:(?:\\d+)(?:\\.(?:\\d+)){3})))|(?:[a-zA-Z](\n?:[a-zA-Z\\d]|[_.+-])*)|\\*))|(?:nntp://(?:(?:(?:(?:(?:[a-zA-Z\\d](?:(?:[\na-zA-Z\\d]|-)*[a-zA-Z\\d])?)\\.)*(?:[a-zA-Z](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d\n])?))|(?:(?:\\d+)(?:\\.(?:\\d+)){3}))(?::(?:\\d+))?)/(?:[a-zA-Z](?:[a-zA-Z\n\\d]|[_.+-])*)(?:/(?:\\d+))?)|(?:telnet://(?:(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+\n!*'(),]|(?:%[a-fA-F\\d]{2}))|[;?&amp;=])*)(?::(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'()\n,]|(?:%[a-fA-F\\d]{2}))|[;?&amp;=])*))?@)?(?:(?:(?:(?:(?:[a-zA-Z\\d](?:(?:[a\n-zA-Z\\d]|-)*[a-zA-Z\\d])?)\\.)*(?:[a-zA-Z](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d]\n)?))|(?:(?:\\d+)(?:\\.(?:\\d+)){3}))(?::(?:\\d+))?))/?)|(?:gopher://(?:(?:\n(?:(?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?)\\.)*(?:[a-zA-Z](?:\n(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:(?:\\d+)(?:\\.(?:\\d+)){3}))(?::(?:\\d+\n))?)(?:/(?:[a-zA-Z\\d$\\-_.+!*'(),;/?:@&amp;=]|(?:%[a-fA-F\\d]{2}))(?:(?:(?:[\na-zA-Z\\d$\\-_.+!*'(),;/?:@&amp;=]|(?:%[a-fA-F\\d]{2}))*)(?:%09(?:(?:(?:[a-zA\n-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[;:@&amp;=])*)(?:%09(?:(?:[a-zA-Z\\d$\n\\-_.+!*'(),;/?:@&amp;=]|(?:%[a-fA-F\\d]{2}))*))?)?)?)?)|(?:wais://(?:(?:(?:\n(?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?)\\.)*(?:[a-zA-Z](?:(?:\n[a-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:(?:\\d+)(?:\\.(?:\\d+)){3}))(?::(?:\\d+))?\n)/(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))*)(?:(?:/(?:(?:[a-zA\n-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))*)/(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(\n?:%[a-fA-F\\d]{2}))*))|\\?(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]\n{2}))|[;:@&amp;=])*))?)|(?:mailto:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),;/?:@&amp;=]|(?:%\n[a-fA-F\\d]{2}))+))|(?:file://(?:(?:(?:(?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]\n|-)*[a-zA-Z\\d])?)\\.)*(?:[a-zA-Z](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:\n(?:\\d+)(?:\\.(?:\\d+)){3}))|localhost)?/(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'()\n,]|(?:%[a-fA-F\\d]{2}))|[?:@&amp;=])*)(?:/(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(\n?:%[a-fA-F\\d]{2}))|[?:@&amp;=])*))*))|(?:prospero://(?:(?:(?:(?:(?:[a-zA-Z\n\\d](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?)\\.)*(?:[a-zA-Z](?:(?:[a-zA-Z\\d]|-)\n*[a-zA-Z\\d])?))|(?:(?:\\d+)(?:\\.(?:\\d+)){3}))(?::(?:\\d+))?)/(?:(?:(?:(?\n:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[?:@&amp;=])*)(?:/(?:(?:(?:[a-\nzA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[?:@&amp;=])*))*)(?:(?:;(?:(?:(?:[\na-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[?:@&amp;])*)=(?:(?:(?:[a-zA-Z\\d\n$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[?:@&amp;])*)))*)|(?:ldap://(?:(?:(?:(?:\n(?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?)\\.)*(?:[a-zA-Z](?:(?:\n[a-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:(?:\\d+)(?:\\.(?:\\d+)){3}))(?::(?:\\d+))?\n))?/(?:(?:(?:(?:(?:(?:(?:[a-zA-Z\\d]|%(?:3\\d|[46][a-fA-F\\d]|[57][Aa\\d])\n)|(?:%20))+|(?:OID|oid)\\.(?:(?:\\d+)(?:\\.(?:\\d+))*))(?:(?:%0[Aa])?(?:%2\n0)*)=(?:(?:%0[Aa])?(?:%20)*))?(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\n\\d]{2}))*))(?:(?:(?:%0[Aa])?(?:%20)*)\\+(?:(?:%0[Aa])?(?:%20)*)(?:(?:(?\n:(?:(?:[a-zA-Z\\d]|%(?:3\\d|[46][a-fA-F\\d]|[57][Aa\\d]))|(?:%20))+|(?:OID\n|oid)\\.(?:(?:\\d+)(?:\\.(?:\\d+))*))(?:(?:%0[Aa])?(?:%20)*)=(?:(?:%0[Aa])\n?(?:%20)*))?(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))*)))*)(?:(\n?:(?:(?:%0[Aa])?(?:%20)*)(?:[;,])(?:(?:%0[Aa])?(?:%20)*))(?:(?:(?:(?:(\n?:(?:[a-zA-Z\\d]|%(?:3\\d|[46][a-fA-F\\d]|[57][Aa\\d]))|(?:%20))+|(?:OID|o\nid)\\.(?:(?:\\d+)(?:\\.(?:\\d+))*))(?:(?:%0[Aa])?(?:%20)*)=(?:(?:%0[Aa])?(\n?:%20)*))?(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))*))(?:(?:(?:\n%0[Aa])?(?:%20)*)\\+(?:(?:%0[Aa])?(?:%20)*)(?:(?:(?:(?:(?:[a-zA-Z\\d]|%(\n?:3\\d|[46][a-fA-F\\d]|[57][Aa\\d]))|(?:%20))+|(?:OID|oid)\\.(?:(?:\\d+)(?:\n\\.(?:\\d+))*))(?:(?:%0[Aa])?(?:%20)*)=(?:(?:%0[Aa])?(?:%20)*))?(?:(?:[a\n-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))*)))*))*(?:(?:(?:%0[Aa])?(?:%2\n0)*)(?:[;,])(?:(?:%0[Aa])?(?:%20)*))?)(?:\\?(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+\n!*'(),]|(?:%[a-fA-F\\d]{2}))+)(?:,(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-f\nA-F\\d]{2}))+))*)?)(?:\\?(?:base|one|sub)(?:\\?(?:((?:[a-zA-Z\\d$\\-_.+!*'(\n),;/?:@&amp;=]|(?:%[a-fA-F\\d]{2}))+)))?)?)?)|(?:(?:z39\\.50[rs])://(?:(?:(?\n:(?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?)\\.)*(?:[a-zA-Z](?:(?\n:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:(?:\\d+)(?:\\.(?:\\d+)){3}))(?::(?:\\d+))\n?)(?:/(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))+)(?:\\+(?:(?:\n[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))+))*(?:\\?(?:(?:[a-zA-Z\\d$\\-_\n.+!*'(),]|(?:%[a-fA-F\\d]{2}))+))?)?(?:;esn=(?:(?:[a-zA-Z\\d$\\-_.+!*'(),\n]|(?:%[a-fA-F\\d]{2}))+))?(?:;rs=(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA\n-F\\d]{2}))+)(?:\\+(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))+))*)\n?))|(?:cid:(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[;?:@&amp;=\n])*))|(?:mid:(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[;?:@\n&amp;=])*)(?:/(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[;?:@&amp;=]\n)*))?)|(?:vemmi://(?:(?:(?:(?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\n\\d])?)\\.)*(?:[a-zA-Z](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:(?:\\d+)(?:\\\n.(?:\\d+)){3}))(?::(?:\\d+))?)(?:/(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a\n-fA-F\\d]{2}))|[/?:@&amp;=])*)(?:(?:;(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a\n-fA-F\\d]{2}))|[/?:@&amp;])*)=(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d\n]{2}))|[/?:@&amp;])*))*))?)|(?:imap://(?:(?:(?:(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+\n!*'(),]|(?:%[a-fA-F\\d]{2}))|[&amp;=~])+)(?:(?:;[Aa][Uu][Tt][Hh]=(?:\\*|(?:(\n?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[&amp;=~])+))))?)|(?:(?:;[\nAa][Uu][Tt][Hh]=(?:\\*|(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2\n}))|[&amp;=~])+)))(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[\n&amp;=~])+))?))@)?(?:(?:(?:(?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])\n?)\\.)*(?:[a-zA-Z](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:(?:\\d+)(?:\\.(?:\n\\d+)){3}))(?::(?:\\d+))?))/(?:(?:(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:\n%[a-fA-F\\d]{2}))|[&amp;=~:@/])+)?;[Tt][Yy][Pp][Ee]=(?:[Ll](?:[Ii][Ss][Tt]|\n[Ss][Uu][Bb])))|(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))\n|[&amp;=~:@/])+)(?:\\?(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[\n&amp;=~:@/])+))?(?:(?:;[Uu][Ii][Dd][Vv][Aa][Ll][Ii][Dd][Ii][Tt][Yy]=(?:[1-\n9]\\d*)))?)|(?:(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[&amp;=~\n:@/])+)(?:(?:;[Uu][Ii][Dd][Vv][Aa][Ll][Ii][Dd][Ii][Tt][Yy]=(?:[1-9]\\d*\n)))?(?:/;[Uu][Ii][Dd]=(?:[1-9]\\d*))(?:(?:/;[Ss][Ee][Cc][Tt][Ii][Oo][Nn\n]=(?:(?:(?:[a-zA-Z\\d$\\-_.+!*'(),]|(?:%[a-fA-F\\d]{2}))|[&amp;=~:@/])+)))?))\n)?)|(?:nfs:(?:(?://(?:(?:(?:(?:(?:[a-zA-Z\\d](?:(?:[a-zA-Z\\d]|-)*[a-zA-\nZ\\d])?)\\.)*(?:[a-zA-Z](?:(?:[a-zA-Z\\d]|-)*[a-zA-Z\\d])?))|(?:(?:\\d+)(?:\n\\.(?:\\d+)){3}))(?::(?:\\d+))?)(?:(?:/(?:(?:(?:(?:(?:[a-zA-Z\\d\\$\\-_.!~*'\n(),])|(?:%[a-fA-F\\d]{2})|[:@&amp;=+])*)(?:/(?:(?:(?:[a-zA-Z\\d\\$\\-_.!~*'(),\n])|(?:%[a-fA-F\\d]{2})|[:@&amp;=+])*))*)?)))?)|(?:/(?:(?:(?:(?:(?:[a-zA-Z\\d\n\\$\\-_.!~*'(),])|(?:%[a-fA-F\\d]{2})|[:@&amp;=+])*)(?:/(?:(?:(?:[a-zA-Z\\d\\$\\\n-_.!~*'(),])|(?:%[a-fA-F\\d]{2})|[:@&amp;=+])*))*)?))|(?:(?:(?:(?:(?:[a-zA-\nZ\\d\\$\\-_.!~*'(),])|(?:%[a-fA-F\\d]{2})|[:@&amp;=+])*)(?:/(?:(?:(?:[a-zA-Z\\d\n\\$\\-_.!~*'(),])|(?:%[a-fA-F\\d]{2})|[:@&amp;=+])*))*)?)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Given its complexibility, I think you should go the urlparse way."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For completeness, here's the pseudo-BNF of the above regex (as a documentation):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n; The generic form of a URL is:\n\ngenericurl     = scheme \":\" schemepart\n\n; Specific predefined schemes are defined here; new schemes\n; may be registered with IANA\n\nurl            = httpurl | ftpurl | newsurl |\n                 nntpurl | telneturl | gopherurl |\n                 waisurl | mailtourl | fileurl |\n                 prosperourl | otherurl\n\n; new schemes follow the general syntax\notherurl       = genericurl\n\n; the scheme is in lower case; interpreters should use case-ignore\nscheme         = 1*[ lowalpha | digit | \"+\" | \"-\" | \".\" ]\nschemepart     = *xchar | ip-schemepart\n\n\n; URL schemeparts for ip based protocols:\n\nip-schemepart  = \"//\" login [ \"/\" urlpath ]\n\nlogin          = [ user [ \":\" password ] \"@\" ] hostport\nhostport       = host [ \":\" port ]\nhost           = hostname | hostnumber\nhostname       = *[ domainlabel \".\" ] toplabel\ndomainlabel    = alphadigit | alphadigit *[ alphadigit | \"-\" ] alphadigit\ntoplabel       = alpha | alpha *[ alphadigit | \"-\" ] alphadigit\nalphadigit     = alpha | digit\nhostnumber     = digits \".\" digits \".\" digits \".\" digits\nport           = digits\nuser           = *[ uchar | \";\" | \"?\" | \"&\" | \"=\" ]\npassword       = *[ uchar | \";\" | \"?\" | \"&\" | \"=\" ]\nurlpath        = *xchar    ; depends on protocol see section 3.1\n\n; The predefined schemes:\n\n; FTP (see also RFC959)\n\nftpurl         = \"ftp://\" login [ \"/\" fpath [ \";type=\" ftptype ]]\nfpath          = fsegment *[ \"/\" fsegment ]\nfsegment       = *[ uchar | \"?\" | \":\" | \"@\" | \"&\" | \"=\" ]\nftptype        = \"A\" | \"I\" | \"D\" | \"a\" | \"i\" | \"d\"\n\n; FILE\n\nfileurl        = \"file://\" [ host | \"localhost\" ] \"/\" fpath\n\n; HTTP\n\nhttpurl        = \"http://\" hostport [ \"/\" hpath [ \"?\" search ]]\nhpath          = hsegment *[ \"/\" hsegment ]\nhsegment       = *[ uchar | \";\" | \":\" | \"@\" | \"&\" | \"=\" ]\nsearch         = *[ uchar | \";\" | \":\" | \"@\" | \"&\" | \"=\" ]\n\n; GOPHER (see also RFC1436)\n\ngopherurl      = \"gopher://\" hostport [ / [ gtype [ selector\n                 [ \"%09\" search [ \"%09\" gopher+_string ] ] ] ] ]\ngtype          = xchar\nselector       = *xchar\ngopher+_string = *xchar\n\n; MAILTO (see also RFC822)\n\nmailtourl      = \"mailto:\" encoded822addr\nencoded822addr = 1*xchar               ; further defined in RFC822\n\n; NEWS (see also RFC1036)\n\nnewsurl        = \"news:\" grouppart\ngrouppart      = \"*\" | group | article\ngroup          = alpha *[ alpha | digit | \"-\" | \".\" | \"+\" | \"_\" ]\narticle        = 1*[ uchar | \";\" | \"/\" | \"?\" | \":\" | \"&\" | \"=\" ] \"@\" host\n\n; NNTP (see also RFC977)\n\nnntpurl        = \"nntp://\" hostport \"/\" group [ \"/\" digits ]\n\n; TELNET\n\ntelneturl      = \"telnet://\" login [ \"/\" ]\n\n; WAIS (see also RFC1625)\n\nwaisurl        = waisdatabase | waisindex | waisdoc\nwaisdatabase   = \"wais://\" hostport \"/\" database\nwaisindex      = \"wais://\" hostport \"/\" database \"?\" search\nwaisdoc        = \"wais://\" hostport \"/\" database \"/\" wtype \"/\" wpath\ndatabase       = *uchar\nwtype          = *uchar\nwpath          = *uchar\n\n; PROSPERO\n\nprosperourl    = \"prospero://\" hostport \"/\" ppath *[ fieldspec ]\nppath          = psegment *[ \"/\" psegment ]\npsegment       = *[ uchar | \"?\" | \":\" | \"@\" | \"&\" | \"=\" ]\nfieldspec      = \";\" fieldname \"=\" fieldvalue\nfieldname      = *[ uchar | \"?\" | \":\" | \"@\" | \"&\" ]\nfieldvalue     = *[ uchar | \"?\" | \":\" | \"@\" | \"&\" ]\n\n; Miscellaneous definitions\n\nlowalpha       = \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" |\n                 \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" |\n                 \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" |\n                 \"y\" | \"z\"\nhialpha        = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" |\n                 \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" |\n                 \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"\nalpha          = lowalpha | hialpha\ndigit          = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" |\n                 \"8\" | \"9\"\nsafe           = \"$\" | \"-\" | \"_\" | \".\" | \"+\"\nextra          = \"!\" | \"*\" | \"'\" | \"(\" | \")\" | \",\"\nnational       = \"{\" | \"}\" | \"|\" | \"\\\" | \"^\" | \"~\" | \"[\" | \"]\" | \"`\"\npunctuation    = \"\" | \"#\" | \"%\" | \n\n\nreserved       = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\"\nhex            = digit | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" |\n                 \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"\nescape         = \"%\" hex hex\n\nunreserved     = alpha | digit | safe | extra\nuchar          = unreserved | escape\nxchar          = unreserved | reserved | escape\ndigits         = 1*digit\n</pre>\n", "senID": 4}], [{"text": ["An easy way to parse (and validate) URL's is the urlparse module.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "urlparse", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/urlparse.html"}]}, {"text": ["A regex is too much work."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "hr", "senID": 2}, {"text": ["There's no \"validate\" method because almost anything is a valid URL.", "There are some punctuation rules for splitting it up.", "Absent any punctuation, you still have a valid URL."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Check the RFC carefully and see if you can construct an \"invalid\" URL.", "The rules are very flexible.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["For example ::::: is a valid URL.", "The path is \":::::\".", "A pretty stupid filename, but a valid filename."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": ":::::", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\":::::\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Also, ///// is a valid URL.", "The netloc (\"hostname\") is \"\".", "The path is \"///\".", "Again, stupid.", "Also valid.", "This URL normalizes to \"///\" which is the equivalent."], "childNum": 4, "tag": "p", "senID": 6, "childList": [{"text": "/////", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\"///\"", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "\"///\"", "childNum": 0, "tag": "code", "pos": 5, "childList": []}]}, {"text": ["Something like \"bad://///worse/////\" is perfectly valid.", "Dumb but valid."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "\"bad://///worse/////\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Bottom Line.", "Parse it, and look at the pieces to see if they're displeasing in some way.  "], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Bottom Line", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Do you want the scheme to always be \"http\"?", "Do you want the netloc to always be \"www.somename.somedomain\"?", "Do you want the path to look unix-like?", "Or windows-like?", "Do you want to remove the query string?", "Or preserve it?"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["These are not RFC-specified validations.", "These are validations unique to your application."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I admit, I find your regular expression totally incomprehensible.", "I wonder if you could use urlparse instead?", "Something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n pieces = urlparse.urlparse(url)\nassert all([pieces.scheme, pieces.netloc])\nassert set(pieces.netloc) &lt;= set(string.letters + string.digits + '-.')  # and others?\nassert pieces.scheme in ['http', 'https', 'ftp']  # etc.\n</code>\n</pre>\n", "senID": 1}, {"text": ["It might be slower, and maybe you'll miss conditions, but it seems (to me) a lot easier to read and debug than a regular expression for URLs."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "a regular expression for URLs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codinghorror.com/blog/archives/001181.html"}]}], [{"text": ["RFC 3696 defines \"best practices\" for URL validation - http://www.faqs.org/rfcs/rfc3696.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.faqs.org/rfcs/rfc3696.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.faqs.org/rfcs/rfc3696.html"}]}, {"text": ["The latest release of Lepl (a Python parser library) includes an implementation of RFC 3696.", "You would use it something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from lepl.apps.rfc3696 import Email, HttpUrl\n\n# compile the validators (do once at start of program)\nvalid_email = Email()\nvalid_http_url = HttpUrl()\n\n# use the validators (as often as you like)\nif valid_email(some_email):\n    # email is ok\nelse:\n    # email is bad\nif valid_http_url(some_url):\n    # url is ok\nelse:\n    # url is bad\n</code>\n</pre>\n", "senID": 2}, {"text": ["Although the validators are defined in Lepl, which is a recursive descent parser, they are largely compiled internally to regular expressions.", "That combines the best of both worlds - a (relatively) easy to read definition that can be checked against RFC 3696 and an efficient implementation.", "There's a post on my blog showing how this simplifies the parser - http://www.acooke.org/cute/LEPLOptimi0.html"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "and", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "http://www.acooke.org/cute/LEPLOptimi0.html", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.acooke.org/cute/LEPLOptimi0.html"}]}, {"text": ["Lepl is available at http://www.acooke.org/lepl and the RFC 3696 module is documented at http://www.acooke.org/lepl/rfc3696.html"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "http://www.acooke.org/lepl", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.acooke.org/lepl"}, {"href": "http://www.acooke.org/lepl/rfc3696.html", "text": "http://www.acooke.org/lepl/rfc3696.html", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["This is completely new in this release, so may contain bugs.", "Please contact me if you have any problems and I will fix them ASAP.", "Thanks."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["The regex provided should match any url of the form http://www.ietf.org/rfc/rfc3986.txt; and does when tested in the python interpreter."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.ietf.org/rfc/rfc3986.txt", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ietf.org/rfc/rfc3986.txt"}]}, {"text": ["What format have the URLs you've been having trouble parsing had?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I've needed to do this many times over the years and always end up copying someone else's regular expression who has thought about it way more than I want to think about it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "want", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Having said that, there is a regex in the Django forms code which should do the trick:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://code.djangoproject.com/browser/django/trunk/django/forms/fields.py#L534"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://code.djangoproject.com/browser/django/trunk/django/forms/fields.py#L534", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/browser/django/trunk/django/forms/fields.py#L534"}]}], [{"text": ["urlparse quite happily takes invalid URLs, it is more a string string-splitting library than any kind of validator.", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "urlparse", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from urlparse import urlparse\nurlparse('http://----')\n# returns: ParseResult(scheme='http', netloc='----', path='', params='', query='', fragment='')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Depending on the situation, this might be fine.."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you mostly trust the data, and just want to verify the protocol is HTTP, then urlparse is perfect."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "urlparse", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you want to make the URL is actually a legal URL, use the ridiculous regex"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "the ridiculous regex", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/827557/how-do-you-validate-a-url-with-a-regular-expression-in-python/835527#835527"}]}, {"text": ["If you want to make sure it's a real web address,"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import urllib\ntry:\n    urllib.urlopen(url)\nexcept IOError:\n    print \"Not a real URL\"\n</code>\n</pre>\n", "senID": 6}], [{"code": "<pre>\n<code>\n urlfinders = [\n    re.compile(\"([0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}|(((news|telnet|nttp|file|http|ftp|https)://)|(www|ftp)[-A-Za-z0-9]*\\\\.)[-A-Za-z0-9\\\\.]+)(:[0-9]*)?/[-A-Za-z0-9_\\\\$\\\\.\\\\+\\\\!\\\\*\\\\(\\\\),;:@&amp;=\\\\?/~\\\\#\\\\%]*[^]'\\\\.}&gt;\\\\),\\\\\\\"]\"),\n    re.compile(\"([0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}|(((news|telnet|nttp|file|http|ftp|https)://)|(www|ftp)[-A-Za-z0-9]*\\\\.)[-A-Za-z0-9\\\\.]+)(:[0-9]*)?\"),\n    re.compile(\"(~/|/|\\\\./)([-A-Za-z0-9_\\\\$\\\\.\\\\+\\\\!\\\\*\\\\(\\\\),;:@&amp;=\\\\?/~\\\\#\\\\%]|\\\\\\\\\n)+\"),\n    re.compile(\"'\\\\&lt;((mailto:)|)[-A-Za-z0-9\\\\.]+@[-A-Za-z0-9\\\\.]+\"),\n]\n</code>\n</pre>\n", "senID": 0}, {"text": ["NOTE: As ugly as it looks in your browser just copy paste and the formatting should be good"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Found at the python mailing lists and used for the gnome-terminal"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["source: http://mail.python.org/pipermail/python-list/2007-January/595436.html"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://mail.python.org/pipermail/python-list/2007-January/595436.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2007-January/595436.html"}]}], [{"text": ["I'm using the one used by Django and it seems pretty well:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_valid_url(url):\n    import re\n    regex = re.compile(\n        r'^https?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})' # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return url is not None and regex.search(url)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You always can check the last version here: https://code.djangoproject.com/browser/django/trunk/django/core/validators.py#L47"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "https://code.djangoproject.com/browser/django/trunk/django/core/validators.py#L47", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://code.djangoproject.com/browser/django/trunk/django/core/validators.py#L47"}]}], [{"text": ["function isUrl(s) {\n var regexp = /(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.", "?+=&amp;%@!-\\/]))?/\n return regexp.test(s);\n}"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]