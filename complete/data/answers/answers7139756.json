[[{"text": ["Yes it is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n reduce(lambda x,y: x + (y == 'apple'), l, 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["But as you mentioned yourself, there is no need to use reduce here.", "It is likely that it will be slower than any other counting method and the intention is not immediately clear."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This is easiest using an initializer (the extra 0 at the end of the call to reduce), so you only need to convert the second argument:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n reduce(lambda x, y: x + (1 if y=='apple' else 0), [1,'apple',2,'apple','apple'], 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or you can reduce something that has been transformed by a map into 0 and 1:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n reduce(lambda x, y: x+y, map(lambda x: 1 if x=='apple' else 0,  [1,'apple',2,'apple','apple']))\n</code>\n</pre>\n", "senID": 3}, {"text": ["But there are lots of ways to make this more natural:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "use list comprehensions rather than reduce", "tag": "none", "senID": 5}, {"text": "use the operators package instead of defining your own function for addition", "tag": "none", "senID": 6}, {"text": "user itertools", "tag": "none", "senID": 7}]}, {"text": ["(And the counter suggestion above is really cool - I don't think I even knew that existed."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["A simpler (but not very efficient) approach would be:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n len([x for x in [1,'apple',2,'apple','apple'] if x=='apple'])\n</code>\n</pre>\n", "senID": 10}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; l\n[1, 'apple', 2, 'apple', 'apple']\n&gt;&gt;&gt; reduce(lambda x, y: x + (1 if y == 'apple' else 0), l, 0)\n3\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; l = [1,'apple',2,'apple','apple']\n&gt;&gt;&gt; reduce(lambda s, i: s+1 if i == \"apple\" else s, l, 0)\n3\n</code>\n</pre>\n", "senID": 0}, {"text": ["You can simplify s+1 if i == \"apple\" else s part to just s + (i == \"apple\"), but I think implicit bool => int conversions are cryptic.", "But using reduce for this job is cryptic anyway :)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "s+1 if i == \"apple\" else s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "s + (i == \"apple\")", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["If you use a \"real\" function instead of a lambda function solutions to problems like this usually become much clearer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def count_apples(acc, v):\n   if v == 'apple':\n      return acc+1\n   else:\n      return acc\n\nl = [1,'apple',2,'apple','apple']\nprint reduce(count_apples, l, 0)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n from operator import mul\nfrom time import clock\n\nn= 10000\n\nli = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\nte = clock()\nfor i in xrange(n):\n    x = reduce(mul,li)\nprint clock()-te\n\n\nte = clock()\nfor i in xrange(n):\n    y = reduce(lambda a,b: a*b,li)\nprint clock()-te\n\n\nprint x==y\n</code>\n</pre>\n", "senID": 0}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n 0.0616016840129\n0.124420003101\nTrue\n</code>\n</pre>\n", "senID": 2}, {"text": [], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n li = [1,78,2,2,12,45,1,2,8,1,2,5,4,2]\n\n\nte = clock()\nfor i in xrange(n):\n    x = li.count(2)\nprint clock()-te\n\nte = clock()\nfor i in xrange(n):\n    y = sum(1 for a in li if a==2)\nprint clock()-te\n\nte = clock()\nfor i in xrange(n):\n    z = len([a for a in li if a==2])\nprint clock()-te\n\nprint x==y==z\n</code>\n</pre>\n", "senID": 4}, {"text": ["produces"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n 0.0110332458455\n0.0428308625817\n0.0518741907142\nTrue\n</code>\n</pre>\n", "senID": 6}]]