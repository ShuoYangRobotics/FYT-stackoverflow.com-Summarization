[[{"text": ["Don't parse it.", "Just ask."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import socket\n\ntry:\n    socket.inet_aton(addr)\n    # legal\nexcept socket.error:\n    # Not legal\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The IPy module (a module designed for dealing with IP addresses) will throw a ValueError exception for invalid addresses."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "IPy module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/IPy/"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from IPy import IP\n&gt;&gt;&gt; IP('127.0.0.1')\nIP('127.0.0.1')\n&gt;&gt;&gt; IP('277.0.0.1')\nTraceback (most recent call last):\n ...\nValueError: '277.0.0.1': single byte must be 0 &lt;= byte &lt; 256\n&gt;&gt;&gt; IP('foobar')\nTraceback (most recent call last):\n ...\nValueError: invalid literal for long() with base 10: 'foobar'\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, like Dustin's answer, it will accept things like \"4\" and \"192.168\" since, as mentioned, these are valid representations of IP addresses."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n def is_valid_ip(ip):\n    \"\"\"Validates IP addresses.\n    \"\"\"\n    return is_valid_ipv4(ip) or is_valid_ipv6(ip)\n</code>\n</pre>\n", "senID": 0}, {"text": ["IPv4:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def is_valid_ipv4(ip):\n    \"\"\"Validates IPv4 addresses.\n    \"\"\"\n    pattern = re.compile(r\"\"\"\n        ^\n        (?:\n          # Dotted variants:\n          (?:\n            # Decimal 1-255 (no leading 0's)\n            [3-9]\\d?|2(?:5[0-5]|[0-4]?\\d)?|1\\d{0,2}\n          |\n            0x0*[0-9a-f]{1,2}  # Hexadecimal 0x0 - 0xFF (possible leading 0's)\n          |\n            0+[1-3]?[0-7]{0,2} # Octal 0 - 0377 (possible leading 0's)\n          )\n          (?:                  # Repeat 0-3 times, separated by a dot\n            \\.\n            (?:\n              [3-9]\\d?|2(?:5[0-5]|[0-4]?\\d)?|1\\d{0,2}\n            |\n              0x0*[0-9a-f]{1,2}\n            |\n              0+[1-3]?[0-7]{0,2}\n            )\n          ){0,3}\n        |\n          0x0*[0-9a-f]{1,8}    # Hexadecimal notation, 0x0 - 0xffffffff\n        |\n          0+[0-3]?[0-7]{0,10}  # Octal notation, 0 - 037777777777\n        |\n          # Decimal notation, 1-4294967295:\n          429496729[0-5]|42949672[0-8]\\d|4294967[01]\\d\\d|429496[0-6]\\d{3}|\n          42949[0-5]\\d{4}|4294[0-8]\\d{5}|429[0-3]\\d{6}|42[0-8]\\d{7}|\n          4[01]\\d{8}|[1-3]\\d{0,9}|[4-9]\\d{0,8}\n        )\n        $\n    \"\"\", re.VERBOSE | re.IGNORECASE)\n    return pattern.match(ip) is not None\n</code>\n</pre>\n", "senID": 2}, {"text": ["IPv6:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def is_valid_ipv6(ip):\n    \"\"\"Validates IPv6 addresses.\n    \"\"\"\n    pattern = re.compile(r\"\"\"\n        ^\n        \\s*                         # Leading whitespace\n        (?!.*::.*::)                # Only a single whildcard allowed\n        (?:(?!:)|:(?=:))            # Colon iff it would be part of a wildcard\n        (?:                         # Repeat 6 times:\n            [0-9a-f]{0,4}           #   A group of at most four hexadecimal digits\n            (?:(?&lt;=::)|(?&lt;!::):)    #   Colon unless preceeded by wildcard\n        ){6}                        #\n        (?:                         # Either\n            [0-9a-f]{0,4}           #   Another group\n            (?:(?&lt;=::)|(?&lt;!::):)    #   Colon unless preceeded by wildcard\n            [0-9a-f]{0,4}           #   Last group\n            (?: (?&lt;=::)             #   Colon iff preceeded by exacly one colon\n             |  (?&lt;!:)              #\n             |  (?&lt;=:) (?&lt;!::) :    #\n             )                      # OR\n         |                          #   A v4 address with NO leading zeros \n            (?:25[0-4]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\n            (?: \\.\n                (?:25[0-4]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\n            ){3}\n        )\n        \\s*                         # Trailing whitespace\n        $\n    \"\"\", re.VERBOSE | re.IGNORECASE | re.DOTALL)\n    return pattern.match(ip) is not None\n</code>\n</pre>\n", "senID": 4}, {"text": ["The IPv6 version uses \"(?:(?&lt;=::)|(?&lt;!", "::):)\", which could be replaced with \"(?(?&lt;!", "::):)\" on regex engines that support conditionals with look-arounds.", "(i.e.", "PCRE, .NET)"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "(?:(?&lt;=::)|(?&lt;!::):)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(?(?&lt;!::):)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "Dropped the native variant.", "tag": "none", "senID": 7}, {"text": "Expanded the regex to comply with the RFC.", "tag": "none", "senID": 8}, {"text": "Added another regex for IPv6 addresses.", "tag": "none", "senID": 9}]}, {"text": ["Edit2:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Edit2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I found some links discussing how to parse IPv6 addresses with regex:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["A Regular Expression for IPv6 Addresses"], "childNum": 0, "tag": "a", "senID": 12, "childList": []}, {"text": ["Working IPv6 regular expression"], "childNum": 0, "tag": "a", "senID": 13, "childList": []}, {"text": ["test-ipv6-regex.pl"], "childNum": 0, "tag": "a", "senID": 14, "childList": []}]}, {"text": ["Edit3:"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "Edit3:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Finally managed to write a pattern that passes all tests, and that I am also happy with."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}], [{"text": ["I think this would do it..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def validIP(address):\n    parts = address.split(\".\")\n    if len(parts) != 4:\n        return False\n    for item in parts:\n        if not 0 &lt;= int(item) &lt;= 255:\n            return False\n    return True\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import socket\n\ndef is_valid_ipv4_address(address):\n    try:\n        addr= socket.inet_pton(socket.AF_INET, address)\n    except AttributeError: # no inet_pton here, sorry\n        try:\n            addr= socket.inet_aton(address)\n        except socket.error:\n            return False\n        return address.count('.') == 3\n    except socket.error: # not a valid address\n        return False\n\n    return True\n\ndef is_valid_ipv6_address(address):\n    try:\n        addr= socket.inet_pton(socket.AF_INET6, address)\n    except socket.error: # not a valid address\n        return False\n    return True\n</code>\n</pre>\n", "senID": 0}], [{"text": ["if the following script is hosted on a webserver, it should print out visitors Ip address.", "You can also put it in a database by assigning it to a variable:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n 'import os\n\n print 'Content-Type:text/html'\n print \n\n print os.environ[\"REMOTE_ADDR\"]'\n</code>\n</pre>\n", "senID": 1}]]