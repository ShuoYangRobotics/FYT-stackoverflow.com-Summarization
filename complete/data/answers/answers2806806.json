[[{"text": ["If the only reason you need this in memory is because you need to be able to read and write it fast, then use a database.", "Databases read and write extremely fast, often they can read without going to disk at all."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You appear to have very few edges considering the amount of nodes - suggesting that most of the nodes aren't strictly necessary.", "So, instead of actually storing all of the nodes, why not use a sparse structure and only insert them when they're in use?", "This should be pretty easy to do with a dictionary; just don't insert the node until you use it for an edge."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The edges can be stored using an adjacency list on the nodes."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "adjacency list", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Adjacency_list"}]}, {"text": ["Of course, this only applies if you really mean 100-600 nodes in total.", "If you mean per node, that's a completely different story."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I doubt you'll be able to use a memory structure unless you have a LOT of memory at your disposal:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Assume you are talking about 600 directed edges from each node, with a node being 4-bytes (integer key) and a directed edge being JUST the destination node keys (4 bytes each)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then the raw data about each node is 4 + 600 * 4 = 2404 bytes x 6,000,000 = over 14.4GB"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["That's without any other overheads or any additional data in the nodes (or edges)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Depending on you hardware resources an all in memory for a graph this size is probably out of the question.", "Two possible options from a graph specific DB point of view are:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["Neo4j"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["FlockDB"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}]}, {"text": ["Since your using Python, have you looked at Networkx?", "How far did you get loading a graph of this size if you have looked at it out of interest?"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Networkx", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://networkx.lanl.gov/"}]}], [{"text": ["Sounds like you need a database and an iterator over the results.", "Then you wouldn't have to keep it all in memory at the same time but you could always have access to it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you do decide to use some kind of database after all, I suggest looking at neo4j and its python bindings.", "It's a graph database capable of handling large graphs.", "Here's a presentation from this year's PyCon."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "neo4j", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://neo4j.org/"}, {"text": "presentation", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://us.pycon.org/2010/conference/schedule/event/115/"}]}], [{"text": ["Assuming you mean 600 per node, you could try something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os.path\nimport cPickle\nclass LazyGraph:\n    def __init__(self,folder):\n        self.folder = folder\n\n    def get_node(self,id):\n        f = open(os.path.join(self.folder,str(id)),'rb')\n        node = cPickle.load(f)\n        f.close() # just being paranoid\n        return node\n\n    def set_node(self,id,node):\n        f = open(os.path.join(self.folder,str(id)),'wb')\n        cPickle.dump(node,f,-1) # use highest protocol\n        f.close() # just being paranoid\n</code>\n</pre>\n", "senID": 1}, {"text": ["Use arrays (or numpy arrays) to hold the actual node ids, as they are faster."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note, this will be very very slow."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You could use threading to pre-fetch nodes (assuming you knew which order you were processing them in), but it won't be fun."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]