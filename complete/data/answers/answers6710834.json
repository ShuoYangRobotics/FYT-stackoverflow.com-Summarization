[[{"text": ["It's not particularly elegant to include the code everywhere you need it.", "So write a function that does the massaging.", "Here's a suggestion I came up with for a similar previous question.", "It special-cases strings (which would usually be iterable) as single items, which is what I find I usually want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def iterfy(iterable):\n    if isinstance(iterable, basestring):\n        iterable = [iterable]\n    try:\n        iter(iterable)\n    except TypeError:\n        iterable = [iterable]\n    return iterable\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for item in iterfy(unknownfunction()):\n     # do something\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The most general solution to this problem is to use isinstance with the abstract base class collections.Iterable. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "isinstance", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "collections.Iterable", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import collections\n\ndef get_iterable(x):\n    if isinstance(x, collections.Iterable):\n        return x\n    else:\n        return (x,)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You might also want to test for basestring as well, as Kindall suggests."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "basestring", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/6710834/iterating-over-list-or-single-element-in-python/6710895#6710895", "text": "Kindall", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n if isinstance(x, collections.Iterable) and not isinstance(x, basestring):\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now some people might think, as I once did, \"isn't isinstance considered harmful?", "Doesn't it lock you into using one kind of type?", "Wouldn't using hasattr(x, '__iter__') be better?"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "isinstance", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "considered harmful", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.canonical.org/~kragen/isinstance/"}, {"text": "hasattr(x, '__iter__')", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The answer is: not when it comes to abstract base classes.", "In fact, you can define your own class with an __iter__ method and it will be recognized as an instance of collections.Iterable, even if you do not subclass collections.Iterable.", "This works because collections.Iterable defines a __subclasshook__ that determines whether a type passed to it is an Iterable by whatever definition it implements."], "childNum": 7, "tag": "p", "senID": 5, "childList": [{"text": "__iter__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "collections.Iterable", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "even if you do not subclass", "childNum": 0, "tag": "em", "childList": []}, {"text": "collections.Iterable", "childNum": 0, "tag": "code", "childList": []}, {"text": "collections.Iterable", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/abc.html#abc.ABCMeta.__subclasshook__", "text": "__subclasshook__", "childNum": 1, "tag": "a", "childList": [{"text": "__subclasshook__", "tag": "code"}]}, {"text": "__subclasshook__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class MyIter(object):\n...     def __iter__(self):\n...         return iter(range(10))\n... \n&gt;&gt;&gt; i = MyIter()\n&gt;&gt;&gt; isinstance(i, collections.Iterable)\nTrue\n&gt;&gt;&gt; collections.Iterable.__subclasshook__(type(i))\nTrue\n</code>\n</pre>\n", "senID": 6}], [{"text": ["You'll want to do the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n iterator = (x,) if not isinstance(x, (tuple, list)) else x\n</code>\n</pre>\n", "senID": 1}, {"text": ["then"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for i in iterator:\n    #do stuff\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Perhaps better to use collections.Iterable to find out whether the output is an iterable or not."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collections.Iterable", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import collections\n\nx = UnknownFunction()\nif not isinstance(x, collections.Iterable): x = [x]\n\nfor ii in x:\n    #do stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will work if type of x is either of these - list, tuple, dict, str, any class derived from these."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You could also try using the operator.isSequenceType function"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\nx = unknown_function()\nif not operator.isSequenceType(x) and not isinstance(x, basestring):\n    x = (x,)\nfor item in x:\n    do_something(item)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You might define a function that ensures the returned value supports iteration (str, dict, tuple, etc --including user-defined sequence types that don't directly inherit from these classes) rather than checking if it is a tuple or list directly."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def ensure_iterable(x):\n    return (x,) if not hasattr(x, '__iter__') else x\n\nx = ensure_iterable(UnknownFunction())\nfor i in x:\n    do_something(i)\n</code>\n</pre>\n", "senID": 1}]]