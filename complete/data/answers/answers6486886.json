[[{"text": ["you could try the following: in a first step you zip() the reversed() items of the list:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "reversed()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n zipped = zip(reversed(lines1), reversed(lines2), reversed(lines3))\n</code>\n</pre>\n", "senID": 1}, {"text": ["then you can concatenate the items in zipped again:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n lst = []\nfor triple in zipped:\n    lst.append(triple)\n</code>\n</pre>\n", "senID": 3}, {"text": ["finally you have to remove all Nones added by zip()"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "zip()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n lst.remove(None)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["What about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = [[\"1a\",\"1b\",\"1c\",\"1d\"], [\"2a\",\"2b\"], [\"3a\",\"3b\",\"3c\",\"3d\",\"3e\"]]\n&gt;&gt;&gt; while l:\n...     x = random.choice(l)\n...     print x.pop(-1) \n...     if not x:\n...         l.remove(x)\n\n1d\n1c\n2b\n3e\n2a\n3d\n1b\n3c\n3b\n3a\n1a\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could optimize it in various ways, but that's the general idea.", "This also works if you cannot read the files at once but need to iterate them because of memory restrictions.", "In that case"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "read a line from the file instead of popping from a list", "tag": "none", "senID": 3}, {"text": "check for EOF instead of empty lists", "tag": "none", "senID": 4}]}], [{"text": ["A simple solution might be to create a list of lists, and then pop a line off a random list until they're all exhausted:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import random\n&gt;&gt;&gt; filerecords = [['File{0}Record{1}'.format(i, j) for j in range(5)] for i in range(5)]\n&gt;&gt;&gt; concatenation = []\n&gt;&gt;&gt; while any(filerecords):\n...     selection = random.choice(filerecords)\n...     if selection:\n...         concatenation.append(selection.pop())\n...     else:\n...         filerecords.remove(selection)\n... \n&gt;&gt;&gt; concatenation\n['File1Record4', 'File3Record4', 'File0Record4', 'File0Record3', 'File0Record2',\n 'File4Record4', 'File0Record1', 'File3Record3', 'File4Record3', 'File0Record0',\n 'File4Record2', 'File2Record4', 'File4Record1', 'File3Record2', 'File4Record0',\n 'File2Record3', 'File1Record3', 'File2Record2', 'File2Record1', 'File3Record1',\n 'File3Record0', 'File1Record2', 'File2Record0', 'File1Record1', 'File1Record0']\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n filenames = [ 'filename0', ... , 'filenameN' ]\nfiles = [ open(fn, 'r') for fn in filenames ]\nlines = [ f.readlines() for f in files ]\n\noutput = open('output', 'w')\n\nwhile len(lines) &gt; 0:\n    l = random.choice( lines )\n    if len(l)==0: \n        lines.remove(l)\n    else:\n        output.write( l.pop() )\n\noutput.close()\n</code>\n</pre>\n", "senID": 0}, {"text": ["One bite may seem magical here: the lines read from files don't need reversing, because when we write them to output file we use list.pop() which takes items from the end of the list (here the contents of the file)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "list.pop()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I strongly recommend investing some time to read Generator Tricks for Systems Programmers(PDF).", "It's from a presentation at PyCon 08 and it deals specifically with processing arbitrarily large log files.", "The reversal aspect is an interesting wrinkle, but the rest of the presentation should speak directly to your problem."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Generator Tricks for Systems Programmers", "tag": "a", "pos": 0, "childList": [{"text": "Generator Tricks for Systems Programmers", "tag": "em"}], "childNum": 1, "href": "http://www.dabeaz.com/generators/Generators.pdf"}, {"text": "Generator Tricks for Systems Programmers", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"code": "<pre>\n<code>\n filelist = (\n    'file1.txt',\n    'file2.txt',\n    'file3.txt',\n)\n\nall_records = []\n\nmax_records = 0\nfor f in filelist:\n    fp = open(f, 'r')\n    records = fp.readlines()\n    if len(records) &gt; max_records:\n        max_records = len(records)\n    records.reverse()\n    all_records.append(records)\n    fp.close()\n\nall_records.reverse()\n\nres_fp = open('result.txt', 'w')\nfor i in range(max_records):\n    for records in all_records:\n        try:\n            res_fp.write(records[i])\n        except IndexError:\n            pass\n    i += 1\nres_fp.close()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I'm not a python zen master, but here's my take."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\n\n#You have you read everything into a list from at least one of the files.\nfin = open(\"filename1\",\"r\").readlines()\n# tuple of all of the files.\nfls = ( open(\"filename2\",\"r\"), \n       open(\"filename3\",\"r\"), )\n\nfor fl in fls: #iterate through tuple\n   curr = 0\n   clen = len(fin)\n   for line in fl: #iterate through a file.\n      # If we're at the end or 1 is randomly chosen, insert at current position.\n      if curr &gt; clen or round(random.random()):\n         fin.insert(curr,line)\n         clen = len(fin)\n      curr +=1 #increment current index.\n\n# when you're *done* reverse. It's easier.\nfin.reverse()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Unfortunately with this it becomes obvious that this is a weighted distrobution.", "This can be fixed by calculating the length of each of the files and multiplying the call to random by certain probability based on that.", "I'll see if I can't provide that at some later point."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A possible merging function is available in the standard library.", "It's intended to merge sorted lists to make sorted combined lists; garbage in, garbage out, but it does have the desired property of maintaining sublist order no matter what."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def merge_files(output, *inputs):\n    # all parameters are opened files with appropriate modes.\n    from heapq import merge\n    for line in heapq.merge(*(reversed(tuple(input)) for input in inputs)):\n        output.write(line)\n</code>\n</pre>\n", "senID": 1}]]