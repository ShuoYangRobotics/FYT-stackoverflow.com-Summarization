[[{"text": ["Or shorten David's answer with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if 4 &lt;= day &lt;= 20 or 24 &lt;= day &lt;= 30:\n    suffix = \"th\"\nelse:\n    suffix = [\"st\", \"nd\", \"rd\"][day % 10 - 1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Attribution."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Attribution.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2005-July/333218.html"}]}], [{"text": ["Here's a more general solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def ordinal(n):\n    if 10 &lt;= n % 100 &lt; 20:\n        return str(n) + 'th'\n    else:\n       return  str(n) + {1 : 'st', 2 : 'nd', 3 : 'rd'}.get(n % 10, \"th\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Except for 1st, 2nd, and 3rd, I think they all just add th... 4th, 5th, 6th, 11th, 21st ... oh, oops ;-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think this might work:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def ordinal(num):\n     ldig = num % 10\n     l2dig = (num // 10) % 10\n     if l2dig == 1:\n         suffix = 'th'\n     elif ldig == 1:\n         suffix = 'st'\n     elif ldig == 2:\n         suffix = 'nd'\n     elif ldig == 3:\n         suffix = 'rd'\n     else: \n         suffix = 'th'\n     return '%d%s' % (num, suffix)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Here it is using dictionaries as either a function or as a lambda..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you look at the dictionaries backwards you can read it as..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Everything ends in 'th'"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["...unless it ends in 1, 2, or 3 then it ends in 'st', 'nd', or 'rd'"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["...unless it ends in 11, 12, or 13 then it ends in 'th, 'th', or 'th'"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # as a function\ndef ordinal(num):\n    return '%d%s' % (num, { 11: 'th', 12: 'th', 13: 'th' }.get(num % 100, { 1: 'st',2: 'nd',3: 'rd',}.get(num % 10, 'th')))\n\n# as a lambda\nordinal = lambda num : '%d%s' % (num, { 11: 'th', 12: 'th', 13: 'th' }.get(num % 100, { 1: 'st',2: 'nd',3: 'rd',}.get(num % 10, 'th')))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here is an even shorter general solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(n):\n    return str(n) + {1: 'st', 2: 'nd', 3: 'rd'}.get(4 if 10 &lt;= n % 100 &lt; 20 else n % 10, \"th\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["Although the other solutions above are probably easier to understand at first glance, this works just as well while using a bit less code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Fixed for negative-inputs, based on eric.frederich's nice sol'n (just added abs when using %):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "abs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "%", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def ordinal(num):\n    return '%d%s' % (num, { 11: 'th', 12: 'th', 13: 'th'}.get(abs(num) % 100, { 1: 'st',2: 'nd',3: 'rd',}.get(abs(num) % 10, 'th')))\n</code>\n</pre>\n", "senID": 1}]]