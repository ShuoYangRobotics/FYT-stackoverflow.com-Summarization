[[{"text": ["It's stored in the operating system's disk cache in memory until it is flushed to disk, either implicitly due to timing or space issues, or explicitly via fp.flush()."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "fp.flush()", "tag": "a", "pos": 0, "childList": [{"text": "fp.flush()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#file.flush"}, {"text": "fp.flush()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There will be write buffering in the Linux kernel, but at (ir)regular intervals they will be flushed to disk.", "Running out of such buffer space should never cause an application-level memory error; the buffers should empty before that happens, pausing the application while doing so."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you a writing out a large file for which the writes might fail you a better off flushing the file to disk yourself at regular intervals using fp.flush().", "This way the file will be in a location of your choosing that you can easily get to rather than being at the mercy of the OS:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fp.flush()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n fp = open('output.txt', 'wb')\ncounter = 0\nfor line in many_lines:\n    file.write(line)\n    counter += 1\n    if counter &gt; 999:\n        fp.flush()\nfp.close()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will flush the file to disk every 1000 lines."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Building on ataylor's comment to the question: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You might want to nest your loop.", "Something like "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for i in range(1,n):\n    for each in range n:\n        fp.write('something')\nfp.close()\n</code>\n</pre>\n", "senID": 2}, {"text": ["That way, the only thing that gets put into memory is the string \"something\", not \"something\" * n."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "\"something\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"something\" * n", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If you write line by line, it should not be a problem.", "You should show the code of what you are doing before the write.", "For a start you can try to delete objects where not necessary, use fp.flush() etc.."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fp.flush()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["File writing should never give a memory error; with all probability, you have some bug in another place."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you have a loop, and a memory error, then I would look if you are \"leaking\" references to objects.", "Something like:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def do_something(a, b = []):\n    b.append(a)\n    return b\n\nfp = open('output.txt', 'wb') \n\nfor i in range(1, n): \n    something = do_something(i)\n    fp.write(something)\n\nfp.close()\n</code>\n</pre>\n", "senID": 2}, {"text": ["I am now picking just an example, but in your actual case the reference leak may be much more difficult to find; however this case will just leak memory inside do_something because of the way Python handles default parameters of functions."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "do_something", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]