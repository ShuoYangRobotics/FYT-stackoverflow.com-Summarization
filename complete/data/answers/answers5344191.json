[[{"text": ["No need for a list comprehension."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n output.write(''.join(itertools.islice(inputfile, 2, 4))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you want to do it with a generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n output.writelines(line for line in input if 2 &lt; int(line) &lt; 5)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Not faster, but if you want to use a list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n output.writelines([line for (x, line) in enumerate(input) if 1 &lt; x &lt; 4])\n</code>\n</pre>\n", "senID": 1}, {"text": ["This assumes you're using the actual line count of the file position and not the read value in the file (which, judging by your assignment of x, is true)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You asked specifically about generators vs. list comprehension, but in general there are a few was to approach the problem.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The generator version:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n input  = open('input.txt', 'r')\noutput = open('output.txt', 'w')\n\ndef gen() :\n    for line in input :\n        yield \"FOO \" + line\n\nfor l in gen() :\n    output.write(l)\n</code>\n</pre>\n", "senID": 2}, {"text": ["List comprehension:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n output.writelines(\"FOO \" + line for line in input)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Iterator style:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class GenClass(object) :\n    def __init__(self, _in) :\n        self.input = _in\n\n    def __iter__(self):\n        return self\n\n    def next(self) :\n        line = self.input.readline()\n        if len(line) == 0 :\n            raise StopIteration\n        return \"FOO \" + line\n\noutput.writelines(GenClass(input))\n</code>\n</pre>\n", "senID": 6}, {"text": ["Thoughts:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "List comprehension is going to have everything in memory", "tag": "none", "senID": 8}, {"text": "List comprehension will restrict the amount of code (functions are oneline)", "tag": "none", "senID": 9}, {"text": "Generator is more flexible in coding practices", "tag": "none", "senID": 10}, {"text": "Iterator style, gives you probably the most flexibility", "tag": "none", "senID": 11}, {"text": "Slightly higher initialization cost (object)", "tag": "none", "senID": 12}]}], [{"text": ["The best way to find out which is fastest is to test it! "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In this code I'm assuming that you care about the value of the line, and not which line number."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import timeit\n\ndef test_comprehension():\n  input = open('list.txt')\n  output = open('output.txt','w')\n  [output.write(x) for x in input if int(x) &gt; 2 and int(x) &lt; 5]\n\ndef test_forloop():\n    input = open('list.txt')\n    output = open('output.txt','w')\n\n    for x in input:\n        if int(x) &gt; 2 and int(x) &lt; 5:\n            output.write(x)\n\nif __name__=='__main__':\n    times = 10000\n\n    from timeit import Timer\n    t = Timer(\"test_comprehension()\", \"from __main__ import test_comprehension\")\n    print \"Comprehension: %s\" % t.timeit(times)\n\n    t = Timer(\"test_forloop()\", \"from __main__ import test_forloop\")\n    print \"For Loop: %s\" % t.timeit(times)\n</code>\n</pre>\n", "senID": 2}, {"text": ["In this I'm just setting up a couple functions, one that does it with a list comprehension, and another that does it as a forloop.", "The timeit module runs small bits of code the number of times you specify, times it and returns the time it took to run.", "So if you run the above code you'll get an output of something along the lines of:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Comprehension: 0.957081079483\nFor Loop: 0.956691980362"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Depressingly enough, it's about the same either way."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n def copyLines(infname, outfname, lines):\n    lines = list(set(lines))   # remove duplicates\n    lines.sort(reverse=True)\n    with open(infname, 'r') as inf, open(outfname, 'w') as outf:\n        try:\n            i = 1\n            while lines:\n                seek = lines.pop()\n                while i&lt;seek:\n                    inf.next()\n                    i += 1\n                outf.write(inf.next())\n                i += 1\n        except StopIteration:  # hit end of file\n            pass\n\ndef main():\n    copyLines('C:/.../list.txt', 'C:/.../output.txt', range(3,5))\n\nif __name__==\"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 0}, {"text": ["Note that this will quit as soon as it runs out of desired lines."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]