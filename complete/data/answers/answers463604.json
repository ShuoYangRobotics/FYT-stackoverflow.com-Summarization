[[{"code": "<pre>\n<code>\n isinstance(n, int)\n</code>\n</pre>\n", "senID": 0}, {"text": ["If you need to know whether it's definitely an actual int and not a subclass of int (generally you shouldn't need to do this):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n type(n) is int\n</code>\n</pre>\n", "senID": 2}, {"text": ["this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n return int(n) == n\n</code>\n</pre>\n", "senID": 4}, {"text": ["isn't such a good idea, as cross-type comparisons can be true - notably int(3.0)==3.0"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "int(3.0)==3.0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Yeah, as Evan said, don't type check.", "Just try to use the value:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def myintfunction(value):\n   \"\"\" Please pass an integer \"\"\"\n   return 2 + value\n</code>\n</pre>\n", "senID": 1}, {"text": ["That doesn't have a typecheck.", "It is much better!", "Let's see what happens when I try it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; myintfunction(5)\n7\n</code>\n</pre>\n", "senID": 3}, {"text": ["That works, because it is an integer.", "Hm.", "Lets try some text."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; myintfunction('text')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 3, in myintfunction\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n</code>\n</pre>\n", "senID": 5}, {"text": ["It shows an error, TypeError, which is what it should do anyway.", "If caller wants to catch that, it is possible.  "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["What would you do if you did a typecheck?", "Show an error right?", "So you don't have to typecheck because the error is already showing up automatically."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Plus since you didn't typecheck, you have your function working with other types:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Floats:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print myintfunction(2.2)\n4.2\n</code>\n</pre>\n", "senID": 10}, {"text": ["Complex numbers:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print myintfunction(5j)\n(2+5j)\n</code>\n</pre>\n", "senID": 12}, {"text": ["Decimals:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import decimal\n&gt;&gt;&gt; myintfunction(decimal.Decimal('15'))\nDecimal(\"17\")\n</code>\n</pre>\n", "senID": 14}, {"text": ["Even completely arbitrary objects that can add numbers!"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class MyAdderClass(object):\n...     def __radd__(self, value):\n...             print 'got some value: ', value\n...             return 25\n... \n&gt;&gt;&gt; m = MyAdderClass()\n&gt;&gt;&gt; print myintfunction(m)\ngot some value:  2\n25\n</code>\n</pre>\n", "senID": 16}, {"text": ["So you clearly get nothing by typechecking.", "And lose a lot."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"tag": "hr", "senID": 18}, {"text": ["Since you've edited the question, it is now clear that your application calls some upstream routine that makes sense only with ints. "], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["That being the case, I still think you should pass the parameter as received to the upstream function.", "The upstream function will deal with it correctly e.g.", "raising an error if it needs to.", "I highly doubt it your function that deals with IPs will behave strangely if you pass it a float.", "If you can give us the name of the library we can check that for you."], "childNum": 2, "tag": "p", "senID": 20, "childList": [{"text": "as received", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "doubt it", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["But...", "If the upstream function will behave incorrectly and kill some kids if you pass it a float (I still highly doubt it), then just just call int() on it:"], "childNum": 1, "tag": "p", "senID": 21, "childList": [{"text": "int()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def myintfunction(value):\n   \"\"\" Please pass an integer \"\"\"\n   return upstreamfunction(int(value))\n</code>\n</pre>\n", "senID": 22}, {"text": ["You're still not typechecking, so you get most benefits of not typechecking."], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"tag": "hr", "senID": 24}, {"text": ["If even after all that, you really want to type check, despite it reducing your application's readability and performance for absolutely no benefit, use an assert to do it."], "childNum": 1, "tag": "p", "senID": 25, "childList": [{"text": "assert", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n assert isinstance(...)\nassert type() is xxxx\n</code>\n</pre>\n", "senID": 26}, {"text": ["That way we can turn off asserts and remove this &lt;sarcasm&gt;feature&lt;/sarcasm&gt; from the program by calling it as"], "childNum": 4, "tag": "p", "senID": 27, "childList": [{"text": "assert", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&lt;sarcasm&gt;", "childNum": 0, "tag": "code", "childList": []}, {"text": "feature", "childNum": 0, "tag": "em", "childList": []}, {"text": "&lt;/sarcasm&gt;", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n python -OO program.py\n</code>\n</pre>\n", "senID": 28}], [{"text": ["Don't type check.", "The whole point of duck typing is that you shouldn't have to.", "For instance, what if someone did something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyInt(int):\n    # ... extra stuff ...\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Programming in Python and performing typechecking as you might in other languages does seem like choosing a screwdriver to bang a nail in with.", "It is more elegant to use Python's exception handling features."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["From an interactive command line, you can run a statement like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n int('sometext')\n</code>\n</pre>\n", "senID": 2}, {"text": ["That will generate an error - ipython tells me:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &lt;type 'exceptions.ValueError'&gt;: invalid literal for int() with base 10: 'sometext'\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now you can write some code like:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n try:\n   int(myvar) + 50\nexcept ValueError:\n   print \"Not a number\"\n</code>\n</pre>\n", "senID": 6}, {"text": ["That can be customised to perform whatever operations are required AND to catch any errors that are expected.", "It looks a bit convoluted but fits the syntax and idioms of Python and results in very readable code (once you become used to speaking Python)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"code": "<pre>\n<code>\n if type(n) is int\n</code>\n</pre>\n", "senID": 0}, {"text": ["This checks if n is a Python int, and only an int.", "It won't accept subclasses of int."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "only", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Type-checking, however, does not fit the \"Python way\".", "You better use n as an int, and if it throws an exception, catch it and act upon it."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I would be tempted to to something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def check_and_convert(x):\n    x = int(x)\n    assert 0 &lt;= x &lt;= 255, \"must be between 0 and 255 (inclusive)\"\n    return x\n\nclass IPv4(object):\n    \"\"\"IPv4 CIDR prefixes is A.B.C.D/E where A-D are \n       integers in the range 0-255, and E is an int \n       in the range 0-32.\"\"\"\n\n    def __init__(self, a, b, c, d, e=0):\n        self.a = check_and_convert(a)\n        self.b = check_and_convert(a)\n        self.c = check_and_convert(a)\n        self.d = check_and_convert(a)\n        assert 0 &lt;= x &lt;= 32, \"must be between 0 and 32 (inclusive)\"\n        self.e = int(e)\n</code>\n</pre>\n", "senID": 1}, {"text": ["That way when you are using it anything can be passed in yet you only store a valid integer. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["how about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def ip(string):\n    subs = string.split('.')\n    if len(subs) != 4:\n        raise ValueError(\"incorrect input\")\n    out = tuple(int(v) for v in subs if 0 &lt;= int(v) &lt;= 255)\n    if len(out) != 4:\n        raise ValueError(\"incorrect input\")\n    return out\n</code>\n</pre>\n", "senID": 1}, {"text": ["ofcourse there is the standard isinstance(3, int) function ..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]