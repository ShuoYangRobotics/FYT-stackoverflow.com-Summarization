[[{"text": ["If you mean that list3 is the collection of values from list1 where the corresponding value in list2 is smaller, then:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "list3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "childList": []}, {"text": "corresponding value", "childNum": 0, "tag": "strong", "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n list3 = [item1 for item1, item2 in zip(list1, list2) if item1 &gt; item2]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You say \"list\", but from the error message and the outputs I suspect you're working with numpy arrays.", "In any case, the problem with v = [c for c in f if c &gt; y] is that you're comparing an element c with the array y.", "You want to compare element to element."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "v = [c for c in f if c &gt; y]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In the case of a list, you can do the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; aa = [2,3,4,5]\n&gt;&gt;&gt; bb = [3,4,2,5]\n&gt;&gt;&gt; \n&gt;&gt;&gt; z = [a for a,b in zip(aa,bb) if a &gt; b]\n&gt;&gt;&gt; z\n[4]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or if you're really working with numpy arrays, you can make it even easier:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy\n&gt;&gt;&gt; aa = numpy.array([2,3,4,5])\n&gt;&gt;&gt; bb = numpy.array([3,4,2,5])\n&gt;&gt;&gt; aa &gt; bb\narray([False, False,  True, False], dtype=bool)\n&gt;&gt;&gt; aa[aa &gt; bb]\narray([4])\n</code>\n</pre>\n", "senID": 4}], [{"text": ["assuming both lists are of equal size,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list3 = [list1[i] for i in range(len(list1)) if list1[i]&gt;list2[i]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["using izip_longest \nhttp://docs.python.org/library/itertools.html#itertools.izip_longest"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/itertools.html#itertools.izip_longest", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.izip_longest"}]}, {"code": "<pre>\n<code>\n list3 = [i for i,j in itertools.izip_longest(list1, list2, 0) if i &gt; j]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n [elmt1 for elmt1, elmt2 in zip(list1, list2) if elmt1 &gt; elmt2]\n</code>\n</pre>\n", "senID": 0}, {"text": ["This essentially directly mirrors the question: select elements from list1 that are larger than the corresponding element in list2."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If one of the lists is longer, its extra elements cannot be compared to elements from the other list, and they are ignored."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Assuming I correctly understand your question to mean a list of the points (x,y) at which list1[i] > list2[i] rather than just a list of values from list1, this "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list3 = [(i,val) for i, val in enumerate(list1) if val &gt; list2[i]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["will return that list as points.", "If you need to know at which index list1 > list2 then enumerate is helpful."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "enumerate", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If all you are interested in is the list of indexes at which the two arrays are equal: all x for which f(x) > g(x) in other words, then all you need are the indexes:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n list3 = [i for i, val in enumerate(list1) if val &gt; list2[i]]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["For those of you who want a lazy iterator approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip, ifilter\ni = ifilter(lambda (x,y): x &gt; y, izip(list1, list2))\nlist3 = list(i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will quit once either list runs out of values.", "To iterate over the longest list, use izip_longest:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "izip_longest", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import izip_longest, ifilter\ni = ifilter(lambda (x,y): x &gt; y, izip_longest(list1, list2, fillvalue=0))\nlist3 = list(i)\n</code>\n</pre>\n", "senID": 3}, {"text": ["And since this uses iterators, you can replace list3 = list(i) bit with a loop to actually use the values as they get generated, if necessary."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "list3 = list(i)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]