[[{"text": ["Use dict.fromkeys:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict.fromkeys", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; my_list = [1, 2, 3]\n&gt;&gt;&gt; dict.fromkeys(my_list)\n{1: None, 2: None, 3: None}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Values default to None, but you can specify them as an optional argument:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; my_list = [1, 2, 3]\n&gt;&gt;&gt; dict.fromkeys(my_list, 0)\n{1: 0, 2: 0, 3: 0}\n</code>\n</pre>\n", "senID": 3}, {"text": ["From the docs:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You could use a set instead of a dict:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "set", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#set-types-set-frozenset"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; myList=['a','b','c','d']\n&gt;&gt;&gt; set(myList)\nset(['a', 'c', 'b', 'd'])\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is better if you never need to store values, and are just storing an unordered collection of unique items."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["To answer the original questioner's performance worries (for lookups in dict vs set), somewhat surprisingly, dict lookups can be minutely faster (in Python 2.5.1 on my rather slow laptop) assuming for example that half the lookups fail and half succeed.", "Here's how one goes about finding out:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "can", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'k=dict.fromkeys(range(99))' '5 in k and 112 in k'\n1000000 loops, best of 3: 0.236 usec per loop\n$ python -mtimeit -s'k=set(range(99))' '5 in k and 112 in k'\n1000000 loops, best of 3: 0.265 usec per loop\n</code>\n</pre>\n", "senID": 1}, {"text": ["doing each check several times to verify they're repeatable.", "So, if those 30 nanoseconds or less on a slow laptop are in an absolutely crucial bottleneck, it may be worth going for the obscure dict.fromkeys solution rather than the simple, obvious, readable, and clearly correct set (unusual -- almost invariably in Python the simple and direct solution has performance advantages too)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "dict.fromkeys", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Of course, one needs to check with one's own Python version, machine, data, and ratio of successful vs failing tests, and confirm with extremely accurate profiling that shaving 30 nanoseconds (or whatever) off this lookup will make an important difference."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "and", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Fortunately, in the vast majority of cases, this will prove totally unnecessary... but since programmers will obsess about meaningless micro-optimizations anyway, no matter how many times they're told about their irrelevance, the timeit module is right there in the standard library to make those mostly-meaningless micro-benchmarks easy as pie anyway!-)"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "will", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "anyway", "childNum": 0, "tag": "em", "childList": []}, {"text": "timeit", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["And here's a fairly wrong and inefficient way to do it using map:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d = dict()\n&gt;&gt;&gt; map (lambda x: d.__setitem__(x, None), [1,2,3])\n[None, None, None]\n&gt;&gt;&gt; d\n{1: None, 2: None, 3: None}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can use a list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my_list = ['a','b','c','d']\nmy_dict = dict([(ele, None) for ele in my_list])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Maybe you can use itertools:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;import itertools\n&gt;&gt;&gt;my_list = ['a','b','c','d']\n&gt;&gt;&gt;d = {}\n&gt;&gt;&gt;for x in itertools.imap(d.setdefault, my_list): pass\n&gt;&gt;&gt;print d\n{'a': None, 'c': None, 'b': None, 'd': None}\n</code>\n</pre>\n", "senID": 1}, {"text": ["For huge lists, maybe this is very good :P"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]