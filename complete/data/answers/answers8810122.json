[[{"text": ["There is a very elegant way to do it using a generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def cycle(lst, val, stop=None):\n    d = dict(lst)\n    stop = stop if stop is not None else val\n    while True:\n        yield val\n        val = d.get(val, stop)\n        if val == stop: break\n</code>\n</pre>\n", "senID": 1}, {"text": ["Firstly, it allows natural iteration:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for x in cycle([[0, 3], [1, 0], [3, 1]], 0):\n....    print x\n....\n0\n3\n1\n</code>\n</pre>\n", "senID": 3}, {"text": ["Secondly, it allows to create a list easily:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(cycle([[0, 3], [1, 0], [3, 1]], 0))\n[0, 3, 1]\n</code>\n</pre>\n", "senID": 5}, {"text": ["And eventually, it allows infinite item generation:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; generator = cycle([[0, 3], [1, 0], [3, 1]], 0, Ellipsis)\n&gt;&gt;&gt; generator.next()\n... 0\n&gt;&gt;&gt; generator.next()\n... 3\n&gt;&gt;&gt; generator.next()\n... 1\n&gt;&gt;&gt; generator.next()\n... 0\n&gt;&gt;&gt; generator.next()\n... 3\n&gt;&gt;&gt; generator.next()\n... 1\n&gt;&gt;&gt; generator.next()\n... 0\n&gt;&gt;&gt; generator.next()\n... 3\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Consider using the networkx package:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "networkx", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://networkx.lanl.gov/"}]}, {"code": "<pre>\n<code>\n import networkx as nx\nG = nx.DiGraph() #creates directed graph\nG.add_edges_from([[0, 3], [1, 0], [3, 1]])\nprint nx.simple_cycles(G).pop()[:-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; [0, 3, 1]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I'd take a look at python-graph:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "python-graph", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/python-graph/"}]}], [{"text": ["Turn it into a dictionary, and cycle through it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_cycles(links):\n    \"\"\"Get a list of all cycles given a list of links\"\"\"\n    links_dict = dict(links)\n    ret = []\n    ret_sets = []\n    for starting_point in links_dict:\n        cycle = []\n        x = starting_point\n        while x != None:\n            cycle.append(x)\n            x = links_dict.get(x)\n            if x == starting_point:\n                break\n        # make sure the cycle is not a repeat (and was a cycle)\n        if x != None:\n            cycle_set = set(cycle)\n            if cycle_set not in ret_sets:\n                    ret.append(cycle)\n                    ret_sets.append(cycle_set)\n    return ret\n\nassert get_cycles([[0, 3], [1, 0], [3, 1]]) == [[0, 3, 1]]\nassert get_cycles([[0, 3], [1, 0], [3, 1], [5, 2]]) == [[0, 3, 1]]\nassert get_cycles([[0, 3], [1, 0], [3, 1], [5, 2], [2, 5]]) == [[0, 3, 1], [2, 5]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Try this, assuming that only a single cycle is present in the list of links:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def cycle_list(links):\n    d = dict(links)\n    ele = links[0][0]\n    nxt = d[ele]\n    lst = [ele]\n    seen = set(lst)\n    while nxt not in seen:\n        lst.append(nxt)\n        seen.add(nxt)\n        ele = nxt\n        nxt = d[ele]\n    return lst\n</code>\n</pre>\n", "senID": 1}, {"text": ["With your example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n cycle_list([[0, 3], [1, 0], [3, 1]])\n&gt; [0, 3, 1]\n</code>\n</pre>\n", "senID": 3}, {"text": ["If it's possible that more than one cycle exists in the list of links (you don't mention it in the question), then you're better off using David Robinson's answer."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you know there is a cycle and all the links are in the cycle (or at least there are no \"splits\" in the directions, meaning there is only one way from any given point), you can use this:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "there is a cycle", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "there is only one way from any given point", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n def get_cycle(data):\n    d = dict(data)\n    first = data[0][0]\n    current = d[first]\n    path = [first]\n    while True:\n        if current == first:\n            return path\n        else:\n            path.append(current)\n            current = d[current]\n</code>\n</pre>\n", "senID": 1}, {"text": ["What it does is walking through the given data, beginning with the first point of the first link.", "Then it just follows all the links until it reaches the beginning of the path.", "When it reaches the beginning of the path, it returns the path."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Simple and I believe it is pretty efficient."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Using itertools.permutations, this will get you the set of unique cycles:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ng = [(0,3), (1,0), (3,1), (1,4), (4,3)]\n\ncycles = {}\nfor edges in itertools.permutations(g):\n    start = prev = edges[0]\n    for i, edge in enumerate(edges[1:], start=1):\n        if prev[1] != edge[0]:\n            break\n        if edge[1] != start[0]:\n            prev = edge\n            continue\n        cycles.update({tuple(sorted(edges[0:i+1])): edges[0:i+1]})\n        break\n\nresult = []\nfor cycle in cycles.values():\n    result.append([edge[0] for edge in cycle])\n\nprint result\n</code>\n</pre>\n", "senID": 1}, {"text": ["the result in this case being [[3, 1, 0], [4, 3, 1]]"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[[3, 1, 0], [4, 3, 1]]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]