[[{"text": ["I can't point you to a better algorithm straight away, but I would argue that there is space for improvement because in unweighted graphs, you gain an additional attribute which does not hold for weighted graphs, namely:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With this in mind, you should be able to simplify Dijkstra's Algorithm: As you may know, it works with three sets of nodes: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["When following an edge e from A (1.", ") to C (3.", "), original Dijkstra would move node C from (3.", ") to (2.).", "Since the above attribute holds in all your graphs, you can however add it directly to the set (1.", "), which is more efficient."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "e", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "A", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "C", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "C", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Addendum: Here's the essential observation: The procedure outlined above is basically a BFS (breadth first search), i.e.", "you can find the distance from some fixed node v to any other node in O(|V| + |E|)."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Addendum", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "v", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "O(|V| + |E|)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You did not mention in your original question that the graph was basically a grid with some holes in it.", "This is an even stronger requirement, and I am sure you can exploit it.", "Doing a quick search for \"grid graph shortest path\" yields this paper which promises O(sqrt(n)) in the best case.", "As the problem you specify is fairly well-structured, I'm almost sure there are several more papers which you might want to look into."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "this paper", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://onlinelibrary.wiley.com/doi/10.1002/net.3230070404/abstract"}, {"text": "O(sqrt(n))", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Run a breadth-first search from each node.", "Total time: O(|V| |E|) = O(|V|2), which is optimal."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}]}], [{"text": ["I don't how you can measure the distance if all edges are unweighted but you want to look at Edmond's Blossom V algorithm.", "You want to look at http://code.activestate.com/recipes/221251-maximum-cardinality-matching-in-general-graphs.", "Here is something similar: http://wilanw.blogspot.com/2009/09/maximumminimum-weighted-bipartite.html."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/221251-maximum-cardinality-matching-in-general-graphs", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/221251-maximum-cardinality-matching-in-general-graphs"}, {"text": "http://wilanw.blogspot.com/2009/09/maximumminimum-weighted-bipartite.html", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://wilanw.blogspot.com/2009/09/maximumminimum-weighted-bipartite.html"}]}], [{"text": ["How about the Warshall algorithm, with the following very simple implementation: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def warshall(graph):\n  n = graph.numNodes+1\n  W = [ [graph.w(i,j) for j in graph.V()] for i in graph.V() ]\n  for k in range(1,n): \n    for i in range(1,n):\n      for j in range(1,n):\n        W[i][j] = min( W[i][j] , W[i][k]+W[k][j] )\n  return W\n</code>\n</pre>\n", "senID": 1}, {"text": ["where "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["V()"], "childNum": 0, "tag": "code", "senID": 3, "childList": []}, {"text": ["w(i,j)"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": ["numNodes"], "childNum": 0, "tag": "code", "senID": 5, "childList": []}]}, {"text": ["complexity is, however O(n^3)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I would refer you to the following paper: \"Sub-cubic Cost Algorithms for the All Pairs Shortest Path Problem\" by Tadao Takaoka.", "There a sequential algorithm with sub-cubic complexity for graphs with unit weight (actually max edge weight = O(n ^ 0.624)) is available."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I suggest you give networkx a try, it seemed to work fine with 1000 nodes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["the following link contains Shortest path algorithms for unweighted graphs:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://networkx.lanl.gov/reference/algorithms.shortest_paths.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://networkx.lanl.gov/reference/algorithms.shortest_paths.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://networkx.lanl.gov/reference/algorithms.shortest_paths.html"}]}, {"text": ["Here is an example with 10 nodes:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from random import random\nimport networkx as nx\nG=nx.DiGraph()\nN=10\n#make a random graph\nfor i in range(N):\n    for j in range(i):\n        if 4*random()&lt;1:\n            G.add_edge(i,j)\n\nprint G.adj\nprint nx.all_pairs_shortest_path(G)\nprint nx.all_pairs_shortest_path_length(G)\n\n#output:\n#Graph ADJ={0: {}, 1: {}, 2: {}, 3: {0: {}, 2: {}}, 4: {}, 5: {0: {}, 3: {}, 4: {}}, 6: {0: {}, 1: {}, 4: {}}, 7: {2: {}, 4: {}, 6: {}}, 8: {1: {}}, 9: {2: {}, 5: {}}}\n#PAIRS={0: {0: [0]}, 1: {1: [1]}, 2: {2: [2]}, 3: {0: [3, 0], 2: [3, 2], 3: [3]}, 4: {4: [4]}, 5: {0: [5, 0], 2: [5, 3, 2], 3: [5, 3], 4: [5, 4], 5: [5]}, 6: {0: [6, 0], 1: [6, 1], 4: [6, 4], 6: [6]}, 7: {0: [7, 6, 0], 1: [7, 6, 1], 2: [7, 2], 4: [7, 4], 6: [7, 6], 7: [7]}, 8: {8: [8], 1: [8, 1]}, 9: {0: [9, 5, 0], 2: [9, 2], 3: [9, 5, 3], 4: [9, 5, 4], 5: [9, 5], 9: [9]}}\n#LENGTHS={0: {0: 0}, 1: {1: 0}, 2: {2: 0}, 3: {0: 1, 2: 1, 3: 0}, 4: {4: 0}, 5: {0: 1, 2: 2, 3: 1, 4: 1, 5: 0}, 6: {0: 1, 1: 1, 4: 1, 6: 0}, 7: {0: 2, 1: 2, 2: 1, 4: 1, 6: 1, 7: 0}, 8: {8: 0, 1: 1}, 9: {0: 2, 2: 1, 3: 2, 4: 2, 5: 1, 9: 0}}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["In the Python Graph project:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://code.google.com/p/python-graph/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.google.com/p/python-graph/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/python-graph/"}]}, {"text": ["You can find my implementation of the A* algorithm with support for hinting-heuristics.", "This is particularly suitable for obstacle avoidance in 2 dimensions as the hinting algorithm need not be anything more than pythogras' theorem. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I think this would do everything you nedd.", "If you dont like the graph abstractions used by this project you can re-use the algorithm.", "It's written in a very generic way."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I'm assuming the graph is dynamic; otherwise, there's no reason not to use Floyd-Warshall to precompute all-pairs distances on such a small graph ;)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Suppose you have a grid of points (x, y) with 0 &lt;= x &lt;= n, 0 &lt;= y &lt;= n. Upon removing an edge E: (i, j) &lt;-> (i+1, j), you partition row j into sets A = { (0, j), ..., (i, j) }, B = { (i+1, j), ..., (n, j) } such that points a in A, b in B are forced to route around E - so you need only recompute distance for all pairs (a, b) in (A, B)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "forced", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Maybe you can precompute Floyd-Warshall, then, and use something like this to cut recomputation down to O(n^2) (or so) per graph modification..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["After taking a quick flip through the Algorithm Design Manual, here is what Skiena has to say (from Chapter 15.4 - Shortest Path).", "Unsurprisingly, it comes to the same conclusion many of you have already provided, but also provides some other insights"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the Algorithm Design Manual", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.algorist.com/"}]}, {"text": ["He goes on to mention the other cases you may be interested in (e.g.", "what if the input is a set of geometric obstacles?", "Do you need the shortest path between all pairs of points?", ") but in these cases he also concludes the same as you have: Djikstra's algorithm or the Floyd-Warshall algorithm."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Depending on your use, you may also want to look into Transitive Closures which deal with reachability, and use similar algorithms. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Transitive Closures", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Transitive_closure"}]}], [{"code": "<pre>\n<code>\n def from_vertex(v, E):\n    active = [v]\n    step = 0\n    result = {v:0}\n    while active:\n        step += 1\n        new_active = []\n        for x in active:\n            for nh in E[x]:\n                if nh not in result:\n                    new_active.append(nh)\n                    result[nh] = step + 1\n        active = new_active\n    return result\n</code>\n</pre>\n", "senID": 0}, {"text": ["Basically you do a flood-fill from each vertex and you get as result the minimum distance of any other reachable vertex from that one."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]