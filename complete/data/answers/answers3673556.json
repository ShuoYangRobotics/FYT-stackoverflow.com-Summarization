[[{"text": ["The \"correct\" answer varies according to the situation; primarily the most desired statistic and the availability of resources to gather and process them:\neg:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Raw web server logs"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"text": ["All webservers have some facility to log requests.", "The trouble with them is that it requires a lot of processing to get meaningful data out and, for your example scenario, they won't record application specific details; like whether or not the request was associated with a registered user."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This option won't work for what you're interested in."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["File based application logs"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"text": ["The application programmer can apply custom code to the application to record the stuff you're most interested in to a log file.", "This is similiar to the webserver log; except that it can be application aware and record things like the member making the request."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The programmers may also need to build scripts which extract from these logs the stuff you're most interested.", "This option might be suited to a high traffic site with lots of disk space and sysadmins who know how to ensure the logs get rotated and pruned from the production servers before bad things happen."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Database based application logs"], "childNum": 0, "tag": "h2", "senID": 7, "childList": []}, {"text": ["The application programmer can write custom code for the application which records every request in a database.", "This makes it relatively easy to run reports and makes the data instantly accessible.", "This solution incurs more system overhead at the time of each request so better suited to lesser traffic sites, or scenarios where the data is highly valued."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Javascript postback"], "childNum": 0, "tag": "h2", "senID": 9, "childList": []}, {"text": ["This is a consideration on top of the above options.", "Google analytics does this."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Each page includes some javascript code which tells the client to report back to the webserver that the page was viewed.", "The data might be recorded in a database, or written to file."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Has an strong advantage of improving accuracy in scenarios where impressions get lost due to heavy caching/proxying between the client and server."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Cookies"], "childNum": 0, "tag": "h2", "senID": 13, "childList": []}, {"text": ["Every time a request is received from someone who doesn't present a cookie then you assume they're new and record that hit as 'anonymous' and return a uniquely identifying cookie after they login.", "It depends on your application as to how accurate this proves.", "Some applications don't lend themselves to caching so it will be quite accurate; others (high traffic) encourage caching which will reduce the accuracy.", "Obviously it's not much use till they re-authenticate whenever they switch browsers/location."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["Then there's the question of what statistics are important to you.", "For example, in some situations you're keen to know:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "how many times a page was viewed, period,", "tag": "none", "senID": 16}, {"text": "how many times a page was viewed, by a known user", "tag": "none", "senID": 17}, {"text": "how many of your known users have viewed a specific page", "tag": "none", "senID": 18}]}, {"text": ["Thence you typically want to break it down into periods of time to see trending.", "Respectively:"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "are we getting more views from random people?", "tag": "none", "senID": 20}, {"text": "or we getting more views from registered users?", "tag": "none", "senID": 21}, {"text": "or has pretty much every one who is going to see the page now seen it?", "tag": "none", "senID": 22}]}, {"text": ["So back to your question: best practice for \"number of imprints when a user goes on a page\"?"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["It depends on your application."], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"text": ["My guess is that you're best off with a database backed application which records what is most interesting to your application and uses cookies to trace the member's sessions."], "childNum": 0, "tag": "p", "senID": 25, "childList": []}], [{"text": ["The best practice for a hit counter depends on how much traffic you expect your site to receive.", "As wybiral suggested, you can implement something that writes to a database after every request.", "This might include the IP address if you want to count unique visitors, or it could be a simple as just incrementing a running total for each page or for each (page, user) pair."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But that requires a database write for every request, even if you just want to serve a static page.", "Ideally speaking, a scalable web app should serve as much as possible from an in-memory cache.", "Database or disk I/O should be avoided as much as possible."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So the ideal set up would be to build up some representation of the server's activity in-memory and then occasionally (say every 15 minutes) write those events to the database.", "You could conceivably queue up thousands of requests and then store them with a single database write."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["There's a tutorial describing how to do exactly this in python using Celery and Carrot: http://packages.python.org/celery/tutorials/clickcounter.html.", "It also includes some examples of how to set up your database tables using Django models and what code to call whenever someone accesses a page."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://packages.python.org/celery/tutorials/clickcounter.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://packages.python.org/celery/tutorials/clickcounter.html"}]}, {"text": ["This tutorial will certainly be helpful to you regardless of what you choose to implement, although this level of architecture might be overkill if you don't expect thousands of hits each hour."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Use a database to keep a record of the unique IPs (if the IP doesn't exist in the DB, create it, otherwise continue as planned) and then query the database for the number of those entities.", "Index this with IP and URL to store views for individual pages.", "You wont have to worry about tracking registered users this way, they will be totaled into the unique IP count.", "As far as multiple people from one IP, there's not much you can do there short of requiring an account and counting user->to->page-views similarly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I would suggest using a persistent key/value store like Redis.", "If you use a list with the list key being the serialized identifier, you can store other serialized entries and use llen to find the list size."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example (python) after initializing your Redis store:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def intializeAndPush(serializedKey, serializedValue):\n    if not redisStore.exists(serializedKey):\n        redisStore.push(serializedKey, serializedValue)\n    else:\n        if serializedValue not in redisStore.lrange(serializedKey, 0, -1):\n            redisStore.push(serializedKey, serializedValue)\n\ndef getSizeOf(serializedKey):\n    if redisStore.exists(serializedKey):\n        return redisStore.llen(serializedKey)\n    else:\n        return 0\n</code>\n</pre>\n", "senID": 2}, {"text": ["Using this technique, you can use anything as serializedKey or serializedValue.", "If you want to store IPs with today's date or serialized login information, both are just as simple.", "Also, only unique serializedValues are stored since writes are locked on read (at least as I recall)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I will try and implement pixel tracking to track views on your page/object.", "This method is used by google (google analytics) and other high profile media companies."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Pixel tracking will be fine, since you can have point the trackingpixel  to a HttpHandler specific for that purpose.", "That way you can seperate the load and even use some kind of queue for highload scenarios."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, you can incorporate user specific information in the tracking pixel such as WHO has visited the page."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["eg:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &lt;a href=\"fakeimages/imba.gif?uid=123&amp;info2=a&amp;info3=b\" style=\"height:1px;width:1px;\" /&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then you need to handle the request going to fakeimages/*.gif with a specific HttpHandler / php redirect/controller (whatever language you're using) and process the infos."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["regards"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]