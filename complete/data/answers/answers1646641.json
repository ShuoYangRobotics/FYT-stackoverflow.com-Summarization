[[{"code": "<pre>\n<code>\n def in_list(small, big):\n    l_sml = len(small)\n    l_big = len(big)\n    return any((big[i:i+l_sml]==small for i in xrange(l_big-l_sml+1)))\n\nprint in_list([4,2,1], [1,2,3,4,2,1,0,5]) # True\nprint in_list([1,2,3], [1,2,4])           # False\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Rather non-optimized, demonstrates the general strategy simply:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n tuple(small_list) in zip(big_list[:], big_list[1:], big_list[2:])\n</code>\n</pre>\n", "senID": 1}, {"text": ["The funky zip thing does this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; zip(big_list[:], big_list[1:], big_list[2:])\n[(1, 2, 5), (2, 5, 7), (5, 7, 2), (7, 2, 4), (2, 4, 2), (4, 2, 5), (2, 5, 67), (5, 67, 8), (67, 8, 5), (8, 5, 13), (5, 13, 45)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["A more optimized version:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip, islice\ntuple(small_list) in izip(big_list, islice(big_list, 1, None), islice(big_list, 2, None))\n</code>\n</pre>\n", "senID": 5}, {"text": ["To handle small_list length of any size:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip, islice\ntuple(small_list) in izip(*(islice(big_list, i, None) for i in xrange(len(small_list))))\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Hmm, maybe it's overkill, but you can use the SequenceMatcher class from difflib:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from difflib import SequenceMatcher \nsmall_list = [4,2,5]\nbig_list = [1,2,5,7,2,4,2,5,67,8,5,13,45]\nprint SequenceMatcher(None, small_list, big_list).get_matching_blocks()\n</code>\n</pre>\n", "senID": 1}, {"text": ["difflib documentation"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "difflib documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/difflib.html"}]}], [{"text": ["This problem is trickier than it seems.", "Unless I'm mistaken, it's a special case of the longest common substring problem."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "longest common substring problem", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Longest%5Fcommon%5Fsubstring%5Fproblem"}]}, {"text": ["For the general case (arbitrarily large lists), I would use some kind of finite state automaton, akin to a regular expression.", "I believe the result could then be calculated in O(mn) time."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "finite state automaton", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Finite-state%5Fmachine"}]}], [{"text": ["That's because small_list in big_list checks whether an element in big_list is equal to small_list.", "What you want to do instead is see if a slice of big_list is the same as small_list."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "small_list in big_list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def isSubList(slice, L):\n    n = len(slice)\n    for i in range(0, len(L) - n):\n        if slice == L[i:i+n]:\n            return True\n    return False\n\nisSubList(small_list, big_list)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Edit: Leaving the answer here but I failed to note the requirement that they be in the same order.", "This does not meet that requirement"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Edit: Leaving the answer here but I failed to note the requirement that they be in the same order. This does not meet that requirement", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Quick and dirty answer.", "Based it off of the answer for Python - Intersection of two lists"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Python - Intersection of two lists", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/642763/python-intersection-of-two-lists"}]}, {"code": "<pre>\n<code>\n small_list == filter( lambda x: x in big_list, small_list)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If you know a reasonable bound of your numbers, you can convert them to a Python type whose 'in' operator does this automatically.", "The two I know are str and unicode."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "unicode", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Then you ask the strings if the smaller is in the larger, this does a substring comparison:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; small_list = [4,2,5]\n&gt;&gt;&gt; big_list = [1,2,5,7,2,4,2,5,67,8,5,13,45]\n&gt;&gt;&gt;\n&gt;&gt;&gt; def encode(lst):\n      return u\"\".join(unichr(c) for c in lst)\n\n&gt;&gt;&gt; encode(small_list) in encode(big_list)\nTrue\n</code>\n</pre>\n", "senID": 2}, {"text": ["(You can \"encode\" to str if all numbers are in 0 &lt;= x &lt;= 255, you can \"encode\" to unicode if all are in 0 &lt;= x &lt;= sys.maxunicode )."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0 &lt;= x &lt;= 255", "childNum": 0, "tag": "code", "childList": []}, {"text": "unicode", "childNum": 0, "tag": "code", "childList": []}, {"text": "0 &lt;= x &lt;= sys.maxunicode", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There's no built in operator doing that particular comparison.", "I suggest a list comprehension or a quick for loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["you could use sets"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from sets import Set\nsmall_set = set(small_list)\nbig_set = set(big_list)\nsmall_set &lt;= big_set\n</code>\n</pre>\n", "senID": 1}, {"text": ["&lt;= is the subset operator"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you want to use the \"in\" keyword to do what you want, you can override contains using one of the solutions mentioned in the answers here:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "contains", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class mylist(list):\n    def __contains__(self, lst):\n        return ':'.join(map(str, lst)) in ':'.join(map(str, self))\n\nsmall_list = mylist([4,2,5])\nbig_list = mylist([1,2,5,7,2,4,2,5,67,8,5,13,45])\n\nprint small_list in big_list\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: Addresses Jeffrey's comment."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]