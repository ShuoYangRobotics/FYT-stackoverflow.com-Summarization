[[{"text": ["What you have is an example of Role -- it's a common trap to model Role by inheritance, but Roles can change, and changing an object's inheritance structure (even in languages where it's possible, like Python) is not recommended.", "Children grow and become adults, and some adults will also be parents of children students as well as adult students themselves -- they might then drop either role but need to keep the other (their child changes schools but they don't, or viceversa)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Just have a class Person with mandatory fields and optional ones, and the latter, representing Roles, can change.", "\"Asking for a list\" (quite independently of inheritance or otherwise) can be done either by building the list on the fly (walking through all objects to check for each whether it meets requirements) or maintaining lists corresponding to the possible requirements (or a mix of the two strategies for both frequent and ad-hoc queries).", "A database of some sort is likely to help here (and most DBs work much better without inheritance in the way;-)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As I'm sure someone else will comment soon (if they haven't already), one good OO principle is \"Favor composition over inheritance\".", "From your description, it sounds suspiciously like you're breaking the Single Responsibility Principle, and should be breaking down the functionality into separate objects."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Favor composition over inheritance", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.artima.com/lejava/articles/designprinciples4.html"}, {"text": "Single Responsibility Principle", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Single%5Fresponsibility%5Fprinciple"}]}, {"text": ["It also occurs to me that Python supports duck typing, which begs the question \"Why is it so important that all the classes have a common base class?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "duck typing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Duck%5Ftyping"}]}], [{"text": ["Very simple solution: Use composition rather than inheritance.", "Rather than having Student inherit from Contact and Billing, make Contact a field/attribute of Person and inherit from that.", "Make Billing a field of Student.", "Make Parent a self-reference field of Person. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It doesn't sound like you really need multiple inheritance.", "In fact, you don't ever really need multiple inheritance.", "It's just a question of whether multiple inheritance simplifies things (which I couldn't see as being the case here)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "need", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I would create a Person class that has all the code that the adult and student would share.", "Then, you can have an Adult class that has all of the things that only the adult needs and a Child class that has the code only the child needs."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "only", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "only", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["I think your requirements are over-simplified, since in a real situation, you might have students with their own accounts to handle billing even if they are minors who need parent contact information.", "Also, you might have parental contact information be different from billing information in an actual situation.", "You might also have adult students with someone else to bill.", "BUT, that aside - looking at your requirements, here is one way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["classes:  Person, BillingInfo, StudentInfo."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["All people are instances of class Person..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Person:\n    # Will have contact fields all people have - or you could split these off into an\n    # object.\n    parent        # Will be set to None for adults or else point to their parent's\n                  # Person object.\n    billing_info  # Set to None for non-adults, else to their BillingInfo object.\n    student_info  # Set to None for non-student parents, else to their StudentInfo\n                  # object.\n</code>\n</pre>\n", "senID": 3}, {"text": ["Checking the fields will allow you to create lists as you desire."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["One solution is to create a base Info class/interface that the classes ContactInfo, StudentInfo, and BillingInfo inherit from.", "Have some sort of Person object that contains a list of Info objects, and then you can populate the list of Info objects with ContactInfo, StudentInfo, etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This sounds like something that could be done quite nicely and flexibly with a component architecture, like zope.components.", "Components are in a way a sort of super-flexible composition patterns."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In this case I'd probably end up doing something when you load the data to also set marker interfaces on it depending on some information, like if age >= 18 you set the IAdult interface, etc.", "You can then get the adult information by doing "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n adultschema = IAdultSchema(person)\n</code>\n</pre>\n", "senID": 2}, {"text": ["or something like that.", "(Edit: Actually I'd probably use"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n queryAdapters(person, ISchema)\n</code>\n</pre>\n", "senID": 4}, {"text": ["to get all schemas in one go.", ":)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["A component architecture may be overkill, but once you got used to thinking like that, many problems get trivial.", ":)"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "may", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Check out Brandons excellent PyCon talk about it: http://www.youtube.com/watch?v=UF77e2TeeQo\nAnd my intro blog post: http://regebro.wordpress.com/2007/11/16/a-python-component-architecture/"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "http://www.youtube.com/watch?v=UF77e2TeeQo", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.youtube.com/watch?v=UF77e2TeeQo"}, {"href": "http://regebro.wordpress.com/2007/11/16/a-python-component-architecture/", "text": "http://regebro.wordpress.com/2007/11/16/a-python-component-architecture/", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["In pseudocode, you could do something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Class Student\n    Inherits WhateverBase\n\n    Private m_StudentType as EnumStudentTypes 'an enum containing: Adult, Child\n    Private m_Billing as Billing\n    Private m_Contact as Contact\n    Private m_Parent as Parent\n\n    Public Sub Constructor(studentType, billing, contact, parent)\n        ...logic to make sure we have the right combination depending on studentType.\n        ...throw an exception if we try to assign a a parent to an adult, etc.\n        ...maybe you could have seperate constructors, one for each studenttype.             \n    End Sub\n\n\n    Public Property StudentType as EnumStudentTypes\n        Get\n             Return m_StudentType\n        End Get\n    End Sub\n\n    Public Property Parent \n        Get \n           ...code to make sure we're using a studentType that has a parent,\n           ...and throws an exception if not. Otherwise it returns m_Parent\n        End Get\n    End Sub\n\n\n    [more properties]\nEnd Class Student\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you could create a class called StudentManager:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Public Class StudentManager\n    Public Function GetAdults(studentCollection(Of Students)) as StudentCollection(Of Students)\n        Dim ResultCollection(Of Students)\n\n        ...Loop through studentCollection, adding all students where Student.StudentType=Adult  \n\n        Return ResultCollection\n    End Function\n\n\n    [Other Functions]\nEnd Class\n\nPublic Enum StudentType\n    Adult=0\n    Child=1  \nEnd Enum\n</code>\n</pre>\n", "senID": 3}]]