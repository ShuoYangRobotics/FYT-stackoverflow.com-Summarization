[[{"text": ["I recently spent a lot of time trying to do something like this and ended up walking away from it.", "There's a lot of corner cases. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you just want the lowest level of the call stack, you can just reference the name that is used in the def statement.", "This will be bound to the function that you want through lexical closure."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "def", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def recursive(*args, **kwargs):\n    me = recursive\n</code>\n</pre>\n", "senID": 3}, {"text": ["me will now refer to the function in question regardless of the scope that the function is called from so long as it is not redefined in the scope where the definition occurs.", "Is there some reason why this won't work?"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "me", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To get a function that is executing higher up the call stack, I couldn't think of anything that can be reliably done."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["This is what you asked for, as close as I can come.", "Tested in python versions 2.4, 2.6, 3.0."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\ndef getfunc():\n    from inspect import currentframe, getframeinfo\n    caller = currentframe().f_back\n    func_name = getframeinfo(caller)[2]\n    caller = caller.f_back\n    from pprint import pprint\n    func = caller.f_locals.get(\n            func_name, caller.f_globals.get(\n                func_name\n        )\n    )\n\n    return func\n\ndef main():\n    def inner1():\n        def inner2():\n            print(\"Current function is %s\" % getfunc())\n        print(\"Current function is %s\" % getfunc())\n        inner2()\n    print(\"Current function is %s\" % getfunc())\n    inner1()\n\n\n#entry point: parse arguments and call main()\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Current function is &lt;function main at 0x2aec09fe2ed8&gt;\nCurrent function is &lt;function inner1 at 0x2aec09fe2f50&gt;\nCurrent function is &lt;function inner2 at 0x2aec0a0635f0&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The stack frame tells us what code object we're in.", "If we can find a function object that refers to that code object in its func_code attribute, we have found the function."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "func_code", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Fortunately, we can ask the garbage collector which objects hold a reference to our code object, and sift through those, rather than having to traverse every active object in the Python world.", "There are typically only a handful of references to a code object."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now, functions can share code objects, and do in the case where you return a function from a function, i.e.", "a closure.", "When there's more than one function using a given code object, we can't tell which function it is, so we return None."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "from", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n import inspect, gc\n\ndef giveupthefunc():\n    frame = inspect.currentframe(1)\n    code  = frame.f_code\n    globs = frame.f_globals\n    functype = type(lambda: 0)\n    funcs = []\n    for func in gc.get_referrers(code):\n        if type(func) is functype:\n            if getattr(func, \"func_code\", None) is code:\n                if getattr(func, \"func_globals\", None) is globs:\n                    funcs.append(func)\n                    if len(funcs) &gt; 1:\n                        return None\n    return funcs[0] if funcs else None\n</code>\n</pre>\n", "senID": 3}, {"text": ["Some test cases:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n    return giveupthefunc()\n\nzed = lambda: giveupthefunc()\n\nbar, foo = foo, None\n\nprint bar()\nprint zed()\n</code>\n</pre>\n", "senID": 5}, {"text": ["I'm not sure about the performance characteristics of this, but i think it should be fine for your use case."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Here's another possibility: a decorator that implicitly passes a reference to the called function as the first argument (similar to self in bound instance methods).", "You have to decorate each function that you want to receive such a reference, but \"explicit is better than implicit\" as they say. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Of course, it has all the disadvantage of decorators: another function call slightly degrades performance, and the signature of the wrapped function is no longer visible."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import functools\n\ndef gottahavethatfunc(func):\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(func, *args, **kwargs)\n\n    return wrapper\n</code>\n</pre>\n", "senID": 2}, {"text": ["The test case illustrates that the decorated function still gets the reference to itself even if you change the name to which the function is bound.", "This is because you're only changing the binding of the wrapper function.", "It also illustrates its use with a lambda."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n @gottahavethatfunc\ndef quux(me):\n    return me\n\nzoom = gottahavethatfunc(lambda me: me)\n\nbaz, quux = quux, None\n\nprint baz()\nprint zoom()\n</code>\n</pre>\n", "senID": 4}, {"text": ["When using this decorator with an instance or class method, the method should accept the function reference as the first argument and the traditional self as the second."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Demo(object):\n\n    @gottahavethatfunc\n    def method(me, self):\n        return me\n\nprint Demo().method()\n</code>\n</pre>\n", "senID": 6}], [{"text": ["The call stack does not keep a reference to the function itself - \nalthough the running frame as a reference to the code object that is the code associated to a given function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(Functions are objects with code, and some information about their environment, such as closures, name, globals dictionary, doc string, default parameters and so on)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Therefore if you are running a regular function, you are better of using its own name on the globals dictionary to call itself, as has been pointed out."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you are running some dynamic, or lambda code, in which you can't use the function name, the only solution is to rebuild another function object which re-uses thre currently running code object and call that new function instead."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You will loose a couple of things, like default arguments, and it may be hard to get it working with closures (although it can be done)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I have written a blog post on doing exactly that - calling anonymous functions from within themselves - I hope the code in there can help you:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["http://metapython.blogspot.com/2010/11/recursive-lambda-functions.html"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://metapython.blogspot.com/2010/11/recursive-lambda-functions.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://metapython.blogspot.com/2010/11/recursive-lambda-functions.html"}]}, {"text": ["On a side note: avoid the use o inspect.stack -- it is too slow, as it rebuilds a lot of information each time it is called.", "prefer to use inspect.currentframe to deal with code frames instead."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["This may sounds complicated, but the code itself is very short - I am pasting it bellow.", "The post above contains more information on how this works."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n from inspect import currentframe\nfrom types import FunctionType\n\nlambda_cache = {}\n\ndef myself (*args, **kw):\n    caller_frame = currentframe(1)\n    code = caller_frame.f_code\n    if not code in lambda_cache:\n        lambda_cache[code] = FunctionType(code, caller_frame.f_globals)\n    return lambda_cache[code](*args, **kw)\n\nif __name__ == \"__main__\":\n    print \"Factorial of 5\", (lambda n: n * myself(n - 1) if n &gt; 1 else 1)(5)\n</code>\n</pre>\n", "senID": 9}, {"text": ["If you really need the original function itself, the \"myself\" function above could be made to search on some scopes (like the calling function global dictionary) for a function object which code object would match with the one retrieved from the frame, instead of creating a new function."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["OK after reading the question and comments again, I think this is a decent test case:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(n):\n  \"\"\" print numbers from 0 to n \"\"\"\n  if n: foo(n-1)\n  print n\n\ng = foo    # assign name 'g' to function object\nfoo = None # clobber name 'foo' which refers to function object\ng(10)      # dies with TypeError because function object tries to call NoneType\n</code>\n</pre>\n", "senID": 1}, {"text": ["I tried solving it by using a decorator to temporarily clobber the global namespace and reassigning the function object to the original name of the function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def selfbind(f):\n   \"\"\" Ensures that f's original function name is always defined as f when f is executed \"\"\"\n   oname = f.__name__\n   def g(*args, **kwargs):\n\n      # Clobber global namespace\n      had_key = None\n      if globals().has_key(oname):\n         had_key = True\n         key = globals()[oname]\n      globals()[oname] = g\n\n      # Run function in modified environment\n      result = f(*args, **kwargs)\n\n      # Restore global namespace\n      if had_key: \n         globals()[oname] = key\n      else:\n         del globals()[oname]\n\n      return result\n\n   return g\n\n@selfbind\ndef foo(n):\n   if n: foo(n-1)\n   print n\n\ng = foo   # assign name 'g' to function object\nfoo = 2   # calling 'foo' now fails since foo is an int\ng(10)     # print from 0..10, even though foo is now an int\nprint foo # prints 2 (the new value of Foo)\n</code>\n</pre>\n", "senID": 3}, {"text": ["I'm sure I haven't thought through all the use cases.", "The biggest problem I see is the function object intentionally changing what its own name points to (an operation which would be overwritten by the decorator), but that should be ok as long as the recursive function doesn't redefine its own name in the middle of recursing."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Still not sure I'd ever need to do this, but thinking about was interesting."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I just define in the beginning of each function a \"keyword\" which is just a reference to the actual name of the function.", "I just do this for any function, if it needs it or not:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def test():\n    this=test\n    if not hasattr(this,'cnt'):\n        this.cnt=0\n    else:\n        this.cnt+=1\n    print this.cnt\n</code>\n</pre>\n", "senID": 1}]]