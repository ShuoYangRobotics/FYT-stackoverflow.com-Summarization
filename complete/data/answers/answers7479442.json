[[{"text": ["The difficult thing with passwords is to make them strong enough and still be able to remember them.", "If the password is not meant to be remembered by a human being, then it is not really a password."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You use Python's os.urandom(): that's good.", "For any practical purpose (even cryptography), the output of os.urandom() is indistinguishable from true alea.", "Then you use it as seed in random, which is less good: that one is a non-cryptographic PRNG, and its output may exhibit some structure which will not register in a statistical measurement tool, but might be exploited by an intelligent attacker.", "You should work with os.urandom() all along.", "To make things simple: choose an alphabet of length 64, e.g.", "letters (uppercase and lowercase), digits, and two extra punctuation characters (such as '+' and '/').", "Then, for each password character, get one byte from os.urandom(), reduce the value modulo 64 (this is unbiased because 64 divides 256) and use the result as index in your chars array."], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "os.urandom()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.urandom()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "random", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "os.urandom()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "os.urandom()", "childNum": 0, "tag": "code", "pos": 6, "childList": []}, {"text": "chars", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["With an alphabet of length 64, you get 6 bits of entropy per character (because 26 = 64).", "Thus, with 13 characters, you get 78 bits of entropy.", "This is not ultimately strong in all cases, but already very strong (it could be defeated with a budget which will be counted in months and billions of dollars, not mere millions)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "6", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}]}], [{"text": ["Just two days ago, Kragen Javier Sitaker posted a program to do this at http://lists.canonical.org/pipermail/kragen-hacks/2011-September/000527.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://lists.canonical.org/pipermail/kragen-hacks/2011-September/000527.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://lists.canonical.org/pipermail/kragen-hacks/2011-September/000527.html"}]}, {"text": ["Generate a random, memorizable password: http://xkcd.com/936/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://xkcd.com/936/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://xkcd.com/936/"}]}, {"text": ["Example run:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["kragen at inexorable:~/devel/inexorable-misc$ ./mkpass.py 5 12 Your password is \"learned damage saved residential stages\".", "That's equivalent to a 60-bit key."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["That password would take 2.5e+03 CPU-years to crack on my inexpensive Celeron E1200 from 2008, assuming an offline attack on a MS-Cache hash, which is the worst password hashing algorithm in common use, slightly worse than even simple MD5."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The most common password-hashing algorithm these days is FreeBSD\u2019s iterated MD5; cracking such a hash would take 5.2e+06 CPU-years."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["But a modern GPU can crack about 250 times as fast, so that same iterated MD5 would fall in 2e+04 GPU-years."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["That GPU costs about US$1.45 per day to run in 2011, so cracking the password would cost about US$3e+09."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["I've started using a password generated this way in place of a 9-printable- ASCII-character random password, which is equally strong.", "Munroe's assertion that these passwords are much easier to memorize is correct.", "However, there is still a problem: because there are many fewer bits of entropy per character (about 1.7 instead of 6.6) there is a lot of redundancy in the password, and so attacks such as the ssh timing-channel attack (the Song, Wagner, and Tian Herbivore attack, which I learned about from Bram Cohen in the Bagdad Caf\u00e9 in the wee hours one morning, years ago) and keyboard audio recording attacks have a much better chance of capturing enough information to make the password attackable."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["My countermeasure to the Herbivore attack, which works well with 9-character password but is extremely annoying with my new password, is to type the password with a half-second delay between characters, so that the timing channel does not carry much information about the actual characters used.", "Additionally, the lower length of the 9-character password inherently gives the Herbivore approach much less information to chew on."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Other possible countermeasures include using Emacs shell-mode, which prompts you locally for the password when it recognizes a password prompt and then sends the whole password at once, and copying and pasting the password from somewhere else."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["As you'd expect, this password also takes a little while longer to type: about 6 seconds instead of about 3 seconds."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport random, itertools, os, sys\n\ndef main(argv):\n    try:\n        nwords = int(argv[1])\n    except IndexError:\n        return usage(argv[0])\n\n    try:\n        nbits = int(argv[2])\n    except IndexError:\n        nbits = 11\n\n    filename = os.path.join(os.environ['HOME'], 'devel', 'wordlist')\n    wordlist = read_file(filename, nbits)\n    if len(wordlist) != 2**nbits:\n        sys.stderr.write(\"%r contains only %d words, not %d.\\n\" %\n                         (filename, len(wordlist), 2**nbits))\n        return 2\n\n    display_password(generate_password(nwords, wordlist), nwords, nbits)\n    return 0\n\ndef usage(argv0):\n    p = sys.stderr.write\n    p(\"Usage: %s nwords [nbits]\\n\" % argv0)\n    p(\"Generates a password of nwords words, each with nbits bits\\n\")\n    p(\"of entropy, choosing words from the first entries in\\n\")\n    p(\"$HOME/devel/wordlist, which should be in the same format as\\n\")\n    p(\"&lt;http://canonical.org/~kragen/sw/wordlist&gt;, which is a text file\\n\")\n    p(\"with one word per line, preceded by its frequency, most frequent\\n\")\n    p(\"words first.\\n\")\n    p(\"\\nRecommended:\\n\")\n    p(\"    %s 5 12\\n\" % argv0)\n    p(\"    %s 6\\n\" % argv0)\n    return 1\n\ndef read_file(filename, nbits):\n    return [line.split()[1] for line in\n            itertools.islice(open(filename), 2**nbits)]\n\ndef generate_password(nwords, wordlist):\n    choice = random.SystemRandom().choice\n    return ' '.join(choice(wordlist) for ii in range(nwords))\n\ndef display_password(password, nwords, nbits):\n    print 'Your password is \"%s\".' % password\n    entropy = nwords * nbits\n    print \"That's equivalent to a %d-bit key.\" % entropy\n    print\n\n    # My Celeron E1200\n    # (&lt;http://ark.intel.com/products/34440/Intel-Celeron-Processor-E1200-(512K-Cache-1_60-GHz-800-MHz-FSB)&gt;)\n    # was released on January 20, 2008.  Running it in 32-bit mode,\n    # john --test (&lt;http://www.openwall.com/john/&gt;) reports that it\n    # can do 7303000 MD5 operations per second, but I\u2019m pretty sure\n    # that\u2019s a single-core number (I don\u2019t think John is\n    # multithreaded) on a dual-core processor.\n    t = years(entropy, 7303000 * 2)\n    print \"That password would take %.2g CPU-years to crack\" % t\n    print \"on my inexpensive Celeron E1200 from 2008,\"\n    print \"assuming an offline attack on a MS-Cache hash,\"\n    print \"which is the worst password hashing algorithm in common use,\"\n    print \"slightly worse than even simple MD5.\"\n    print\n\n    t = years(entropy, 3539 * 2)\n    print \"The most common password-hashing algorithm these days is FreeBSD\u2019s\"\n    print \"iterated MD5; cracking such a hash would take %.2g CPU-years.\" % t\n    print\n\n    # (As it happens, my own machines use Drepper\u2019s SHA-2-based\n    # hashing algorithm that was developed to replace the one\n    # mentioned above; I am assuming that it\u2019s at least as slow as the\n    # MD5-crypt.)\n\n    # &lt;https://en.bitcoin.it/wiki/Mining_hardware_comparison&gt; says a\n    # Core 2 Duo U7600 can do 1.1 Mhash/s (of Bitcoin) at a 1.2GHz\n    # clock with one thread.  The Celeron in my machine that I\n    # benchmarked is basically a Core 2 Duo with a smaller cache, so\n    # I\u2019m going to assume that it could probably do about 1.5Mhash/s.\n    # All common password-hashing algorithms (the ones mentioned\n    # above, the others implemented in John, and bcrypt, but not\n    # scrypt) use very little memory and, I believe, should scale on\n    # GPUs comparably to the SHA-256 used in Bitcoin.\n\n    # The same mining-hardware comparison says a Radeon 5870 card can\n    # do 393.46 Mhash/s for US$350.\n\n    print \"But a modern GPU can crack about 250 times as fast,\"\n    print \"so that same iterated MD5 would fall in %.1g GPU-years.\" % (t / 250)\n    print\n\n    # Suppose we depreciate the video card by Moore\u2019s law,\n    # i.e. halving in value every 18 months.  That's a loss of about\n    # 0.13% in value every day; at US$350, that\u2019s about 44\u00a2 per day,\n    # or US$160 per GPU-year.  If someone wanted your password as\n    # quickly as possible, they could distribute the cracking job\n    # across a network of millions of these cards.  The cards\n    # additionally use about 200 watts of power, which at 16\u00a2/kWh\n    # works out to 77\u00a2 per day.  If we assume an additional 20%\n    # overhead, that\u2019s US$1.45/day or US$529/GPU-year.\n    cost_per_day = 1.45\n    cost_per_crack = cost_per_day * 365 * t\n    print \"That GPU costs about US$%.2f per day to run in 2011,\" % cost_per_day\n    print \"so cracking the password would cost about US$%.1g.\" % cost_per_crack\n\ndef years(entropy, crypts_per_second):\n    return float(2**entropy) / crypts_per_second / 86400 / 365.2422\n\nif __name__ == '__main__':\n    sys.exit(main(sys.argv))\n</code>\n</pre>\n", "senID": 12}], [{"text": ["XKCD has a great explanation of why randomness doesn't make cryptographically strong passwords."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "XKCD", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://xkcd.com/936/"}]}, {"src": "http://imgs.xkcd.com/comics/password_strength.png", "tag": "img", "senID": 1}, {"text": ["And if you don't understand the math behind what this illustration is explaining, don't try writing anything that should be cryptographically secure, because it won't be.", "Just put the mouse down and step away from the keyboard."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "math behind what this illustration is explaining", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Password_strength#Entropy_as_a_measure_of_password_strength"}]}], [{"text": ["Considering your comment,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["it seems you want to use your program to generate passwords, rather than just writing it as an exercise.", "It is preferable to use an existing implementation, because if you make a mistake, the output might be compromised.", "Read about random number generator attacks; in particular, a well-known RNG bug in Debian exposed people's SSL private keys."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "random number generator attacks", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Random_number_generator_attack"}]}, {"text": ["So instead, consider using pwgen.", "It provides several options, which you should choose depending on what you plan to use the passwords for."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "pwgen", "tag": "a", "pos": 0, "childList": [{"text": "pwgen", "tag": "code"}], "childNum": 1, "href": "http://linux.die.net/man/1/pwgen"}, {"text": "pwgen", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["That way works.", "It is perfectly fine.", "If you had additional rules, such as excluding dictionary words, then you may want to include those filters as well, but the likelihood of randomly generating a dictionary word with that setup is extremely small."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can't trust python's pseudo random number generator when generating a password.", "It is not necessarily cryptographically random.", "You are seeding the pseudo random number generator from os.urandom which is a good start.", "But then you depend on python's generator after that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "os.urandom", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["A better choice be the random.SystemRandom() class which takes random numbers from the same source as urandom.", "According to the python documentation that should be good enough for cryptographic use.", "The SystemRandom class gives you everything that the main random class does but you don't need to worry about the pseudorandomness."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "random.SystemRandom()", "tag": "a", "pos": 0, "childList": [{"text": "random.SystemRandom()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/random.html#random.SystemRandom"}, {"text": "random.SystemRandom()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "urandom", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "SystemRandom", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["This is more for fun than anything.", "Scores favorably in passwordmeter.com but impossible to remember."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/ruby\n\nputs (33..126).map{|x| ('a'..'z').include?(x.chr.downcase) ?\n                       (0..9).to_a.shuffle[0].to_s + x.chr :\n                       x.chr}.uniq.shuffle[0..42].join[0..42]\n</code>\n</pre>\n", "senID": 1}]]