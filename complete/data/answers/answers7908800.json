[[{"text": ["Start by generating as many identical tuples, n, as you need:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(A/n, B/n)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "(A/n, B/n)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Now pick two tuples at random.", "Make a random change to the a value of one, and a compensating change to the a value of the other, keeping everything within the given constraints.", "Put the two tuples back."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Now pick another random pair.", "This times twiddle with the b values."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Lather, rinse repeat."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I think the simplest thing is to"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Note that since we have 2 hard constrains we should expect to throw 2n-2 random numbers, and this method does exactly that (on the assumption that you can do step 1 with n-1 throws."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "2n-2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n-1", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["We look for tuples a_i and b_i such that"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "(a_1, ... a_n) and (b_1, ... b_n) have a distribution which is invariant under permutation of indices (what you would call \"unbiased\")", "tag": "none", "senID": 1}, {"text": "the ratios a_i / b_i are uniformly distributed on [cmin, cmax]", "tag": "none", "senID": 2}, {"text": "sum(a_i) = A, sum(b_i) = B", "tag": "none", "senID": 3}]}, {"text": ["If c_min and c_max are not too ill conditioned (ie they are not very close to another), and n is not very large, the following works:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "c_min", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "c_max", "childNum": 0, "tag": "code", "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "Generate ", "tag": "none", "senID": 5}, {"text": "Generate ", "tag": "none", "senID": 6}, {"text": "If there exists ", "tag": "none", "senID": 7}]}, {"text": ["It doesn't scale well with n, because the set of a_i and b_i satisfying the constraints gets more and more narrow as n increases (and so you reject more candidates)."], "childNum": 5, "tag": "p", "senID": 8, "childList": [{"text": "doesn't", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}, {"text": "a_i", "childNum": 0, "tag": "code", "childList": []}, {"text": "b_i", "childNum": 0, "tag": "code", "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To be honest, I don't see any other simple solution.", "If n gets large and cmin ~ cmax, then you will have to use a sledgehammer (eg.", "MCMC) to generate samples from your distribution, unless there is some trick we did not see."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cmin ~ cmax", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If you really want to use MCMC algorithms, note that you can change cmin to cmin * B / A (likewise for cmax) and assume A == B == 1.", "The problem is then to draw uniformly on the product of two unit n-simplices (u_1...u_n, v_1...v_n) such that"], "childNum": 4, "tag": "p", "senID": 10, "childList": [{"text": "cmin", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cmin * B / A", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "cmax", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "A == B == 1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n u_i / v_i \\in [cmin, cmax].\n</code>\n</pre>\n", "senID": 11}, {"text": ["So you have to use a MCMC algorithm (Metropolis-Hastings seems more suited) on the product of two unit n-simplices with the density"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n f(u_1, ..., u_n, v_1, ..., v_n) = \\prod indicator_{u_i/v_i \\in [cmin, cmax]}\n</code>\n</pre>\n", "senID": 13}, {"text": ["which is definitely doable (albeit involved)."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["Blocked Gibbs sampling is pretty simple and converges to the right distribution (this is along the lines of what Alexandre is proposing)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["So here's what I think from mathematical point of view.", "We have sequences a_i and b_i such that sum of a_i is A and sum of b_i is B.", "Furthermore A/B is in (x,y) and so is a_i/b_i for each i.", "Furthermore you want a_i/b_i to be uniformly distributed in (x,y). "], "childNum": 12, "tag": "p", "senID": 0, "childList": [{"text": "a_i", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "b_i", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "a_i", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "A", "childNum": 0, "tag": "code", "childList": []}, {"text": "b_i", "childNum": 0, "tag": "code", "childList": []}, {"text": "B", "childNum": 0, "tag": "code", "childList": []}, {"text": "A/B", "childNum": 0, "tag": "code", "childList": []}, {"text": "(x,y)", "childNum": 0, "tag": "code", "childList": []}, {"text": "a_i/b_i", "childNum": 0, "tag": "code", "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "childList": []}, {"text": "a_i/b_i", "childNum": 0, "tag": "code", "childList": []}, {"text": "(x,y)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So do it starting from the end.", "Choose c_i from (x,y) such that they are uniformly distributed.", "Then we want to have the following equality a_i/b_i = c_i, so a_i = b_i*c_i."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "c_i", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(x,y)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a_i/b_i = c_i", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "a_i = b_i*c_i", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Therefore we only need to find b_i.", "But we have the following system of linear equations:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "b_i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n A = (sum)b_i*c_i\nB = (sum)b_i\n</code>\n</pre>\n", "senID": 3}, {"text": ["where b_i are variables.", "Solve it (some fancy linear algebra tricks) and you're done! "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "b_i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Note that for large enough n this system will have lots of solutions.", "They will be dependent on some parameters which you can choose randomly."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Enough of the theoretical approach, let's see some practical solution."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["// EDIT 1: Here's some hard core Python code :D"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import random\nmin = 0.0\nmax = 10.0\nA = 500.0\nB = 100.0\n\ndef generate(n):\n    C = [min + i*(max-min)/(n+1) for i in range(1, n+1)]\n    Y = [0]\n    for i in range(1,n-1):\n        # This line should be changed in order to always get positive numbers\n        # It should be relatively easy to figure out some good random generator\n        Y.append(random.random())\n    val = A - C[0]*B\n    for i in range(1, n-1):\n        val -= Y[i] * (C[i] - C[0])\n    val /= (C[n-1] - C[0])\n    Y.append(val)\n    val = B\n    for i in range(1, n):\n        val -= Y[i]\n    Y[0] = val\n    result = []\n    for i in range(0, n):\n        result.append([ Y[i]*C[i], Y[i] ])\n    return result\n</code>\n</pre>\n", "senID": 8}, {"text": ["The result is a list of pairs (X,Y) satisfying your conditions with the exception that they may be negative (see the random generator line in code) i.e.", "the first and the last pair may contain negative numbers."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "(X,Y)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["// EDIT 2:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Too ensure that they are positive you may try something like"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n Y.append(random.random() * B / n)\n</code>\n</pre>\n", "senID": 12}, {"text": ["instead of"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n Y.append(random.random())\n</code>\n</pre>\n", "senID": 14}, {"text": ["I'm not sure though."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["// EDIT 3:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["In order to have better results try something like this:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n avrg = B / n\nran = avrg / 20\nfor i in range(1, n-1):\n    Y.append(random.gauss(avrg, ran))\n</code>\n</pre>\n", "senID": 18}, {"text": ["instead of "], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n for i in range(1, n-1):\n    Y.append(random.random())\n</code>\n</pre>\n", "senID": 20}, {"text": ["This will make all b_i to be near B / n. Unfortunetly the last term will still sometimes jump high.", "I'm sorry, but there is no way to avoid this (mathematics) since the last and the first terms depend on the others.", "For small n (~100) it looks good though.", "Unfortunetly some negative values may appear."], "childNum": 3, "tag": "p", "senID": 21, "childList": [{"text": "b_i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "B / n", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The choice of a correct generator is not so simple if you additionally want b_i to be uniformly distributed."], "childNum": 1, "tag": "p", "senID": 22, "childList": [{"text": "b_i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Lots of good ideas here.", "Thanks!", "Rossum's idea seemed the most straightforward implementation-wise so I went for it.", "Here is the code for posterity:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Rossum", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n c_min = 0.25\nc_max = 0.75\na_sum = 100.0\nb_sum = 200.0\nn = 1000 \n\na = [a_sum / n] * n\nb = [b_sum / n] * n\n\nwhile not good_enough(a, b):\n    i, j = random.sample(range(n), 2)\n    li, ui = c_min * b[i] - a[i], c_max * b[i] - a[i]\n    lj, uj = a[j] - c_min * b[j], a[j] - c_max * b[j]\n    llim = max((li, uj))\n    ulim = min((ui, lj))\n    q = random.uniform(llim, ulim)\n    a[i] += q\n    a[j] -= q\n\n    i, j = random.sample(range(n), 2)\n    li, ui = a[i] / c_max - b[i], a[i] / c_min - b[i]\n    lj, uj = b[j] - a[j] / c_max, b[j] - a[j] / c_min\n    llim = max((li, uj))\n    ulim = min((ui, lj))\n    q = random.uniform(llim, ulim)\n    b[i] += q\n    b[j] -= q\n</code>\n</pre>\n", "senID": 1}, {"text": ["The good_enough(a, b) function can be a lot of things.", "I tried:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "good_enough(a, b)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 4, "lis": [{"text": "Standard deviation, which is hit or miss, as you don't know what is a good enough value.", "tag": "none", "senID": 3}, {"text": "Kurtosis, where a large negative value would be nice. However, it is relatively slow to calculate and is undefined with the seed values of ", "tag": "none", "senID": 4}, {"text": "Skewness, where a value close to ", "tag": "none", "senID": 5}, {"text": "A number of iterations proportional to ", "tag": "none", "senID": 6}]}, {"text": ["Ideally, a heuristic using a combination of skewness and kurtosis would be best but I settled for making sure each value has been changed from the initial (again, as rossum suggested in a comment).", "Though there is no theoretical guarantee that the loop will complete, it seemed to work well enough for me."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "rossum", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]