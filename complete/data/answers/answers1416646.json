[[{"text": ["Typically, strings (plain and unicode) are the only iterables that you want to nevertheless consider as \"single elements\" -- the basestring builtin exists SPECIFICALLY to let you test for either kind of strings with isinstance, so it's very UN-grotty for that special case;-)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "basestring", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "isinstance", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So my suggested approach for the most general case is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if isinstance(input, basestring): input = [input]\n  else:\n    try: iter(input)\n    except TypeError: input = [input]\n    else: input = list(input)\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is THE way to treat EVERY iterable EXCEPT strings as a list directly, strings and numbers and other non-iterables as scalars (to be normalized into single-item lists)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I'm explicitly making a list out of every kind of iterable so you KNOW you can further on perform EVERY kind of list trick - sorting, iterating more than once, adding or removing items to facilitate iteration, etc, all without altering the ACTUAL input list (if list indeed it was;-).", "If all you need is a single plain for loop then that last step is unnecessary (and indeed unhelpful if e.g.", "input is a huge open file) and I'd suggest an auxiliary generator instead:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def justLoopOn(input):\n  if isinstance(input, basestring):\n    yield input\n  else:\n    try:\n      for item in input:\n        yield item\n    except TypeError:\n      yield input\n</code>\n</pre>\n", "senID": 5}, {"text": ["now in every single one of your functions needing such argument normalization, you just use:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n for item in justLoopOn(input):\n</code>\n</pre>\n", "senID": 7}, {"text": ["You can use an auxiliary normalizing-function even in the other case (where you need a real list for further nefarious purposes); actually, in such (rarer) cases, you can just do:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n thelistforme = list(justLoopOn(input))\n</code>\n</pre>\n", "senID": 9}, {"text": ["so that the (inevitably) somewhat-hairy normalization logic is just in ONE place, just as it should be!-)"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I like Andrei Vajna's suggestion of hasattr(var,'__iter__').", "Note these results from some typical Python types:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "hasattr(var,'__iter__')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hasattr(\"abc\",\"__iter__\")\nFalse\n&gt;&gt;&gt; hasattr((0,),\"__iter__\")\nTrue\n&gt;&gt;&gt; hasattr({},\"__iter__\")\nTrue\n&gt;&gt;&gt; hasattr(set(),\"__iter__\")\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["This has the added advantage of treating a string as a non-iterable - strings are a grey area, as sometimes you want to treat them as an element, other times as a sequence of characters."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can put * before your argument, this way you'll always get a tuple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def a(*p):\n  print type(p)\n  print p\n\na(4)\n&gt;&gt;&gt; &lt;type 'tuple'&gt;\n&gt;&gt;&gt; (4,)\n\na(4, 5)\n&gt;&gt;&gt; &lt;type 'tuple'&gt;\n&gt;&gt;&gt; (4,5,)\n</code>\n</pre>\n", "senID": 1}, {"text": ["But that will force you to call your function with variable parameters, I don't know if that 's acceptable for you."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can do direct type comparisons using type()."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "type()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def my_func(input):\n    if not type(input) is list:\n        input = [input]\n    for e in input:\n        # do something\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, the way you have it will allow any type derived from the list type to be passed through.", "Thus preventing the any derived types from accidentally being wrapped."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "any", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Your aproach seems right to me."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's similar to how you use atom?", "in Lisp when you iterate over lists and check the current item to see if it is a list or not, because if it is a list you want to process its items, too."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "atom?", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So, yeah, don't see anything wrong with that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["That is an ok way to do it (don't forget to include tuples)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, you may also want to consider if the argument has a __iter__ method or __getitem__ method.", "(note that strings have __getitem__ instead of __iter__."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "method", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#object.%5F%5Fiter%5F%5F"}, {"text": "method", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#object.%5F%5Fgetitem%5F%5F"}]}, {"code": "<pre>\n<code>\n hasattr(arg, '__iter__') or hasattr(arg, '__getitem__')\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is probably the most general requirement for a list-like type than only checking the type."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["First, there is no general method that could tell a \"single element\" from \"list of elements\" since by definition list can be an element of another list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would say you need to define what kinds of data you might have, so that you might have:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "any descendant of ", "tag": "none", "senID": 2}, {"text": "any sequence type except strings (", "tag": "none", "senID": 3}, {"text": "some sequence type against known cases, like ", "tag": "none", "senID": 4}, {"text": "any iterable except strings:\n", "tag": "none", "senID": 5}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n try: \n        input = iter(input) if not isinstance(input, str) else [input]\n    except TypeError:\n        input = [input]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["This seems like a reasonable way to do it.", "You're wanting to test if the element is a list, and this accomplishes that directly.", "It gets more complicated if you want to support other 'list-like' data types, too, for example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n isinstance(input, (list, tuple))\n</code>\n</pre>\n", "senID": 1}, {"text": ["or more generally, abstract away the question:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def iterable(obj):\n  try:\n    len(obj)\n    return True\n  except TypeError:\n    return False\n</code>\n</pre>\n", "senID": 3}, {"text": ["but again, in summary, your method is simple and correct, which sounds good to me!"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]