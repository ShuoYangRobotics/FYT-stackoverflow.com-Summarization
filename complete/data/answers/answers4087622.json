[[{"text": ["Since the request is now to be more general:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import izip\n&gt;&gt;&gt; ff = {'colors': ['yellow', 'pink', 'green'], 'names': ['banana', 'grapefruit', 'apple'], 'blah': ['a','b','c']}\n\n&gt;&gt;&gt; [dict(izip(ff.iterkeys(), v)) for v in izip(*ff.itervalues())]\n[{'blah': 'a', 'colors': 'yellow', 'names': 'banana'},\n {'blah': 'b', 'colors': 'pink', 'names': 'grapefruit'},\n {'blah': 'c', 'colors': 'green', 'names': 'apple'}]\n</code>\n</pre>\n", "senID": 1}, {"text": ["since the order of keys and values are the same (assuming no intervening modifications to the dictionary)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "keys", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "values", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["It'd be pretty hard to go from keys like 'names' to 'name', teaching the program how to do proper english singlularization ... so i renamed the keys in the input:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ff = dict(name=['banana','grapefruit','apple'], color=['yellow','pink','green'], \n          yummy=[True,False,True])\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can solve this problem with zip again:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # make fruits [('yellow', True, 'banana'), ('pink', False, 'grapefruit'), ... ]\nfruits = zip(*ff.itervalues())\n\n# then add the names to each fruit\ntofruits = [dict(zip(ff.iterkeys(),fruit)) for fruit in fruits]\n# gives: [{'color': 'yellow', 'yummy': True, 'name': 'banana'}, ... ]\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n [dict((x, fromfruits[x][n]) for x in fromfruits.keys())\n  for n in range(len(next(fromfruits.itervalues())))]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Optimize as desired."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; fromfruits\n{'colors': ['yellow', 'pink', 'green'], 'names': ['banana', 'grapefruit', 'apple']}\n&gt;&gt;&gt; [{'name': name, 'color': color} for name in fromfruits['names'] for color in fromfruits['colors']]\n[{'color': 'yellow', 'name': 'banana'}, {'color': 'pink', 'name': 'banana'}, {'color': 'green', 'name': 'banana'}, {'color': 'yellow', 'name': 'grapefruit'}, {'color': 'pink', 'name': 'grapefruit'}, {'color': 'green', 'name': 'grapefruit'}, {'color': 'yellow', 'name': 'apple'}, {'color': 'pink', 'name': 'apple'}, {'color': 'green', 'name': 'apple'}]\n</code>\n</pre>\n", "senID": 0}, {"text": ["And now in some more detail (re-formatted for clarity):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;[{'name': name, 'color': color} \n        for name in fromfruits['names'] \n        for color in fromfruits['colors']]\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is a \"list comprehension\" with a double for which goes over all combinations of names and colors.", "You can add a third loop if you want to mix in other attributes, like \"shape\" or whatever."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["not very pythonic, but ..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n keys = fromfruits.keys()\nnvals = len(fromfruits[keys[0]])\ntofruits = [ ]\nfor i in range(nvals):\n    tofruits.append ({ })\n    for k in keys:\n        tofruits[-1][k] = fromfruits[k][i]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This problem is a bit more convoluted than the average list comprehension because of the nested dictionaries.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However if you can create the right iterable then a list comprehension is the way to go."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "However", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Try:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n tofruits = [ {'name':n, 'color':c} for n,c in zip(fromfruits['names'], \n                                              fromfruits['colors']) ]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Here the zip function is used to produce tuples which match the correct name and color.", "This is a good way to go here because both are stored in basic lists within the fromfruits dict."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "name", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "color", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fromfruits", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["These tuples (from zip) are then unpacked into n and c, which are then used as in a typical list comprehension."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}]}]]