[[{"text": ["You might be getting stack overflow from too many recusive calls on the stack.", "At 42751 you would have a 21375 depth function call stack.", "In such case, refining your method might actually be needed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A handy little routine which will check primeness can be written like this (pseudocode):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if n &lt; 2 return false;\nif n == 2 or n == 3 return true;\nif n % 2 == 0 return false;\nif n % 3 == 0 return false;\nfor (i = 6; i &lt; sqrt(n); i += 6) {\n  if (n % (i - 1) == 0) return false;\n  if (n % (i + 1) == 0) return false;\n}\nreturn true;\n</code>\n</pre>\n", "senID": 2}, {"text": ["This method works because of the following:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Your program is using recursion.", "Every function call saves registers on to the stack and then jumps to the beginning of the function.", "Since your stack has a limited size, eventually you will run out of stack space.", "At this point you are you would be writing over memory you aren't supposed (or even allowed) to.", "Thus leading to a segmentation fault."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Setting a very large recursion limit and then recursing a bunch is one of the documented ways to crash the Python interpeter."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "documented", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/CrashingPython"}]}, {"text": ["Essentially you're telling Python not to stop you if you recurse too far, and then you're recursing too far."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You're making a recursive call, counting up linearly by 2.", "CPython doesn't do tail call elimination, and (IIRC) it uses the C stack, so it's taking up some pretty serious stack space here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I can't find the default stack size on 64-bit Mac OS (on 32-bit it appears to be 8MB) but it's definitely not infinite, and apparently not big enough to hold stack frames for every odd number up to 50,000."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["My guess is you have run out of memory in the recursive part of your routine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you recode it as a loop incrementing x then you will find it goes further before crashing. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For the sake of posterity the code that I wrote in the end which fixed the bug was as follows."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\ndef isPrime( no ):\n  sqrt = round(no**0.5);\n  # if counted through and all numbers from 3 too x are not factors is prime\n  if no % 2 == 0 or no % 3 == 0:\n    return False\n  for x in range(6, int(sqrt), 6):\n    if no % (x - 1) == 0:\n      return False\n    if no % (x + 1) == 0:\n      return False\n  return True\n\ndef primesInRange(limLow, limHigh):\n   # negitive numbers, 0 and 1 are not primes so answer invalid\n  if limLow &lt; 2:\n    raise ValueError('Lower limit must be 2 or more')\n  # if lower limit is even its not prime so increase by 1\n  if limLow % 2 == 0:\n    limLow += 1\n  primes = []\n  while (limLow &lt;= limHigh):\n    if isPrime(limLow): primes.append(limLow)\n    limLow += 2\n  return primes\n\n\ndef main():\n  limLow = int(sys.argv[1])\n  limHigh = int(sys.argv[2])\n  print primesInRange(limLow, limHigh)\n\nif __name__ == '__main__':\n  main()\n</code>\n</pre>\n", "senID": 1}]]