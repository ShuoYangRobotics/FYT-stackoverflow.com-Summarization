[[{"text": ["No, Java and .NET don't do it \"automatically with all strings\".", "They (well, Java and C#) do it with constant string expressions expressed in bytecode/IL, and on demand via the String.intern and String.Intern (.NET) methods.", "The exact situation in .NET is interesting, but basically the C# compiler will guarantee that every reference to an equal string constant within an assembly ends up referring to the same string object.", "That can be done efficiently at type initialization time, and can save a bunch of memory."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "constant", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "String.intern", "tag": "a", "pos": -1, "childList": [{"text": "String.intern", "tag": "code"}], "childNum": 1, "href": "http://download.oracle.com/javase/6/docs/api/java/lang/String.html#intern%28%29"}, {"text": "String.intern", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "String.Intern", "tag": "a", "pos": -1, "childList": [{"text": "String.Intern", "tag": "code"}], "childNum": 1, "href": "http://msdn.microsoft.com/en-us/library/system.string.intern.aspx"}, {"text": "String.Intern", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["It doesn't happen every time a new string is created."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "doesn't", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["(On the string immutability front, I for one am extremely glad that strings are immutable.", "I don't want to have to take a copy every time I receive a parameter etc, thank you very much.", "I haven't seen it make string processing tasks harder, either...)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "extremely", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["And as others have pointed out, looking up a string in a hash table isn't generally an O(n) operation, unless you're incredibly unlucky with hash collisions..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Personally I don't use string interning in user-land code; if I want some sort of cache of strings I'll create a HashSet&lt;string&gt; or something similar.", "That can be useful in various situations where you expect to come across the same strings several times (e.g.", "XML element names) but with a simple collection you don't pollute a system-wide cache."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "HashSet&lt;string&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This is true and string are immutable in Java.", "I am not sure if this a bad thing.", "Without going in to immutable vs mutable, I like to think this is a great design because of caching and so much more simplicity that I won't get in to. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Not exactly O(n).", "You can do hashmaps and/or other data structures that will bring this to near constant look up. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You are right about this and I would agree with you.", "Except I feel that the GC processing and negligible.", "The benefits in the long run are much more useful than having a garbage collector doing an extra check.", "I am not sure what you mean about O(n) for deleting from hashtable.", "Most operations on hashtables are O(1)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So in summary, I think your assumption that most operation are linear.", "But looking up strings is closer to a constant time.", "Therefore, this approach will have negligible performance loss but a huge memory gain.", "Which I'd argue is worth it. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Here is a nice quote on what is actually happening and how it saves memory. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "nice quote", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://javatechniques.com/public/java/docs/basics/string-equality.html"}]}], [{"text": ["Here's the python documentation's take on it:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "documentation's", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/release/3.1.3/library/sys.html?highlight=sys#sys.intern"}]}], [{"text": ["The a.equals(b) is very fast for random strings.", "Its is only slow for Strings which are long and the same (or almost the same)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Random rand = new Random(1);\nString[] list = new String[2000];\nfor(int i=0;i&lt;list.length;i++)\n    list[i] = \"1234567\"+Long.toString(rand.nextInt(36*37), 36); // semi random\nint count = 0;\nlong start = System.nanoTime();\nfor(int i=0;i&lt;list.length;i++)\n    for(int j=0;j&lt;list.length;j++)\n        if (list[i].equals(list[j]))\n            count++;\nlong time = System.nanoTime() - start;\nSystem.out.printf(\"The average time for equals() was %,d ns.%n\", time/list.length/list.length);\n</code>\n</pre>\n", "senID": 1}, {"text": ["on a 2.3 GHz laptop prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n The average time for equals() was 19 ns.\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you intern() the first value and have to intern() one value to do the comparison"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if (list[i] == list[j].intern())\n</code>\n</pre>\n", "senID": 5}, {"text": ["prints"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n The average time for equals() was 258 ns.\n</code>\n</pre>\n", "senID": 7}, {"text": ["This is a common case as you often have one value you know is interned and a second which is input and is not intern'ed."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["if you only use intern'ed Strings and == it, and don't count the cost, prints"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n The average time for equals() was 4 ns.\n</code>\n</pre>\n", "senID": 10}, {"text": ["Which is many times faster if you are doing millions of comparison.", "However for a small number of comparisons, you are saving 8 ns but could be costing 250 ns more."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["It may just be simpler to avoid intern() and use equals()."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["The points you listed are all valid to a certain extent.", "But there are important counter-arguments."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On balance I'd say it is worth it in most cases and fits well with the VM-managed heap concept.", "I could imagine some special scenarios where it could be a real pain though."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Yes.", "It's huge.", "Try it in java."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Write simple tests that compare 1,000's of semi-random strings for equality with and without interning.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a.equals( b )  is slow\n\na == b is fast.\n</code>\n</pre>\n", "senID": 2}]]