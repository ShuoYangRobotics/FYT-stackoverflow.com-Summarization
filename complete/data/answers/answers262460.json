[[{"text": ["The simplest way is just to write a program with an infinite loop, and then hit control-C to stop it.", "Without more description it's hard to know if this works for you."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you do it time-based, you don't need a generator.", "You can just have it pause for user input, something like a \"Continue?", "[y/n]\", read from stdin, and depending on what you get either exit the loop or not."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As in almost all languages:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while True:\n  # check what you want and eventually break\n  print nextValue()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The second part of your question is more interesting:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["you can use a yield instead of return in the function nextValue()"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "childList": []}, {"text": "nextValue()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If you use a child thread to run the function while the main thread waits for character input it should work.", "Just remember to have something that stops the child thread (in the example below the global runthread)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import threading, time\nrunthread = 1\ndef myfun():\n   while runthread:\n      print \"A\"\n      time.sleep(.1)\n\nt = threading.Thread(target=myfun)\nt.start()\nraw_input(\"\")\nrunthread = 0\nt.join()\n</code>\n</pre>\n", "senID": 2}, {"text": ["does just that"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you really want your function to run and still wants user (or system) input, you have two solutions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It will depend on how fine the interaction.", "If you just want to interrupt the function and don't care about the exit, then multi-process is fine."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In both cases, you can rely on some shared resources (file or shared memory for multi-thread, variable with associated mutex for multi-thread) and check for the state of that resource regularly in your function.", "If it is set up to tell you to quit, just do it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Example on multi-thread:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from threading import Thread, Lock\nfrom time import sleep\n\nclass MyFct(Thread):\n    def __init__(self):\n        Thread.__init__(self)\n        self.mutex = Lock()\n        self._quit = False\n\n    def stopped(self):\n        self.mutex.acquire()\n        val = self._quit\n        self.mutex.release()\n        return val\n\n    def stop(self):\n        self.mutex.acquire()\n        self._quit = True\n        self.mutex.release()\n\n    def run(self):\n        i = 1\n        j = 1\n        print i\n        print j\n        while True:\n            if self.stopped():\n                return\n            i,j = j,i+j\n            print j\n\ndef main_fct():\n    t = MyFct()\n    t.start()\n    sleep(1)\n    t.stop()\n    t.join()\n    print \"Exited\"\n\nif __name__ == \"__main__\":\n    main_fct()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["If you want to exit based on time, you can use the signal module's alarm(time) function, and the catch the SIGALRM - here's an example http://docs.python.org/library/signal.html#example"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/signal.html#example", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/signal.html#example"}]}, {"text": ["You can let the user interrupt the program in a sane manner by catching KeyboardInterrupt.", "Simply catch the KeyboardInterrupt exception from outside you main loop, and do whatever cleanup you want."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want to continue later where you left off, you will have to add some sort persistence.", "I would pickle a data structure to disk, that you could read back in to continue the operations. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pickle", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pickle.html#module-pickle"}]}, {"text": ["I haven't tried anything like this, but you could look into using something like memoizing, and caching to the disk."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "memoizing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonDecoratorLibrary#head-11870a08b0fa59a8622201abfac735ea47ffade5"}]}], [{"text": ["You could use a generator for this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def finished():\n    \"Define your exit condition here\"\n    return ...\n\ndef count(i=0):\n    while not finished():\n        yield i\n        i += 1\n\nfor i in count():\n    print i\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to change the exit condition you could pass a value back into the generator function and use that value to determine when to exit."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could do something like this to generate fibonnacci numbers for 1 second then stop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fibonnacci = [1,1]\nstoptime = time.time() + 1 # set stop time to 1 second in the future\nwhile time.time() &lt; stoptime:\n  fibonnacci.append(fibonnacci[-1]+fibonnacci[-2])\n\nprint \"Generated %s numbers, the last one was %s.\" % (len(fibonnacci),fibonnacci[-1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm not sure how efficient it is to call time.time() in every loop - depending on the what you are doing inside the loop, it might end up taking a lot of the performance away."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]