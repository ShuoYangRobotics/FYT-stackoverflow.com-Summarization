[[{"code": "<pre>\n<code>\n import re\n\npat = re.compile(r\"----\\s+(.*?) \\((.*?)\\) (?:changed status from (\\w+) to|became) (\\w+) @ (.*?) ----\\s*\")\nwith open(\"data.txt\") as f:\n    for line in f:\n        (name, email, prev, curr, date) = pat.match(line).groups()\n        print \"{0}/{1}  {2} {3} {4}\".format(name, email, prev or \"NaN\", curr, date)\n</code>\n</pre>\n", "senID": 0}, {"text": ["This makes assumptions about whitespace and also assumes that every line conforms to the pattern.", "You might want to add error checking (such as checking that pat.match() doesn't return None) if you want to handle dirty input gracefully."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pat.match()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["To get you started:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = []\nregex = re.compile(\n    r\"\"\"^-*\\s+\n    (?P&lt;name&gt;.*?)\\s+\n    \\((?P&lt;email&gt;.*?)\\)\\s+\n    (?:changed\\s+status\\s+from\\s+(?P&lt;previous&gt;.*?)\\s+to|became)\\s+\n    (?P&lt;new&gt;.*?)\\s+@\\s+\n    (?P&lt;date&gt;\\S+)\\s+\n    (?P&lt;time&gt;\\S+)\\s+\n    -*$\"\"\", re.VERBOSE)\nwith open(\"inputfile\") as f:\n    for line in f:\n        match = regex.match(line)\n        if match:\n            result.append([\n                match.group(\"name\"),\n                match.group(\"email\"),\n                match.group(\"previous\")\n                # etc.\n            ])\n        else:\n            # Match attempt failed\n</code>\n</pre>\n", "senID": 1}, {"text": ["will get you an array of the parts of the match.", "I'd then suggest you use the csv module to store the results in a standard format."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "csv module", "tag": "a", "pos": 1, "childList": [{"text": "csv module", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/csv.html"}, {"text": "csv module", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The two RE patterns of interest seem to be...:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n p1 = r'^---- ([^(]+) \\(([^)]+)\\) changed status from (\\w+) to (\\w+) (\\S+) (\\S+) ----$'\np2 = r'^---- ([^(]+) \\(([^)]+)\\) became (\\w+) (\\S+) (\\S+) ----$'\n</code>\n</pre>\n", "senID": 1}, {"text": ["so I'd do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import csv, re, sys\n\n# assign p1, p2 as above (or enhance them, etc etc)\n\nr1 = re.compile(p1)\nr2 = re.compile(p2)\ndata = []\n\nwith open('somefile.txt') as f:\n    for line in f:\n        m = p1.match(line)\n        if m:\n            data.append(m.groups())\n            continue\n        m = p2.match(line)\n        if not m:\n            print&gt;&gt;sys.stderr, \"No match for line: %r\" % line\n            continue\n        listofgroups = m.groups()\n        listofgroups.insert(2, 'NaN')\n        data.append(listofgroups)\n\nwith open('result.csv', 'w') as f:\n    w = csv.writer(f)\n    w.writerow('UserName/ID Previous Status New Status Date Time'.split())\n    w.writerows(data)\n</code>\n</pre>\n", "senID": 3}, {"text": ["If the two patterns I described are not general enough, they may need to be tweaked, of course, but I think this general approach will be useful.", "While many Python users on Stack Overflow intensely dislike REs, I find them very useful for this kind of pragmatical ad hoc text processing."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Maybe the dislike is explained by others wanting to use REs for absurd uses such as ad hoc parsing of CSV, HTML, XML, ... -- and many other kinds of structured text formats for which perfectly good parsers exist!", "And also, other tasks well beyond REs' \"comfort zone\", and requiring instead solid general parser systems like pyparsing.", "Or at the other extreme super-simple tasks done perfectly well with simple strings (e.g.", "I remember a recent SO question which used if re.search('something', s): instead of if 'something' in s:!-)."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "structured", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "pyparsing", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}, {"text": "if re.search('something', s):", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "if 'something' in s:", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["But for the reasonably broad swathe of tasks (excluding the very simplest ones at one end, and the parsing of structured or somewhat-complicated grammars at the other) for which REs are appropriate, there's really nothing wrong with using them, and I recommend to all programmers to learn at least REs' basics."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Alex mentioned pyparsing and so here is a pyparsing approach to your same problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from pyparsing import Word, Suppress, Regex, oneOf, SkipTo\nimport datetime\n\nDASHES = Word('-').suppress()\nLPAR,RPAR,AT = map(Suppress,\"()@\")\ndate = Regex(r'\\d{2}/\\d{2}/\\d{4}')\ntime = Regex(r'\\d{2}:\\d{2}:\\d{2}')\nstatus = oneOf(\"Busy Available Idle Offline Unavailable\")\n\nstatechange1 = 'changed status from' + status('fromstate') + 'to' + status('tostate')\nstatechange2 = 'became' + status('tostate')\nlinefmt = (DASHES + SkipTo('(')('name') + LPAR + SkipTo(RPAR)('email') + RPAR + \n            (statechange1 | statechange2) +\n            AT + date('date') + time('time') + DASHES)\n\ndef convertFields(tokens):\n    if 'fromstate' not in tokens:\n        tokens['fromstate'] = 'NULL'\n    tokens['name'] = tokens.name.strip()\n    tokens['email'] = tokens.email.strip()\n    d,mon,yr = map(int, tokens.date.split('/'))\n    h,m,s = map(int, tokens.time.split(':'))\n    tokens['datetime'] = datetime.datetime(yr, mon, d, h, m, s)\nlinefmt.setParseAction(convertFields)\n\nfor line in text.splitlines():\n    fields = linefmt.parseString(line)\n    print \"%(name)s/%(email)s  %(fromstate)-10.10s %(tostate)-10.10s %(datetime)s\" % fields\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Mark Grey/mark.grey@gmail.com  Busy       Available  2010-07-14 16:32:36\nSilvia Pablo/spablo@gmail.com  NULL       Available  2010-07-14 16:32:39\n</code>\n</pre>\n", "senID": 3}, {"text": ["pyparsing allows you to attach names to the results fields (just like the named groups in Tom Pietzcker's RE-styled answer), plus parse-time actions to act on or manipulate the parsed actions - note the conversion of the separate date and time fields into a true datetime object, already converted and ready for processing after parsing with no additional muss nor fuss.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Here is a modified loop that just dumps out the parsed tokens and the named fields for each line:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for line in text.splitlines():\n    fields = linefmt.parseString(line)\n    print fields.dump()\n</code>\n</pre>\n", "senID": 6}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n ['Mark Grey ', 'mark.grey@gmail.com', 'changed status from', 'Busy', 'to', 'Available', '14/07/2010', '16:32:36']\n- date: 14/07/2010\n- datetime: 2010-07-14 16:32:36\n- email: mark.grey@gmail.com\n- fromstate: Busy\n- name: Mark Grey\n- time: 16:32:36\n- tostate: Available\n['Silvia Pablo ', 'spablo@gmail.com', 'became', 'Available', '14/07/2010', '16:32:39']\n- date: 14/07/2010\n- datetime: 2010-07-14 16:32:39\n- email: spablo@gmail.com\n- fromstate: NULL\n- name: Silvia Pablo\n- time: 16:32:39\n- tostate: Available\n</code>\n</pre>\n", "senID": 8}, {"text": ["I suspect that as you continue to work on this problem, you will find other variations on the format of the input text specifying how the user's state changed.", "In this case, you would just add another definition like statechange1 or statechange2, and insert it into linefmt with the others.", "I feel that pyparsing's structuring of the parser definition helps developers come back to a parser after things have changed, and easily extend their parsing program."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "statechange1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "statechange2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "linefmt", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Well, if i were to approach this problem, probably I'd start by splitting each entry into its own, separate string.", "This looks like it might be line oriented, so a inputfile.split('\\n') is probably adequate.", "From there I would probably craft a regular expression to match each of the possible status changes, with subgroups wrapping each of the important fields.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "inputfile.split('\\n')", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["EDIT NOTE: Marcelo and Tim gave you a pretty good answer for what you want to do. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's documentation for the regular expression library, included in Python, which may help you expand the code further:\nhttp://docs.python.org/library/re.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/re.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}]}], [{"text": ["thanks very much for all your comments.", "They were very useful.", "I wrote my code using the directory functionality.", "What it does is it reads through the file and creates an output file for each of the user with all his status updates.", "Here is the code pasted below. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #Script to extract info from individual data files and print out a data file combining info from these files\n\nimport os\nimport commands\n\ndataFileDir=\"data/\";\n\n#Dictionary linking names to email ids\n#For the time being, assume no 2 people have the same name\nusrName2Id={};\n\n#User id  to user name mapping to check for duplicate names\nusrId2Name={};\n\n#Store info: key: user ids and values a dictionary with time stamp keys and status messages values\ninfoDict={};\n\n#Given an array of space tokenized inputs, extract user name\ndef getUserName(info,mailInd):\n\n    userName=\"\";\n    for i in range(mailInd-1,0,-1):\n\n        if info[i].endswith(\"-\") or info[i].endswith(\"+\"):\n            break;\n\n        userName=info[i]+\" \"+userName;\n\n    userName=userName.strip();\n    userName=userName.replace(\"  \",\" \");\n    userName=userName.replace(\" \",\"_\");\n\n    return userName;\n\n#Given an array of space tokenized inputs, extract time stamp\ndef getTimeStamp(info,timeStartInd):\n    timeStamp=\"\";\n    for i in range(timeStartInd+1,len(info)):\n        timeStamp=timeStamp+\" \"+info[i];\n\n    timeStamp=timeStamp.replace(\"-\",\"\");\n    timeStamp=timeStamp.strip();\n    return timeStamp;\n\n#Given an array of space tokenized inputs, extract status message\ndef getStatusMsg(info,startInd,endInd):\n    msg=\"\";\n    for i in range(startInd,endInd):\n        msg=msg+\" \"+info[i];\n    msg=msg.strip();\n    msg=msg.replace(\" \",\"_\");\n    return msg;\n\n#Extract and store info from each line in the datafile\ndef extractLineInfo(line):\n\n    print line;\n    info=line.split(\" \");\n\n    mailInd=-1;userId=\"-NONE-\";\n    timeStartInd=-1;timeStamp=\"-NONE-\";\n    becameInd=\"-1\";\n    statusMsg=\"-NONE-\";\n\n    #Find indices of email id and \"@\" char indicating start of timestamp\n    for i in range(0,len(info)):\n        #print (str(i)+\" \"+info[i]);\n        if(info[i].startswith(\"(\") and info[i].endswith(\"@in.ibm.com)\")):\n            mailInd=i;\n        if(info[i]==\"@\"):\n            timeStartInd=i;\n\n        if(info[i]==\"became\"):\n            becameInd=i;\n\n    #Debug print of mail and time stamp start inds\n    \"\"\"print \"\\n\";\n    print \"Index of mail id: \"+str(mailInd);\n    print \"Index of time start index: \"+str(timeStartInd);\n    print \"\\n\";\"\"\"\n\n    #Extract IBM user id and name for lines with ibm id\n    if(mailInd&gt;=0):\n        userId=info[mailInd].replace(\"(\",\"\");\n        userId=userId.replace(\")\",\"\");\n        userName=getUserName(info,mailInd);\n    #Lines with no ibm id are of the form \"Suraj Godar Mr became idle @ 15/07/2010 16:30:18\"\n    elif(becameInd&gt;0):\n        userName=getUserName(info,becameInd);\n\n    #Time stamp info\n    if(timeStartInd&gt;=0):\n        timeStamp=getTimeStamp(info,timeStartInd);\n        if(mailInd&gt;=0):\n            statusMsg=getStatusMsg(info,mailInd+1,timeStartInd);\n        elif(becameInd&gt;0):\n            statusMsg=getStatusMsg(info,becameInd,timeStartInd);\n\n    print userId;\n    print userName;\n    print timeStamp\n    print statusMsg+\"\\n\";\n\n    if not(userName in usrName2Id) and not(userName==\"-NONE-\") and not(userId==\"-NONE-\"):\n        usrName2Id[userName]=userId;\n\n    #Store status messages keyed by user email ids\n    timeDict={};\n\n    #Retrieve user id corresponding to user name\n    if userName in usrName2Id:\n        userId=usrName2Id[userName];\n\n    #For valid user ids, store status message in the dict within dict data str arrangement\n    if not(userId==\"-NONE-\"):\n\n        if not(userId in infoDict.keys()):\n            infoDict[userId]={};\n\n        timeDict=infoDict[userId];\n        if not(timeStamp in timeDict.keys()):\n            timeDict[timeStamp]=statusMsg;\n        else:\n            timeDict[timeStamp]=timeDict[timeStamp]+\" \"+statusMsg;\n\n\n#Print for each user a file containing status\ndef printStatusFiles(dataFileDir):\n\n\n    volNum=0;\n\n    for userName in usrName2Id:\n        volNum=volNum+1;\n\n        filename=dataFileDir+\"/\"+\"status-\"+str(volNum)+\".txt\";\n        file = open(filename,\"w\");\n\n        print \"Printing output file name: \"+filename;\n        print volNum,userName,usrName2Id[userName]+\"\\n\";\n        file.write(userName+\" \"+usrName2Id[userName]+\"\\n\");\n\n        timeDict=infoDict[usrName2Id[userName]];\n        for time in sorted(timeDict.keys()):\n            file.write(time+\" \"+timeDict[time]+\"\\n\");\n\n\n#Read and store data from individual data files\ndef readDataFiles(dataFileDir):\n\n    #Process each datafile\n    files=os.listdir(dataFileDir)\n    files.sort();\n    for i in range(0,len(files)):\n    #for i in range(0,1):\n\n        file=files[i];\n\n        #Do not process other non-data files lying around in that dir\n        if not file.endswith(\".txt\"):\n            continue\n\n        print \"Processing data file: \"+file\n        dataFile=dataFileDir+str(file);\n        inpFile=open(dataFile,\"r\");\n        lines=inpFile.readlines();\n\n        #Process lines\n        for line in lines:\n\n            #Clean lines\n            line=line.strip();\n            line=line.replace(\"/India/Contr/IBM\",\"\");\n            line=line.strip();\n\n            #Skip header line of the file and L's sign in sign out times\n            if(line.startswith(\"System log for account\") or line.find(\"signed\")&gt;-1):\n                continue;\n\n\n            extractLineInfo(line);\n\n\nprint \"\\n\";\nreadDataFiles(dataFileDir);\nprint \"\\n\";\nprintStatusFiles(\"out/\");\n</code>\n</pre>\n", "senID": 1}]]