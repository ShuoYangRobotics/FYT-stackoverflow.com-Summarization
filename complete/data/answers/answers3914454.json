[[{"text": ["Use a generator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def blocks( iterable ):\n    accumulator= []\n    for line in iterable:\n        if start_pattern( line ):\n            if accumulator:\n                yield accumulator\n                accumulator= []\n        # elif other significant patterns\n        else:\n            accumulator.append( line )\n     if accumulator:\n         yield accumulator\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import re\nresult = re.findall(\n    r\"\"\"(?mx)           # multiline, verbose regex\n    ^ID:.*\\s*           # Match ID: and anything else on that line \n    Name:\\s*(.*)\\s*     # Match name, capture all characters on this line\n    FamilyN:\\s*(.*)\\s*  # etc. for family name\n    Age:\\s*(.*)$        # and age\"\"\", \n    subject)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Result will then be"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [('X', 'Y', '20'), ('H', 'F', '23'), ('S', 'Y', '13'), ('M', 'Z', '25')]\n</code>\n</pre>\n", "senID": 2}, {"text": ["which can be trivially changed into whatever string representation you want."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["import itertools"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Assuming input in file input.txt\ndata = open('input.txt').readlines()\n\nrecords = (lines for valid, lines in itertools.groupby(data, lambda l : l != '\\n') if valid)    \noutput = [tuple(field.split(':')[1].strip() for field in itertools.islice(record, 1, None)) for record in records]\n\n# You can change output to generator by    \noutput = (tuple(field.split(':')[1].strip() for field in itertools.islice(record, 1, None)) for record in records)\n\n# output = [('X', 'Y', '20'), ('H', 'F', '23'), ('S', 'Y', '13'), ('M', 'Z', '25')]    \n#You can iterate and change the order of elements in the way you want    \n# [(elem[1], elem[0], elem[2]) for elem in output] as required in your output\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's another way, using itertools.groupby.", "The function groupy iterates through lines of the file and calls isa_group_separator(line) for each line.", "isa_group_separator returns either True or False (called the key), and itertools.groupby then groups all the consecutive lines that yielded the same True or False result."], "childNum": 7, "tag": "p", "senID": 0, "childList": [{"text": "itertools.groupby", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.groupby"}, {"text": "groupy", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "isa_group_separator(line)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "line", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "isa_group_separator", "childNum": 0, "tag": "code", "childList": []}, {"text": "key", "childNum": 0, "tag": "code", "childList": []}, {"text": "itertools.groupby", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This is a very convenient way to collect lines into groups."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef isa_group_separator(line):\n    return line=='\\n'\n\nwith open('data_file') as f:\n    for key,group in itertools.groupby(f,isa_group_separator):\n        # print(key,list(group))  # uncomment to see what itertools.groupby does.\n        if not key:\n            data={}\n            for item in group:\n                field,value=item.split(':')\n                value=value.strip()\n                data[field]=value\n            print('{FamilyN} {Name} {Age}'.format(**data))\n\n# Y X 20\n# F H 23\n# Y S 13\n# Z M 25\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If file is not huge you can read whole file with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n content = f.open(filename).read()\n</code>\n</pre>\n", "senID": 1}, {"text": ["then you can split content to blocks using:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "content", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n blocks = content.split('\\n\\n')\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now you can create function to parse block of text.", "I would use split('\\n') to get lines from block and split(':') to get key and value, eventually with str.strip() or some help of regular expressions."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "split('\\n')", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "split(':')", "childNum": 0, "tag": "code", "childList": []}, {"text": "str.strip()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Without checking if block has required data code can look like:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n f = open('data.txt', 'r')\ncontent = f.read()\nf.close()\nfor block in content.split('\\n\\n'):\n    person = {}\n    for l in block.split('\\n'):\n        k, v = l.split(': ')\n        person[k] = v\n    print('%s %s %s' % (person['FamilyN'], person['Name'], person['Age']))\n</code>\n</pre>\n", "senID": 6}], [{"text": ["If your file is too large to read into memory all at once, you can still use a regular expressions based solution by using a memory mapped file, with the mmap module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mmap module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/mmap.html"}]}, {"code": "<pre>\n<code>\n import sys\nimport re\nimport os\nimport mmap\n\nblock_expr = re.compile('ID:.*?\\nAge: \\d+', re.DOTALL)\n\nfilepath = sys.argv[1]\nfp = open(filepath)\ncontents = mmap.mmap(fp.fileno(), os.stat(filepath).st_size, access=mmap.ACCESS_READ)\n\nfor block_match in block_expr.finditer(contents):\n    print block_match.group()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The mmap trick will provide a \"pretend string\" to make regular expressions work on the file without having to read it all into one large string.", "And the find_iter() method of the regular expression object will yield matches without creating an entire list of all matches at once (which findall() does)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "find_iter()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "findall()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I do think this solution is overkill for this use case however (still: it's a nice trick to know...)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Use a dict, namedtuple, or custom class to store each attribute as you come across it, then append the object to a list when you reach a blank line or EOF."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["simple solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = []\nfor record in content.split('\\n\\n'):\n    try:\n        id, name, familyn, age = map(lambda rec: rec.split(' ', 1)[1], record.split('\\n'))\n    except ValueError:\n        pass\n    except IndexError:\n        pass\n    else:\n        result.append((familyn, name, age))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Along with the half-dozen other solutions I already see here, I'm a bit surprised that no one has been so simple-minded (that is, generator-, regex-, map-, and read-free) as to propose, for example, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fp = open(fn)\ndef get_one_value():\n    line = fp.readline()\n    if not line:\n        return None\n    parts = line.split(':')\n    if 2 != len(parts):\n        return ''\n    return parts[1].strip()\n\n# The result is supposed to be a list.\nresult = []\nwhile 1:\n        # We don't care about the ID.\n   if get_one_value() is None:\n       break\n   name = get_one_value()\n   familyn = get_one_value()\n   age = get_one_value()\n   result.append((name, familyn, age))\n       # We don't care about the block separator.\n   if get_one_value() is None:\n       break\n\nfor item in result:\n    print item\n</code>\n</pre>\n", "senID": 1}, {"text": ["Re-format to taste."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This answer isn't necessarily better than what's already been posted, but as an illustration of how I approach problems like this it might be useful, especially if you're not used to working with Python's interactive interpreter.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've started out knowing two things about this problem.", "First, I'm going to use itertools.groupby to group the input into lists of data lines, one list for each individual data record.", "Second, I want to represent those records as dictionaries so that I can easily format the output."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "itertools.groupby", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["One other thing that this shows is how using generators makes breaking a problem like this down into small parts easy."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; # first let's create some useful test data and put it into something \n&gt;&gt;&gt; # we can easily iterate over:\n&gt;&gt;&gt; data = \"\"\"ID: 1\nName: X\nFamilyN: Y\nAge: 20\n\nID: 2\nName: H\nFamilyN: F\nAge: 23\n\nID: 3\nName: S\nFamilyN: Y\nAge: 13\"\"\"\n&gt;&gt;&gt; data = data.split(\"\\n\")\n&gt;&gt;&gt; # now we need a key function for itertools.groupby.\n&gt;&gt;&gt; # the key we'll be grouping by is, essentially, whether or not\n&gt;&gt;&gt; # the line is empty.\n&gt;&gt;&gt; # this will make groupby return groups whose key is True if we\n&gt;&gt;&gt; care about them.\n&gt;&gt;&gt; def is_data(line):\n        return True if line.strip() else False\n\n&gt;&gt;&gt; # make sure this really works\n&gt;&gt;&gt; \"\\n\".join([line for line in data if is_data(line)])\n'ID: 1\\nName: X\\nFamilyN: Y\\nAge: 20\\nID: 2\\nName: H\\nFamilyN: F\\nAge: 23\\nID: 3\\nName: S\\nFamilyN: Y\\nAge: 13\\nID: 4\\nName: M\\nFamilyN: Z\\nAge: 25'\n\n&gt;&gt;&gt; # does groupby return what we expect?\n&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; [list(value) for (key, value) in itertools.groupby(data, is_data) if key]\n[['ID: 1', 'Name: X', 'FamilyN: Y', 'Age: 20'], ['ID: 2', 'Name: H', 'FamilyN: F', 'Age: 23'], ['ID: 3', 'Name: S', 'FamilyN: Y', 'Age: 13'], ['ID: 4', 'Name: M', 'FamilyN: Z', 'Age: 25']]\n&gt;&gt;&gt; # what we really want is for each item in the group to be a tuple\n&gt;&gt;&gt; # that's a key/value pair, so that we can easily create a dictionary\n&gt;&gt;&gt; # from each item.\n&gt;&gt;&gt; def make_key_value_pair(item):\n        items = item.split(\":\")\n        return (items[0].strip(), items[1].strip())\n\n&gt;&gt;&gt; make_key_value_pair(\"a: b\")\n('a', 'b')\n&gt;&gt;&gt; # let's test this:\n&gt;&gt;&gt; dict(make_key_value_pair(item) for item in [\"a:1\", \"b:2\", \"c:3\"])\n{'a': '1', 'c': '3', 'b': '2'}\n&gt;&gt;&gt; # we could conceivably do all this in one line of code, but this \n&gt;&gt;&gt; # will be much more readable as a function:\n&gt;&gt;&gt; def get_data_as_dicts(data):\n        for (key, value) in itertools.groupby(data, is_data):\n            if key:\n                yield dict(make_key_value_pair(item) for item in value)\n\n&gt;&gt;&gt; list(get_data_as_dicts(data))\n[{'FamilyN': 'Y', 'Age': '20', 'ID': '1', 'Name': 'X'}, {'FamilyN': 'F', 'Age': '23', 'ID': '2', 'Name': 'H'}, {'FamilyN': 'Y', 'Age': '13', 'ID': '3', 'Name': 'S'}, {'FamilyN': 'Z', 'Age': '25', 'ID': '4', 'Name': 'M'}]\n&gt;&gt;&gt; # now for an old trick:  using a list of column names to drive the output.\n&gt;&gt;&gt; columns = [\"Name\", \"FamilyN\", \"Age\"]\n&gt;&gt;&gt; print \"\\n\".join(\" \".join(d[c] for c in columns) for d in get_data_as_dicts(data))\nX Y 20\nH F 23\nS Y 13\nM Z 25\n&gt;&gt;&gt; # okay, let's package this all into one function that takes a filename\n&gt;&gt;&gt; def get_formatted_data(filename):\n        with open(filename, \"r\") as f:\n            columns = [\"Name\", \"FamilyN\", \"Age\"]\n            for d in get_data_as_dicts(f):\n                yield \" \".join(d[c] for c in columns)\n\n&gt;&gt;&gt; print \"\\n\".join(get_formatted_data(\"c:\\\\temp\\\\test_data.txt\"))\nX Y 20\nH F 23\nS Y 13\nM Z 25\n</code>\n</pre>\n", "senID": 3}]]