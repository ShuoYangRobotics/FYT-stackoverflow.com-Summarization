[[{"text": ["General idea"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Load both images as arrays (scipy.misc.imread) and calculate an element-wise difference.", "Calculate the norm of the difference."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "scipy.misc.imread", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["However, there are some decisions to make."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Questions"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["You should answer these questions first:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 7, "lis": [{"text": ["Are images of the same shape and dimension?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Are images well-aligned?"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Is exposure of the images always the same?", "(Is lightness/contrast the same?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Is color information important?"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Are there distinct edges in the image?", "Are they likely to move?"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Is there noise in the image?"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["What kind of changes do you want to notice?"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}]}, {"text": ["Example"], "childNum": 0, "tag": "h2", "senID": 12, "childList": []}, {"text": ["I assume your images are well-aligned, the same size and shape, possibly with different exposure.", "For simplicity, I convert them to grayscale even if they are color (RGB) images."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["You will need these imports:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\nfrom scipy.misc import imread\nfrom scipy.linalg import norm\nfrom scipy import sum, average\n</code>\n</pre>\n", "senID": 15}, {"text": ["Main function, read two images, convert to grayscale, compare and print results:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n def main():\n    file1, file2 = sys.argv[1:1+2]\n    # read images as 2D arrays (convert to grayscale for simplicity)\n    img1 = to_grayscale(imread(file1).astype(float))\n    img2 = to_grayscale(imread(file2).astype(float))\n    # compare\n    n_m, n_0 = compare_images(img1, img2)\n    print \"Manhattan norm:\", n_m, \"/ per pixel:\", n_m/img1.size\n    print \"Zero norm:\", n_0, \"/ per pixel:\", n_0*1.0/img1.size\n</code>\n</pre>\n", "senID": 17}, {"text": ["How to compare.", "img1 and img2 are 2D SciPy arrays here:"], "childNum": 2, "tag": "p", "senID": 18, "childList": [{"text": "img1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "img2", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def compare_images(img1, img2):\n    # normalize to compensate for exposure difference, this may be unnecessary\n    # consider disabling it\n    img1 = normalize(img1)\n    img2 = normalize(img2)\n    # calculate the difference and its norms\n    diff = img1 - img2  # elementwise for scipy arrays\n    m_norm = sum(abs(diff))  # Manhattan norm\n    z_norm = norm(diff.ravel(), 0)  # Zero norm\n    return (m_norm, z_norm)\n</code>\n</pre>\n", "senID": 19}, {"text": ["If the file is a color image, imread returns a 3D array, average RGB channels (the last array axis) to obtain intensity.", "No need to do it for grayscale images (e.g.", ".pgm):"], "childNum": 2, "tag": "p", "senID": 20, "childList": [{"text": "imread", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".pgm", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def to_grayscale(arr):\n    \"If arr is a color image (3D array), convert it to grayscale (2D array).\"\n    if len(arr.shape) == 3:\n        return average(arr, -1)  # average over the last axis (color channels)\n    else:\n        return arr\n</code>\n</pre>\n", "senID": 21}, {"text": ["Normalization is trivial, you may choose to normalize to [0,1] instead of [0,255].", "arr is a SciPy array here, so all operations are element-wise:"], "childNum": 1, "tag": "p", "senID": 22, "childList": [{"text": "arr", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def normalize(arr):\n    rng = arr.max()-arr.min()\n    amin = arr.min()\n    return (arr-amin)*255/rng\n</code>\n</pre>\n", "senID": 23}, {"text": ["Run the main function:"], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "main", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 25}, {"text": ["Now you can put this all in a script and run against two images.", "If we compare image to itself, there is no difference:"], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"code": "<pre>\n<code>\n $ python compare.py one.jpg one.jpg\nManhattan norm: 0.0 / per pixel: 0.0\nZero norm: 0 / per pixel: 0.0\n</code>\n</pre>\n", "senID": 27}, {"text": ["If we blur the image and compare to the original, there is some difference:"], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"code": "<pre>\n<code>\n $ python compare.py one.jpg one-blurred.jpg \nManhattan norm: 92605183.67 / per pixel: 13.4210411116\nZero norm: 6900000 / per pixel: 1.0\n</code>\n</pre>\n", "senID": 29}, {"text": ["P.S.", "Entire compare.py script."], "childNum": 1, "tag": "p", "senID": 30, "childList": [{"text": "compare.py", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://gist.github.com/626356"}]}], [{"text": ["You can compare two images using functions from PIL. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PIL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pythonware.com/products/pil/"}]}, {"code": "<pre>\n<code>\n import Image\nimport ImageChops\n\nim1 = Image.open(\"splash.png\")\nim2 = Image.open(\"splash2.png\")\n\ndiff = ImageChops.difference(im2, im1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The diff object is an image in which every pixel is the result of the subtraction of the color values of that pixel in the second image from the first image.", "Using the diff image you can do several things.", "The simplest one is the diff.getbbox() function.", "It will tell you the minimal rectangle that contains all the changes between your two images."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "diff.getbbox()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["You can probably implement approximations of the other stuff mentioned here using functions from PIL as well."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["A simple solution:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "A simple solution:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Encode the image as a jpeg and look for a substantial change in filesize."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "jpeg", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "filesize", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["I've implemented something similar with video thumbnails, and had a lot of success and scalability."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Two popular and relatively simple methods are: (a) the Euclidean distance already suggested, or (b) normalized cross-correlation.", "Normalized cross-correlation tends to be noticeably more robust to lighting changes than simple cross-correlation.", "Wikipedia gives a formula for the normalized cross-correlation.", "More sophisticated methods exist too, but they require quite a bit more work."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "normalized cross-correlation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Cross-correlation#Normalized_cross-correlation"}]}, {"text": ["Using numpy-like syntax,"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\ndist_euclidean = sqrt(sum((i1 - i2)^2)) / i1.size\n\ndist_manhattan = sum(abs(i1 - i2)) / i1.size\n\ndist_ncc = sum( (i1 - mean(i1)) * (i2 - mean(i2)) ) / (\n  (i1.size - 1) * stdev(i1) * stdev(i2) )\n</pre>\n", "senID": 2}, {"text": ["assuming that i1 and i2 are 2D grayscale image arrays.  "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "i1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i2", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["A trivial thing to try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Resample both images to small thumbnails (e.g.", "64 x 64) and compare the thumbnails pixel-by-pixel with a certain threshold.", "If the original images are almost the same, the resampled thumbnails will be very similar or even exactly the same.", "This method takes care of noise that can occur especially in low-light scenes.", "It may even be better if you go grayscale."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Most of the answers given won't deal with lighting levels."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would first normalize the image to a standard light level before doing the comparison."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I am addressing specifically the question of how to compute if they are \"different enough\".", "I assume you can figure out how to subtract the pixels one by one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, I would take a bunch of images with nothing changing, and find out the maximum amount that any pixel changes just because of variations in the capture, noise in the imaging system, JPEG compression artifacts, and moment-to-moment changes in lighting.", "Perhaps you'll find that 1 or 2 bit differences are to be expected even when nothing moves."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "nothing", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Then for the \"real\" test, you want a criterion like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "same if up to P pixels differ by no more than E.", "tag": "none", "senID": 3}]}, {"text": ["So, perhaps, if E = 0.02, P = 1000, that would mean (approximately) that it would be \"different\" if any single pixel changes by more than ~5 units (assuming 8-bit images), or if more than 1000 pixels had any errors at all."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["This is intended mainly as a good \"triage\" technique to quickly identify images that are close enough to not need further examination.", "The images that \"fail\" may then more to a more elaborate/expensive technique that wouldn't have false positives if the camera shook bit, for example, or was more robust to lighting changes."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I run an open source project, OpenImageIO, that contains a utility called \"idiff\" that compares differences with thresholds like this (even more elaborate, actually).", "Even if you don't want to use this software, you may want to look at the source to see how we did it.", "It's used commercially quite a bit and this thresholding technique was developed so that we could have a test suite for rendering and image processing software, with \"reference images\" that might have small differences from platform-to-platform or as we made minor tweaks to tha algorithms, so we wanted a \"match within tolerance\" operation."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "OpenImageIO", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.openimageio.org"}]}], [{"text": ["Have you seen the Algorithm for finding similar images question?", "Check it out to see suggestions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Algorithm for finding similar images", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/75891/algorithm-for-finding-similar-images"}]}, {"text": ["I would suggest a wavelet transformation of your frames (I've written a C extension for that using Haar transformation); then, comparing the indexes of the largest (proportionally) wavelet factors between the two pictures, you should get a numerical similarity approximation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I was reading about this on Processing.org recently and found it stashed in my favorites.", "Maybe it helps you..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://processing.org/discourse/yabb_beta/YaBB.cgi?board=Video;action=display;num=1159141301"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://processing.org/discourse/yabb_beta/YaBB.cgi?board=Video;action=display;num=1159141301", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://processing.org/discourse/yabb_beta/YaBB.cgi?board=Video;action=display;num=1159141301"}]}], [{"text": ["I think you could simply compute the euclidean distance (i.e.", "sqrt(sum of squares of differences, pixel by pixel)) between the luminance of the two images, and consider them equal if this falls under some empirical threshold.", "And you would better do it wrapping a C function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Earth movers distance might be exactly what you need.", "It might be abit heavy to implement in real time though."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Earth movers distance", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.ca/search?hl=en&safe=off&client=firefox-a&rls=org.mozilla:en-US:official&hs=HD8&pwst=1&sa=X&oi=spell&resnum=0&ct=result&cd=1&q=earth+mover%27s+distance+image&spell=1"}, {"text": "abit", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["What about calculating the Manhattan Distance of the two images.", "That gives you n*n values.", "Then you could do something like an row average to reduce to n values and a function over that to get one single value."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Manhattan Distance", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Manhattan_distance"}]}], [{"text": ["I have been having a lot of luck with jpg images taken with the same camera on a tripod by\n(1) simplifying greatly (like going from 3000 pixels wide to 100 pixels wide or even fewer)\n(2) flattening each jpg array into a single vector\n(3) pairwise correlating sequential images with a simple correlate algorithm to get correlation coefficient\n(4) squaring correlation coefficient to get r-square (i.e fraction of variability in one image explained by variation in the next)\n(5) generally in my application if r-square &lt; 0.9, I say the two images are different and something happened in between."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is robust and fast in my implementation (Mathematica 7)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It's worth playing around with the part of the image you are interested in and focussing on that by cropping all images to that little area, otherwise a distant-from-the-camera but important change will be missed. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I don't know how to use Python, but am sure it does correlations, too, no?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["you can compute the histogram of both the images and then calculate the Bhattacharyya Coefficient, this is a very fast algorithm and I have used it to detect shot changes in a cricket video (in C using openCV)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Bhattacharyya Coefficient", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Bhattacharyya_distance#Bhattacharyya_coefficient"}]}], [{"text": ["Check out how Haar Wavelets are implemented by isk-daemon.", "You could use it's imgdb C++ code to calculate the difference between images on-the-fly:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "isk-daemon", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://server.imgseek.net/"}]}]]