[[{"text": ["You want the maximum sum contiguous sequence, but inverted.", "This page has the best explanation of it I have seen."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This page", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://wordaligned.org/articles/the-maximum-subsequence-problem"}]}, {"text": ["The basic algorithm will look like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def min_sum_subsequence(seq):\n...     minsofar = 0\n...     minendinghere = 0\n...     for s in seq:\n...         # invariant: maxendinghere and maxsofar are accurate\n...         # are accurate up to s\n...         minendinghere = min(minendinghere + s, 0)\n...         minsofar = min(minsofar, minendinghere)\n...     return minsofar\n... \n&gt;&gt;&gt; series = [300,301,303,299,300,298,301,305]\n&gt;&gt;&gt; returns = [series[i] - series[i-1] for i in range(1, len(series))]\n&gt;&gt;&gt; min_sum_subsequence(returns)\n-5\n</code>\n</pre>\n", "senID": 2}, {"text": ["You have to add code to keep track of the index of the start and finish."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Its always best to print all the values and check out the results."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The problem with your code is when you write p[i]> p[high] you update the value of newhigh but the value of high is not changing."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Just write it as p[i] > p[newhigh] and check out if its giving the correct results.", "I have'nt checked if it will give the correct output.", "Do that on your own."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Though you can always use the shortened versions mentioned above."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python allows for much shorter code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = [300,301,303,299,300,298,301,305]\n\nmax([(l[i] - l[j], i, j) for i in range(len(l)) for j in range(i, len(l))], key=lambda x:x[0])\n\n(5, 2, 5)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This can maybe be shortened, but it's a good starting point.", "Also, as others said, please use [homework] tag if appropriate.", "Edit: this answers (drop, begin, end)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Having copy-pasted your code and indented it, you're nearly there.", "Where you test:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if p[i] &gt;= p[high]:\n</code>\n</pre>\n", "senID": 1}, {"text": ["You're not considering that p[i] might be >= p[high], but less than p[newhigh]."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You are asking for the largest non-monotonically decreasing sequence.", "There is a similar question for monotonically in this question.", "Lots of ways to approach this problem.", "Here is a recursive approach."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this question", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2310043/find-the-length-of-the-largest-increasing-sequence"}]}, {"code": "<pre>\n<code>\n def biggest_drop(sequence):\n    seq_min, seq_max = min(sequence), max(sequence)\n    imin, imax = sequence.index(seq_min), sequence.index(seq_max)\n    if imin == imax:\n        return None\n    if imin &lt; imax:\n        # split the sequence and look for local drops\n        drop_a = biggest_drop(sequence[:imax])\n        drop_b = biggest_drop(sequence[imax:])\n        if drop_a is None or drop_b is None:\n            if drop_a:\n                return drop_a\n            return drop_b\n        value_a = drop_a[0] - drop_a[-1] \n        value_b = drop_b[0] - drop_b[-1]\n        if value_a &gt; value_b:\n            return drop_a\n        else:\n            return drop_b\n    return sequence[imax:imin+1]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is my solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n start_=stop_=None\nmin_=0\nfor start in range(len(li)-1):\n    for stop in range(start+1, len(li)):\n        tmp= li[stop]-li[start]\n        if tmp&lt;min_:\n            min_=tmp\n            start_=start\n            stop_=stop\nprint min_\nprint (start_, stop_)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It works for your sample."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's my try at it.", "It works correctly on all the examples that you gave. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I basically just go through the array and when there is a drop between two points, referring to the first point as A, look ahead until there is a value that is higher than A. I keep track of the minimum in this region.", "If the difference between A and the minimum is a bigger drop than what I've already found, I hold onto it.", "I then start looking again for a drop between two points, starting at the next point that was higher than A. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's the code.", "It isn't very Python-esque, but it works pretty well (I'd just go to Cython if I needed it to be faster).", "Also, it returns the magnitude of the drop."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def maxdrop(p):\n    bestdrop = 0\n    wheredrop = -1,-1\n    i = 0\n    while i &lt; len(p) - 1:\n        if p[i+1] &lt; p[i]:\n            bestlocal = p[i+1]\n            wherelocal = i+1\n            j = i + 1\n            while j &lt; len(p) - 1 and p[j + 1] &lt; p[i]:\n                j += 1\n                if p[j] &lt; bestlocal:\n                    bestlocal = p[j]\n                    wherelocal = j\n            if p[i] - bestlocal &gt; bestdrop:\n                bestdrop = p[i] - bestlocal\n                wheredrop = i, wherelocal\n            i = j+1\n        else:\n            i += 1\n    return bestdrop,wheredrop\n</code>\n</pre>\n", "senID": 3}, {"text": ["A big problem with your code is that you only look at the next value for the biggest drop after a new high value is found."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["There's a faster way to compute mins than this example, but this is concise and readable:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mins", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; data = [300, 301, 303, 299, 300, 298, 301, 305]\n&gt;&gt;&gt; mins = [min(data[i:]) for (i, _) in enumerate(data)]\n&gt;&gt;&gt; mins\n[298, 298, 298, 298, 298, 298, 301, 305]\n&gt;&gt;&gt; drops = [ d - m for (d, m) in zip(data, mins)]\n&gt;&gt;&gt; drops\n[2, 3, 5, 1, 2, 0, 0, 0]\n&gt;&gt;&gt; [ (i, data[i] - drop) for (i, drop) in enumerate(drops) if drop == max(drops) ]\n[(2, 298)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Knowing that the start of the period is 2 and the low point is 298, the end of the period is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [ i for (i, x) in enumerate(data) if i &gt; 2 and x == 298]\n[5]\n</code>\n</pre>\n", "senID": 3}]]