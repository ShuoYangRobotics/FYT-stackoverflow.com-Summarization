[[{"text": ["Do you need to use regex?", "I don't think you do, you can't parse SGML with regular expressions because SGML itself is not regular, see this famous stackoverflow answer for the reasoning: http://stackoverflow.com/a/1732454/88123"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/a/1732454/88123", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/a/1732454/88123"}]}, {"text": ["Anyhow.", "You should use the lxml Python module and its xpath implementation.", "xpath supports selecting with text that starts with."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "lxml", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "xpath", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["XPath in this case would be //h1/text()."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "//h1/text()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Or, use the BeautifulSoup Python module."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "BeautifulSoup", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Don't try to use regular expressions to parse HTML or XML.", "Use a parser such as lxml."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "lxml", "tag": "a", "pos": 1, "childList": [{"text": "lxml", "tag": "code"}], "childNum": 1, "href": "http://lxml.de"}, {"text": "lxml", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n import lxml.html as lh\n\ntree = lh.fromstring(html)\n\nprint tree.xpath(\"//pre/a[starts-with(., 'CVE')]/text()\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["Result:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Result:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n['CVE-2010-3718']\n</pre>\n", "senID": 3}], [{"text": ["Use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n re.compile('\"&gt;(CVE.*?)&lt;/a&gt;') \n\n# instead of your re.compile('\\&gt;\"(CVE.*)\"\\&lt;\\/a&gt;')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that characters &lt; > / don't need to be escaped in a regex pattern"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["And note that the ?", "character after .", "* stops the greedy behavior of the quantifier * in order that the match stops when the first &lt;/a&gt; is encoutered.", "See the docs on this point, it is fundamental"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "?", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "&lt;/a&gt;", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Sometimes there are problems when using re to analyze a XML|GML text\nOnce, I was told that one possible problem is that a tag can be written on several lines,  for example:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"code": "<pre>\n<code>\n ss = '''\n&lt;pre&gt;\n    &lt;a href=\"https://www.redhat.com/security/data/cve/CVE-2010-3718.html\"&gt;CVE-20\n    10-371\n    8&lt;/a&gt;\n&lt;/pre&gt;'''\n</code>\n</pre>\n", "senID": 6}, {"text": ["In this case, there won't be any match because the dot used as symbol in a regex's pattern doesnt symbolize the newline '\\n'.", "So the portion .*?", "of the pattern won't allow to run from line to line."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": ".*?", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["To correct this problem, use the re.DOTALL specification that gives to the dot symbol the power to represent any and all characters."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "re.DOTALL", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Note that the common conviction is that the re tool must not be used to parse a SGML or XML text.", "But few people are able to explain thoroughly why.", "And I am one of these people who don't know precisely why."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "re", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["But personally, I think that regular expression can be used to analyze texts indeed.", "I write 'ANALYZE' not 'PARSE'."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["As far as I understood, parsing is the process of analyzing a text AND building a tree representation of it based on the tags.", "While I define analyzing a text as ... analyzing it without the aim to obtain a tree representation.", "When a tree representation isn't necessary to extract data from a text, use regular expressions, and don't listen guys that have religious considerations on the subject like in the funny but deceiving (in my opinion) post whose link has been given"], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["If you still want to use regexps for HTML parsing (while it's not recommended as was alredy mentioned - but I don't know why) try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = re.compile('&lt;a href=\".*\"&gt;(.*)&lt;/a&gt;')\nresult = a.match(string).group(0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["the result will contain CVE-2010-3718"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As others have already suggested, regular expressions are often not a good tool for HTML parsing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But if you want to use regexp, this is an example of how i would extract all tuples of both URLs and content between the &lt;a&gt; &lt;/a&gt; tags:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "&lt;a&gt; &lt;/a&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\n#example html string with various hits\nhtml_string = \"\"\"\n    &lt;pre&gt;\n    &lt;a href=\"https://www.redhat.com/security/data/cve/CVE-2010-3718.html\"&gt;CVE-2010-3718&lt;/a&gt;\n    &lt;a href=\"https://www.redhat.com/security/data/cve/CVE-2010-3710.html\"&gt;CVE-2010-3710&lt;/a&gt;\n    &lt;a href=\"https://www.redhat.com/security/data/cve/CVE-2010-3700.html\"&gt;CVE-2010-3700&lt;/a&gt;\n    &lt;/pre&gt;\n\"\"\"\n\n#regular expression:\npattern = re.compile('&lt;a href=([^&gt;]*)&gt;([^&lt;]*)&lt;/a&gt;')\n\n#find all matches in our html string:\ntuples = pattern.findall(html_string)\n\nfor tuple in tuples:\n    print \"%s \u2014&gt; %s\" % (tuple[1], tuple[0])\n</code>\n</pre>\n", "senID": 2}, {"text": ["As others mentioned, lxml would be a more suitable tool."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you are going to do it this way, i recommend you to follow the @Acorn reply."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I am surprised no one suggested to use BeautifulSoup:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["here is how I would do it :"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from BeautifulSoup import BeautifulSoup\nimport re\n\nhello = \"\"\"\n&lt;pre&gt;\n&lt;a href=\"https://www.redhat.com/security/data/cve/CVE-2010-3718.html\"&gt;CVE-2010-3718&lt;/a&gt;\n&lt;a href=\"https://www.redhat.com/security/data/cve/CVE-2010-3710.html\"&gt;CVE-2010-3718&lt;/a&gt;\n&lt;a href=\"https://www.redhat.com/security/data/cve/CVE-2010-3700.html\"&gt;CVE-2010-3718&lt;/a&gt;\n&lt;/pre&gt;\n\"\"\"\n\ntarget = re.compile(\"CVE-\\d+-\\d+.html\")\ncommentSoup = BeautifulSoup(hello)\natags = commentSoup.findAll(href=target)\nfor a in atags:\n    match = re.findall(target, a['href'])[0]\n    print match\n</code>\n</pre>\n", "senID": 2}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n CVE-2010-3718.html\nCVE-2010-3710.html\nCVE-2010-3700.html\n</code>\n</pre>\n", "senID": 4}]]