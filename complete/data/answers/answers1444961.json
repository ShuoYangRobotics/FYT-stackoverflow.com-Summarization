[[{"text": ["C++ is notoriously hard to parse.", "Most people who try to do this properly end up taking apart a compiler.", "In fact this is (in part) why LLVM started: Apple needed a way they could parse C++ for use in XCode that matched the way the compiler parsed it. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That's why there are projects like GCC_XML which you could combine with a python xml library."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "GCC_XML", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.gccxml.org/HTML/Index.html"}]}, {"text": ["Some non-compiler projects that seem to do a pretty good job at parsing C++ are:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Eclipse CDT", "tag": "none", "senID": 3}, {"text": "OpenGrok", "tag": "none", "senID": 4}, {"text": "Doxygen", "tag": "none", "senID": 5}]}], [{"text": ["Not an answer as such, but just to demonstrate how hard parsing C++ correctly actually is.", "My favorite demo:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n template&lt;bool&gt; struct a_t;\n\ntemplate&lt;&gt; struct a_t&lt;true&gt; {\n    template&lt;int&gt; struct b {};\n};\n\ntemplate&lt;&gt; struct a_t&lt;false&gt; {\n    enum { b };\n};\n\ntypedef a_t&lt;sizeof(void*)==sizeof(int)&gt; a;\n\nenum { c, d };\nint main() {\n    a::b&lt;c&gt;d; // declaration or expression?\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is perfectly valid, standard-compliant C++, but the exact meaning of commented line depends on your implementation.", "If sizeof(void*)==sizeof(int) (typical on 32-bit platforms), it is a declaration of local variable d of type a::b&lt;c&gt;.", "If the condition doesn't hold, then it is a no-op expression ((a::b &lt; c) &gt; d).", "Adding a constructor for a::b will actually let you expose the difference via presence/absence of side effects."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "sizeof(void*)==sizeof(int)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "d", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "a::b&lt;c&gt;", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "((a::b &lt; c) &gt; d)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a::b", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["You won't find a drop-in Python library to do this.", "Parsing C++ is fiddly, and few parsers have been written that aren't part of a compiler.", "You can find a good summary of the issues here.", "The best bet might be clang, though C++ support is some time away.", "Though this is not a Python solution, it sounds as though it would be amenable to re-use within a Python wrapper, given the emphasis on encapsulation and good design in its development."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.nobugs.org/developer/parsingcpp/"}, {"text": "clang", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://clang.llvm.org/"}, {"text": "some time away", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://clang.llvm.org/cxx%5Fstatus.html"}]}], [{"text": ["If you've formatted your comments in a compatible way, Doxygen does a fantastic job.", "It'll even draw inheritance diagrams if you've got graphviz installed."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Doxygen", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.stack.nl/~dimitri/doxygen/"}, {"text": "graphviz", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.graphviz.org/"}]}, {"text": ["For example, running DOxygen over the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n /// &lt;summary&gt;\n/// A summary of my class\n/// &lt;/summary&gt;\npublic class MyClass\n{\nprotected:\n\tint m_numOfWidgets; /// Keeps track of the number of widgets stored\n\npublic:\n\t/// &lt;summary&gt;\n\t/// Constructor for the class.\n\t/// &lt;/summary&gt;\n\t/// &lt;param paramName=\"numOfWidgets\"&gt;Specifies how many widgets to start with&lt;/param&gt;\n\tBaseFitter(int numOfWidgets)\n\t{\n\t\tm_numOfWidgets = numOfWidgets;\n\t}\n\n\t/// &lt;summary&gt;\n\t/// Increments the number of widgets stored by the amount supplied.\n\t/// &lt;/summary&gt;\n\t/// &lt;param paramName=\"numOfWidgets\"&gt;Specifies how many widgets to start with&lt;/param&gt;\n\t/// &lt;returns&gt;The number of widgets stored&lt;/returns&gt;\n\tIncreaseWidgets(int numOfWidgetsToAdd)\n\t{\n\t\tm_numOfWidgets += numOfWidgets;\n\t\treturn m_numOfWidgets;\n\t}\n};\n</code>\n</pre>\n", "senID": 2}, {"text": ["Will turn all those comments into entries in .html files.", "With more complicated designs, the result is even more beneficial - often much easier than trying to browse through the source."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This page shows a C++ grammar written in Antlr, and you can generate Python code from it."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "This page", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.antlr.org/grammar/list"}, {"href": "http://www.antlr.org/wiki/display/ANTLR3/Example", "text": "can generate Python code", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["There also seems to be someone who was working on a C++ parser in pyparsing, but I was not able to find out who or its current status."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["There is no (free) good library to parse C++ in any language.", "Your best choices are probably Dehydra g++ plugin, clang, or Elsa."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "any", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"href": "https://developer.mozilla.org/en/Dehydra", "text": "Dehydra", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://clang.llvm.org/cxx%5Fstatus.html", "text": "clang", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://scottmcpeak.com/elkhound/sources/elsa/index.html", "text": "Elsa", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Pycparser is a complete and functional parser for ANSI C.\nPerhaps you can extend it to c++ :-)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Pycparser", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pycparser/"}]}], [{"text": ["For many years I've been using pygccxml, which is a very nice Python wrapper around GCC-XML.", "It's a very full featured package that forms the basis of some well used code-generation tools out there such as py++ which is from the same author."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pygccxml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://language-binding.net/pygccxml/pygccxml.html"}, {"text": "py++", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://language-binding.net/pyplusplus/pyplusplus.html"}]}], [{"text": ["The pyparsing wiki shows this example - all it does is parse struct declarations, so this might give you just a glimpse at the magnitude of the problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I suggest you (or even better, your employer) shell out $200 and buy Enterprise Architect from sparxsystems.", "This software is amazingly powerful for the price, and includes pretty good code reverse engineering features.", "You will spend far more than this in your own time to only get about 2% of the job done.", "In this case, \"buys\" wins over \"make\"."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Enterprise Architect from sparxsystems", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sparxsystems.com.au/"}]}], [{"text": ["Ctypes uses gcc-xml for code generation.", "It's possible that cpptypes does also.", "Even if it doesn't, you could use gcc-xml to generate XML from your C++ file, then parse the xml with one of the built-in or third-party Python XML parsers."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Ctypes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://starship.python.net/crew/theller/ctypes/old/codegen.html"}, {"text": "gcc-xml", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.gccxml.org/HTML/Index.html"}]}], [{"text": ["Our DMS Software Reengineering Toolkit has a full C++ parser that builds ASTs and complete symbol tables."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "DMS Software Reengineering Toolkit", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.semanticdesigns.com/Products/DMS/DMSToolkit.html"}, {"href": "http://www.semanticdesigns.com/Products/FrontEnds/CppFrontEnd.html", "text": "C++ parser", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Here's a SourceForge project that claims to parse c++ headers.", "As the other commenters have pointed out, there's no general solution, but you this sounds like it will do enough for your needs.", "(I just ran across it for a similar need and haven't tried it myself yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://sourceforge.net/projects/cppheaderparser/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://sourceforge.net/projects/cppheaderparser/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/cppheaderparser/"}]}], [{"text": ["The Clang project provides libraries for just parsing C++ code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Either with Clang and GCC you can generate an XML representation of the code"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you prefer a more Pythonian solution you could also search for a C++ yacc grammar and use py-ply (Yacc for Python), but that seems the solution that needs more work"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'm adding this as a separate answer since this is a new piece of information:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's an article on using the Python bindings of Clang to parse C++."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "using the Python bindings of Clang to parse C++", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang/"}]}]]