[[{"text": ["If you are free / willing to change your definition of error, you might want to consider using the variance instead of (max-min)/min. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "error", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "variance", "childNum": 0, "tag": "code", "childList": []}, {"text": "(max-min)/min", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can compute the variance incrementally.", "True, using this method, you are not deleting any values from your stream -- the variance will depend on all the values.", "But so what?", "With enough values, the first few won't matter a great deal to the variance, and the variance of the average, variance/n, will become small when enough values cluster around some fixed value."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "compute the variance incrementally", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/5543651/computing-standard-deviation-in-a-stream/5544108#5544108"}, {"text": "variance/n", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["So, you can choose to halt when the variance/n &lt; epsilon."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "variance/n &lt; epsilon", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["As a refinement of @unutbu's excellent idea, you could consider using exponentially-weighted moving variance.", "It can be computed in O(1) time per observation, requires O(1) space, and has the advantage of automatically reducing the observation's weight as the observation gets older."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "exponentially-weighted", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "O(1)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "O(1)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The following paper has the relevant formulae: link.", "See equations (140)-(143) therein."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "link", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www-uxsup.csx.cam.ac.uk/~fanf2/hermes/doc/antiforgery/stats.pdf"}]}, {"text": ["Finally, you might want to work with the standard deviation instead of variance.", "It is simply the square root of variance, and has the advantage of having the same units as the original data.", "This should make it easier to formulate a meaningful stopping criterion."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["How about numpy?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Just to compare the speed:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\na = range(1000)\nb = np.arange(1000)\n\nmax(a) # 29.7us\nb.max() # 7.29us\n</code>\n</pre>\n", "senID": 2}, {"text": ["and you can write to this array infinitely:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n i = 0\nb = np.empty([1000]) + np.nan\n\nyour loop:\n    b[i % 1000] = value\n    i += 1\n</code>\n</pre>\n", "senID": 4}, {"text": ["The values older than 1000 iterations will get overwritten.", "You get the minimum/maximum with np.nanmin(b) and np.nanmax(b)."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "np.nanmin(b)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "np.nanmax(b)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The idea behind the nan is that you initialize this array with 1000 nan's and you overwrite them one after another.", "The nanmin and nanmax methods ignore these nan's."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "nan", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "nanmin", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "nanmax", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I'm afraid I'm not in a position to provide a nice Python answer now, but I'll give you the outline of the data structure you'll need to use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Keep your 1000 items in an FIFO queue.", "Keep pointers to the largest and smallest items in the queue.", "If one of these leaves the queue, search the queue for the new largest/smallest (Amortized cost dependent on your data).", "If a new largest/smallest value enters the queue, just update the pointer (O(1)).", "Assuming your data is converging, this should work well."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Create a subclass of deque that has minvalue and maxvalue properties.", "When adding or removing entries, compare them to the current min and maxvalues - then you only need to rescan the deque for min/max if the value you are removing is the current min or max.", "And when adding, just compare the new value with the current min and max, and update accordingly.", "This will optimize the scanning of your deque for min/max values."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You could use two fibonacci heaps.", "Adding values is in O(1), deleting is in O(log(n)).", "In your question you already suggest the heapq module.", "I am not sure what kind of heap it provides, but a normal one will also work very smoothly. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fibonacci heaps", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Fibonacci_heap"}]}, {"text": ["The problem that you can only extract the minimum from one heap but not the maximum can be solved by keeping two heaps.", "Since I do not know the heapq module, you either might be able to provide it your own comparison function, or you can just use -value instead of value for the key of the second heap."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "-value", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "value", "childNum": 0, "tag": "code", "childList": []}]}]]