[[{"text": ["Searching for the namespace names is pretty easy with a regular expression.", "However, to determine the nesting level you will have to keep track of the curly bracket nesting level in the source file.", "This is a parsing problem, one that cannot be solved (sanely) with regular expressions.", "Also, you may have to deal with any C preprocessor directives in the file which can definitely affect parsing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["C++ is a notoriously tricky language to parse completely, but you may be able to get by with a tokeniser and a curly bracket counter."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The need is simple enough that you may not need a complex parser.", "You need to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "extract the namespace names", "tag": "none", "senID": 1}, {"text": "count the open/close braces to keep track of where your namespace is defined.", "tag": "none", "senID": 2}]}, {"text": ["This simple approach works if the other conditions are met:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "you don't get spurious namespace like strings inside comments or inside strings", "tag": "none", "senID": 4}, {"text": "you don't get unmatched open/closeing braces inside comments or strings", "tag": "none", "senID": 5}]}, {"text": ["I don't think this is too much asking from your source."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["You cannot completely ignore preprocessor directives, as they may introduce additional namespaces.", "I have seen a lot of code like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #define __NAMESPACE_SYSTEM__ namespace system\n\n__NAMESPACE_SYSTEM__ {\n   // actual code here...\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Yet, I don't see any reason for using such directives, other than defeating regular expression parsing strategy..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could write a basic lexer for it.", "It's not that hard."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Most of the time when someone asks how to do something with regex, they're doing something very wrong.", "I don't think this case is different."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to parse c++, you need to use a c++ parser.", "There are many things that can be done that will defeat a regex but still be valid c++."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["That is what I did earlier today:    "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Extract the comment out of the C++ files", "tag": "none", "senID": 1}, {"text": "Use regex to extract the namespace definition", "tag": "none", "senID": 2}, {"text": "Use a simple string search to get the open &amp; close braces positions", "tag": "none", "senID": 3}]}, {"text": ["The various sanity check added show that I am successfully processing 99.925% of my files (5 failures ouf of 6678 files).", "The issues are due to mismatches in numbers of { and } cause by few '{' or '}' in strings, and unclean usage of the preprocessor instruction."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["However, I am only dealing with header files, and I own the code.", "That limits the number of scenari that could cause some issues and I can manually modify the ones I don't cover."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Of course I know there are plenty of cases where it would fail but it is probably enough for what I want to achieve."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Thanks for your answers."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]