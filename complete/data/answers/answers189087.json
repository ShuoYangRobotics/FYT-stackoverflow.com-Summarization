[[{"text": ["If anyone is interested in performance of the above solutions, here they are for 4000x4000 grids, from fastest to slowest:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 7, "lis": [{"text": ["Brian"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["John"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}, {"text": ["DzinX"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["\u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}, {"text": ["Eugene"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}, {"text": ["Robert"], "childNum": 0, "tag": "a", "senID": 6, "childList": []}, {"text": ["Brian"], "childNum": 0, "tag": "a", "senID": 7, "childList": []}]}, {"text": ["EDIT: Added Brian's scores with izip modification and it won by a large amount!"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "izip", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["John's solution is also very fast, although it uses indices (I was really surprised to see this!", "), whereas Robert's and Brian's (with zip) are slower than the question creator's initial solution."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["So let's present Brian's winning function, as it is not shown in proper form anywhere in this thread:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Brian", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/189087/how-can-i-in-python-iterate-over-multiple-2d-lists-at-once-cleanly#189111"}]}, {"code": "<pre>\n<code>\n from itertools import izip\nfor a_row,b_row in izip(alist, blist):\n    for a_item, b_item in izip(a_row,b_row):\n        if a_item.isWhatever:\n            b_item.doSomething()\n</code>\n</pre>\n", "senID": 11}], [{"text": ["You could zip them.", "ie:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for a_row,b_row in zip(alist, blist):\n    for a_item, b_item in zip(a_row,b_row):\n        if a_item.isWhatever:\n            b_item.doSomething()\n</code>\n</pre>\n", "senID": 1}, {"text": ["However the overhead of zipping and iterating over the items may be higher than your original method if you rarely actually use the b_item (ie a_item.isWhatever is usually False).", "You could use itertools.izip instead of zip to reduce the memory impact of this, but its still probably going to be slightly slower unless you always need the b_item."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Alternatively, consider using a 3D list instead, so terrain for cell i,j is at l[i][j][0], objects at l[i][j][1] etc, or even combine the objects so you can do a[i][j].terrain, a[i][j].object etc."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["[Edit]  DzinX's timings actually show that the impact of the extra check for b_item isn't really significant, next to the performance penalty of re-looking up by index, so the above (using izip) seems to be fastest.  "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "DzinX's timings", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/189087/how-can-i-in-python-iterate-over-multiple-2d-lists-at-once-cleanly#189497"}]}, {"text": ["I've now given a quick test for the 3d approach as well, and it seems faster still, so if you can store your data in that form, it could be both simpler and faster to access.", "Here's an example of using it:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n # Initialise 3d list:\nalist = [ [[A(a_args), B(b_args)] for i in xrange(WIDTH)] for j in xrange(HEIGHT)]\n\n# Process it:\nfor row in xlist:\n    for a,b in row:\n        if a.isWhatever(): \n            b.doSomething()\n</code>\n</pre>\n", "senID": 6}, {"text": ["Here are my timings for 10 loops using a 1000x1000 array, with various proportions of isWhatever being true are:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n ( Chance isWhatever is True )\nMethod      100%     50%      10%      1%\n\n3d          3.422    2.151    1.067    0.824\nizip        3.647    2.383    1.282    0.985\noriginal    5.422    3.426    1.891    1.534\n</code>\n</pre>\n", "senID": 8}], [{"text": ["I'd start by writing a generator method:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def grid_objects(alist, blist):\n    for i in range(len(alist)):\n        for j in range(len(alist[i])):\n            yield(alist[i][j], blist[i][j])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then whenever you need to iterate over the lists your code looks like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for (a, b) in grid_objects(alist, blist):\n    if a.is_whatever():\n        b.do_something()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Generator expressions and izip from itertools module will do very nicely here:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Generator expressions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/ref/genexpr.html"}, {"text": "izip", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://www.python.org/doc/2.5.2/lib/itertools-functions.html", "text": "itertools module", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import izip\nfor a, b in (pair for (aline, bline) in izip(alist, blist) \n             for pair in izip(aline, bline)):\n    if a.isWhatever:\n        b.doSomething()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The line in for statement above means:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "take each line from combined grids ", "tag": "none", "senID": 3}, {"text": "now combine these lists with ", "tag": "none", "senID": 4}]}, {"text": ["This method has two advantages:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "there are no indices used anywhere", "tag": "none", "senID": 6}, {"text": "you don't have to create lists with ", "tag": "none", "senID": 7}]}], [{"text": ["As a slight style change, you could use enumerate:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i, arow in enumerate(alist):\n    for j, aval in enumerate(arow):\n        if aval.isWhatever():\n            blist[i][j].doSomething()\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't think you'll get anything significantly simpler unless you rearrange your data structures as Federico suggests.", "So that you could turn the last line into something like \"aval.b.doSomething()\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["When you are operating with grids of numbers and want really good performance, you should consider using Numpy.", "It's surprisingly easy to use and lets you think in terms of operations with grids instead of loops over grids.", "The performance comes from the fact that the operations are then run over whole grids with optimised SSE code."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org"}]}, {"text": ["For example here is some numpy using code that I wrote that does brute force numerical simulation of charged particles connected by springs.", "This code calculates a timestep for a 3d system with 100 nodes and 99 edges in 31ms.", "That is over 10x faster than the best pure python code I could come up with."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from numpy import array, sqrt, float32, newaxis\ndef evolve(points, velocities, edges, timestep=0.01, charge=0.1, mass=1., edgelen=0.5, dampen=0.95):\n    \"\"\"Evolve a n body system of electrostatically repulsive nodes connected by\n       springs by one timestep.\"\"\"\n    velocities *= dampen\n\n    # calculate matrix of distance vectors between all points and their lengths squared\n    dists = array([[p2 - p1 for p2 in points] for p1 in points])\n    l_2 = (dists*dists).sum(axis=2)\n\n    # make the diagonal 1's to avoid division by zero\n    for i in xrange(points.shape[0]):\n        l_2[i,i] = 1\n\n    l_2_inv = 1/l_2\n    l_3_inv = l_2_inv*sqrt(l_2_inv)\n\n    # repulsive force: distance vectors divided by length cubed, summed and multiplied by scale\n    scale = timestep*charge*charge/mass\n    velocities -= scale*(l_3_inv[:,:,newaxis].repeat(points.shape[1], axis=2)*dists).sum(axis=1)\n\n    # calculate spring contributions for each point\n    for idx, (point, outedges) in enumerate(izip(points, edges)):\n        edgevecs = point - points.take(outedges, axis=0)\n        edgevec_lens = sqrt((edgevecs*edgevecs).sum(axis=1))\n        scale = timestep/mass\n        velocities[idx] += (edgevecs*((((edgelen*scale)/edgevec_lens - scale))[:,newaxis].repeat(points.shape[1],axis=1))).sum(axis=0)\n\n    # move points to new positions\n    points += velocities*timestep\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Are you sure that the objects in the two matrices you are iterating in parallel are instances of conceptually distinct classes?", "What about merging the two classes ending up with a matrix of objects that contain both isWhatever() and doSomething()?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "both", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["If the two 2D-lists remain constant during the lifetime of your game and you can't enjoy Python's multiple inheritance to join the alist[i][j] and blist[i][j] object classes (as others have suggested), you could add a pointer to the corresponding b item in each a item after the lists are created, like this:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "and", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "em", "childList": []}, {"text": "a", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n for a_row, b_row  in itertools.izip(alist, blist):\n    for a_item, b_item in itertools.izip(a_row, b_row):\n        a_item.b_item= b_item\n</code>\n</pre>\n", "senID": 1}, {"text": ["Various optimisations can apply here, like your classes having __slots__ defined, or the initialization code above could be merged with your own initialization code e.t.c.", "After that, your loop will become:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for a_row in alist:\n    for a_item in a_row:\n        if a_item.isWhatever():\n            a_item.b_item.doSomething()\n</code>\n</pre>\n", "senID": 3}, {"text": ["That should be more efficient."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If a.isWhatever is rarely true you could build an \"index\" once:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "a.isWhatever", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a_index = set((i,j) \n              for i,arow in enumerate(a) \n              for j,a in enumerate(arow) \n              if a.IsWhatever())\n</code>\n</pre>\n", "senID": 1}, {"text": ["and each time you want something to be done:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for (i,j) in a_index:\n    b[i][j].doSomething()\n</code>\n</pre>\n", "senID": 3}, {"text": ["If a changes over time, then you will need to\nkeep the index up-to-date.", "That's why I used\na set, so items can be added and removed fast."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n for d1 in alist\n   for d2 in d1\n      if d2 = \"whatever\"\n          do_my_thing()\n</code>\n</pre>\n", "senID": 0}]]