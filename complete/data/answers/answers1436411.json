[[{"text": ["With a 32-bit address space, any language is going to be struggling to be able to address such an array.", "Then there's the problem of how much real memory you have on your computer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want 10B array elements, each element representing either true or false, use an array.array('I', ...) ..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n container = array.array('I', [0]) * ((10000000000 + 31) // 32)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then you can set and clear bits using the usual masking and shifting operations."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Alternative:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Alternative:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If only a small number of elements are true, or only a small number of elements are false, you could use a set for the best memory saving, or a dict for programming convenience."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["A dense bit vector is plausible but it won't be optimal unless you know you won't have more than about 10**10 elements, all clustered near each other, with a reasonably randomized distribution.", "If you have a different distribution, then a different structure will be better.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "10**10", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For instance, if you know that in that range, [0,10**10), only a few members are present, use a set(), or if the reverse is true, with nearly every element present except for a fraction, use a negated set, ie element not in mySet.  "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "set()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "element not in mySet", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the elements tend to cluster around small ranges, you could use a run length encoding, something like [xrange(0,10),xrange(10,15),xrange(15,100)], which you lookup into by bisecting until you find a matching range, and if the index is even, then the element is in the set.", "inserts and removals involve shuffling the ranges a bit."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[xrange(0,10),xrange(10,15),xrange(15,100)]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If your distribution really is dense, but you need a little more than what fits in memory (seems to be typical in practice) then you can manage memory by using mmap and wrapping the mapped file with an adaptor that uses a similar mechanism to the suggested array('I') solution already suggested."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "mmap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "array('I')", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To get an idea of just how compressible you can possibly get, try building a plain file with a reasonable corpus of data in packed form and then apply a general compression algorithm (such as gzip) to see how much reduction you see.", "If there is much reduction, then you can probably use some sort of space optimization in your code as well."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The bitarray package looks like it might be another useful option."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bitarray", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/bitarray/"}]}], [{"text": ["I think you have your arithmetic wrong -- stored supercompactly, 10B booleans would be 1.25 GIGA, _not__ MEGA, bytes."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "GIGA", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "MEGA", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["A list takes at least 4 bytes per item, so you'd need 40GB to do it the way you want."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can store an array (see the array module in the standard library) in much less memory than that, so it might possibly fit."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "array", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "array", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Another option for very large bit arrays would be to use bitstring.", "It uses a bytearray (or array.array on older Python versions) to store the data but its interface is just an array of bits.", "For your case you could use:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "bitstring", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python-bitstring.googlecode.com"}, {"text": "bytearray", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "array.array", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from bitstring import BitString\n&gt;&gt;&gt; s = BitString(10000000000)         # zero initialised\n&gt;&gt;&gt; s.set([9, 999999999, 253])         # set 3 bits to '1'\n&gt;&gt;&gt; s[66] = True                       # set another bit\n&gt;&gt;&gt; s.allset([9, 66])                  # check if bits are set to '1'\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think it's preferable to doing all the bit masking and shifting yourself!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["From googling around some , e.g.", "PEP 353 (assuming I'm understanding it) and this exchange it looks like the real issue is probably platform/system dependent.", "Do you have enough memory to handle 10,000,000,000 entries?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PEP 353", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5/whatsnew/pep-353.html"}, {"text": "this exchange", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2006-January/532801.html"}]}]]