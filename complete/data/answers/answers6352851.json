[[{"text": ["Looks like another job for groupby."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "groupby", "tag": "a", "pos": 0, "childList": [{"text": "groupby", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.groupby"}, {"text": "groupby", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import groupby\n&gt;&gt;&gt; n = 529\n&gt;&gt;&gt; max(sum(1 for i in g) for k,g in groupby(bin(n)[2:]) if k=='0')\n4\n</code>\n</pre>\n", "senID": 1}, {"text": ["Perhaps not the fastest, but reasonably so:*"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n % python -m timeit -s \"from itertools import groupby; n = 10\" \"max(sum(1 for i in g) for k,g in groupby(bin(n)[2:]) if k=='0')\"\n100000 loops, best of 3: 5.46 usec per loop\n% python -m timeit -s \"from itertools import groupby; n = 10**100\" \"max(sum(1 for i in g) for k,g in groupby(bin(n)[2:]) if k=='0')\"\n10000 loops, best of 3: 128 usec per loop\n</code>\n</pre>\n", "senID": 3}, {"text": ["On a MacBook Pro, 2.5 GHz Core i5, Python 2.6.5 running in 32-bit mode.", "(Doubling the bits seems to knock about 25% off the time."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["*Actually JBernardo's solution seems to roll right over this one for large numbers."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["No need to convert to binary string - you can test each bit using bit operators like | and &amp;.", "I have written down the solution where you iterate once starting from the lowest bit keeping the max gap in the variable m and the current running gap in the variable cur:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "|", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&amp;", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "cur", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def maxGap(n):\n    cur = 0\n    m = 0\n    p = 1\n    while (p &lt;= n and (n &amp; p) == 0): p &lt;&lt;= 1\n    while (p &lt;= n):\n        if (n &amp; p != 0):\n            m = max(cur, m)\n            cur = 0\n        else:\n            cur+=1\n        p &lt;&lt;= 1\n    return m\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Another string based solution"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def max_gap(x):\n    return len(max(bin(x)[2:].rstrip('0').split('1')))\n</code>\n</pre>\n", "senID": 1}, {"text": ["for python2.6+ you can use format(x, 'b') instead of bin(x)[2:] for readability"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "format(x, 'b')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "bin(x)[2:]", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["On the face of it, this problem seems similar to normal bit counting, which has been very heavily analyzed.", "All of the solutions presented so far would be terribly slow by cyrptographers' standards (heavy bit count users).", "I'd guess that if you wanted the fastest easily implemented software solution, you'd  want to do something with pre-computed tables.", "Look at http://gurmeet.net/puzzles/fast-bit-counting-routines/ for good code examples of approaches to bit counting (http://graphics.stanford.edu/~seander/bithacks.html is an interesting page too but may not help you with this particular problem).", "For consecutive bit counting, I think you'd want something like three tables - a \"left zero count\", \"middle zero count\" and \"right zero count\" table.", "Then precompute that for the biggest number size you can stomach (e.g.", "16 bits) and chomp your inputs that number of bits at a time, tracking the largest consecutive block of zeroes you've found."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://gurmeet.net/puzzles/fast-bit-counting-routines/", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://gurmeet.net/puzzles/fast-bit-counting-routines/"}, {"text": "think", "childNum": 0, "tag": "em", "pos": 4, "childList": []}]}], [{"text": ["Another divide and conquer approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Shift the number right successively by 1, 2, 4, ... and apply OR, until it is all ones.", "Then you know the smallest power of two that is greater than the largest gap of zeros.", "Back up one step and repeat for the remaining zeros."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Whether this is an improvement would be interesting to see.", "I would guess that for 64 bit numbers it would be better in the average case but not in the worst case, compared to a loop that looks at the bits one by one."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: In the average case it is substantially faster, by a factor of more than 9 for random 64 bit numbers.", "Here is the Java code of the implementations I used for benchmarking:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n private static final int consecutiveZeros0(long n)\n{\n    int result = 0;\n    long rest = n;\n    int count = 0;\n    while (rest != 0)\n    {\n        if ((rest &amp; 1) == 0)\n        {\n            count++;\n        }\n        else\n        {\n            result = Math.max(count, result);\n            count = 0;\n        }\n\n        rest &gt;&gt;&gt;= 1;\n    }\n    return result;\n}\n\n\nprivate static final int consecutiveZeros1(long n)\n{\n    int result = 0;\n\n    long a = n;\n    while (!isAllOnes(a))\n    {\n        int count = 1;\n        a |= (a &gt;&gt; count);\n        while (!isAllOnes(a | (a &gt;&gt; count)))\n        {\n            a |= (a &gt;&gt; count);\n            count *= 2;\n        }\n        result += count;\n    }\n    return result;\n}\n\n\nprivate static boolean isAllOnes(long a)\n{\n    return (a &amp; (a + 1)) == 0;\n}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Yours is a perfectly good solution IMO.", "There's little you can do to improve the performance, in asymptotic terms at least.", "Probably not worth trying to optimise unless you're working in C or C++, and even then only if you need to optimise."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, as a slightly different (no doubt slower, but perhaps simpler) solution..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; \"10010001101\".split (\"1\")\n['', '00', '000', '', '0', '']\n</code>\n</pre>\n", "senID": 2}, {"text": ["Use a list comprehension to map from those strings of zeros to the lengths, then extract the maximum."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT  As pointed out by fiver, this doesn't work if your number is even (the binary ends with one or more zeros).", "To fix the bug, take a look at the string.strip method."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "string.strip", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I should probably update this answer to include more ideas from the comments - for the moment, just be aware that the comments are worth reading."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I think I can suggest a mathematical way.....before reading remember that i am not a good ex-plainer so bear up with it..:)\nI have only thought of the algorithm and not implemented so bear up with some loopholes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What i suggest is we can detect a pattern in the way the binary numbers change as the number increases.lets take an example if we want to take out the max binary gap for 27\nstarting from 16"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["10000  max=0   "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["10001  max=3   [1 number]"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["10010\n10011  max=2   [2 numbers]"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["10100\n10101\n10110\n10111  max=1   [4 numbers]"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["11000  max=0"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["11001  max=2   [1 number]"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["11010\n11011  max=1   [2 numbers]"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["11100  max=0"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["11101  max=1   [1 number]"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["11110\n11111  max=0   [2 numbers]"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["this number(27) lies between 2^4 and 2^5 and from the above pattern we can see that any number lying in this range cannot have binary gap more than 3.\nabove we can see for a range 0f 2^4-2^5 the values change in the interval of 2^3 then 2^2 and so on.... so by finding the interval in which the number we want to find teh binary gap of lies we can calculate its maximum binary gap.", "taking an example:\nthe max binary gap follows the above pattern so when we get a number say 27 we first find the range within which it lies.we get 2^4-2^5.", "therefore value of max=3[4-1], now \n27mod[lower range]\nwe get 11 which greater that 8 so now what we know from this is that value of max=3-1\nnor 11mod4 we get 3.before proceeding one more thing noteworthy in the pattern is that the value of max within the range also follows a pattern\nwithin first 8 number of the range\n4[max=3]-->2[max=2]-->1[max=1]-->1[max=0](common to all)\nthen for next 4\n2[max=2]-->1[max=1]-->1[max=0]\nand so on....\ncoming back to the example..\nafter mod with 8 we get three so we know that the value of max=2 now(following the pattern 8-->4-->2-->1)\nnote:before moding check if the remainder of the previous i larger than 2^n(whatever may be the case then) \n3mod2 we get 1 making the value of max=1....which will  be the answer for 27....."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["I am really bad descriptor and ex-planer so please bear up with the explanation and comment on whatever you find confusing.....\nand do tell me the loopholes if you find any....:)\nhope this is the answer...."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Well I can think of one way to do it mathematically, but it would still involve iteration."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Assume the indices of the binary number start from 0 at the least significant digit, and up one for each digit."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["for the number n, the index of the first 1 is given by floor(log(n)).", "Then set n = n-2^floor(log(n)), repeat until n = 0.", "Then you will have the indices of all 1's and it is trivial to find the largest gap."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Logs are all base 2 of course.", "I'm sure there is a better way than this though."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I believe you can do it without converting the number to a string. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can rotate the number to the right and check if the number is odd , if yes you have a 1 in the last bit else its a 0,now keep rotating and storing the distance(s) between the 1s and you will have the largest distance."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This solution uses the fact that x&amp;(x-1) is x with its least significant 1 bit set to 0.", "It returns 1&lt;&lt;max_binary_gap."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "x&amp;(x-1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "1&lt;&lt;max_binary_gap", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n # Return Y,BIT where BIT is the least significant 1 bit of X, and\n# Y is X shifted right to remove this bit.\ndef lsbit(x):\n  u = x &amp; (x-1)         # U = X with least significant 1 removed\n  bit = u ^ x           # BIT = least significant 1\n  return ((x/bit)&gt;&gt;1), bit\n\n# Return 0 if X is negative or does not have 2 bits set\n# Otherwise, return 1&lt;&lt;max_binary_gap\ndef binary_gap(x):\n  if x &lt;= 0: return 0  # Invalid input\n  gap = 0\n  x,bit = lsbit(x)\n  while x&gt;0:\n    x,bit = lsbit(x)\n    gap = max(gap,bit)  # Keep largest BIT in GAP\n  return gap\n</code>\n</pre>\n", "senID": 1}]]