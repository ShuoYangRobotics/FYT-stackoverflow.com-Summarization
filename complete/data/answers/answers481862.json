[[{"text": ["That is pretty good.", "Below some suggestions, let me know if you like'em:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nimport pprint\nimport sys\n\nclass Despacho(object):\n    \"\"\"\n    Class to parse each line, applying the regexp and storing the results\n    for future use\n    \"\"\"\n    #used a dict with the keys instead of functions.\n    regexp = {\n        ('processo', \n         'data', \n         'despacho'): re.compile(r'No.([\\d]{9})  ([\\d]{2}/[\\d]{2}/[\\d]{4})  (.*)'),\n        ('titular',): re.compile(r'Tit.(.*)'),\n        ('procurador',): re.compile(r'Procurador: (.*)'),\n        ('documento',): re.compile(r'C.N.P.J./C.I.C./N INPI :(.*)'),\n        ('apresentacao',\n         'natureza'): re.compile(r'Apres.: (.*) ; Nat.: (.*)'),\n        ('marca',): re.compile(r'Marca: (.*)'),\n        ('classe',): re.compile(r'Clas.Prod/Serv: (.*)'),\n        ('complemento',): re.compile(r'\\*(.*)'),\n    }\n\n    def __init__(self):\n        \"\"\"\n        'complemento' is the only field that can be multiple in a single registry\n        \"\"\"\n        self.complemento = []\n\n\n    def read(self, line):\n        for attrs, pattern in Despacho.regexp.iteritems():\n            m = pattern.match(line)\n            if m:\n                for groupn, attr in enumerate(attrs):\n                    # special case complemento:\n                    if attr == 'complemento':\n                        self.complemento.append(m.group(groupn + 1))\n                    else:\n                        # set the attribute on the object\n                        setattr(self, attr, m.group(groupn + 1))\n\n    def __repr__(self):\n        # defines object printed representation\n        d = {}\n        for attrs in self.regexp:\n            for attr in attrs:\n                d[attr] = getattr(self, attr, None)\n        return pprint.pformat(d)\n\ndef process(rpi):\n    \"\"\"\n    read data and process each group\n    \"\"\"\n    #Useless line, since you're doing a for anyway\n    #rpi = (line for line in rpi)\n    group = False\n\n    for line in rpi:\n        if line.startswith('No.'):\n            group = True\n            d = Despacho()        \n\n        if not line.strip() and group: # empty line - end of block\n            yield d\n            group = False\n\n        d.read(line)\n\ndef main():\n    arquivo = open('rm1972.txt') # file to process\n    for desp in process(arquivo):\n        print desp # can print directly here.\n        print('-' * 20)\n    return 0\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It would be easier to help if you had a specific concern.", "Performance will depend greatly on the efficiency of the particular regex engine you are using.", "100K lines in a single file doesn't sound that big, but again it all depends on your environment."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I use Expresso in my .NET development to test expressions for accuracy and performance.", "A Google search turned up Kodos, a GUI Python regex authoring tool."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Expresso", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ultrapico.com/Expresso.htm"}, {"text": "Kodos", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://kodos.sourceforge.net/about.html"}]}], [{"text": ["It looks good overall, but why do you have the line:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n rpi = (line for line in rpi)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can already iterate over the file object without this intermediate step."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I wouldn't use regex here.", "If you know that your lines will be starting with fixed strings, why not check those strings and write a logic around it?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for line in open(file):\n    if line[0:3]=='No.':\n        currIndex='No'\n        map['No']=line[4:]\n   ....\n   ...\n   else if line.strip()=='':\n       //store the record in the map and clear the map\n   else:\n      //append line to the last index in map.. this is when the record overflows to the next line.\n      Map[currIndex]=Map[currIndex]+\"\\n\"+line\n</code>\n</pre>\n", "senID": 1}, {"text": ["Consider the above code as just the pseudocode."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Another version with only one combined regular expression:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\nimport re\nimport pprint\nimport sys\n\nclass Despacho(object):\n    \"\"\"\n    Class to parse each line, applying the regexp and storing the results\n    for future use\n    \"\"\"\n    #used a dict with the keys instead of functions.\n    regexp = re.compile(\n        r'No.(?P&lt;processo&gt;[\\d]{9})  (?P&lt;data&gt;[\\d]{2}/[\\d]{2}/[\\d]{4})  (?P&lt;despacho&gt;.*)'\n        r'|Tit.(?P&lt;titular&gt;.*)'\n        r'|Procurador: (?P&lt;procurador&gt;.*)'\n        r'|C.N.P.J./C.I.C./N INPI :(?P&lt;documento&gt;.*)'\n        r'|Apres.: (?P&lt;apresentacao&gt;.*) ; Nat.: (?P&lt;natureza&gt;.*)'\n        r'|Marca: (?P&lt;marca&gt;.*)'\n        r'|Clas.Prod/Serv: (?P&lt;classe&gt;.*)'\n        r'|\\*(?P&lt;complemento&gt;.*)')\n\n    simplefields = ('processo', 'data', 'despacho', 'titular', 'procurador',\n                    'documento', 'apresentacao', 'natureza', 'marca', 'classe')\n\n    def __init__(self):\n        \"\"\"\n        'complemento' is the only field that can be multiple in a single\n        registry\n        \"\"\"\n        self.__dict__ = dict.fromkeys(self.simplefields)\n        self.complemento = []\n\n    def parse(self, line):\n        m = self.regexp.match(line)\n        if m:\n            gd = dict((k, v) for k, v in m.groupdict().items() if v)\n            if 'complemento' in gd:\n                self.complemento.append(gd['complemento'])\n            else:\n                self.__dict__.update(gd)\n\n    def __repr__(self):\n        # defines object printed representation\n        return pprint.pformat(self.__dict__)\n\ndef process(rpi):\n    \"\"\"\n    read data and process each group\n    \"\"\"\n    d = None\n\n    for line in rpi:\n        if line.startswith('No.'):\n            if d:\n                yield d\n            d = Despacho()\n        d.parse(line)\n    yield d\n\ndef main():\n    arquivo = file('rm1972.txt') # file to process\n    for desp in process(arquivo):\n        print desp # can print directly here.\n        print '-' * 20\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm not going to go over everything but for starters: instead of making functions that each of the lambdas call, why not perform the work directly in the lambda?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n regexp = {\n            re.compile(r'No.([\\d]{9})  ([\\d]{2}/[\\d]{2}/[\\d]{4})  (.*)'): lambda self, matches: self.processo, self.data, self.despacho = matches.groups()\n    }\n\n...\n\nDespacho.regexp[pattern](self, m)\n</code>\n</pre>\n", "senID": 2}, {"text": ["That saves you a lot of function definitions."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]