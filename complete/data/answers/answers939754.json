[[{"text": ["You have to consider multiple things if you want to use multiple threads:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The conclusion I take from that:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Since you're new to threading, there's something else worth bearing in mind - which I prefer to view as parallel scoping of values."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With traditional linear/sequential programming for any given object you only have one thread accessing and changing a piece of data.", "This is generally made safe due to having lexical scope.", "Specifically one function can operate on a variable's value without affect a global value.", "If you don't have lexical scope, or poor lexical scoping, then changing the value of a variable named \"foo\" in one function affects another called \"foo\".", "It's less commonly a problem these days, but still common enough to be alluding to."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["With threading, you have the same issue, in more subtle ways.", "Whilst you still have lexical scoping helping you - in that a local value \"X\" inside one function is independent of another local value called \"X\" in another, the fact that data structures are mutable is a major source of bugs in threading."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Specifically, if a function is passed a mutable value, then in a threaded environment unless you have taken care, that function cannot guarantee that the value is not being changed by anything else."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This shared state is the source of probably 90-99% of bugs in threaded systems, and can be very hard to debug.", "As a result, if you're going to write a threaded system you should try to bear in mind the distance that your shared values will travel - ie the scope of parallel access."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In order to limit bugs you have a handful of options which are known to work:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["1 is most equivalent to unix pipelines.", "3 is logically equivalent to version control, and is normally referred to as software transactional memory."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["1 &amp; 3 are modes of concurrency supported in Kamaelia which aims to eliminate bugs caused by class 2.", "(disclosure, I run the Kamaelia project) 2 isn't supported because it relies on \"always getting everything right\"."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["No matter which approach you use to solve your problem though, bearing in mind this issue, and the ways of dealing with it, and planning upfront how you intend to deal with it will save you no end of headaches later on."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["It depends on the platform. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Windows threads have to commit around 1MB of memory when created.", "It's better to have some kind of threadpool than spawning threads like a madman, to make sure you never allocate more than a fixed amount of threads.", "Also, when you work in Python, you're subject to the Global Interpreter Lock which hinders code that rely on lots of concurrent threads."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["On Unix, you may consider using different processes instead of threads, or look at other asynchronous way of doing things (the Twisted server framework has interesting ways of handling asynchronous network tasks, and if you feel really adventurous you can take a look at stackless Python, a continuation framework which don't really use kernel threads at all)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You might consider using microthreads if you need concurrency.", "There's a good article on the subject here.", "The advantage is that you're not creating \"real\" threads that eat up resources and cause context switching.", "Of course the downside is that you're not taking advantage of multicore technology."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/library/l-pythrd.html"}]}, {"text": ["This is the approach Kamaelia and stackless take."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Kamaelia", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.kamaelia.org/Home"}, {"href": "http://www.stackless.com/", "text": "stackless", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["If you're doing I/O, you might consider using asynchronous I/O as well.", "This can be a real pain to program, but it prevents you from having threads fight over CPU time.", "Unfortunately, I don't know of any platform independent way to do this in Python."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Threads do have some CPU and memory overhead but unless you spawn hundreds or thousands of them, it usually isn't all that significant.", "The more important issue is that threads make correct programming a lot more difficult if you share any writable datastructures between concurrent threads.", "See the paper The Problem with Threads for an explanation why they aren't a good abstraction for concurrent programming."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "The Problem with Threads", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf"}]}], [{"text": ["Excellent answers all around!", "I just wanted to add that, if you decide to go with a thread pool (generally advisable if you decide that threads are suitable for your app), you would be well advised to reuse (and possibly adapt) an existing general-purpose implementation, such as Christopher Arndt's, rather than roll your own from scratch (which is always an instructive undertaking, to be sure, but less productive in terms of time it takes to get you properly working and debugged code;-)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Christopher Arndt's", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://chrisarndt.de/projects/threadpool/"}]}]]