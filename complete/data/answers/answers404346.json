[[{"text": ["@Kiv's answer is correct but it is slow for large n if you don't need an infinite precision.", "It is better to use an asymptotic formula in this case:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "@Kiv's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/404346/python-program-to-calculate-harmonic-series#404425"}, {"text": "asymptotic formula", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Harmonic_number"}]}, {"src": "http://upload.wikimedia.org/math/0/5/1/0516d4c5d9a19f09ffcfc04a6a596928.png", "tag": "img", "senID": 1}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nfrom math import log\n\ndef H(n):\n    \"\"\"Returns an approximate value of n-th harmonic number.\n\n       http://en.wikipedia.org/wiki/Harmonic_number\n    \"\"\"\n    # Euler-Mascheroni constant\n    gamma = 0.57721566490153286060651209008240243104215933593992\n    return gamma + log(n) + 0.5/n - 1./(12*n**2) + 1./(120*n**4)\n</code>\n</pre>\n", "senID": 2}, {"text": ["@Kiv's answer for Python 2.6:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "@Kiv's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/404346/python-program-to-calculate-harmonic-series#404425"}]}, {"code": "<pre>\n<code>\n from fractions import Fraction\n\nharmonic_number = lambda n: sum(Fraction(1, d) for d in xrange(1, n+1))\n</code>\n</pre>\n", "senID": 4}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; N = 100\n&gt;&gt;&gt; h_exact = harmonic_number(N)\n&gt;&gt;&gt; h = H(N)\n&gt;&gt;&gt; rel_err = (abs(h - h_exact) / h_exact)\n&gt;&gt;&gt; print n, \"%r\" % h, \"%.2g\" % rel_err\n100 5.1873775176396242 6.8e-16\n</code>\n</pre>\n", "senID": 6}, {"text": ["At N = 100 relative error is less then 1e-15."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "N = 100", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1e-15", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["@recursive's solution is correct for a floating point approximation.", "If you prefer, you can get the exact answer in Python 3.0 using the fractions module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@recursive's solution", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/404346/python-program-to-calculate-harmonic-series#404354"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; def calc_harmonic(n):\n...   return sum(Fraction(1, d) for d in range(1, n + 1))\n...\n&gt;&gt;&gt; calc_harmonic(20) # sum of the first 20 terms\nFraction(55835135, 15519504)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that the number of digits grows quickly so this will require a lot of memory for large n. You could also use a generator to look at the series of partial sums if you wanted to get really fancy."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The harmonic series diverges, i.e.", "its sum is infinity.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["edit: Unless you want partial sums, but you weren't really clear about that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This ought to do the trick."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def calc_harmonic(n):\n    return sum(1.0/d for d in range(2,n+1))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n partialsum = 0\nfor i in xrange(1,1000000):\n    partialsum += 1.0 / i\nprint partialsum\n</code>\n</pre>\n", "senID": 1}, {"text": ["where 1000000 is the upper bound."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Just a footnote on the other answers that used floating point; starting with the largest divisor and iterating downward (toward the reciprocals with largest value) will put off accumulated round-off error as much as possible."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "downward", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Homework?  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's a divergent series, so it's impossible to sum it for all terms."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I don't know Python, but I know how to write it in Java."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n public class Harmonic\n{\n    private static final int DEFAULT_NUM_TERMS = 10;\n\n    public static void main(String[] args)\n    {\n        int numTerms = ((args.length &gt; 0) ? Integer.parseInt(args[0]) : DEFAULT_NUM_TERMS);\n\n        System.out.println(\"sum of \" + numTerms + \" terms=\" + sum(numTerms));\n     }\n\n     public static double sum(int numTerms)\n     {\n         double sum = 0.0;\n\n         if (numTerms &gt; 0)\n         {\n             for (int k = 1; k &lt;= numTerms; ++k)\n             {\n                 sum += 1.0/k;\n             }\n         }\n\n         return sum;\n     }\n }\n</code>\n</pre>\n", "senID": 3}]]