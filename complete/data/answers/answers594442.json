[[{"text": ["Sigh.", "Too much hand-wringing over the wrong part of the problem.", "The switch statement is not the issue.", "There are many ways of expressing \"alternative\" that don't add meaning."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "meaning", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["The issue is meaning -- not technical statement choices. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "meaning", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["There are three common patterns."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["Mapping a key to an object.", "Use a dictionary if it is almost totally static and you have a mapping between a simple key and another more complex thing.", "Building a dictionary on the fly each time you need it is silly.", "You can use this if it's what you mean: your \"conditions\" are simple, static key values that map to objects."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Mapping a key to an object", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "mean", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["Variant behavior among subclasses.", "Use Polymorphism instead of type checking objects.", "Correct.", "If you have similar objects in multiple classes with variant behavior, they should be polymorphic.", "Use this as often as possible."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Variant behavior among subclasses", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Other variant behavior.", "Use an if-elif-else ladder.", "Use this when you don't have largely static key-to-value mapping.", "Use this when the conditions are complex, or you mean procedures, not objects."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "Other variant behavior", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "mean", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}]}, {"text": ["Everything else is just tricky code that can achieve similar results."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Using a Tuple.", "This is just dictionary without the mapping.", "This requires search, and search should be avoided whenever possible.", "Don't do this, it's inefficient.", "Use a dictionary."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Using a function decorator (http://code.activestate.com/recipes/440499/).", "Icky.", "This conceals the if-elif-elif nature of the problem you're solving.", "Don't do this, it isn't obvious that the choices are exclusive.", "Use anything else."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "http://code.activestate.com/recipes/440499/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/440499/"}, {"text": "exclusive", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["Someone even recommended the Visitor pattern.", "Use this when you have an object which follows the Composite design pattern.", "This depends on polymorphism to work, so it's not really a different solution."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "Visitor", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Composite", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"text": ["In the first example I would certainly stick with the if-else statement.", "In fact I don't see a reason not to use if-else unless"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Your second example I would actually rewrite"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n setattr(self, name, value)\n</code>\n</pre>\n", "senID": 2}, {"text": ["(probably adding an assert statement to catch invalid names)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Considering that this is done in response to a user action (pickings something from a menu), and the number of choices you anticipate is very small, I'd definitely go with a simple if-elif-else ladder."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There's no point in optinizing for speed, since it only happens as fast as the user can make the selection anyway, this is not \"inner loop of a raytracer\"-territory.", "Sure, it matters to give the user quick feedback, but since the number of cases is so small, there is no danger of that either."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There's no point in optimizing for conciseness, since the (imo clearer, zero-readability-overhead) if-ladder will be so very short anyway."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Regarding your dictionary questions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My rule of thumb is to ask \"What's going on here?", "\" for each component of my code.", "If the answer is of the form"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(as in \"defining the library of functions and associating each with a value in the menu\") then there are some concerns begging to be separated."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "and", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Each of the exposed options fit well some scenarios:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python is about readability and consistency and even if your decision will always be a subjective and it will depend on your style, you should always think about Python mantras."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["./alex"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I agree with df regarding the second example.", "The first example I would probably try to rewrite using a dictionary, particularly if all the curve constructors have the same type signature (perhaps using *args and/or **kwargs).", "Something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def _setCurrentCurve(self, new_curve):\n    self.currentCurve = self.preset_curves[new_curve](options_here)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or perhaps even"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def _setCurrentCurve(self, new_curve):\n    self.currentCurve = self.preset_curves[new_curve](**preset_curve_defaults[new_curve])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In Python, don't event think about how to replace a switch statement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use classes and polymorphism instead.", "Try to keep the information about each availble choice and how to implement it in one place (i.e.", "the class that implements it)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Otherwise you will end up having lots of places that each contain a tiny fraction of each choice, and updating/extending will be a maintenance nightmare. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This is exactly the kind of problem that OOD tries to solve by abstraction, information hiding, polymorphism and the lot."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Think about what classes of objects you have and their properties, then create an OO architecture around them.", "This way you will never ever have to worry about a missing \"switch\" statement again."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]