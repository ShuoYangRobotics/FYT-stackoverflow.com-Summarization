[[{"text": ["Generators have no length, they aren't collections after all."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Generators are functions with a internal state (and fancy syntax).", "You can repeatedly call them to get a sequence of values, so you can use them in loop.", "But they don't contain any elements, so asking for the length of a generator is like asking for the length of a function. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "functions with a internal state", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Functions are objects, but you cannot assign new attributes to them.", "The reason is probably to keep such a basic object as efficient as possible."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You can however simply return (generator, lenght) pairs from your functions or wrap the generator in a simple object like this:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "(generator, lenght)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class GeneratorLen(object):\n    def __init__(self, gen, length):\n        self.gen = gen\n        self.length = length\n\n    def __len__(self): \n        return self.length\n\n    def __iter__(self):\n        return self.gen\n\ng = some_generator()\nh = GeneratorLen(g, 1)\nprint len(h), list(h)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Suppose we have a generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def gen():\n    for i in range(10):\n        yield i\n</code>\n</pre>\n", "senID": 1}, {"text": ["We can wrap the generator, along with the known length, in an object:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import itertools\nclass LenGen(object):\n    def __init__(self,gen,length):\n        self.gen=gen\n        self.length=length\n    def __call__(self):\n        return itertools.islice(self.gen(),self.length)\n    def __len__(self):\n        return self.length\n\nlgen=LenGen(gen,10)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Instances of LenGen are generators themselves, since calling them returns an iterator."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "LenGen", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Now we can use the lgen generator in place of gen, and access len(lgen) as well:"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "lgen", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "gen", "childNum": 0, "tag": "code", "childList": []}, {"text": "len(lgen)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def new_gen():\n    for i in lgen():\n        yield float(i)/len(lgen)\n\nfor i in new_gen():\n    print(i)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["You can combine the benefits of generators with the certainty of len(), by creating your own iterable object:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "len()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class MyIterable(object):\n    def __init__(self, n):\n        self.n = n\n\n    def __len__(self):\n        return self.n\n\n    def __iter__(self):\n        self._gen = self._generator()\n        return self\n\n    def _generator(self):\n        # Put your generator code here\n        i = 0\n        while i &lt; self.n:\n            yield i\n            i += 1\n\n    def next(self):\n        return next(self._gen)\n\nmi = MyIterable(100)\nprint len(mi)\nfor i in mi:\n    print i,\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is basically a simple implementation of xrange, which returns an object you can take the len of, but doesn't create an explicit list."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "xrange", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can use len(list(generator_function()).", "However, this consumes the generator, but that's the only way you can find out how many elements are generated.", "So you may want to save the list somewhere if you also want to use the items."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "len(list(generator_function())", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = list(generator_function())\nprint(len(a))\nprint(a[0])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The conversion to list that's been suggested in the other answers is the best way if you want to still want to process the generator elements afterwards, but has one flaw: It uses O(n) memory.", "You can count the elements in a  generator without using that much memory with:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n sum(1 for x in generator)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, be aware that this might be slower than len(list(generator)) in common Python implementations, and if the generators are long enough for the memory complexity to matter, the operation would take quite some time.", "Still, I personally prefer this solution as it describes what I want to get, and it doesn't give me anything extra that's not required (such as a list of all the elements)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "len(list(generator))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Also listen to delnan's advice: If you're discarding the output of the generator it is very likely that there is a way to calculate the number of elements without running it, or by counting them in another manner."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can len(list(generator)) but you could probably make something more efficient if you really intend to discard the results."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "len(list(generator))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can use reduce."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For Python 3:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import functools\n&gt;&gt;&gt; def gen():\n...     yield 1\n...     yield 2\n...     yield 3\n...\n&gt;&gt;&gt; functools.reduce(lambda x,y: x + 1, gen(), 0)\n</code>\n</pre>\n", "senID": 2}, {"text": ["In Python 2, reduce is in the global namespace so the import is unnecessary."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can use send as a hack:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "send", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def counter():\n    length = 10\n    i = 0\n    while i &lt; length:\n        val = (yield i)\n        if val == 'length':\n            yield length\n        i += 1\n\nit = counter()\nprint(it.next())\n#0\nprint(it.next())\n#1\nprint(it.send('length'))\n#10\nprint(it.next())\n#2\nprint(it.next())\n#3\n</code>\n</pre>\n", "senID": 1}]]