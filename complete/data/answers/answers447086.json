[[{"text": ["You might like this module which implements the wrapper you are looking for."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/456151/"}]}], [{"text": ["Trying out some ideas..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It looks like you would ideally want an expression with side effects.", "If this were allowed in Python:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if m = re.match('foo (\\w+) bar (\\d+)', line):\n  # do stuff with m.group(1) and m.group(2)\nelif m = re.match('baz whoo_(\\d+)', line):\n  # do stuff with m.group(1)\nelif ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["... then you would clearly and cleanly be expressing your intent.", "But it's not.", "If side effects were allowed in nested functions, you could:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n m = None\ndef assign_m(x):\n  m = x\n  return x\n\nif assign_m(re.match('foo (\\w+) bar (\\d+)', line)):\n  # do stuff with m.group(1) and m.group(2)\nelif assign_m(re.match('baz whoo_(\\d+)', line)):\n  # do stuff with m.group(1)\nelif ...\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now, not only is that getting ugly, but it's still not valid Python code -- the nested function 'assign_m' isn't allowed to modify the variable m in the outer scope.", "The best I can come up with is really ugly, using nested class which is allowed side effects:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "really", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n # per Brian's suggestion, a wrapper that is stateful\nclass m_(object):\n  def match(self, *args):\n    self.inner_ = re.match(*args)\n    return self.inner_\n  def group(self, *args):\n    return self.inner_.group(*args)\nm = m_()\n\n# now 'm' is a stateful regex\nif m.match('foo (\\w+) bar (\\d+)', line):\n  # do stuff with m.group(1) and m.group(2)\nelif m.match('baz whoo_(\\d+)', line):\n  # do stuff with m.group(1)\nelif ...\n</code>\n</pre>\n", "senID": 6}, {"text": ["But that is clearly overkill."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "clearly", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You migth consider using an inner function to allow local scope exits, which allows you to remove the else nesting:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "else", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def find_the_right_match():\n  # now 'm' is a stateful regex\n  m = re.match('foo (\\w+) bar (\\d+)', line)\n  if m:\n    # do stuff with m.group(1) and m.group(2)\n    return # &lt;== exit nested function only\n  m = re.match('baz whoo_(\\d+)', line)\n  if m:\n    # do stuff with m.group(1)\n    return\n\nfind_the_right_match()\n</code>\n</pre>\n", "senID": 9}, {"text": ["This lets you flatten nesting=(2*N-1) to nesting=1, but you may have just moved the side-effects problem around, and the nested functions are very likely to confuse most Python programmers."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Lastly, there are side-effect-free ways of dealing with this:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def cond_with(*phrases):\n  \"\"\"for each 2-tuple, invokes first item.  the first pair where\n  the first item returns logical true, result is passed to second\n  function in pair.  Like an if-elif-elif.. chain\"\"\"\n  for (cond_lambda, then_lambda) in phrases:\n    c = cond_lambda()\n    if c:\n      return then_lambda(c) \n  return None\n\n\ncond_with( \n  ((lambda: re.match('foo (\\w+) bar (\\d+)', line)), \n      (lambda m: \n          ... # do stuff with m.group(1) and m.group(2)\n          )),\n  ((lambda: re.match('baz whoo_(\\d+)', line)),\n      (lambda m:\n          ... # do stuff with m.group(1)\n          )),\n  ...)\n</code>\n</pre>\n", "senID": 12}, {"text": ["And now the code barely even looks like Python, let alone understandable to Python programmers (is that Lisp?", ")."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "looks", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I think the moral of this story is that Python is not optimized for this sort of idiom.", "You really need to just be a little verbose and live with a large nesting factor of else conditions."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["You could write a utility class to do the \"save state and return result\" operation.", "I don't think this is that hackish.", "It's fairly trivial to implement:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Var(object):\n    def __init__(self, val=None): self.val = val\n\n    def set(self, result):\n        self.val = result\n        return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["And then use it as:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n lastMatch = Var()\n\nif lastMatch.set(re.match('foo (\\w+) bar (\\d+)', line)):\n    print lastMatch.val.groups()\n\nelif lastMatch.set(re.match('baz whoo_(\\d+)', line)):\n    print lastMatch.val.groups()\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n class last(object):\n  def __init__(self, wrapped, initial=None):\n    self.last = initial\n    self.func = wrapped\n\n  def __call__(self, *args, **kwds):\n    self.last = self.func(*args, **kwds)\n    return self.last\n\ndef test():\n  \"\"\"\n  &gt;&gt;&gt; test()\n  crude, but effective: (oYo)\n  \"\"\"\n  import re\n  m = last(re.compile(\"(oYo)\").match)\n  if m(\"abc\"):\n    print(\"oops\")\n  elif m(\"oYo\"): #A\n    print(\"crude, but effective: (%s)\" % m.last.group(1)) #B\n  else:\n    print(\"mark\")\n\nif __name__ == \"__main__\":\n  import doctest\n  doctest.testmod()\n</code>\n</pre>\n", "senID": 0}, {"text": ["last is also suitable as a decorator."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "last", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Realized that in my effort to make it self-testing and work in 2.5, 2.6, and 3.0 that I obscured the real solution somewhat.", "The important lines are marked #A and #B above, where you use the same object to test (name it match or is_somename) and retrieve its last value.", "Easy to abuse, but also easy to tweak and, if not pushed too far, get surprisingly clear code."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "match", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "is_somename", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Based on the great answers to this question, I've concocted the following mechanism.", "It appears like a general way to solve the \"no assignment in conditions\" limitation of Python.", "The focus is transparency, implemented by silent delegation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Var(object):\n    def __init__(self, val=None):\n        self._val = val\n\n    def __getattr__(self, attr):\n        return getattr(self._val, attr)\n\n    def __call__(self, arg):\n        self._val = arg\n        return self._val\n\n\nif __name__ == \"__main__\":\n    import re\n\n    var = Var()\n\n    line = 'foo kwa bar 12'\n\n    if var(re.match('foo (\\w+) bar (\\d+)', line)):\n        print var.group(1), var.group(2)\n    elif var(re.match('baz whoo_(\\d+)', line)):\n        print var.group(1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In the general case, this is a thread-safe solution, because you can create your own instances of Var.", "For more ease-of-use when threading is not an issue, a default Var object can be imported and used.", "Here's a module holding the Var class:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Var", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Var(object):\n    def __init__(self, val=None):\n        self._val = val\n\n    def __getattr__(self, attr):\n        return getattr(self._val, attr)\n\n    def __call__(self, arg):\n        self._val = arg\n        return self._val\n\nvar = Var()\n</code>\n</pre>\n", "senID": 3}, {"text": ["And here's the user's code:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from var import Var, var\nimport re\n\nline = 'foo kwa bar 12'\n\nif var(re.match('foo (\\w+) bar (\\d+)', line)):\n    print var.group(1), var.group(2)\nelif var(re.match('baz whoo_(\\d+)', line)):\n    print var.group(1)\n</code>\n</pre>\n", "senID": 5}, {"text": ["While not thread-safe, for a lot of simple scripts this provides a useful shortcut."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Probably the simplest solution is to return early so you can get back to creating variables instead of needing to make an immediate test."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_results(line):\n    m = re.match('foo (\\w+) bar (\\d+)', line)\n    if m:\n      # do stuff with .group(1) and .group(2)\n      return result\n    m = re.match('baz whoo_(\\d+)', line)\n    if m:\n      # do stuff with .group(1)\n      return other_result\n    # etc.\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way you avoid excessive nesting."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]