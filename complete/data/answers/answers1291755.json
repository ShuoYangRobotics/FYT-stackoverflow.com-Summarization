[[{"code": "<pre>\n<code>\n server = request.META.get('wsgi.file_wrapper', None)\nif server is not None and server.__module__ == 'django.core.servers.basehttp':\n    print 'inside dev'\n</code>\n</pre>\n", "senID": 0}, {"text": ["Of course, wsgi.file_wrapper might be set on META, and have a class from a module named django.core.servers.basehttp by extreme coincidence on another server environment, but I hope this will have you covered."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "wsgi.file_wrapper", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "django.core.servers.basehttp", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["By the way, I discovered this by making a syntatically invalid template while running on the development server, and searched for interesting stuff on the Traceback and the Request information sections, so I'm just editing my answer to corroborate with Nate's ideas."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Traceback", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Request information", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Typically I set an variable called environment and set it to \"DEVELOPMENT\", \"STAGING\" or \"PRODUCTION\".", "Within the settings file I can then add basic logic to change which settings are being used, based on environment."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "environment", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT: Additionally, you can simply use this logic to include different settings.py files that override the base settings.", "For example:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "settings.py", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n if environment == \"DEBUG\":\n    from debugsettings import *\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I put the following in my settings.py to distinguish between the standard dev server and fcgi"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nRUNNING_DEVSERVER = (sys.argv[1] == 'runserver')\n</code>\n</pre>\n", "senID": 1}, {"text": ["This also relies on convention, however."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["settings.DEBUG could be True and running under Apache or some other non-development server.", "It will still run.", "As far as I can tell, there is nothing in the run-time environment short of examining the pid and comparing to pids in the OS that will give you this information."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["One difference between the development and deployment environment is going to be the server that it\u2019s running on.", "What exactly is different will depend on your dev and deployment environments."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Knowing your own dev and deploy environments, the HTTP request variables could be used to distinguish between the two.", "Look at request variables like request.META.HTTP_HOST, request.META.SERVER_NAME and request.META.SERVER_PORT and compare them in the two environments."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "request variables", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/ref/request-response/"}, {"text": "request.META.HTTP_HOST", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "request.META.SERVER_NAME", "childNum": 0, "tag": "code", "childList": []}, {"text": "request.META.SERVER_PORT", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I bet you\u2019ll find something quite obvious that\u2019s different and can be used to detect your development environment.", "Do the test in settings.py and set a variable that you can use elsewhere."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "settings.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Relying on settings.DEBUG is the most elegant way AFAICS as it is also used in Django code base on occasion. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I suppose what you really want is a way to set that flag automatically without needing you update it manually everytime you upload the project to production servers. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For that I check the path of settings.py (in settings.py) to determine what server the project is running on:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if __file__ == \"path to settings.py in my development machine\":\n    DEBUG = True\nelif __file__ in [paths of production servers]:\n    DEBUG = False\nelse:\n    raise WhereTheHellIsThisServedException()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Mind you, you might also prefer doing this check with environment variables as @Soviut suggests.", "But as someone developing on Windows and serving on Linux checking the file paths was plain easier than going with environment variables."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I came across this problem just now, and ended up writing a solution similar to Aryeh Leib Taurog's.", "My main difference is that I want to differentiate between a production and dev environments when running the server, but also when running some one-off scripts for my app (which I run like DJANGO_SETTINGS_MODULE=settings python [the script] ).", "In this case, simply looking at whether argv[1] == runserver isn't enough.", "So what I came up with is to pass an extra command-line argument when I run the devserver, and also when I run my scripts, and just look for that argument in settings.py.", "So the code looks like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if '--in-development' in sys.argv:\n    ## YES! we're in dev\n    pass\nelse:\n    ## Nope, this is prod\n    pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["then, running the django server becomes"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["python manage.py runserver [whatever options you want] --in-development"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["and running my scripts is as easy as"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["DJANGO_SETTINGS_MODULE=settings python [myscript] --in-development"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Just make sure the extra argument you pass along doens't conflict with anything django (in reality I use my app's name as part of the argument).", "I think this is pretty decent, as it lets me control exactly when my server and scripts will behave as prod or dev, and I'm not relying on anyone else's conventions, other than my own."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["EDIT: manage.py complains if you pass unrecognized options, so you need to change the code in settings.py to be something like"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n if sys.argv[0] == 'manage.py' or '--in-development' in sys.argv:\n    # ...\n    pass\n</code>\n</pre>\n", "senID": 8}, {"text": ["Although this works, I recognize it's not the most elegant of solutions..."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]