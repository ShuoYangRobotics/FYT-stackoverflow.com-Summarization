[[{"text": ["You could take a look at: Get last n lines of a file with Python, similar to tail"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Get last n lines of a file with Python, similar to tail", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/136168/get-last-n-lines-of-a-file-with-python-similar-to-tail"}]}, {"text": ["It is really close to what you need."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Use the file's seek method with a negative offset and whence=os.SEEK_END to read a block from the end of the file.", "Search that block for the last line end character(s) and grab all the characters after it.", "If there is no line end, back up farther and repeat the process."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "seek", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "whence=os.SEEK_END", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def last_line(in_file, block_size=1024, ignore_ending_newline=False):\n    suffix = \"\"\n    in_file.seek(0, os.SEEK_END)\n    in_file_length = in_file.tell()\n    seek_offset = 0\n\n    while(-seek_offset &lt; in_file_length):\n        # Read from end.\n        seek_offset -= block_size\n        if -seek_offset &gt; in_file_length:\n            # Limit if we ran out of file (can't seek backward from start).\n            block_size -= -seek_offset - in_file_length\n            if block_size == 0:\n                break\n            seek_offset = -in_file_length\n        in_file.seek(seek_offset, os.SEEK_END)\n        buf = in_file.read(block_size)\n\n        # Search for line end.\n        if ignore_ending_newline and seek_offset == -block_size and buf[-1] == '\\n':\n            buf = buf[:-1]\n        pos = buf.rfind('\\n')\n        if pos != -1:\n            # Found line end.\n            return buf[pos+1:] + suffix\n\n        suffix = buf + suffix\n\n    # One-line file.\n    return suffix\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that this will not work on things that don't support seek, like stdin or sockets.", "In those cases, you're stuck reading the whole thing (like the tail command does)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "seek", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tail", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Not the straight forward way, but probably much faster than a simple Python implementation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n line = subprocess.check_output(['tail', '-1', filename])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you do know the maximal length of a line, you can do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def getLastLine(fname, maxLineLength=80):\n    fp=file(fname, \"rb\")\n    fp.seek(-maxLineLength-1, 2) # 2 means \"from the end of the file\"\n    return fp.readlines()[-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works on my windows machine.", "But I do not know what happens on other platforms if you open a text file in binary mode.", "The binary mode is needed if you want to use seek()."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Seek to the end of the file minus 100 bytes or so.", "Do a read and search for a newline.", "If here is no newline, seek back another 100 bytes or so.", "Lather, rinse, repeat.", "Eventually you'll find a newline.", "The last line begins immediately after that newline."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Best case scenario you only do one read of 100 bytes. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you can pick a reasonable maximum line length, you can seek to nearly the end of the file before you start reading."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n myfile.seek(-max_line_length, os.SEEK_END)\nline = myfile.readlines()[-1]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You shouldn't have to loop through all the lines.", "Can you just read the files into a list and index the last line?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I found this example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://www.daniweb.com/software-development/python/threads/121557"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.daniweb.com/software-development/python/threads/121557", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.daniweb.com/software-development/python/threads/121557"}]}], [{"text": ["Could you load the file into a mmap, then use mmap.rfind(string[, start[, end]]) to find the second last EOL character in the file?", "A seek to that point in the file should point you to the last line I would think."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mmap", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/mmap.html#module-mmap"}]}], [{"text": ["The inefficiency here is not really due to Python, but to the nature of how files are read.", "The only way to find the last line is to read the file in and find the line endings.", "However, the seek operation may be used to skip to any byte offset in the file.", "You can, therefore begin very close to the end of the file, and grab larger and larger chunks as needed until the last line ending is found:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from os import SEEK_END\n\ndef get_last_line(file):\n  CHUNK_SIZE = 1024 # Would be good to make this the chunk size of the filesystem\n\n  last_line = \"\"\n\n  while True:\n    # We grab chunks from the end of the file towards the beginning until we \n    # get a new line\n    file.seek(-len(last_line) - CHUNK_SIZE, SEEK_END)\n    chunk = file.read(CHUNK_SIZE)\n\n    if not chunk:\n      # The whole file is one big line\n      return last_line\n\n    if not last_line and chunk.endswith('\\n'):\n      # Ignore the trailing newline at the end of the file (but include it \n      # in the output).\n      last_line = '\\n'\n      chunk = chunk[:-1]\n\n    nl_pos = chunk.rfind('\\n')\n    # What's being searched for will have to be modified if you are searching\n    # files with non-unix line endings.\n\n    last_line = chunk[nl_pos + 1:] + last_line\n\n    if nl_pos == -1:\n      # The whole chunk is part of the last line.\n      continue\n\n    return last_line\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n lines = file.readlines()\nfileHandle.close()\nlast_line = lines[-1]\n</code>\n</pre>\n", "senID": 0}]]