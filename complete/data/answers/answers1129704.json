[[{"text": ["Third time's the charm:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def perm(i, seq):\n  seq = tuple(seq)\n  n = len(seq)\n  max = n # number of perms with 'digits' digits\n  digits = 1\n  last_max = 0\n  while i &gt;= max:\n    last_max = max\n    max = n * (max + 1)\n    digits += 1\n  result = ''\n  i -= last_max\n  while digits:\n    digits -= 1\n    result = seq[i % n] + result\n    i //= n\n  return result\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Multi-radix solution at the bottom."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import math\ndef idx_to_length_and_value(n, length):\n    chars = 1\n    while True:\n        cnt = pow(length, chars)\n        if cnt &gt; n:\n            return chars, n\n\n        chars += 1\n        n -= cnt\n\ndef conv_base(chars, n, values):\n    ret = []\n    for i in range(0, chars):\n        c = values[n % len(values)]\n        ret.append(c)\n        n /= len(values)\n\n    return reversed(ret)\n\nvalues = \"ABCDEF\"\nfor i in range(0, 100):\n    chars, n = idx_to_length_and_value(i, len(values))\n    print \"\".join(conv_base(chars, n, values))\n</code>\n</pre>\n", "senID": 1}, {"tag": "hr", "senID": 2}, {"code": "<pre>\n<code>\n import math\ndef get_max_value_for_digits(digits_list):\n    max_vals = []\n\n    for val in digits_list:\n        val = len(val)\n        if max_vals:\n            val *= max_vals[-1]\n        max_vals.append(val)\n    return max_vals\n\ndef idx_to_length_and_value(n, digits_list):\n    chars = 1\n    max_vals = get_max_value_for_digits(digits_list)\n\n    while True:\n        if chars-1 &gt;= len(max_vals):\n            raise OverflowError, \"number not representable\"\n        max_val = max_vals[chars-1]\n        if n &lt; max_val:\n            return chars, n\n\n        chars += 1\n        n -= max_val\n\ndef conv_base(chars, n, digits_list):\n    ret = []\n    for i in range(chars-1, -1, -1):\n        digits = digits_list[i]\n        radix = len(digits)\n\n        c = digits[n % len(digits)]\n        ret.append(c)\n        n /= radix\n\n    return reversed(ret)\n\ndigits_list = [\"ABCDEF\", \"ABC\", \"AB\"]\nfor i in range(0, 120):\n    chars, n = idx_to_length_and_value(i, digits_list)\n    print \"\".join(conv_base(chars, n, digits_list))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["What you're doing is close to a conversion from base 10 (your number) to base 6, with ABCDEF being your digits.", "The only difference is \"AA\" and \"A\" are different, which is wrong if you consider \"A\" the zero-digit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you add the next greater power of six to your number, and then do a base conversion to base 6 using these digits, and finally strip the first digit (which should be a \"B\", i.e.", "a \"1\"), you've got the result."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I just want to post an idea here, not an implementation, because the question smells a lot like homework to me (I do give the benefit of the doubt; it's just my feeling)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["First compute the length by summing up powers of six until you exceed your index (or better use the formula for the geometric series)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Subtract the sum of smaller powers from the index."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Compute the representation to base 6, fill leading zeros and map 0 -> A, ..., 5 -> F."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This works (and is what i finally settled on), and thought it was worth posting because it is tidy.", "However it is slower than most answers.", "Can i perform % and / in the same operation?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f0(x, alph='ABCDE'):\n    result = ''\n    ct = len(alph)\n    while x&gt;=0:\n        result += alph[x%ct]\n        x /= ct-1\n    return result[::-1]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n alphabet = 'ABCDEF'\n\ndef idx_to_excel_column_name(x):\n  x += 1 # Make us skip \"\" as a valid word\n  group_size = 1\n  for num_letters in itertools.count():\n    if x &lt; group_size:\n      break\n    x -= group_size\n    group_size *= len(alphabet)\n  letters = []\n  for i in range(num_letters):\n    x, m = divmod(x, len(alphabet))\n    letters.append(alphabet[m])\n  return ''.join(reversed(letters))\n\ndef excel_column_name_to_idx(name):\n  q = len(alphabet)\n  x = 0\n  for letter in name:\n    x *= q\n    x += alphabet.index(letter)\n  return x+q**len(name)//(q-1)-1\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Since we are converting from a number Base(10) to a number Base(7), whilst avoiding all \"0\" in the output, we will have to adjust the orginal number, so we do skip by one every time the result would contain a \"0\"."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "converting", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 1 =&gt; A,  or 1  in base [0ABCDEF]\n 7 =&gt; AA, or 8  in base [0ABCDEF]\n13 =&gt; BA, or 15 in base [0ABCDEF]\n42 =&gt; FF, or 48 in base [0ABCDEF]\n43 =&gt;AAA, or 50 in base [0ABCDEF]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's some Perl code that shows what I'm trying to explain\n(sorry, didn't see this is a Phython request)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n use strict;\nuse warnings;\nmy @Symbols=qw/0 A B C D E F/;\nmy $BaseSize=@Symbols ;\nfor my $NR ( 1 .. 45) {\n   printf (\"Convert %3i =&gt; %s\\n\",$NR ,convert($NR));\n}\n\nsub convert {\n   my ($nr,$res)=@_;\n   return $res unless $nr&gt;0;\n   $res=\"\" unless defined($res);\n   #Adjust to skip '0'\n   $nr=$nr + int(($nr-1)/($BaseSize-1));\n   return convert(int($nr/$BaseSize),$Symbols[($nr % ($BaseSize))] . $res);\n}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In perl you'd just convert your input i from base(10) to base(length of \"ABCDEF\"), then do a tr/012345/ABCDEF/ which is the same as y/0-5/A-F/.", "Surely Python has a similar feature set."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "tr/012345/ABCDEF/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y/0-5/A-F/", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Oh, as pointed out by Yarichu the combinations are a tad different because if A represented 0, then there would be no combinations with leading A (though he said it a bit different).", "It seems I thought the problem to be more trivial than it is.", "You cannot just transliterate different base numbers, because numbers containing the equivalent of 0 would be \nskipped in the sequence."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Yarichu", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/40916/yairchu"}]}, {"text": ["So what I suggested is actually only the last step of what starblue suggested, which is essentially what Laurence Gonsalves implemented ftw.", "Oh, and there is no transliteration (tr// or y//) operation in Python, what a shame."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "starblue", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/49246/starblue"}, {"text": "suggested", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "#1130119"}, {"text": "Laurence Gonsalves", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/90848/laurence-gonsalves"}, {"text": "implemented", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "#1129732"}, {"text": "tr//", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "y//", "childNum": 0, "tag": "code", "childList": []}]}]]