[[{"text": ["This is to be expected with computer arithmetic.", "It is following particular rules, such as IEEE 754, that probably don't match the math you learned in school."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "IEEE 754", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/IEEE%5F754"}]}, {"text": ["If this actually matters, use Python's decimal type."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "actually", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/decimal.html", "text": "decimal type", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from decimal import Decimal, Context\nctx = Context(prec=20)\ntwo = Decimal(2)\nctx.divide(ctx.power(two, Decimal(31)).ln(ctx), two.ln(ctx))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You should read \"What Every Computer Scientist Should Know About Floating-Point Arithmetic\". "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.sun.com/source/806-3568/ncg_goldberg.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.sun.com/source/806-3568/ncg_goldberg.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.sun.com/source/806-3568/ncg_goldberg.html"}]}], [{"text": ["Always assume that floating point operations will have some error in them and check for equality taking that error into account (either a percentage value like 0.00001% or a fixed value like 0.00000000001).", "This inaccuracy is a given since not all decimal numbers can be represented in binary with a fixed number of bits precision."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Always", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Your particular case is not one of them if Python uses IEEE754 since 31 should be easily representable with even single precision.", "It's possible however that it loses precision in one of the many steps it takes to calculate log2231, simply because it doesn't have code to detect special cases like a direct power of two."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "2", "childNum": 0, "tag": "sub", "pos": 1, "childList": []}, {"text": "31", "childNum": 0, "tag": "sup", "childList": []}]}], [{"text": ["floating-point operations are never exact.", "They return a result which has an acceptable relative error, for the language/hardware infrastructure."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In general, it's quite wrong to assume that floating-point operations are precise, especially with single-precision.", "\"Accuracy problems\" section from Wikipedia Floating point article :)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "\"Accuracy problems\" section", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Floating%5Fpoint#Accuracy%5Fproblems"}]}], [{"text": ["IEEE double floating point numbers have 52 bits of precision.", "Since 10^15 &lt; 2^52 &lt; 10^16, a double has between 15 and 16 significant figures.", "The result 31.000000000000004 is correct to 16 figures, so it is as good as you can expect."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "52 bits of precision", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/"}]}], [{"text": ["This is normal.", "I would expect log10 to be more accurate then log(x, y), since it knows exactly what the base of the logarithm is, also there may be some hardware support for calculating base-10 logarithms."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The representation (float.__repr__) of a number in python tries to return a string of digits as close to the real value as possible when converted back, given that IEEE-754 arithmetic is precise up to a limit.", "In any case, if you printed the result, you wouldn't notice:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "repr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "float.__repr__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "print", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from math import log\n&gt;&gt;&gt; log(2**31,2)\n31.000000000000004\n&gt;&gt;&gt; print log(2**31,2)\n31.0\n</code>\n</pre>\n", "senID": 1}, {"text": ["print converts its arguments to strings (in this case, through the float.__str__ method), which caters for the inaccuracy by displaying less digits:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "print", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "float.__str__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; log(1000000,2)\n19.931568569324174\n&gt;&gt;&gt; print log(1000000,2)\n19.9315685693\n&gt;&gt;&gt; 1.0/10\n0.10000000000000001\n&gt;&gt;&gt; print 1.0/10\n0.1\n</code>\n</pre>\n", "senID": 3}, {"text": ["usuallyuseless' answer is very useful, actually :)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]