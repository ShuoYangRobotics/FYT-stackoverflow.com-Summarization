[[{"text": ["Sorry, misunderstood the question with my first answer.", "You can accomplish the ability to have optional arguments to command line flags use the callback action type when you define an option.", "Use the following function as a call back (you will likely wish to tailor to your needs) and configure it for each of the flags that can optionally receive an argument:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "callback", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import optparse\n\ndef optional_arg(arg_default):\n    def func(option,opt_str,value,parser):\n        if parser.rargs and not parser.rargs[0].startswith('-'):\n            val=parser.rargs[0]\n            parser.rargs.pop(0)\n        else:\n            val=arg_default\n        setattr(parser.values,option.dest,val)\n    return func\n\ndef main(args):\n    parser=optparse.OptionParser()\n    parser.add_option('--foo',action='callback',callback=optional_arg('empty'),dest='foo')\n    parser.add_option('--file',action='store_true',default=False)\n    return parser.parse_args(args)\n\nif __name__=='__main__':\n    import sys\n    print main(sys.argv)\n</code>\n</pre>\n", "senID": 1}, {"senID": 2}, {"text": ["Running from the command line you'll see this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # python parser.py\n(&lt;Values at 0x8e42d8: {'foo': None, 'file': False}&gt;, [])\n\n# python parser.py --foo\n(&lt;Values at 0x8e42d8: {'foo': 'empty', 'file': False}&gt;, [])\n\n# python parser.py --foo bar\n(&lt;Values at 0x8e42d8: {'foo': 'bar', 'file': False}&gt;, [])\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I don't think optparse can do this.", "argparse is a different (non-standard) module that can handle situations like this where the options have optional values."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "optparse", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "argparse", "tag": "a", "pos": 1, "childList": [{"text": "argparse", "tag": "code"}], "childNum": 1, "href": "http://argparse.googlecode.com/"}, {"text": "argparse", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://argparse.googlecode.com/svn/trunk/doc/argparse-vs-optparse.html#more-nargs-options", "text": "handle situations like this", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["With optparse you have to either have to specify the option including it's value or leave out both."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "optparse", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Yes, there is an argument to do so when you add the option:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from optparse import OptionParser\nparser = OptionParser()\nparser.add_option(\"--SomeData\",action=\"store\", dest=\"TheData\", default='')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Give the default argument the value you want the option to have it is to be specified but optionally have an argument."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "default", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Optparse already allows you to pass the empty string as an option argument.", "So if possible, treat the empty string as \"no value\".", "For long options, any of the following work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my_script --opt=   --anotheroption\nmy_script --opt='' --anotheroption\nmy_script --opt=\"\" --anotheroption\nmy_script --opt '' --anotheroption\nmy_script --opt \"\" --anotheroption\n</code>\n</pre>\n", "senID": 1}, {"text": ["For short-style options, you can use either of:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n my_script -o '' --anotheroption\nmy_script -o \"\" --anotheroption\n</code>\n</pre>\n", "senID": 3}, {"text": ["Caveat: this has been tested under Linux and should work the same under other Unixlike systems; Windows handles command line quoting differently and might not accept all of the variants listed above."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Great response from Mark Roddy.", "One change I made to make things a bit cleaner for me was to change the first callback definition line from:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def optional_arg(arg_default):\n</code>\n</pre>\n", "senID": 1}, {"text": ["to:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def optional_arg(arg_default=\"None\"):\n</code>\n</pre>\n", "senID": 3}, {"text": ["Having the function argument set with a default allows it to be called with just \"optional_arg()\", which saves quite a bit of typing if you have a large number of arguments that use it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Mark Roddy's solution would work, but it requires attribute modification of a parser object during runtime, and has no support for alternative option formattings other than - or --.", "A slightly less involved solution is to modify the sys.argv array before running optparse and insert an empty string (\"\") after a switch which doesn't need to have arguments.", "The only constraint of this method is that you have your options default to a predictable value other than the one you are inserting into sys.argv (I chose None for the example below, but it really doesn't matter)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The following code creates an example parser and set of options, extracts an array of allowed switches from the parser (using a little bit of instance variable magic), and then iterates through sys.argv, and every time it finds an\nallowed switch, it checks to see if it was given without any arguments following it .", "If there is no argument after a switch, the empty string will be inserted on the command\nline.", "After altering sys.argv, the parser is invoked, and you can check for options whose values are \"\", and act accordingly. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #Instantiate the parser, and add some options; set the options' default values to None, or something predictable that\n#can be checked later.\nPARSER_DEFAULTVAL = None\nparser = OptionParser(usage=\"%prog -[MODE] INPUT [options]\")\n#This method doesn't work if interspersed switches and arguments are allowed.\nparser.allow_interspersed_args = False\nparser.add_option(\"-d\", \"--delete\", action=\"store\", type=\"string\", dest=\"to_delete\", default=PARSER_DEFAULTVAL)\nparser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"to_add\", default=PARSER_DEFAULTVAL)\n\n#Build a list of allowed switches, in this case ['-d', '--delete', '-a', '--add'] so that you can check if something\n#found on sys.argv is indeed a valid switch. This is trivial to make by hand in a short example, but if a program has\n#a lot of options, or if you want an idiot-proof way of getting all added options without modifying a list yourself,\n#this way is durable. If you are using OptionGroups, simply run the loop below with each group's option_list field.\nallowed_switches = []\nfor opt in parser.option_list:\n    #Add the short (-a) and long (--add) form of each switch to the list.\n    allowed_switches.extend(opt._short_opts + opt._long_opts)\n\n#Insert empty-string values into sys.argv whenever a switch without arguments is found.\nfor a in range(len(sys.argv)):\n    arg = sys.argv[a]\n    #Check if the sys.argv value is a switch\n    if arg in allowed_switches:\n        #Check if it doesn't have an accompanying argument (i.e. if it is followed by another switch, or if it is last\n        #on the command line)\n        if a == len(sys.argv) - 1 or argv[a + 1] in allowed_switches:\n            sys.argv.insert(a + 1, \"\")\n\noptions, args = parser.parse_args()\n\n#If the option is present (i.e. wasn't set to the default value)\nif not (options.to_delete == PARSER_DEFAULTVAL):\n    if options.droptables_ids_csv == \"\":\n        #The switch was not used with any arguments.\n        ...\n    else:\n        #The switch had arguments.\n        ...\n</code>\n</pre>\n", "senID": 2}]]