[[{"text": ["Repeating a string a fixed number of times is a built-in operation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n 'abc' * 7\n</code>\n</pre>\n", "senID": 1}, {"text": ["So, just calculate the number of repeats you need to reach the length you want, and put that on the RHS.", "You'll then need to trim it to the right length."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(It appears that this is what the other answer does, but a little bit more explanation seemed useful."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n def rep(s, m):\n    a, b = divmod(m, len(s))\n    return s * a + s[:b]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def repeat_to_length(string_to_expand, length):\n   return (string_to_expand * ((length/len(string_to_expand))+1))[:length]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n from itertools import cycle, islice\ndef srepeat(string, n):\n   return ''.join(islice(cycle(string), n))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Yay recursion!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Yay recursion!", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def trunc(s,l):\n    if l &gt; 0:\n        return s[:l] + trunc(s, l - len(s))\n    return ''\n</code>\n</pre>\n", "senID": 1}, {"text": ["Won't scale forever, but it's fine for smaller strings.", "And it's pretty."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I admit I just read the Little Schemer and I like recursion right now."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["How about string * (length / len(string)) + string[0:(length % len(string))]"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "string * (length / len(string)) + string[0:(length % len(string))]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This is one way to do it using a list comprehension, though it's increasingly wasteful as the length of the rpt string increases."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "rpt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def repeat(rpt, length):\n    return ''.join([rpt for x in range(0, (len(rpt) % length))])[:length]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Perhaps not the most efficient solution, but certainly short &amp; simple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def repstr(string, length):\n    return (string * length)[0:length]\n\nrepstr(\"foobar\", 14)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Gives \"foobarfoobarfo\".", "One thing about this version is that if length &lt; len(string) then the output string will be truncated.", "For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n repstr(\"foobar\", 3)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Gives \"foo\"."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit: actually to my surprise, this is faster than the currently accepted solution (the 'repeat_to_length' function), at least on short strings:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from timeit import Timer\nt1 = Timer(\"repstr('foofoo', 30)\", 'from __main__ import repstr')\nt2 = Timer(\"repeat_to_length('foofoo', 30)\", 'from __main__ import repeat_to_length')\nt1.timeit()  # gives ~0.35 secs\nt2.timeit()  # gives ~0.43 secs\n</code>\n</pre>\n", "senID": 6}, {"text": ["Presumably if the string was long, or length was very high (that is, if the wastefulness of the string * length part was high) then it would perform poorly.", "And in fact we can modify the above to verify this:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "string * length", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from timeit import Timer\nt1 = Timer(\"repstr('foofoo' * 10, 3000)\", 'from __main__ import repstr')\nt2 = Timer(\"repeat_to_length('foofoo' * 10, 3000)\", 'from __main__ import repeat_to_length')\nt1.timeit()  # gives ~18.85 secs\nt2.timeit()  # gives ~1.13 secs\n</code>\n</pre>\n", "senID": 8}]]