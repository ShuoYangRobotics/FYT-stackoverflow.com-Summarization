[[{"text": ["for rec in inh: reads one line at a time -- not what you want for a binary file.", "Read 4 bytes at a time (with a while loop and inh.read(4)) instead (or read everything into memory with a single .read() call, then unpack successive 4-byte slices).", "The second approach is simplest and most practical as long as the amount of data involved isn't huge:"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "for rec in inh:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "line", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "binary", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "inh.read(4)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".read()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import struct\nwith open('test.bin', 'rb') as inh:\n    indata = inh.read()\nfor i in range(0, len(data), 4):\n    pos = struct.unpack('i', data[i:i+4])  \n    print pos\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you do fear potentially huge amounts of data (which would take more memory than you have available), a simple generator offers an elegant alternative:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import struct\ndef by4(f):\n    rec = 'x'  # placeholder for the `while`\n    while rec:\n        rec = f.read(4)\n        if rec: yield rec           \nwith open('test.bin', 'rb') as inh:\n    for rec in by4(f):\n        pos = struct.unpack('i', rec)  \n        print pos\n</code>\n</pre>\n", "senID": 3}, {"text": ["A key advantage to this second approach is that the by4 generator can easily be tweaked (while maintaining the specs: return a binary file's data 4 bytes at a time) to use a different implementation strategy for buffering, all the way to the first approach (read everything then parcel it out) which can be seen as \"infinite buffering\" and coded:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "by4", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def by4(f):\n    data = inf.read()\n    for i in range(0, len(data), 4):\n        yield data[i:i+4]\n</code>\n</pre>\n", "senID": 5}, {"text": ["while leaving the \"application logic\" (what to do with that stream of 4-byte chunks) intact and independent of the I/O layer (which gets encapsulated within the generator)."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I think \"for rec in inh\" is supposed to read 'lines', not bytes.", "What you want is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while True:\n    rec = inh.read(4) # Or inh.read(struct.calcsize('i'))\n    if len(rec) != 4:\n        break\n    (pos,) = struct.unpack('i', rec)\n    print pos\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or as others have mentioned:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n while True:\n    try:\n        (pos,) = struct.unpack_from('i', inh)\n    except (some_exception...):\n        break\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Check the size of the packed integers:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; pos\n[7623, 3015, 3231, 3829]\n&gt;&gt;&gt; [struct.pack('i',e) for e in pos]\n['\\xc7\\x1d\\x00\\x00', '\\xc7\\x0b\\x00\\x00', '\\x9f\\x0c\\x00\\x00', '\\xf5\\x0e\\x00\\x00']\n</code>\n</pre>\n", "senID": 1}, {"text": ["We see 4-byte strings, it means that reading should be 4 bytes at a time:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; inh=open('test.bin','rb')\n&gt;&gt;&gt; b1=inh.read(4)\n&gt;&gt;&gt; b1\n'\\xc7\\x1d\\x00\\x00'\n&gt;&gt;&gt; struct.unpack('i',b1)\n(7623,)\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is the original int!", "Extending into a reading loop is left as an exercise ."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You can probably use array as well if you want:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "array", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import array  \npos = array.array('i', [7623, 3015, 3231, 3829]) \ninh = open('test.bin', 'wb')  \npos.write(inh)\ninh.close()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then use array.array.fromfile or fromstring to read it back."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "array.array.fromfile", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fromstring", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Your iterator isn't reading 4 bytes at a time so I imagine it's rather confused.", "Like SilentGhost mentioned, it'd probably be best to use unpack_from()."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This function reads all bytes from file"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def read_binary_file(filename):\ntry:\n    f = open(filename, 'rb')\n    n = os.path.getsize(filename)\n    data = array.array('B')\n    data.read(f, n)\n    f.close()\n    fsize = data.__len__()\n    return (fsize, data)\n\nexcept IOError:\n    return (-1, [])\n\n# somewhere in your code\nt = read_binary_file(FILENAME)\nfsize = t[0]\n\nif (fsize &gt; 0):\n    data = t[1]\n    # work with data\nelse:\n    print 'Error reading file'\n</code>\n</pre>\n", "senID": 1}]]