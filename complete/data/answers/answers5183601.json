[[{"text": ["This works for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n __loader__.fullname\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also if I do python -m b.c from a\\ I get 'b.c' as expected."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Not entirely sure what the __loader__ attribute is so let me know if this is no good."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["edit: It comes from PEP 302: http://www.python.org/dev/peps/pep-0302/"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://www.python.org/dev/peps/pep-0302/", "text": "http://www.python.org/dev/peps/pep-0302/", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Interesting snippets from the link:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["So it looks like it should work fine in all cases."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["When run with -m, sys.path[0] contains the full path to the module.", "You could use that to build the name."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sys.path[0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["source: http://docs.python.org/using/cmdline.html#command-line"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/using/cmdline.html#command-line", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/using/cmdline.html#command-line"}]}, {"text": ["Another option may be the __package__ built in variable which is available within modules."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__package__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I think you're actually looking for the __name__ special variable.", "From the Python documentation:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__name__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Python documentation", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/modules.html"}]}, {"text": ["If you run a file directly, this name will 'main'.", "However, if you're in a module (as in the case where you're using the -m flag, or any other import), it will be the complete name of the module."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "main", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["The only way is to do path manipulation with os.getcwd(), os.path, file and whatnot, as you mentioned."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "file", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Actually, it could be a good patch to implement for optparse / argparse (which currently replace \"%prog\" in the usage string with os.path.basename(sys.argv[0]) -- you are using optparse, right?", "-- ), i.e.", "another special string like %module."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "are", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Can't see why there is such a restriction as \"python -m a.b.c\".", "Of course, the actual module could be inside some zip or whatever, but I'd rather simplified the whole approach with a wrapper script, which makes sure execution happens in the right context, with right python instance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The wrapper can contain as little as:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import sys\n__import__(sys.argv[1])\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then you can use your favorite method to get the module name for usage."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["back to the original requirement.", "If I understood correctly, the idea is that someone runs a python file in some sub-sub-directory to find out from usage message that it is really a module of some.mega.package."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I think, there is no reliable, generic way to determine if one wants to run c, b.c or a.b.c module, without some file system analysis with certain heuristics (say, finding all __init__.py in the outer directories till the points there are no more __init__.py), and even with the analysis its not 100%."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["you should hardcode a.b.c in your help, if you distribute the package as such then that's the way to call it regardless of where a is located in the filesystem, as long as it's on the PYTHONPATH it'll be imported."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "a.b.c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}]}]]