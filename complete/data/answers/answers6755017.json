[[{"text": ["Do you get a stackoverflow exception per chance :) ?", "Since python does not have tail-call recursion optimization, you can not infinitely nest function calls.", "For this reason you should consider putting your logic into an infinite while loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while True:\n    //logic to call func1, 2, 3 or whatever\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your program is essentially an infinitely recursive program.", "You're blowing away Python's call stack with extreme prejudice."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I ... am not sure I fully grasp why things are chained together the way they are.", "In Python, at least in my experience, the standard idiom for \"a program that runs forever\" is something along these lines:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while True:\n  function_1()\n</code>\n</pre>\n", "senID": 1}, {"text": ["What you're setting up is infinite recursion, which will eventually pass the interpreter's max recursion level setting, causing an exception you don't get to catch and ignore."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This programming style seems to expect tail call optimization, which is not supported in Python.", "Python's call stack keeps track of every function that hasn't returned, and since you're just calling new functions infinitely you'll excede the maximum size of the stack very quickly, and your program will crash."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "tail call", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Tail_call"}]}], [{"text": ["You should not implement a loop by calling your main from inside the exception handler.", "Try something more like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while True:\n    try:\n        func1() or func2() or func3()\n    except:\n        logger.exception(\"somthing bad happened\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You have coded an infinite loop.", "What's worse us that you are endlessly making jumps into functions.", "Everytime you jump into a function the computer needs to store the location to jump back to when it has finished execution of that function.", "Only so many of these jumps can be stored before a stack overflow exception is caused."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Consider a while loop with calls to your three functions inside.", "Although without knowing what you are trying to achieve it will be difficult to advise."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["A piece of advice is that using except: is very bad.", "Always try to specify the type of exception you are catching."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "except:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Check this thread about recursion depth!"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this thread", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bytes.com/topic/python/answers/25061-runtimeerror-maximum-recursion-depth-exceeded"}]}], [{"text": ["I think John is right with you blowing away the call stack.", "However what would happen if you did hit the exceptionRecovery function the first time and it called function 1 2 or 3, either way it is no longer in a try except and would therefore exit if it was not in a new try except."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You have implemented your program flow using continuations.", "If you have a background programming in Scheme or certain other languages, then you may have used this style in the past without any negative consequences.", "In Python, using the continuation-based style the way you did will eventually result in a stack overflow, unless your program happens to terminate quickly enough to prevent it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "continuations", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Continuation-passing_style"}]}, {"text": ["If you have previously relied on the GOTO statement in your programming in other languages, you should know that in Python, calling a function is not the same as \"jumping\", as in GOTO, to the beginning of that function in the source."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "GOTO", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "childList": []}, {"text": "GOTO", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Learn how the stack works (there are many places online that can help you with this).", "Use the return statement in your code, so that you can avoid an \"unbounded stack\"."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "how the stack works", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.seas.upenn.edu/~ese112/lectures07/references.pdf"}, {"text": "return", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]