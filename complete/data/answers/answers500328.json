[[{"text": ["In general, the flexible, fast, and pythonic way to handle unknown types is to just perform some operation on them and catch an exception on invalid types.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    a = 5+'5'\nexcept TypeError:\n    print \"Oops\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Seems to me that this approach is easier than special-casing out some function to determine absolute type certainty."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As others have answered, there could be other numeric types besides the ones you mention.", "One approach would be to check explicitly for the capabilities you want, with something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_numeric(obj):\n    attrs = ['__add__', '__sub__', '__mul__', '__div__', '__pow__']\n    return all(hasattr(obj, attr) for attr in attrs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works for all your examples except the last one, numpy.array(['1']).", "That's because numpy.ndarray has the special methods for numeric operations but raises TypeError if you try to use them inappropriately with string or object arrays.", "You could add an explicit check for this like"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "numpy.array(['1'])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "numpy.ndarray", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n ... and not (isinstance(obj, ndarray) and obj.dtype.kind in 'OSU')\n</code>\n</pre>\n", "senID": 3}, {"text": ["This may be good enough. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["But... you can never be 100% sure that somebody won't define another type with the same behavior, so a more foolproof way is to actually try to do a calculation and catch the exception, something like"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "100%", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def is_numeric_paranoid(obj):\n    try:\n        obj+obj, obj-obj, obj*obj, obj**obj, obj/obj\n    except ZeroDivisionError:\n        return True\n    except Exception:\n        return False\n    else:\n        return True\n</code>\n</pre>\n", "senID": 6}, {"text": ["but depending on how often you plan to call use it and with what arguments, this may not be practical (it can be potentially slow, e.g.", "with large arrays)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Also, numpy has numpy.isreal and other similar functions (numpy.is + Tab should list them)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "numpy.isreal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "numpy.is", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["They all have their fun corner cases but one of those could be useful."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You can use type():"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "type()", "tag": "a", "pos": 0, "childList": [{"text": "type()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#type"}, {"text": "type()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a=scipy.array([1,2,3,4])\n&gt;&gt;&gt; b=array.array('L')\n&gt;&gt;&gt; type(a)\n&lt;type 'numpy.ndarray'&gt;\n&gt;&gt;&gt; type(b)\n&lt;type 'array.array'&gt;\n&gt;&gt;&gt; c=10.5\n&gt;&gt;&gt; type(c) in scipy.ScalarType\nTrue\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your is_numeric is ill-defined.", "See my comments to your question."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "is_numeric", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Other numerical types could be: long, complex, fractions.Fraction, numpy.bool_, numpy.ubyte, ..."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "long", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "complex", "childNum": 0, "tag": "code", "childList": []}, {"text": "fractions.Fraction", "childNum": 0, "tag": "code", "childList": []}, {"text": "numpy.bool_", "childNum": 0, "tag": "code", "childList": []}, {"text": "numpy.ubyte", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["operator.isNumberType() returns True for Python numbers and numpy.array."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "operator.isNumberType()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}, {"text": "numpy.array", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Since Python 2.6 you can use isinstance(d, numbers.Number) instead of deprecated operator.isNumberType()."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "isinstance(d, numbers.Number)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "operator.isNumberType()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Generally it is better to check the capabilities of the object (e.g., whether you can add an integer to it) and not its type."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["isinstance(numpy.int32(4), numbers.Number) returns False, so that doesn't quite work.", "operator.isNumberType() does work on all the variants of numpy numbers, however, including numpy.array([1])."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "isinstance(numpy.int32(4), numbers.Number)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "operator.isNumberType()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "numpy.array([1])", "childNum": 0, "tag": "code", "childList": []}]}]]