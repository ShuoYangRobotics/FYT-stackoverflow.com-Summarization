[[{"text": ["Suppose you have M points already given, and N more need to be added.", "If all points were evenly spaced, then you would have gaps of 2*pi/(N+M) between them.", "So, if you cut at your M points to give M segments of angle, you can certainly place points into a segment (evenly spaced from each other) until the space is less than or equal to 2*pi/(N+M)."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "M", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "2*pi/(N+M)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "M", "childNum": 0, "tag": "code", "childList": []}, {"text": "M", "childNum": 0, "tag": "code", "childList": []}, {"text": "2*pi/(N+M)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So, if the length of a segment is L, then you should place floor(L*(N+M)/(2*pi)) - 1 points into it."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "L", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "floor(L*(N+M)/(2*pi)) - 1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Now you're going to have some points left over.", "Rank the segments by the spacing that you would have between points if one more point was added.", "Actually add the point to the segment with lowest rank.", "Re-insert that one into your sorted list and do this again, until you run out of points."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Since at every time you're placing a point into a segment where the result will be points as widely spaced as possible, and space between points is not dependent on the order in which you added them, you will end up with the optimal spacing."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["(Edit: where \"optimal\" means \"maximal minimum distance between points\", i.e.", "avoiding the worst-case scenario of points on top of each other as best as possible."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["(Edit: I hope it's clear that the idea is to decide how many points go into each segment, and then only at the very end, after the numbers have all been decided, do you space them out equally within each segment."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Assume the intervals between the points are a_1 ... a_n.", "Then if we divide up each segment into pieces of minimum size d, we can fit floor(a_i/d) - 1 points in the segment.", "This means that sum(floor(a/d) for a in interval_lengths) must be larger than or equal to n + s where n is the number of points we want to add, and s is the number of points already there.", "We want to choose d as large as possible, it is probably best to just do a binary search for the best d."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "floor(a_i/d) - 1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sum(floor(a/d) for a in interval_lengths)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "n + s", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Once we have chosen d, just step through each segment adding points every d degrees until there are less than 2 d degrees left in the segment"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit all you need is to find d such that sum(floor(a/d) for a in interval_lengths) == n + s, then assign  floor(a_i/d) - 1 to segment i every a_i/(floor(a_i/d) - 1) degrees.", "Binary search will find this quickly."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "sum(floor(a/d) for a in interval_lengths) == n + s", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "floor(a_i/d) - 1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a_i/(floor(a_i/d) - 1)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Further Edit"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Further Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here is code to find d"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def get_d(n, a, lo=0, hi=None):\n    s = len(a)\n    lo = 360./(s + n)\n    hi = 2. * lo\n    d = (lo + hi)/2\n    c = sum(floor(x/d) for x in a)\n    while c != (n + s):\n        if c &lt; (n + s):\n            hi = mid\n        else:\n            lo = mid\n        d = (lo + hi)/2\n        c = sum(floor(x/d) for x in a)\n    return d\n</code>\n</pre>\n", "senID": 5}], [{"text": ["First we redefine term as follows:\nFind such distribution of N points, that the length of minimal distance between any of two point of these and M predefined is maximal.", "So your task is to find this maximum of minimal length.", "Call it L\nYou have M lengths of existing segments, assume they are stored in list s. So if this length is L first of all"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "L", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "s", "childNum": 0, "tag": "code", "childList": []}, {"text": "L", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n min(s) &gt; L\n</code>\n</pre>\n", "senID": 1}, {"text": ["and maximum amount of additional points is"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f(L) = sum(ls/L -1 for ls in s)\n</code>\n</pre>\n", "senID": 3}, {"text": ["So you can find optimal L using the binary search taking starting minimum L = 0 and maximum L = min(s) and checking condition if sum(ls/L -1 for ls in s) >= N.\nThen for each segment s[i] you can just place s[i]/L -1 of points evenly of it.", "I think this is optimal solution."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Updated There was flaw in min(s) &gt; L. It was good enough for redefined term, but mistake for the original.", "I have changed this condition to max(s) &gt; L. Also added skipping of segments smaller than L in binary search.", "Here is full updated code:"], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "Updated", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "min(s) &gt; L", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "max(s) &gt; L", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "updated", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n from math import pi,floor\ndef distribute(angles,n):\n    s = [angles[i] - angles[i-1] for i in xrange(len(angles))]\n    s = [ls if ls &gt; 0 else 2*pi+ls for ls in s]\n    Lmin, Lmax = 0., max(s)\n    while Lmax - Lmin &gt;1e-9:\n        L = (Lmax + Lmin)/2\n        if sum(max(floor(ls/L) -1,0) for ls in s ) &lt; n: Lmax = L\n        else : Lmin = L\n    L= Lmin\n    p = []\n    for i in xrange(len(s)):\n        u = floor(s[i]/L) -1\n        if u &lt;= 0:continue\n        d = s[i]/(u+1)\n        for j in xrange(u):\n            p.append(angles[i-1]+d*(j+1))\n    return p[:n]\nprint distribute((0, pi/4),1)\nprint distribute((-pi,-pi/2,pi/2),2\n</code>\n</pre>\n", "senID": 6}], [{"text": ["You could use an Interval object.", "An interval is an arc of the circle between two of the original, immovable points."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The following is just pseudo-code.", "Don't expect it to run anywhere."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Interval {\n\n  private length;\n  private point_count;\n\n  constructor(length) {\n    this.length = length;\n    this.point_count = 0;\n  }\n\n  public add_point() {\n    this.point_count++;\n  }\n\n  public length() {\n    return this.length;\n  }\n\n  // The current length of each sub-interval\n  public sub_length() {\n    return this.length / (this.point_count + 1);\n  }\n\n  // The sub-interval length if you were to add another point\n  public next_sub_length() { \n    return this.length / (this.point_count + 2);\n  }\n\n  public point_count() {\n    return this.point_count;\n  }\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Create a list of these objects corresponding to the intervals between points on your circle.", "Each time you add a point, select the interval with the largest next_sub_length().", "When you're done, it won't be hard to reconstruct the new circle."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This should give you the spacing with the the largest possible minimum interval.", "That is, if you score a solution by the length of its smallest interval, this will give you the highest score possible.", "I think that's what you've been shooting for."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit: Just realized that you specifically asked about this in Python.", "I'm quite a Python n00b, but you should be able to convert this to a Python object easily enough, though you won't need the getters, since everything in Python is public."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["You never did say what \"how evenly spaced\" is measured precisely.", "Total root-mean-square variance of interval size from perfectly-spaced interval sizes, or something else?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you look at any particular open interval at the beginning, I believe an optimal solution that places k points in that interval will always space them evenly.", "Therefore, the problem reduces to choosing cutoff points for what the minimum interval size is, to get a certain number of interstitial points.", "When done, if you have not enough points to distribute, drop one point from each interval from largest to smallest and repeat until you get something sane."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "k", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I'm not sure of the best way to choose the cutoffs, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I propose that you consider the problem either as : "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "A wrapped line - allowing you to determine inter-point distance easily, then re-map to the circle", "tag": "none", "senID": 1}]}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "Consider the angles between points and the centre of the circle rather than arc distance. Again, this simplifies the positioning of new points, and is perhaps the easier candidate for re-mapping to circle-edge points. Find all angles between the already-placed points, then bisect the largest (or similar), and place the new point at the appropriate point on the circle edge.  ", "tag": "none", "senID": 3}]}], [{"code": "<pre>\nOne idea, write angles as list (in degrees):\n    [30, 80, 120, 260, 310]\nConvert to differences:\n    [ 50, 40, 140, 50, 80]\nNote that we wrap around 310 + 80 (mod 360) = 30, the first angle\nFor each point to be added, split the largest difference:\nn=1, split 140:\n    [50, 40, 70, 70, 50, 80 ]\nn=2, split 80:\n    [50, 40, 70, 70, 50, 40, 40]\nConvert back to angles:\n    [30, 80, 120, 190, 260, 310, 350]\n</pre>\n", "senID": 0}], [{"text": ["I have a function called \"condition\" which takes two arguments - a numerator (const) and a denominator (pass-by-ref).", "It either \"grows\" or \"shrinks\" the value of the demoniator until an integer number of \"denominators\" fit into the numerator, i.e.", "so that numerator/denominator is an integer.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["whether the denominator is grown or shrunk depends on which one will cause it to change by a smaller amount."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Set numerator to 2*pi and denominator to anythink kind of close to the spacing you want, and you should have pretty close to even distribution."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["8note that I also have a function \"compare\" which comapre two doubles for equality within a certain tolerance."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n bool compare( const double num1, const double num2, const double epsilon = 0.0001 )\n{\n     return abs(num1 - num2) &lt; epsilon;\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["then the condition function is"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n void condition(const double numerator, double &amp;denominator)\n{\n  double epsilon = 0.01;\n  double mod = fmod( numerator, denominator );\n  if( compare(mod, 0) )\n    return;\n  if( mod &gt; denominator/2 ) // decide whether to grow or shrink\n    epsilon *= -1;\n\n  int count = 0;\n  while( !compare( fmod( numerator, denominator ), 0, 0.1) )\n  {\n    denominator += epsilon;\n    count++;\n    if( count &gt; 10000 ) // a safety net\n      return;\n  }\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["hope it helps, i know this little algo has come in very handy for me a number of times"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"code": "<pre>\nStarting with array  [30, 80, 120, 260, 310] and adding n = 5 angles,\nthe given algorithm (see below) gives [30, 55, 80, 120, 155, 190, 225, 260, 310, 350]\nwith a root mean square of the differences between angles\n   rms(diff) = sqrt[sum(diff * diff)] / n = 11.5974135047,\nwhich appears to be optimal for practical purposes.\n</pre>\n", "senID": 0}, {"senID": 1}]]