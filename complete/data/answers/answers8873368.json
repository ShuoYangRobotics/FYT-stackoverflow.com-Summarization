[[{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import permutations, chain\n\nwith open('/usr/share/dict/words') as fp:\n    words = set(fp.read().split())\n\ngiven_word = 'textbook'\n\nperms = (permutations(given_word, i) for i in range(4, len(given_word)+1))\npwords = (''.join(p) for p in chain(*perms))\nmatches = words.intersection(pwords)\n\nprint matches\n</code>\n</pre>\n", "senID": 1}, {"text": ["which gives"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print matches\nset(['textbook', 'keto', 'obex', 'tote', 'oboe', 'text', 'boot', 'toto', 'took', 'koto', 'bott', 'tobe', 'boke', 'toot', 'book', 'bote', 'otto', 'toke', 'toko', 'oket'])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I thought I'd share this slightly interesting trick although it takes a good bit more code than the rest and isn't really \"pythonic\".", "This will take a good bit more code than the other solutions but should be rather quick if I look at the timing the others need. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["We're doing a bit preprocessing to speed up the computations.", "The basic approach is the following: We assign every letter in the alphabet a prime number.", "E.g.", "A = 2, B = 3, and so on.", "We then compute a hash for every word in the alphabet which is simply the product of the prime representations of every character in the word.", "We then store every word in a dictionary indexed by the hash."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now if we want to find out which words are equivalent to say textbook we only have to compute the same hash for the word and look it up in our dictionary.", "Usually (say in C++) we'd have to worry about overflows, but in python it's even simpler than that: Every word in the list with the same index will contain exactly the same characters."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "textbook", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here's the code with the slightly optimization that in our case we only have to worry about characters also appearing in the given word, which means we can get by with a much smaller prime table than otherwise (the obvious optimization would be to only assign characters that appear in the word a value at all - it was fast enough anyhow so I didn't bother and this way we could pre process only once and do it for several words).", "The prime algorithm is useful often enough so you should have one yourself anyhow ;) "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\nfrom itertools import permutations\n\nPRIMES = list(gen_primes(256)) # some arbitrary prime generator\n\ndef get_dict(path):\n    res = defaultdict(list)\n    with open(path, \"r\") as file:\n        for line in file.readlines():\n            word = line.strip().upper()\n            hash = compute_hash(word)\n            res[hash].append(word)\n    return res\n\ndef compute_hash(word):\n    hash = 1\n    for char in word:\n        try:\n            hash *= PRIMES[ord(char) - ord(' ')]\n        except IndexError:\n            # contains some character out of range - always 0 for our purposes\n            return 0\n    return hash\n\ndef get_result(path, given_word):\n    words = get_dict(path)\n    given_word = given_word.upper()\n    result = set()\n    powerset = lambda x: powerset(x[1:]) + [x[:1] + y for y in powerset(x[1:])] if x else [x]\n    for word in (word for word in powerset(given_word) if len(word) &gt;= 4):\n        hash = compute_hash(word)\n        for equiv in words[hash]:\n            result.add(equiv)\n    return result\n\nif __name__ == '__main__':\n    path = \"dict.txt\"\n    given_word = \"textbook\"\n    result = get_result(path, given_word)\n    print(result)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Runs on my ubuntu word list (98k words) rather quickly, but not what I'd call pythonic since it's basically a port of a c++ algorithm.", "Useful if you want to compare more than one word that way.."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["There is a generator itertools.permutations with which you can gather all permutations of a sequence with a specified length.", "That makes it easier:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.permutations", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import permutations\n\nGIVEN_WORD = 'textbook'\n\nwith open('/usr/share/dict/words', 'r') as f:\n    words = [s.strip() for s in f.readlines()]\n\nprint len(filter(lambda x: ''.join(x) in words, permutations(GIVEN_WORD, 4)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit #1: Oh!", "It says \"4 or more\" ;) Forget what I said!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit #2: This is the second version I came up with:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n LETTERS = set('textbook')\n\nwith open('/usr/share/dict/words') as f:\n    WORDS = filter(lambda x: len(x) &gt;= 4, [l.strip() for l in f])\n\nmatching = filter(lambda x: set(x).issubset(LETTERS) and all([x.count(c) == 1 for c in x]), WORDS)\nprint len(matching)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Create the whole power set, then check whether the dictionary word is in the set (order of the letters doesn't matter):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n powerset = lambda x: powerset(x[1:]) + [x[:1] + y for y in powerset(x[1:])] if x else [x]\n\npw = map(lambda x: sorted(x), powerset(given_word))\nfilter(lambda x: sorted(x) in pw, words)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The following just checks each word in the dictionary to see if it is of the appropriate length, and then if it is a permutation of 'textbook'.", "I borrowed the permutation check from \nChecking if two strings are permutations of each other in Python\nbut changed it slightly."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Checking if two strings are permutations of each other in Python", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/396421/checking-if-two-strings-are-permutations-of-each-other-in-python"}]}, {"code": "<pre>\n<code>\n given_word = 'textbook'\n\nwith open('/usr/share/dict/words', 'r') as f:\n    words = [s.strip() for s in f.readlines()]\n\nmatches = []\nfor word in words:\n    if word != given_word and 4 &lt;= len(word) &lt;= len(given_word):\n        if all(word.count(char) &lt;= given_word.count(char) for char in word):\n            matches.append(word)\nprint sorted(matches)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This finishes almost immediately and gives the correct result."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Permutations get very big for longer words.", "Try counterrevolutionary for example. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "counterrevolutionary", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["I would filter the dict for words from 4 to len(word) (8 for textbook).", "Then I would filter with regular expression \"oboe\".matches (\"[textbook]+\"). "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The remaining words, I would sort, and compare them with a sorted version of your word, (\"beoo\", \"bekoottx\") with jumping to the next index of a matching character, to find mismatching numbers of characters: "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (\"beoo\", \"bekoottx\") \n(\"eoo\", \"ekoottx\") \n(\"oo\", \"koottx\") \n(\"oo\", \"oottx\") \n(\"o\", \"ottx\") \n(\"\", \"ttx\") =&gt; matched\n\n\n(\"bbo\", \"bekoottx\") \n(\"bo\", \"ekoottx\") =&gt; mismatch\n</code>\n</pre>\n", "senID": 3}, {"text": ["Since I don't talk python, I leave the implementation as an exercise to the audience. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]