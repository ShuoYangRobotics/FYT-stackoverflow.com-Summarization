[[{"text": ["Having a variable in Java be final basically means that once you assign to a variable, you may not reassign that variable to point to another object.", "It actually doesn't mean that the object can't be modified.", "For example, the following Java code works perfectly well:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "final", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n public final List&lt;String&gt; messages = new LinkedList&lt;String&gt;();\n\npublic void addMessage()\n{\n    messages.add(\"Hello World!\");  // this mutates the messages list\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["but the following wouldn't even compile:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n public final List&lt;String&gt; messages = new LinkedList&lt;String&gt;();\n\npublic void changeMessages()\n{\n    messages = new ArrayList&lt;String&gt;();  // can't change a final variable\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["So your question is about whether final exists in Python.", "It does not."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "final", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["However, Python does have immutable data structures.", "For example, while you can mutate a list, you can't mutate a tuple.", "You can mutate a set but not a frozenset, etc."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "frozenset", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["My advice would be to just not worry about enforcing non-mutation at the language level and simply concentrate on making sure that you don't write any code which mutates these objects after they're assigned."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["There is no ``final'' equivalent in Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But, to create read-only fields of class instances, you can use the property function."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "property", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/3.0/library/functions.html#property"}]}, {"text": ["Edit: perhaps you want something like this:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class WriteOnceReadWhenever:\n    def __setattr__(self, attr, value):\n        if hasattr(self, attr):\n            raise Exception(\"Attempting to alter read-only value\")\n\n        self.__dict__[attr] = value\n</code>\n</pre>\n", "senID": 3}], [{"text": ["There is no such thing.", "In general, the Python attitude is \"if you don't want this modified, just don't modify it\".", "Clients of an API are unlikely to just poke around your undocumented internals anyway."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could, I suppose, work around this by using tuples or namedtuples for the relevant bits of your model, which are inherently immutable.", "That still doesn't help with any part of your model that has to be mutable of course."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["An assign-once variable is a design issue.", "You design your application in a way that the variable is set once and once only."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, if you want run-time checking of your design, you can do it with a wrapper around the object."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class OnePingOnlyPleaseVassily( object ):\n    def __init__( self ):\n        self.value= None\n    def set( self, value ):\n        if self.value is not None:\n            raise Exception( \"Already set.\")\n        self.value= value\n\nsomeStateMemo= OnePingOnlyPleaseVassily()\nsomeStateMemo.set( aValue ) # works\nsomeStateMemo.set( aValue ) # fails\n</code>\n</pre>\n", "senID": 2}, {"text": ["That's clunky, but it will detect design problems at run time."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python has no equivalent of \"final\".", "It doesn't have \"public\" and \"protected\" either, except by naming convention.", "It's not that \"bondage and discipline\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["http://code.activestate.com/recipes/576527/ defines a freeze function, although it doesn't work perfectly."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/576527/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/576527/"}]}, {"text": ["I would consider just leaving it mutable though."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["you can simulate something like that through the descriptor protocol, since it allows to define reading and setting a variable the way you wish."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "descriptor protocol", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#customizing-attribute-access"}]}, {"code": "<pre>\n<code>\n class Foo(object):\n\n  @property\n  def myvar(self):\n     # return value here\n\n  @myvar.setter\n  def myvar(self, newvalue):\n     # do nothing if some condition is met\n\na = Foo()\nprint a.myvar\na.myvar = 5 # does nothing if you don't want to\n</code>\n</pre>\n", "senID": 1}]]