[[{"text": ["This was discussed not too long ago in PyQt mailing list.", "Short summary:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "discussed", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.mail-archive.com/pyqt@riverbankcomputing.com/msg16050.html"}]}, {"text": ["It's mostly the same.", "The main difference is that QThreads are better integrated with Qt (asynchrnous signals/slots, event loop, etc.).", "Also, you can't use Qt from a Python thread (you can't for instance post event to the main thread through QApplication.postEvent): you need a QThread for that to work."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["A general rule of thumb might be to use QThreads if you're going to interact somehow with Qt, and use Python threads otherwise."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["And some earlier comment on this subject from PyQt's author: \"they are both wrappers around the same native thread implementations\".", "And both implementations use GIL in the same way."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The advantage of QThread is that it's integrated with the rest of the Qt library.", "That is, thread-aware methods in Qt will need to know in which thread they run, and to move objects between threads, you will need to use QThread.", "Another useful feature is running your own event loop in a thread."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "QThread", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "QThread", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If you are accessing a HTTP server, you should consider QNetworkAccessManager."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "QNetworkAccessManager", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Python's threads will be simpler and safer, and since it is for an I/O-based application, they are able to bypass the GIL.", "That said, have you considered non-blocking I/O using Twisted or non-blocking sockets/select?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["EDIT: more on threads"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "EDIT: more on threads", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Python threads"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Python threads", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Python's threads are system threads.", "However, Python uses a global interpreter lock (GIL) to ensure that the interpreter is only ever executing a certain size block of byte-code instructions at a time.", "Luckily, Python releases the GIL during input/output operations, making threads useful for simulating non-blocking I/O."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Important caveat: This can be misleading, since the number of byte-code instructions does not correspond to the number of lines in a program.", "Even a single assignment may not be atomic in Python, so a mutex lock is necessary for any block of code that must be executed atomically, even with the GIL."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Important caveat:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "any", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["QT threads"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "QT threads", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["When Python hands off control to a 3rd party compiled module, it releases the GIL.", "It becomes the responsibility of the module to ensure atomicity where required.", "When control is passed back, Python will use the GIL.", "This can make using 3rd party libraries in conjunction with threads confusing.", "It is even more difficult to use an external threading library because it adds uncertainty as to where and when control is in the hands of the module vs the interpreter."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["QT threads operate with the GIL released.", "QT threads are able to execute QT library code (and other compiled module code that does not acquire the GIL) concurrently.", "However, the Python code executed within the context of a QT thread still acquires the GIL, and now you have to manage two sets of logic for locking your code."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "still", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "two", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["In the end, both QT threads and Python threads are wrappers around system threads.", "Python threads are marginally safer to use, since those parts that are not written in Python (implicitly using the GIL) use the GIL in any case (although the caveat above still applies."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Non-blocking I/O"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Non-blocking I/O", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Threads add extraordinarily complexity to your application.", "Especially when dealing with the already complex interaction between the Python interpreter and compiled module code.", "While many find event-based programming difficult to follow, event-based, non-blocking I/O is often much less difficult to reason about than threads."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["With asynchronous I/O, you can always be sure that, for each open descriptor, the path of execution is consistent and orderly.", "There are, obviously, issues that must be addressed, such as what to do when code depending on one open channel further depends on the results of code to be called when another open channel returns data."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["One nice solution for event-based, non-blocking I/O is the new Diesel library.", "It is restricted to Linux at the moment, but it is extraordinarily fast and quite elegant."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "Diesel", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://dieselweb.org/"}]}, {"text": ["It is also worth your time to learn pyevent, a wrapper around the wonderful libevent library, which provides a basic framework for event-based programming using the fastest available method for your system (determined at compile time)."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "pyevent", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pyevent/"}]}], [{"text": ["I asked myself the same question when I was working to PyTalk."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PyTalk", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pytalk.trunat.fr/"}]}, {"text": ["If you are using Qt, you need to use QThread to be able to use the Qt framework and expecially the signal/slot system."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "QThread", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["With the signal/slot engine, you will be able to talk from a thread to another and with every part of your project."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Moreover, there is not very performance question about this choice since both are a C++ bindings."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Here is my experience of PyQt and thread."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I encourage you to use QThread."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "QThread", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Jeff has some good points.", "Only one main thread can do any GUI updates.", "If you do need to update the GUI from within the thread, Qt-4's queued connection signals make it easy to send data across threads and will automatically be invoked if you're using QThread; I'm not sure if they will be if you're using Python threads, although it's easy to add a parameter to connect()."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "queued connection", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://doc.trolltech.com/4.5/qobject.html#connect-2"}, {"text": "connect()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I can't really recommend either, but I can try describing differences between CPython and Qt threads."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First of all, CPython threads do not run concurrently, at least not Python code.", "Yes, they do create system threads for each Python thread, however only the thread currently holding Global Interpreter Lock is allowed to run (C extensions and FFI code might bypass it, but Python bytecode is not executed while thread doesn't hold GIL)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["On the other hand, we have Qt threads, which are basically common layer over system threads, don't have Global Interpreter Lock, and thus are capable of running concurrently.", "I'm not sure how PyQt deals with it, however unless your Qt threads call Python code, they should be able to run concurrently (bar various extra locks that might be implemented in various structures)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For extra fine-tuning, you can modify the amount of bytecode instructions that are interpreted before switching ownership of GIL - lower values mean more context switching (and possibly higher responsiveness) but lower performance per individual thread (context switches have their cost - if you try switching every few instructions it doesn't help speed."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Hope it helps with your problems :)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I can't comment on the exact differences between Python and PyQt threads, but I've been doing what you're attempting to do using QThread, QNetworkAcessManager and making sure to call QApplication.processEvents() while the thread is alive.", "If GUI responsiveness is really the issue you're trying to solve, the later will help."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "QThread", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "QNetworkAcessManager", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "QApplication.processEvents()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "the later", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qcoreapplication.html#processEvents"}]}]]