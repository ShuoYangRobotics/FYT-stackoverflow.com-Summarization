[[{"text": ["If you're only looking for one:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nmatch = re.search(r'href=[\\'\"]?([^\\'\" &gt;]+)', s)\nif match:\n    print match.group(0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you have a long string, and want every instance of the pattern in it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\nurls = re.findall(r'href=[\\'\"]?([^\\'\" &gt;]+)', s)\nprint ', '.join(urls)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Where s is the string that you're looking for matches in."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Quick explanation of the regexp bits:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Quick explanation of the regexp bits:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The suggestion in another answer to use BeautifulSoup isn't bad, but it does introduce a higher level of external requirements.", "Plus it doesn't help you in your stated goal of learning regexps, which I'd assume this specific html-parsing project is just a part of."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["It's pretty easy to do:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n from BeautifulSoup import BeautifulSoup\nsoup = BeautifulSoup(html_to_parse)\nfor tag in soup.findAll('a', href=True):\n    print tag['href']\n</code>\n</pre>\n", "senID": 8}, {"text": ["Once you've installed BeautifulSoup, anyway."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Don't use regexes, use BeautifulSoup.", "That, or be so crufty as to spawn it out to, say, w3m/lynx and pull back in what w3m/lynx renders.", "First is more elegant probably, second just worked a heck of a lot faster on some unoptimized code I wrote a while back."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "BeautifulSoup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}]}], [{"text": ["John Gruber (who wrote Markdown, which is made of regular expressions and is used right here on Stack Overflow) had a go at producing a regular expression that recognises URLs in text:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://daringfireball.net/2009/11/liberal_regex_for_matching_urls"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://daringfireball.net/2009/11/liberal_regex_for_matching_urls", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://daringfireball.net/2009/11/liberal%5Fregex%5Ffor%5Fmatching%5Furls"}]}, {"text": ["If you just want to grab the URL (i.e.", "you\u2019re not really trying to parse the HTML), this might be more lightweight than an HTML parser."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Regexes are fundamentally bad at parsing HTML (see Can you provide some examples of why it is hard to parse XML and HTML with a regex?", "for why).", "What you need is an HTML parser.", "See Can you provide an example of parsing HTML with your favorite parser?", "for examples using a variety of parsers."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Can you provide some examples of why it is hard to parse XML and HTML with a regex?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/701166"}, {"text": "Can you provide an example of parsing HTML with your favorite parser?", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/773340"}]}, {"text": ["In particular you will want to look at the Python answers: BeautifulSoup, HTMLParser, and lxml."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "BeautifulSoup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/773340/can-you-provide-an-example-of-parsing-html-with-your-favorite-parser/773565#773565"}, {"href": "http://stackoverflow.com/questions/773340/can-you-provide-an-example-of-parsing-html-with-your-favorite-parser/773344#773344", "text": "HTMLParser", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://stackoverflow.com/questions/773340/can-you-provide-an-example-of-parsing-html-with-your-favorite-parser/774062#774062", "text": "lxml", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["There's tonnes of them on regexlib"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "regexlib", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://regexlib.com/default.aspx"}]}], [{"text": ["Yes, there are tons of them on regexlib.", "That only proves that RE's should not be used to do that.", "Use SGMLParser or BeautifulSoup or write a parser - but don't use RE's.", "The ones that seems to work are extremely compliated and still don't cover all cases."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "regexlib", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://regexlib.com/"}]}], [{"text": ["this should work, although there might be more elegant ways."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nurl='&lt;a href=\"http://www.ptop.se\" target=\"_blank\"&gt;http://www.ptop.se&lt;/a&gt;'\nr = re.compile('(?&lt;=href=\").*?(?=\")')\nr.findall(url)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This improved version should work as reliably as a parser."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n // Applies to URI, not just URL or URN:\n   //    http://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Relationship_to_URL_and_URN\n   //\n   // http://labs.apache.org/webarch/uri/rfc/rfc3986.html#regexp\n   //\n   // (?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?\n   //\n   // http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax\n   //\n   // $@ matches the entire uri\n   // $1 matches scheme (ftp, http, mailto, mshelp, ymsgr, etc)\n   // $2 matches authority (host, user:pwd@host, etc)\n   // $3 matches path\n   // $4 matches query (http GET REST api, etc)\n   // $5 matches fragment (html anchor, etc)\n   //\n   // Match specific schemes, non-optional authority, disallow white-space so can delimit in text, and allow 'www.' w/o scheme\n   // Note the schemes must match ^[^\\s|:/?#]+(?:\\|[^\\s|:/?#]+)*$\n   //\n   // (?:()(www\\.[^\\s/?#]+\\.[^\\s/?#]+)|(schemes)://([^\\s/?#]*))([^\\s?#]*)(?:\\?([^\\s#]*))?(#(\\S*))?\n   //\n   // Validate the authority with an orthogonal RegExp, so the RegExp above won\u2019t fail to match any valid urls.\n   function uriRegExp( flags, schemes/* = null*/, noSubMatches/* = false*/ )\n   {\n      if( !schemes )\n         schemes = '[^\\\\s:\\/?#]+'\n      else if( !RegExp( /^[^\\s|:\\/?#]+(?:\\|[^\\s|:\\/?#]+)*$/ ).test( schemes ) )\n         throw TypeError( 'expected URI schemes' )\n      return noSubMatches ? new RegExp( '(?:www\\\\.[^\\\\s/?#]+\\\\.[^\\\\s/?#]+|' + schemes + '://[^\\\\s/?#]*)[^\\\\s?#]*(?:\\\\?[^\\\\s#]*)?(?:#\\\\S*)?', flags ) :\n         new RegExp( '(?:()(www\\\\.[^\\\\s/?#]+\\\\.[^\\\\s/?#]+)|(' + schemes + ')://([^\\\\s/?#]*))([^\\\\s?#]*)(?:\\\\?([^\\\\s#]*))?(?:#(\\\\S*))?', flags )\n   }\n\n   // http://en.wikipedia.org/wiki/URI_scheme#Official_IANA-registered_schemes\n   function uriSchemesRegExp()\n   {\n      return 'about|callto|ftp|gtalk|http|https|irc|ircs|javascript|mailto|mshelp|sftp|ssh|steam|tel|view-source|ymsgr'\n   }\n</code>\n</pre>\n", "senID": 1}]]