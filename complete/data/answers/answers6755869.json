[[{"text": ["Iterators do not work recursively like that.", "You have to re-yield each result, by replacing"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-python prettyprint-override\">\n<code>\n explore(path)\n</code>\n</pre>\n", "senID": 1}, {"text": ["with something like"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre class=\"lang-python prettyprint-override\">\n<code>\n for value in explore(path):\n    yield value\n</code>\n</pre>\n", "senID": 3}, {"text": ["Python 3.3 will add the syntax yield from X, as proposed in PEP 380, to serve this purpose.", "You will be able to do this instead:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "yield from X", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "PEP 380", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0380/"}]}, {"code": "<pre class=\"lang-python prettyprint-override\">\n<code>\n yield from explore(path)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Use os.walk instead of reinventing the wheel. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "os.walk", "tag": "a", "pos": 0, "childList": [{"text": "os.walk", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/os.html#os.walk"}, {"text": "os.walk", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In particular, following the examples in the library documentation, here is an untested attempt:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import os\nfrom os.path import join\n\ndef hellothere(somepath):\n    for root, dirs, files in os.walk(somepath):\n        for curfile in files:\n            yield join(root, curfile)\n\n\n# call and get full list of results:\nallfiles = [ x for x in hellothere(\"...\") ]\n\n# iterate over results lazily:\nfor x in hellothere(\"...\"):\n    print x\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The problem is this line of code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n explore(path)\n</code>\n</pre>\n", "senID": 1}, {"text": ["What does it do?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "calls ", "tag": "none", "senID": 3}, {"text": ["explore"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": "the generator is return to the spot where ", "tag": "none", "senID": 5}, {"text": "and is discarded", "tag": "none", "senID": 6}]}, {"text": ["Why is it discarded?", "It wasn't assigned to anything, it wasn't iterated over -- it was completely ignored."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["If you want to do something with the results, well, you have to do something with them!", ";)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["The easiest way to fix your code is:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n for name in explore(path):\n    yield name\n</code>\n</pre>\n", "senID": 10}, {"text": ["When you are confident you understand what's going on, you'll probably want to use os.walk() instead."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "os.walk()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Once you have migrated to Python 3.3 (assuming all works out as planned) you will be able to use the new yield from syntax and the easiest way to fix your code at that point will be:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "yield from", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n yield from explore(path)\n</code>\n</pre>\n", "senID": 13}], [{"text": ["Change this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n explore(path)\n</code>\n</pre>\n", "senID": 1}, {"text": ["To this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for subpath in explore(path):\n    yield subpath\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or use os.walk, as phooji suggested (which is the better option)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "os.walk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if stat.S_ISDIR(stat_info.st_mode):\n    for p in explore(path):\n        yield p\n</code>\n</pre>\n", "senID": 1}], [{"text": ["That calls explore like a function.", "What you should do is iterate it like a generator:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "explore", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if stat.S_ISDIR(stat_info.st_mode):\n  for p in explore(path):\n    yield p\nelse:\n  yield path\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: Instead of the stat module, you could use os.path.isdir(path)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "stat", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.path.isdir(path)", "childNum": 0, "tag": "code", "childList": []}]}]]