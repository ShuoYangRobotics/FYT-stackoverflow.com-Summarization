[[{"code": "<pre>\n<code>\n os.path.dirname(os.path.abspath(__file__))\n</code>\n</pre>\n", "senID": 0}, {"text": ["is indeed the best you're going to get."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It's unusual to be executing a script with exec/execfile; normally you should be using the module infrastructure to load scripts.", "If you must use these methods, I suggest setting __file__ in the globals you pass to the script so it can read that filename."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "exec", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "execfile", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__file__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "globals", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There's no other way to get the filename in execed code: as you note, the CWD may be in a completely different place."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you really want to cover the case that a script is called via execfile(...), you can use the inspect module to deduce the filename (including the path).", "As far as I am aware, this will work for all cases you listed:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "execfile(...)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "inspect", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n filename = inspect.getframeinfo(inspect.currentframe()).filename\npath = os.path.dirname(os.path.abspath(filename))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Would"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\ncwd = os.getcwd()\n</code>\n</pre>\n", "senID": 1}, {"text": ["do what you want?", "I'm not sure what exactly you mean by the \"current script directory\".", "What would the expected output be for the use cases you gave?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["imho, just use os.path.dirname(os.path.abspath(__file__)) and examine very carefully whether there is a real need for the case where exec is used.", "it could be a sign of troubled design if you are not able to use your script as a module for whatever strange reason.  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "os.path.dirname(os.path.abspath(__file__))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "exec", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["keep in mind Zen of Python #8, and if you believe there is a good argument for a use-case where it must work for exec, then please let us know some more details about the background of the problem  :) "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Zen of Python #8", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "exec", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["First.. a couple missing use-cases here if we're talking about ways to inject anonymous code.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n code.compile_command()\ncode.interact()\nimp.load_compiled()\nimp.load_dynamic()\nimp.load_module()\n__builtin__.compile()\nloading C compiled shared objects? example: _socket?)\n</code>\n</pre>\n", "senID": 1}, {"text": ["But, the real question is, what is your goal - are you trying to enforce some sort of security?", "Or are you just interested in whats being loaded."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you're interested in security, the filename that is being imported via exec/execfile is inconsequential - you should use rexec, which offers the following:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "security", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Security_through_obscurity"}, {"href": "http://docs.python.org/library/rexec.html", "text": "rexec", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["However, if this is more of an academic pursuit.. here are a couple goofy approaches that you\nmight be able to dig a little deeper into.. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Example scripts:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["./deep.py"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "./deep.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print ' &gt;&gt; level 1'\nexecfile('deeper.py')\nprint ' &lt;&lt; level 1'\n</code>\n</pre>\n", "senID": 7}, {"text": ["./deeper.py"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "./deeper.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print '\\t &gt;&gt; level 2'\nexec(\"import sys; sys.path.append('/tmp'); import deepest\")\nprint '\\t &lt;&lt; level 2'\n</code>\n</pre>\n", "senID": 9}, {"text": ["/tmp/deepest.py"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "/tmp/deepest.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print '\\t\\t &gt;&gt; level 3'\nprint '\\t\\t\\t I can see the earths core.'\nprint '\\t\\t &lt;&lt; level 3'\n</code>\n</pre>\n", "senID": 11}, {"text": ["./codespy.py"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "./codespy.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import sys, os\n\ndef overseer(frame, event, arg):\n    print \"loaded(%s)\" % os.path.abspath(frame.f_code.co_filename)\n\nsys.settrace(overseer)\nexecfile(\"deep.py\")\nsys.exit(0)\n</code>\n</pre>\n", "senID": 13}, {"text": ["Output"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "Output", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n loaded(/Users/synthesizerpatel/deep.py)\n&gt;&gt; level 1\nloaded(/Users/synthesizerpatel/deeper.py)\n    &gt;&gt; level 2\nloaded(/Users/synthesizerpatel/&lt;string&gt;)\nloaded(/tmp/deepest.py)\n        &gt;&gt; level 3\n            I can see the earths core.\n        &lt;&lt; level 3\n    &lt;&lt; level 2\n&lt;&lt; level 1\n</code>\n</pre>\n", "senID": 15}, {"text": ["Of course, this is a resource-intensive way to do it, you'd be tracing\nall your code.. Not very efficient.", "But, I think it's a novel approach\nsince it continues to work even as you get deeper into the nest.", "You can't override 'eval'.", "Although you can override execfile()."], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Note, this approach only coveres exec/execfile, not 'import'.", "For higher level 'module' load hooking you might be able to use use\nsys.path_hooks (Write-up courtesy of PyMOTW)."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "sys.path_hooks", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://blog.doughellmann.com/2009/11/pymotw-sys-part-7-modules-and-imports.html"}]}, {"text": ["Thats all I have off the top of my head. "], "childNum": 0, "tag": "p", "senID": 18, "childList": []}], [{"text": ["Here is a partial solution, still better than all published ones so far."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys, os, os.path, inspect\n\n#os.chdir(\"..\")\n\nif '__file__' not in locals():\n    __file__ = inspect.getframeinfo(inspect.currentframe())[0]\n\nprint os.path.dirname(os.path.abspath(__file__))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now this works will all calls but if someone use chdir() to change the current directory, this will also fail."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "chdir()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Notes: "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["sys.argv[0]"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": "I published a complete test at ", "tag": "none", "senID": 5}]}], [{"text": ["I use sys.path[0], but I'm not sure it works with exec"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]