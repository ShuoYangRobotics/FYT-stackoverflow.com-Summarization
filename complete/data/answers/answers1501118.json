[[{"text": ["Maybe something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if len(x) == len(set(x)):\n    print \"all elements are unique\"\nelse:\n    print \"elements are not unique\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The most popular answers are O(N) (good!-) but, as @Paul and @Mark point out, they require the list's items to be hashable.", "Both @Paul and @Mark's proposed approaches for unhashable items are general but take O(N squared) -- i.e., a lot."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If your list's items are not hashable but are comparable, you can do better... here's an approach that always work as fast as feasible given the nature of the list's items."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "are", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\n\ndef allunique(L):\n  # first try sets -- fastest, if all items are hashable\n  try:\n    return len(L) == len(set(L))\n  except TypeError:\n    pass\n  # next, try sort -- second fastest, if items are comparable\n  try:\n    L1 = sorted(L)\n  except TypeError:\n    pass\n  else:\n    return all(len(list(g))==1 for k, g in itertools.groupby(L1))\n  # fall back to the slowest but most general approach\n  return all(v not in L[i+1:] for i, L in enumerate(L))\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is O(N) where feasible (all items hashable), O(N log N) as the most frequent fallback (some items unhashable, but all comparable), O(N squared) where inevitable (some items unhashable, e.g.", "dicts, and some non-comparable, e.g.", "complex numbers)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Inspiration for this code comes from an old recipe by the great Tim Peters, which differed by actually producing a list of unique items (and also was so far ago that set was not around -- it had to use a dict...!-), but basically faced identical issues."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if len(x) != len(set(x)):\n    raise Exception(\"throw to caller\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["This assumes that elements in x are hashable."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Hopefully all the items in your sequence are immutable -- if not, you will not be able to call set on the sequence."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; set( ([1,2], [3,4]) )\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you do have mutable items, you can't hash the items and you will pretty much have to repeatedly check through the list:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def isUnique(lst):\n    for i,v in enumerate(lst):\n        if v in lst[i+1:]:\n            return False\n    return True\n</code>\n</pre>\n", "senID": 3}, {"tag": "code", "senID": 4}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; isUnique( ([1,2], [3,4]) )\nTrue\n&gt;&gt;&gt; isUnique( ([1,2], [3,4], [1,2]) )\nFalse\n</code>\n</pre>\n", "senID": 5}], [{"text": ["As you build the list you can check to see if the value already exists, e.g:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if x in y:\n     raise Exception(\"Value %s already in y\" % x)\nelse:\n     y.append(x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["the benefit of this is that the clashing variable will be reported."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could process the list to create a known-to-be-unique copy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def make_unique(seq): \n    t = type(seq) \n    seen = set()\n    return t(c for c in seq if not (c in seen or seen.add(c)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or if the seq elements are not hashable:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def unique1(seq):\n    t = type(seq) \n    seen = [] \n    return t(c for c in seq if not (c in seen or seen.append(c)))\n</code>\n</pre>\n", "senID": 3}, {"text": ["And this will keep the items in order (omitting duplicates, of course)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I would use this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mylist = [1,2,3,4]\nis_unique = all(mylist.count(x) == 1 for x in mylist)\n</code>\n</pre>\n", "senID": 1}]]