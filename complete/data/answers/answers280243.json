[[{"text": ["Here is some list functions based on Martin v. L\u00f6wis's representation:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Martin v. L\u00f6wis's representation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/280243/python-linked-list#280284"}]}, {"code": "<pre>\n<code>\n cons   = lambda el, lst: (el, lst)\nmklist = lambda *args: reduce(lambda lst, el: cons(el, lst), reversed(args), None)\ncar = lambda lst: lst[0] if lst else lst\ncdr = lambda lst: lst[1] if lst else lst\nnth = lambda n, lst: nth(n-1, cdr(lst)) if n &gt; 0 else car(lst)\nlength  = lambda lst, count=0: length(cdr(lst), count+1) if lst else count\nbegin   = lambda *args: args[-1]\ndisplay = lambda lst: begin(w(\"%s \" % car(lst)), display(cdr(lst))) if lst else w(\"nil\\n\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["where w = sys.stdout.write"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "w = sys.stdout.write", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Linked lists have no practical value in Python.", "I've never used a linked list in Python for any problem except educational."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "never", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Thomas Watnedal suggested a good educational resource How to Think Like a Computer Scientist, Chapter 17: Linked lists:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "suggested", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/280243/python-linked-list#280280"}, {"href": "http://greenteapress.com/thinkpython/html/chap17.html", "text": "How to Think Like a Computer Scientist, Chapter 17: Linked lists", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["A linked list is either: "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "the empty list, represented by None, or ", "tag": "none", "senID": 6}, {"text": ["a node that contains a cargo object and a reference to a linked list."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]}], [{"text": ["For some needs, a deque may also be useful.", "You can add and remove items on both ends of a deque at O(1) cost."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "deque", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#id1"}]}, {"code": "<pre>\n<code>\n from collections import deque\nd = deque([1,2,3,4])\n\nprint d\nfor x in d:\n    print x\nprint d.pop(), d\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The How to Think Like a Computer Scientist book covers this well in Chapter 17: Linked lists."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "How to Think Like a Computer Scientist", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.greenteapress.com/thinkpython/"}, {"href": "http://greenteapress.com/thinkpython/html/chap17.html", "text": "Chapter 17: Linked lists", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Immutable lists are best represented through two-tuples, with None representing NIL.", "To allow simple formulation of such lists, you can use this function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def mklist(*args):\n    result = None\n    for element in reversed(args):\n        result = (element, result)\n    return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["To work with such lists, I'd rather provide the whole collection of LISP functions (i.e.", "first, second, nth, etc), than introducing methods."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I wrote this up the other day"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #! /usr/bin/env python\n\nclass node:\n    def __init__(self):\n        self.data = None # contains the data\n        self.next = None # contains the reference to the next node\n\n\nclass linked_list:\n    def __init__(self):\n        self.cur_node = None\n\n    def add_node(self, data):\n        new_node = node() # create a new node\n        new_node.data = data\n        new_node.next = self.cur_node # link the new node to the 'previous' node.\n        self.cur_node = new_node #  set the current node to the new one.\n\n    def list_print(self):\n        node = ll.cur_node\n        while node:\n            print node.data\n            node = node.next\n\n\n\nll = linked_list()\nll.add_node(1)\nll.add_node(2)\nll.add_node(3)\n\nll.list_print()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a slightly more complex version of a linked list class, with a similar interface to python's sequence types (ie.", "supports indexing, slicing, concatenation with arbitrary sequences etc).", "It should have O(1) prepend, doesn't copy data unless it needs to and can be used pretty interchangably with tuples."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It won't be as space or time efficient as lisp cons cells, as python classes are obviously a bit more heavyweight (You could improve things slightly with \"__slots__ = '_head','_tail'\" to reduce memory usage).", "It will have the desired big O performance characteristics however."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__slots__ = '_head','_tail'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Example of usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = LinkedList([1,2,3,4])\n&gt;&gt;&gt; l\nLinkedList([1, 2, 3, 4])\n&gt;&gt;&gt; l.head, l.tail\n(1, LinkedList([2, 3, 4]))\n\n# Prepending is O(1) and can be done with:\nLinkedList.cons(0, l)\nLinkedList([0, 1, 2, 3, 4])\n# Or prepending arbitrary sequences (Still no copy of l performed):\n[-1,0] + l\nLinkedList([-1, 0, 1, 2, 3, 4])\n\n# Normal list indexing and slice operations can be performed.\n# Again, no copy is made unless needed.\n&gt;&gt;&gt; l[1], l[-1], l[2:]\n(2, 4, LinkedList([3, 4]))\n&gt;&gt;&gt; assert l[2:] is l.next.next\n\n# For cases where the slice stops before the end, or uses a\n# non-contiguous range, we do need to create a copy.  However\n# this should be transparent to the user.\n&gt;&gt;&gt; LinkedList(range(100))[-10::2]\nLinkedList([90, 92, 94, 96, 98])\n</code>\n</pre>\n", "senID": 3}, {"text": ["Implementation:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\nclass LinkedList(object):\n    \"\"\"Immutable linked list class.\"\"\"\n\n    def __new__(cls, l=[]):\n        if isinstance(l, LinkedList): return l # Immutable, so no copy needed.\n        i = iter(l)\n        try:\n            head = i.next()\n        except StopIteration:\n            return cls.EmptyList   # Return empty list singleton.\n\n        tail = LinkedList(i)\n\n        obj = super(LinkedList, cls).__new__(cls)\n        obj._head = head\n        obj._tail = tail\n        return obj\n\n    @classmethod\n    def cons(cls, head, tail):\n        ll =  cls([head])\n        if not isinstance(tail, cls):\n            tail = cls(tail)\n        ll._tail = tail\n        return ll\n\n    # head and tail are not modifiable\n    @property  \n    def head(self): return self._head\n\n    @property\n    def tail(self): return self._tail\n\n    def __nonzero__(self): return True\n\n    def __len__(self):\n        return sum(1 for _ in self)\n\n    def __add__(self, other):\n        other = LinkedList(other)\n\n        if not self: return other   # () + l = l\n        start=l = LinkedList(iter(self))  # Create copy, as we'll mutate\n\n        while l:\n            if not l._tail: # Last element?\n                l._tail = other\n                break\n            l = l._tail\n        return start\n\n    def __radd__(self, other):\n        return LinkedList(other) + self\n\n    def __iter__(self):\n        x=self\n        while x:\n            yield x.head\n            x=x.tail\n\n    def __getitem__(self, idx):\n        \"\"\"Get item at specified index\"\"\"\n        if isinstance(idx, slice):\n            # Special case: Avoid constructing a new list, or performing O(n) length \n            # calculation for slices like l[3:].  Since we're immutable, just return\n            # the appropriate node. This becomes O(start) rather than O(n).\n            # We can't do this for  more complicated slices however (eg [l:4]\n            start = idx.start or 0\n            if (start &gt;= 0) and (idx.stop is None) and (idx.step is None or idx.step == 1):\n                no_copy_needed=True\n            else:\n                length = len(self)  # Need to calc length.\n                start, stop, step = idx.indices(length)\n                no_copy_needed = (stop == length) and (step == 1)\n\n            if no_copy_needed:\n                l = self\n                for i in range(start): \n                    if not l: break # End of list.\n                    l=l.tail\n                return l\n            else:\n                # We need to construct a new list.\n                if step &lt; 1:  # Need to instantiate list to deal with -ve step\n                    return LinkedList(list(self)[start:stop:step])\n                else:\n                    return LinkedList(itertools.islice(iter(self), start, stop, step))\n        else:       \n            # Non-slice index.\n            if idx &lt; 0: idx = len(self)+idx\n            if not self: raise IndexError(\"list index out of range\")\n            if idx == 0: return self.head\n            return self.tail[idx-1]\n\n    def __mul__(self, n):\n        if n &lt;= 0: return Nil\n        l=self\n        for i in range(n-1): l += self\n        return l\n    def __rmul__(self, n): return self * n\n\n    # Ideally we should compute the has ourselves rather than construct\n    # a temporary tuple as below.  I haven't impemented this here\n    def __hash__(self): return hash(tuple(self))\n\n    def __eq__(self, other): return self._cmp(other) == 0\n    def __ne__(self, other): return not self == other\n    def __lt__(self, other): return self._cmp(other) &lt; 0\n    def __gt__(self, other): return self._cmp(other) &gt; 0\n    def __le__(self, other): return self._cmp(other) &lt;= 0\n    def __ge__(self, other): return self._cmp(other) &gt;= 0\n\n    def _cmp(self, other):\n        \"\"\"Acts as cmp(): -1 for self&lt;other, 0 for equal, 1 for greater\"\"\"\n        if not isinstance(other, LinkedList):\n            return cmp(LinkedList,type(other))  # Arbitrary ordering.\n\n        A, B = iter(self), iter(other)\n        for a,b in itertools.izip(A,B):\n           if a&lt;b: return -1\n           elif a &gt; b: return 1\n\n        try:\n            A.next()\n            return 1  # a has more items.\n        except StopIteration: pass\n\n        try:\n            B.next()\n            return -1  # b has more items.\n        except StopIteration: pass\n\n        return 0  # Lists are equal\n\n    def __repr__(self):\n        return \"LinkedList([%s])\" % ', '.join(map(repr,self))\n\nclass EmptyList(LinkedList):\n    \"\"\"A singleton representing an empty list.\"\"\"\n    def __new__(cls):\n        return object.__new__(cls)\n\n    def __iter__(self): return iter([])\n    def __nonzero__(self): return False\n\n    @property\n    def head(self): raise IndexError(\"End of list\")\n\n    @property\n    def tail(self): raise IndexError(\"End of list\")\n\n# Create EmptyList singleton\nLinkedList.EmptyList = EmptyList()\ndel EmptyList\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here's a rather Scheme way to do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class cons:\n        def __init__(self, f, r):\n                self.__f = f\n                self.__r = r\n        def __str__(self):\n                return \"(%s, %s)\" % (str(self.__f), str(self.__r))\n        __repr__ = __str__\n        class empty:\n                def __init__(self): pass\n                __repr__ = lambda self: \"empty\"\n                __str__ = __repr__\n        empty = empty()\n        def first(self): return self.__f\n        def rest(self): return self.__r\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm looking for a more python way, though, and ideally one that has easier to work with syntax than this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; cons(12, cons(4, cons.empty))\n(12, (4, empty))\n&gt;&gt;&gt; cons(12, cons(4, cons.empty)).first()\n12\n&gt;&gt;&gt; cons(12, cons(4, cons.empty)).rest()\n(4, empty)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["When using immutable linked lists, consider using Python's tuple directly. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ls = (1, 2, 3, 4, 5)\n\ndef first(ls): return ls[0]\ndef rest(ls): return ls[1:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Its really that ease, and you get to keep the additional funcitons like len(ls), x in ls, etc."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is a simple LinkedList class based on the straightforward C++ design and Chapter 17: Linked lists, as recommended by Thomas Watnedal."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "LinkedList", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://greenteapress.com/thinkpython/html/chap17.html", "text": "Chapter 17: Linked lists", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://stackoverflow.com/questions/280243/python-linked-list/280280#280280", "text": "Thomas Watnedal", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n class Node:\n    def __init__(self, value = None, next = None):\n        self.value = value\n        self.next = next\n\n    def __str__(self):\n        return 'Node ['+str(self.value)+']'\n\nclass LinkedList:\n    def __init__(self):\n        self.first = None\n        self.last = None\n\n    def insert(self, x):\n        if self.first == None:\n            self.first = Node(x, None)\n            self.last = self.first\n        elif self.last == self.first:\n            self.last = Node(x, None)\n            self.first.next = self.last\n        else:\n            current = Node(x, None)\n            self.last.next = current\n            self.last = current\n\n    def __str__(self):\n        if self.first != None:\n            current = self.first\n            out = 'LinkedList [\\n' +str(current.value) +'\\n'\n            while current.next != None:\n                current = current.next\n                out += str(current.value) + '\\n'\n            return out + ']'\n        return 'LinkedList []'\n\n    def clear(self):\n        self.__init__()\n\nL = LinkedList()\nL.insert(1)\nL.insert(1)\nL.insert(2)\nL.insert(4)\nprint L\nL.clear()\nprint L\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I based this additional function on Nick Stinemates"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Nick Stinemates", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/4960/nick-stinemates"}]}, {"code": "<pre>\n<code>\n def add_node_at_end(self, data):\n    new_node = Node()\n    node = self.curr_node\n    while node:\n        if node.next == None:\n            node.next = new_node\n            new_node.next = None\n            new_node.data = data\n        node = node.next\n</code>\n</pre>\n", "senID": 1}, {"text": ["The method he has adds the new node at the beginning while I have seen a lot of implementations which usually add a new node at the end but whatever, it is fun to do."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I think the implementation below fill the bill quite gracefully."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n '''singly linked lists, by Yingjie Lan, December 1st, 2011'''\n\nclass linkst:\n    '''Singly linked list, with pythonic features.\nThe list has pointers to both the first and the last node.'''\n    __slots__ = ['data', 'next'] #memory efficient\n    def __init__(self, iterable=(), data=None, next=None):\n        '''Provide an iterable to make a singly linked list.\nSet iterable to None to make a data node for internal use.'''\n        if iterable is not None: \n            self.data, self.next = self, None\n            self.extend(iterable)\n        else: #a common node\n            self.data, self.next = data, next\n\n    def empty(self):\n        '''test if the list is empty'''\n        return self.next is None\n\n    def append(self, data):\n        '''append to the end of list.'''\n        last = self.data\n        self.data = last.next = linkst(None, data)\n        #self.data = last.next\n\n    def insert(self, data, index=0):\n        '''insert data before index.\nRaise IndexError if index is out of range'''\n        curr, cat = self, 0\n        while cat &lt; index and curr:\n            curr, cat = curr.next, cat+1\n        if index&lt;0 or not curr:\n            raise IndexError(index)\n        new = linkst(None, data, curr.next)\n        if curr.next is None: self.data = new\n        curr.next = new\n\n    def reverse(self):\n        '''reverse the order of list in place'''\n        current, prev = self.next, None\n        while current: #what if list is empty?\n            next = current.next\n            current.next = prev\n            prev, current = current, next\n        if self.next: self.data = self.next\n        self.next = prev\n\n    def delete(self, index=0):\n        '''remvoe the item at index from the list'''\n        curr, cat = self, 0\n        while cat &lt; index and curr.next:\n            curr, cat = curr.next, cat+1\n        if index&lt;0 or not curr.next:\n            raise IndexError(index)\n        curr.next = curr.next.next\n        if curr.next is None: #tail\n            self.data = curr #current == self?\n\n    def remove(self, data):\n        '''remove first occurrence of data.\nRaises ValueError if the data is not present.'''\n        current = self\n        while current.next: #node to be examined\n            if data == current.next.data: break\n            current = current.next #move on\n        else: raise ValueError(data)\n        current.next = current.next.next\n        if current.next is None: #tail\n            self.data = current #current == self?\n\n    def __contains__(self, data):\n        '''membership test using keyword 'in'.'''\n        current = self.next\n        while current:\n            if data == current.data:\n                return True\n            current = current.next\n        return False\n\n    def __iter__(self):\n        '''iterate through list by for-statements.\nreturn an iterator that must define the __next__ method.'''\n        itr = linkst()\n        itr.next = self.next\n        return itr #invariance: itr.data == itr\n\n    def __next__(self):\n        '''the for-statement depends on this method\nto provide items one by one in the list.\nreturn the next data, and move on.'''\n        #the invariance is checked so that a linked list\n        #will not be mistakenly iterated over\n        if self.data is not self or self.next is None:\n            raise StopIteration()\n        next = self.next\n        self.next = next.next\n        return next.data\n\n    def __repr__(self):\n        '''string representation of the list'''\n        return 'linkst(%r)'%list(self)\n\n    def __str__(self):\n        '''converting the list to a string'''\n        return '-&gt;'.join(str(i) for i in self)\n\n    #note: this is NOT the class lab! see file linked.py.\n    def extend(self, iterable):\n        '''takes an iterable, and append all items in the iterable\nto the end of the list self.'''\n        last = self.data\n        for i in iterable:\n            last.next = linkst(None, i)\n            last = last.next\n        self.data = last\n\n    def index(self, data):\n        '''TODO: return first index of data in the list self.\n    Raises ValueError if the value is not present.'''\n        #must not convert self to a tuple or any other containers\n        current, idx = self.next, 0\n        while current:\n            if current.data == data: return idx\n            current, idx = current.next, idx+1\n        raise ValueError(data)\n</code>\n</pre>\n", "senID": 1}]]