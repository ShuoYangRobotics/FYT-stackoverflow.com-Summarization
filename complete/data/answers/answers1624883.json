[[{"text": ["Here you go:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list_of_groups = zip(*(iter(the_list),) * group_size)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n print zip(*(iter(range(10)),) * 3)\n[(0, 1, 2), (3, 4, 5), (6, 7, 8)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["If the number of elements is not divisible by N but you still want to include them you can use izip_longest but it is only available since python 2.6"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n izip_longest(*(iter(range(10)),) * 3)\n</code>\n</pre>\n", "senID": 5}, {"text": ["The result is a generator so you need to convert it into a list if you want to print it."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Finally, if you don't have python 2.6 and stuck with an older version but you still want to have the same result you can use map:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n print map(None, *(iter(range(10)),) * 3)\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, None, None)]\n</code>\n</pre>\n", "senID": 8}, {"text": ["I'd like to add some speed comparison between the different methods presented so far:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n python -m timeit -s 'from itertools import izip_longest; L = range(1000)' 'list(izip_longest(*(iter(L),) * 3))'\n10000 loops, best of 3: 47.1 usec per loop\n\npython -m timeit -s 'L = range(1000)' 'zip(*(iter(L),) * 3)'\n10000 loops, best of 3: 50.1 usec per loop\n\npython -m timeit -s 'L = range(1000)' 'map(None, *(iter(L),) * 3)'\n10000 loops, best of 3: 50.7 usec per loop\n\npython -m timeit -s 'L = range(1000)' '[L[i:i+3] for i in range(0, len(L), 3)]'\n10000 loops, best of 3: 157 usec per loop\n\npython -m timeit -s 'import itertools; L = range(1000)' '[list(group) for key, group in itertools.groupby(L, lambda k: k//3)]'\n1000 loops, best of 3: 1.41 msec per loop\n</code>\n</pre>\n", "senID": 10}, {"text": ["The list comprehension and the group by methods are clearly slower than zip, izip_longest and map"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["A Python recipe (In Python 2.6, use itertools.izip_longest):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Python recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/3.1/library/itertools.html#recipes"}, {"text": "itertools.izip_longest", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def grouper(n, iterable, fillvalue=None):\n    \"grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx\"\n    args = [iter(iterable)] * n\n    return itertools.zip_longest(*args, fillvalue=fillvalue)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(grouper(3, range(9)))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8)]\n&gt;&gt;&gt; list(grouper(3, range(10)))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, None, None)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you want the last group to be shorter than the others instead of padded with fillvalue, then you could e.g.", "change the code like this:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "fillvalue", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def mygrouper(n, iterable):\n...     args = [iter(iterable)] * n\n...     return ([e for e in t if e != None] for t in itertools.zip_longest(*args))\n... \n&gt;&gt;&gt; list(mygrouper(3, range(9)))\n[[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n&gt;&gt;&gt; list(mygrouper(3, range(10)))\n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n n = 25    \nlist_of_lists = [L[i:i+n] for i in range(0, len(L), n)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["it gives you the list of lists [[0..24], [25..49], ..]"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "[[0..24], [25..49], ..]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If len(L) % n isn't 0, the last element's (list_of_lists[-1]) lenght will be len(L) % n."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "len(L) % n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list_of_lists[-1]", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Itertools.groupby is a fine tool, here is a way to split a list of integers simply by using integer division:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for key, group in itertools.groupby(range(10), lambda k: k//3):\n...  print key, list(group)\n... \n0 [0, 1, 2]\n1 [3, 4, 5]\n2 [6, 7, 8]\n3 [9]\n</code>\n</pre>\n", "senID": 1}, {"text": ["(The list has to start with 0 to begin with a full group."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["How about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; n = 2\n&gt;&gt;&gt; l = [1,2,3,4,5,6,7,8,9]\n&gt;&gt;&gt; [ l[i:i+n] for i in range(0, len(l), n) ]\n[[1, 2], [3, 4], [5, 6], [7, 8], [9]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["And if how you choose them matters,\nrandom.sample(population, k),\nReturn a k length list of unique elements chosen from the population sequence.", "Used for random sampling without replacement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]