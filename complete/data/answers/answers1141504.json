[[{"text": ["The Python docs call this Unpacking Argument Lists.", "It's a pretty handy feature.", "In Python, you can also use a double asterisk (**) to unpack a dictionary (hash) into keyword arguments.", "They also work in reverse.", "I can define a function like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Unpacking Argument Lists", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/controlflow.html#unpacking-argument-lists"}]}, {"code": "<pre>\n<code>\n def sum(*args):\n    result = 0\n    for a in args:\n        result += a\n    return result\n\nsum(1,2)\nsum(9,5,7,8)\nsum(1.7,2.3,8.9,3.4)\n</code>\n</pre>\n", "senID": 1}, {"text": ["To pack all arguments into an arbitrarily sized list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In ruby, it is often called \"splat\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also in ruby, you can use it to mean 'all of the other elements in the list'."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a, *rest = [1,2,3,4,5,6]\na     # =&gt; 1\nrest  # =&gt; [2, 3, 4, 5, 6]\n</code>\n</pre>\n", "senID": 2}, {"text": ["It can also appear on either side of the assignment operator:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n a  = d, *e\n</code>\n</pre>\n", "senID": 4}, {"text": ["In this usage, it is a bit like scheme's cdr, although it needn't be all but the head of the list."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I've been calling it \"list expansion\", but I don't think that's standard terminology (I don't think there's any...).", "Lisp in all versions (Scheme included), and Haskell and other functional languages, can do it easily enough, but I don't think it's easy to do in \"mainstream\" languages (maybe you can pull it off as a \"reflection\" stunt in some!-)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The typical terminology for this is called \"applying a function to a list\",\nor \"apply\" for short. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["See http://en.wikipedia.org/wiki/Apply"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Apply", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Apply"}]}, {"text": ["It has been in LISP since pretty much its inception back in 1960 odd.", "Glad python rediscovered it :-}"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Apply is typically on a list or a representation of a list such\nas an array.", "However, one can apply functions to arguments that\ncome from other palces, such as structs.", "Our PARLANSE language\nhas fixed types (int, float, string, ...) and structures.", "Oddly enough, a function argument list looks a lot like a structure\ndefinintion, and in PARLANSE, it is a structure definition,\nand you can \"apply\" a PARLANSE function to a compatible structure.", "You can \"make\" structure instances, too, thus:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "list", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "is", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"code": "<pre>\n(define S\n    (structure [t integer]\n               [f float]\n               [b (array boolean 1 3)]\n    )structure\n )define s\n\n  (= A (array boolean 1 3 ~f ~F ~f))\n\n  (= s (make S -3 19.2 (make (array boolean 1 3) ~f ~t ~f))\n\n\n  (define foo (function string S) ...)\n\n  (foo +17 3e-2 A) ; standard function call\n\n  (foo s) ; here's the \"apply\"\n</pre>\n", "senID": 4}, {"text": ["PARLANSE looks like lisp but isn't."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["ruby calls it 'splat', though david black has also come up with the neat \"unar{,ra}y operator\" (i.e.", "'unary unarray operator')"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The majority of the questions have already been answered, but as to the question \"What is the name of the * operator?", "\": the technical term is \"asterisk\" (comes from the Latin word asteriscum, meaning \"little star\", which, in turn, comes from the Greek \u1f00\u03c3\u03c4\u03b5\u03c1\u03af\u03c3\u03ba\u03bf\u03c2).", "Often, though, it will be referred to as \"star\" or, as stated above, \"splat\"."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "asteriscum", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "\u1f00\u03c3\u03c4\u03b5\u03c1\u03af\u03c3\u03ba\u03bf\u03c2", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["Haskell has it too (for pairs), with the uncurry function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "uncurry", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ghci&gt; let f x y = 2*x + y\nf :: (Num a) =&gt; a -&gt; a -&gt; a\nghci&gt; f 1 2\n4\nghci&gt; f 10 3\n23\nghci&gt; uncurry f (1,2)\n4\nghci&gt; uncurry f (10,3)\n23\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can also make it into an operator, so it's more splat-like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ghci&gt; f `uncurry` (1,2)\n4\nghci&gt; let (***) = uncurry\n(***) :: (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c\nghci&gt; f *** (10,3)\n23\n</code>\n</pre>\n", "senID": 3}, {"text": ["And though it'd be easy to define similar functions for the 3-tuple, 4-tuple, etc cases, there isn't any general function for n-tuples (like splat works in other languages) because of Haskell's strict typing."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]