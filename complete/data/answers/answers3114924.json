[[{"text": ["I see you got a lot of examples, all so far from @Noctis, but I'm not sure how they're going to help you.", "Addressing your question more directly: the only way multithreading can speed your application up, in today's CPython, is if your slow-down is due in good part to \"blocking I/O\" operations, e.g.", "due to interactions with (for example) DB servers, mail servers, websites, and so on.", "(A powerful alternative to speed up I/O is asynchronous, AKA event-driven, programming, for which the richest Python framework is twisted -- but it can be harder to learn, if you've never done event-driven coding)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "twisted", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/"}]}, {"text": ["Even if you have many cores in your machine, one multi-threaded Python process will use only one of them at a time, except when it's executing specially coded extensions (typically in C, C++, Cython, and the like) which \"release the GIL\" (the global interpreter lock) when feasible."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you do have many cores, multiprocessing (a module whose interface is designed to look a lot like threading) can indeed speed up your program.", "There are many other packages supporting \"symmetric multi-processor\" distributed programming, see the list here, but, out of all of them, multiprocessing is the one that comes as part of the standard library (a very convenient thing).", "If you have multiple computers with a fast LAN between them, you should also consider the more general approach of distributed processing, which could let you use all of your available computers for the same task (some of these packages are also listed at the previous URL I gave, under the \"cluster computing\" header)."], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "multiprocessing", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "threading", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "can", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "here", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/ParallelProcessing"}, {"text": "multiprocessing", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "distributed", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/DistributedProgramming"}]}, {"text": ["What speed-up you can get for any number of available cores or computers ultimately depends on the nature of your problems -- and, if the problems per se are suitable for it, then also of the algorithms and data structures you're using... not all will speed-up well (it varies between \"embarassingly parallel\" problems such as ray-tracing, which speed up linearly all the way, to \"intrinsically serial\" ones where 100 machines won't be any faster than one).", "So, it's hard to advise you further without understanding the nature of your problems; care to explain that?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This is not a direct answer to your question but:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Have you considered using Python's multiprocessing module instead?", "It works by forking new processes, which has slightly more overhead but can often be faster because it avoid contention problems with Python's global interpreter lock.", "The documentation is quite thorough and there are a number of other articles about it online."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "multiprocessing module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/multiprocessing.html"}]}], [{"text": ["Here is a good tutorial.", "Section 3.1.2 (page 72 of the tutorial) has a simple client/server example using threads."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://heather.cs.ucdavis.edu/~matloff/158/PLN/ParProcBook.pdf"}]}], [{"text": ["the C (CPython) implementation of Python is multi-threaded but NOT concurrent.", "Only one thread runs at a time, because of the Global Interpeter Lock (GIL).", "If you want true concurrency you can use the mulitprocessing module.  "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "NOT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Global Interpeter Lock", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://blip.tv/file/2232410"}, {"text": "mulitprocessing", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/multiprocessing.html"}]}, {"text": ["None of the examples posted will help your multi-hour process run shorter, they will actually cause it to run L O N G E R.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also you don't mention what you are actually doing, but you are probably I/O bound if you are reading/writing data to anything (network or disk).", "And concurrency will just exacerbate the problem if that is the case."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Example 1"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Example 1", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import thread\n\nclass sync:\n\n    def __init__(self, threads):\n        self.__threads = threads\n        self.__count = 0\n        self.__main = thread.allocate_lock()\n        self.__exit = thread.allocate_lock()\n        self.__exit.acquire()\n\n    def sync(self):\n        self.__main.acquire()\n        self.__count += 1\n        if self.__count &lt; self.__threads:\n            self.__main.release()\n        else:\n            self.__exit.release()\n        self.__exit.acquire()\n        self.__count -= 1\n        if self.__count &gt; 0:\n            self.__exit.release()\n        else:\n            self.__main.release()\n\ndef example():\n    def get_input(share):\n        while share[0]:\n            share[1] = raw_input('Please say something.\\n')\n            share[2].sync()\n        share[3].sync()\n    def do_output(share):\n        while share[0]:\n            share[2].sync()\n            print 'You said, \"%s\"' % share[1]\n        share[3].sync()\n    share = [True, None, sync(2), sync(3)]\n    thread.start_new_thread(get_input, (share,))\n    thread.start_new_thread(do_output, (share,))\n    import time; time.sleep(60)\n    share[0] = False\n    share[3].sync()\n\nif __name__ == '__main__':\n    example()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Example 2"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Example 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from os.path import basename\nfrom Queue import Queue\nfrom random import random\nfrom sys import argv, exit\nfrom threading import Thread\nfrom time import sleep\n\n# for creating widgets\nclass Widget:\n    pass\n\n# for creating stacks\nclass Stack:\n    def __init__(self):\n        self.__stack = list()\n    def __len__(self):\n        return len(self.__stack)\n    def push(self, item):\n        self.__stack.append(item)\n    def pop(self):\n        return self.__stack.pop()\n\n# provides an outline for the execution of the program\ndef main():\n    # check and parse the command line arguments\n    parse_sys_argv()\n    # setup the variables used by the threads\n    run_flag = [True]\n    queue = Queue(argv[1])\n    send = Stack()\n    recv = Stack()\n    # start the threads\n    producer = Thread(target=produce, args=(run_flag, queue, send))\n    consumer = Thread(target=consume, args=(run_flag, queue, recv, producer))\n    producer.start()\n    consumer.start()\n    # let the threads do their work\n    sleep(argv[2])\n    run_flag[0] = False\n    consumer.join()\n    # verify that the solution was valid\n    calculate_results(send, recv)\n\n# parses and checks the command line arguments\ndef parse_sys_argv():\n    try:\n        # there should be two command line arguments\n        assert len(argv) == 3\n        # convert &lt;buf_size&gt; and check\n        argv[1] = abs(int(argv[1]))\n        assert argv[1] &gt; 0\n        # convert &lt;run_time&gt; and check\n        argv[2] = abs(float(argv[2]))\n        assert argv[2] &gt; 0\n    except:\n        # print out usage information\n        print basename(argv[0]),\n        print '&lt;buf_size&gt; &lt;run_time&gt;'\n        # exits the program\n        exit(1)\n\n# called by the producer thread\ndef produce(run_flag, queue, send):\n    while run_flag[0]:\n        # simulate production\n        sleep(random())\n        # put widget in buffer\n        item = Widget()\n        queue.put(item)\n        send.push(item)\n\n# called by the consumer thread\ndef consume(run_flag, queue, recv, producer):\n    # consume items while running\n    while run_flag[0]:\n        do_consume(queue, recv)\n    # empty the queue to allow maximum room\n    while not queue.empty():\n        do_consume(queue, recv)\n    # wait for the producer to end\n    producer.join()\n    # consume any other items that might have been produced\n    while not queue.empty():\n        do_consume(queue, recv)\n\n# executes one consumption operation\ndef do_consume(queue, recv):\n    # get a widget from the queue\n    recv.push(queue.get())\n    # simulate consumption\n    sleep(random())\n\n# verifies that send and recv were equal\ndef calculate_results(send, recv):\n    print 'Solution has',\n    try:\n        # make sure that send and recv have the same length\n        assert len(send) == len(recv)\n        # check all of the contents of send and recv\n        while send:\n            # check the identity of the items in send and recv\n            assert send.pop() is recv.pop()\n        print 'passed.'\n    except:\n        print 'failed.'\n\n# starts the program\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Example 3"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Example 3", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from os.path import basename\nfrom Queue import Queue\nfrom random import random, seed\nfrom sys import argv, exit\nfrom threading import Thread\nfrom time import sleep\n\n################################################################################\n\nclass Widget:\n    pass\n\nclass Stack:\n    def __init__(self):\n        self.__stack = list()\n    def __len__(self):\n        return len(self.__stack)\n    def push(self, item):\n        self.__stack.append(item)\n    def pop(self):\n        return self.__stack.pop()\n\n################################################################################\n\ndef main():\n    parse_argv()\n    run_flag, buffer_queue, producer_stack, consumer_stack, print_queue = [True], Queue(argv[1]), Stack(), Stack(), Queue()\n    producer_thread = Thread(target=producer, args=(run_flag, argv[3], buffer_queue, producer_stack, print_queue))\n    consumer_thread = Thread(target=consumer, args=(run_flag, producer_thread, buffer_queue, consumer_stack, argv[4], print_queue))\n    printer_thread = Thread(target=printer, args=(run_flag, consumer_thread, print_queue))\n    producer_thread.start()\n    consumer_thread.start()\n    printer_thread.start()\n    sleep(argv[2])\n    run_flag[0] = False\n    printer_thread.join()\n    check_results(producer_stack , consumer_stack)\n\ndef parse_argv():\n    try:\n        assert len(argv) &gt; 4\n        argv[1] = abs(int(argv[1]))\n        argv[2] = abs(float(argv[2]))\n        assert argv[1] and argv[2]\n        argv[3] = abs(float(argv[3]))\n        argv[4] = abs(float(argv[4]))\n        if len(argv) &gt; 5:\n            seed(convert(' '.join(argv[5:])))\n    except:\n        print basename(argv[0]), '&lt;buff_size&gt; &lt;main_time&gt; &lt;prod_time&gt; &lt;cons_time&gt; [&lt;seed&gt;]'\n        exit(1)\n\ndef convert(string):\n    number = 1\n    for character in string:\n        number &lt;&lt;= 8\n        number += ord(character)\n    return number\n\ndef check_results(producer_stack , consumer_stack):\n    print 'Solution has',\n    try:\n        assert len(producer_stack) == len(consumer_stack)\n        while producer_stack:\n            assert producer_stack.pop() is consumer_stack.pop()\n        print 'passed.'\n    except:\n        print 'failed.'\n\n################################################################################\n\ndef producer(run_flag, max_time, buffer_queue, producer_stack, print_queue):\n    while run_flag[0]:\n        sleep(random() * max_time)\n        widget = Widget()\n        buffer_queue.put(widget)\n        producer_stack.push(widget)\n        print_queue.put('Producer: %s Widget' % id(widget))\n\ndef consumer(run_flag, producer_thread, buffer_queue, consumer_stack, max_time, print_queue):\n    while run_flag[0] or producer_thread.isAlive() or not buffer_queue.empty():\n        widget = buffer_queue.get()\n        consumer_stack.push(widget)\n        sleep(random() * max_time)\n        print_queue.put('Consumer: %s Widget' % id(widget))\n\ndef printer(run_flag, consumer_thread, print_queue):\n    while run_flag[0] or consumer_thread.isAlive() or not print_queue.empty():\n        if print_queue.empty():\n            sleep(0.1)\n        else:\n            print print_queue.get()\n\n################################################################################\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Example 4"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Example 4", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import socket\nimport sys\nimport thread\n\ndef main(setup, error):\n    sys.stderr = file(error, 'a')\n    for settings in parse(setup):\n        thread.start_new_thread(server, settings)\n    lock = thread.allocate_lock()\n    lock.acquire()\n    lock.acquire()\n\ndef parse(setup):\n    settings = list()\n    for line in file(setup):\n        parts = line.split()\n        settings.append((parts[0], int(parts[1]), int(parts[2])))\n    return settings\n\ndef server(*settings):\n    try:\n        dock_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        dock_socket.bind(('', settings[2]))\n        dock_socket.listen(5)\n        while True:\n            client_socket = dock_socket.accept()[0]\n            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            server_socket.connect((settings[0], settings[1]))\n            thread.start_new_thread(forward, (client_socket, server_socket))\n            thread.start_new_thread(forward, (server_socket, client_socket))\n    finally:\n        thread.start_new_thread(server, settings)\n\ndef forward(source, destination):\n    string = ' '\n    while string:\n        string = source.recv(1024)\n        if string:\n            destination.sendall(string)\n        else:\n            source.shutdown(socket.SHUT_RD)\n            destination.shutdown(socket.SHUT_WR)\n\nif __name__ == '__main__':\n    main('proxy.ini', 'error.log')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Example 5"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Example 5", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # #include &lt;windows.h&gt;\nimport thread\n# #include &lt;math.h&gt;\nimport math\n# #include &lt;stdio.h&gt;\nimport sys\n# #include &lt;stdlib.h&gt;\nimport time\n\n# static int runFlag = TRUE;\nrunFlag = True\n\n# void main(int argc, char *argv[]) {\ndef main(argc, argv):\n    global runFlag\n    # unsigned int runTime\n    # PYTHON: NO CODE\n\n    # SYSTEMTIME now;\n    # PYTHON: NO CODE\n    # WORD stopTimeMinute, stopTimeSecond;\n    # PYTHON: NO CODE\n\n    # // Get command line argument, N\n    try:\n        N = abs(int(argv[1]))\n    except:\n        sys.exit(1)\n    # // Get the time the threads should run, runtime\n    try:\n        runTime = abs(int(argv[2]))\n    except:\n        sys.exit(1)\n    # // Calculate time to halt (learn better ways to do this later)\n    # GetSystemTime(&amp;now);\n    now = time.localtime()\n    # printf(\"mthread: Suite starting at system time\n    #   %d:%d:%d\\n\", now.wHour, now.wMinute, now.wSecond);\n    sys.stdout.write('mthread: Suite starting at system time %d:%d:%d\\n' \\\n          % (now.tm_hour, now.tm_min, now.tm_sec))\n    # stopTimeSecond = (now.wSecond + (WORD) runTime) % 60;\n    stopTimeSecond = (now.tm_sec + runTime) % 60\n    # stopTimeMinute = now.wMinute + (now.wSecond +\n    #   (WORD) runTime) / 60;\n    stopTimeMinute = now.tm_min + (now.tm_sec + runTime) / 60\n\n    # // For 1 to N\n    # for (i = 0; i &lt; N; i++) {\n    for i in range(N):\n        # // Create a new thread to execute simulated word\n        thread.start_new_thread(threadWork, ())\n        # Sleep(100);               // Let newly created thread run\n        time.sleep(0.1)\n    # }\n    # PYTHON: NO CODE\n\n    # // Cycle while children work ...\n    # while (runFlag) {\n    while runFlag:\n        # GetSystemTime(&amp;now);\n        now = time.localtime()\n        # if ((now.wMinute &gt;= stopTimeMinute)\n        #     &amp;&amp;\n        #     (now.wSecond &gt;= stopTimeSecond)\n        #    )\n        if now.tm_min &gt;= stopTimeMinute \\\n           and now.tm_sec &gt;= stopTimeSecond:\n            # runFlag = FALSE;\n            runFlag = False\n        # Sleep(1000);\n        time.sleep(1)\n    # }\n    # PYTHON: NO CODE\n    # Sleep(5000);\n    time.sleep(5)\n# }\n# PYTHON: NO CODE\n\n# // The code executed by each worker thread (simulated work)\n# DWORD WINAPI threadWork(LPVOID threadNo) {\ndef threadWork():\n    threadNo = thread.get_ident()\n    # // Local variables\n    # double y;\n    # PYTHON: NO CODE\n    # const double x = 3.14159;\n    x = 3.14159\n    # const double e = 2.7183;\n    e = 2.7183\n    # int i;\n    # PYTHON: NO CODE\n    # const int napTime = 1000;             // in milliseconds\n    napTime = 1000\n    # const int busyTime = 40000;\n    busyTime = 40000\n    # DWORD result = 0;\n    result = 0\n\n    # // Create load\n    # while (runFlag) {\n    while runFlag:\n        # // Parameterized processor burst phase\n        # for (i = 0; i &lt; busyTime; i++)\n        for i in range(busyTime):\n            # y = pow(x, e);\n            y = math.pow(x, e)\n        # // Parameterized sleep phase\n        # Sleep(napTime);\n        time.sleep(napTime / 1000.0)\n        # // Write message to stdout\n        sys.stdout.write('Thread %s just woke up.\\n' % threadNo)\n    # }\n    # PYTHON: NO CODE\n    # // Terminating\n    # return result;\n    return result\n# }\n# PYTHON: NO CODE\n\nif __name__ == '__main__':\n    main(len(sys.argv), sys.argv)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Example 6"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Example 6", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import tkinter\nimport _thread\nimport time\n\nEPOCH_DELTA = 946684800\nMICREV_IN_DAY = 1000000\nMILREV_IN_DAY = 1000\n\nSECOND_IN_DAY = 86400\nDAY_IN_WEEK = 7\nWEEK_IN_MONTH = 4\nMONTH_IN_SEASON = 3\nSEASON_IN_YEAR = 4\n\nSECOND_IN_WEEK = SECOND_IN_DAY * DAY_IN_WEEK\nSECOND_IN_MONTH = SECOND_IN_WEEK * WEEK_IN_MONTH\nSECOND_IN_SEASON = SECOND_IN_MONTH * MONTH_IN_SEASON\nSECOND_IN_YEAR = SECOND_IN_SEASON * SEASON_IN_YEAR\n\ndef seconds():\n    \"Return seconds since the epoch.\"\n    return time.time() - EPOCH_DELTA\n\ndef micrev(seconds):\n    \"Convert from seconds to micrev.\"\n    x = seconds % SECOND_IN_DAY * MICREV_IN_DAY / SECOND_IN_DAY % MILREV_IN_DAY\n    return int(x)\n\ndef milrev(seconds):\n    \"Convert from seconds to milrev.\"\n    x = seconds % SECOND_IN_DAY * MILREV_IN_DAY / SECOND_IN_DAY\n    return int(x)\n\ndef day(seconds):\n    \"Convert from seconds to days.\"\n    x = seconds / SECOND_IN_DAY % DAY_IN_WEEK\n    return int(x)\n\ndef week(seconds):\n    \"Convert from seconds to weeks.\"\n    x = seconds / SECOND_IN_WEEK % WEEK_IN_MONTH\n    return int(x)\n\ndef month(seconds):\n    \"Convert from seconds to months.\"\n    x = seconds / SECOND_IN_MONTH % MONTH_IN_SEASON\n    return int(x)\n\ndef season(seconds):\n    \"Convert from seconds to seasons.\"\n    x = seconds / SECOND_IN_SEASON % SEASON_IN_YEAR\n    return int(x)\n\ndef year(seconds):\n    \"Convert from seconds to years.\"\n    x = seconds / SECOND_IN_YEAR\n    return int(x)\n\nUNITS = year, season, month, week, day, milrev, micrev\n\ndef text(seconds, spec='{0}.{1}.{2}.{3}.{4}.{5:03}.{6:03}', unit=UNITS):\n    \"Convert from seconds to text.\"\n    return spec.format(*[func(seconds) for func in unit])\n\nclass Quantum_Timer:\n\n    \"Quantum_Timer(function, *args, **kwargs) -&gt; Quantum_Timer\"\n\n    def __init__(self, function, *args, **kwargs):\n        \"Initialize the Quantum_Timer object.\"\n        self.__function = function\n        self.__args = args\n        self.__kwargs = kwargs\n        self.__thread = False\n        self.__lock = _thread.allocate_lock()\n\n    def start(self):\n        \"Start the Quantum_Timer object.\"\n        with self.__lock:\n            self.__active = True\n            if not self.__thread:\n                self.__thread = True\n                _thread.start_new_thread(self.__run, ())\n\n    def stop(self):\n        \"Stop the Quantum_Timer object.\"\n        with self.__lock:\n            self.__active = False\n\n    def __run(self):\n        \"Private class method.\"\n        while True:\n            secs = time.clock()\n            plus = secs + 0.0864\n            over = plus % 0.0864\n            diff = plus - secs - over\n            time.sleep(diff)\n            with self.__lock:\n                if not self.__active:\n                    self.__thread = False\n                    break\n            self.__function(*self.__args, **self.__kwargs)\n\ndef main():\n    root = tkinter.Tk()\n    root.resizable(False, False)\n    root.title('Time in Tessaressunago')\n    secs = tkinter.StringVar()\n    text = tkinter.Label(textvariable=secs, font=('helvetica', 16, 'bold'))\n    text.grid(padx=5, pady=5)\n    thread = Quantum_Timer(update, secs)\n    thread.start()\n    root.mainloop()\n\ndef update(secs):\n    s = seconds()\n    t = text(s)\n    p = 1000000000 * 1.01 ** (s / SECOND_IN_YEAR)\n    secs.set('Time = {0}\\nNational = {1}'.format(t, fix(p)))\n\ndef fix(number, sep=','):\n    number = str(int(number))\n    string = ''\n    while number:\n        string = number[-1] + string\n        number = number[:-1]\n        if number and not (len(string) + 1) % 4:\n            string = sep + string\n    return string\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Example 7"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Example 7", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n HOST = '127.0.0.1'\nPORT = 8080\n\nfrom Tkinter import *\nimport tkColorChooser\n\nimport socket\nimport thread\nimport cPickle\n\n################################################################################\n\nclass ZSP:\n\n    'ZSP(socket) -&gt; ZSP'\n\n    def __init__(self, socket):\n        'Initialize the Zero SPOTS Protocol object.'\n        self.__file = socket.makefile('b', 0)\n\n    def send(self, obj):\n        'Send one object.'\n        cPickle.dump(obj, self.__file, cPickle.HIGHEST_PROTOCOL)\n\n    def recv(self):\n        'Receive one object.'\n        return cPickle.load(self.__file)\n\n################################################################################\n\ndef main():\n    global hold, fill, draw, look\n    hold = []\n    fill = '#000000'\n    connect()\n    root = Tk()\n    root.title('Paint 2.0')\n    root.resizable(False, False)\n    upper = LabelFrame(root, text='Your Canvas')\n    lower = LabelFrame(root, text='Their Canvas')\n    draw = Canvas(upper, bg='#ffffff', width=400, height=300, highlightthickness=0)\n    look = Canvas(lower, bg='#ffffff', width=400, height=300, highlightthickness=0)\n    cursor = Button(upper, text='Cursor Color', command=change_cursor)\n    canvas = Button(upper, text='Canvas Color', command=change_canvas)\n    draw.bind('&lt;Motion&gt;', motion)\n    draw.bind('&lt;ButtonPress-1&gt;', press)\n    draw.bind('&lt;ButtonRelease-1&gt;', release)\n    draw.bind('&lt;Button-3&gt;', delete)\n    upper.grid(padx=5, pady=5)\n    lower.grid(padx=5, pady=5)\n    draw.grid(row=0, column=0, padx=5, pady=5, columnspan=2)\n    look.grid(padx=5, pady=5)\n    cursor.grid(row=1, column=0, padx=5, pady=5, sticky=EW)\n    canvas.grid(row=1, column=1, padx=5, pady=5, sticky=EW)\n    root.mainloop()\n\n################################################################################\n\ndef connect():\n    try:\n        start_client()\n    except:\n        start_server()\n    thread.start_new_thread(processor, ())\n\ndef start_client():\n    global ZSP\n    server = socket.socket()\n    server.connect((HOST, PORT))\n    ZSP = ZSP(server)\n\ndef start_server():\n    global ZSP\n    server = socket.socket()\n    server.bind(('', PORT))\n    server.listen(1)\n    ZSP = ZSP(server.accept()[0])\n\ndef processor():\n    while True:\n        func, args, kwargs = ZSP.recv()\n        getattr(look, func)(*args, **kwargs)\n\ndef call(func, *args, **kwargs):\n    ZSP.send((func, args, kwargs))\n\n################################################################################\n\ndef change_cursor():\n    global fill\n    color = tkColorChooser.askcolor(color=fill)[1]\n    if color is not None:\n        fill = color\n\ndef change_canvas():\n    color = tkColorChooser.askcolor(color=draw['bg'])[1]\n    if color is not None:\n        draw.config(bg=color)\n        call('config', bg=color)\n\n################################################################################\n\ndef motion(event):\n    if hold:\n        hold.extend([event.x, event.y])\n        event.widget.create_line(hold[-4:], fill=fill, tag='TEMP')\n        call('create_line', hold[-4:], fill=fill, tag='TEMP')\n\ndef press(event):\n    global hold\n    hold = [event.x, event.y]\n\ndef release(event):\n    global hold\n    if len(hold) &gt; 2:\n        event.widget.delete('TEMP')\n        event.widget.create_line(hold, fill=fill, smooth=True)\n        call('delete', 'TEMP')\n        call('create_line', hold, fill=fill, smooth=True)\n    hold = []\n\ndef delete(event):\n    event.widget.delete(ALL)\n    call('delete', ALL)\n\n################################################################################\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Example 8"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Example 8", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n HOST = '127.0.0.1'\nPORT = 8080\n\ntry:\n    from Tkinter import *\nexcept ImportError:\n    from tkinter import *\n\ntry:\n    import tkColorChooser\nexcept ImportError:\n    import tkinter.colorchooser as tkColorChooser\n\ntry:\n    import thread\nexcept ImportError:\n    import _thread as thread\n\nimport socket\nimport pickle\nimport time\nimport sys\n\n################################################################################\n\nclass ZSP:\n\n    'ZSP(socket) -&gt; ZSP'\n\n    def __init__(self, socket):\n        'Initialize the Zero SPOTS Protocol object.'\n        self.__o_file = socket.makefile('bw', 0)\n        self.__i_file = socket.makefile('br', 0)\n\n    def send(self, obj):\n        'Send one object.'\n        pickle.dump(obj, self.__o_file, pickle.HIGHEST_PROTOCOL)\n\n    def recv(self):\n        'Receive one object.'\n        return pickle.load(self.__i_file)\n\n################################################################################\n\nclass QRP:\n\n    'QRP(ZSP) -&gt; QRP'\n\n    def __init__(self, ZSP):\n        'Initialize the Query/Reply Protocol object.'\n        self.__ZSP = ZSP\n        self.__error = None\n        self.__Q_anchor = []\n        self.__Q_packet = []\n        self.__R_anchor = {}\n        self.__Q_lock = thread.allocate_lock()\n        self.__R_lock = thread.allocate_lock()\n        thread.start_new_thread(self.__thread, ())\n\n    def send_Q(self, ID, obj):\n        'Send one query.'\n        if self.__error:\n            raise self.__error\n        self.__ZSP.send((False, ID, obj))\n\n    def recv_Q(self, timeout=None):\n        'Receive one query.'\n        if self.__error:\n            raise self.__error\n        if timeout is not None:\n            if not isinstance(timeout, (float, int)):\n                raise TypeError('timeout must be of type float or int')\n            if not timeout &gt;= 0:\n                raise ValueError('timeout must be greater than or equal to 0')\n        self.__Q_lock.acquire()\n        try:\n            try:\n                if self.__Q_packet:\n                    Q = True\n                    ID, obj = self.__Q_packet.pop()\n                else:\n                    Q = False\n                    anchor = [thread.allocate_lock()]\n                    anchor[0].acquire()\n                    self.__Q_anchor.append(anchor)\n            finally:\n                self.__Q_lock.release()\n        except AttributeError:\n            raise self.__error\n        if Q:\n            return ID, obj\n        if timeout:\n            thread.start_new_thread(self.__Q_thread, (timeout, anchor))\n        anchor[0].acquire()\n        try:\n            Q = anchor[1]\n        except IndexError:\n            if self.__error:\n                raise self.__error\n            raise Warning\n        return Q\n\n    def send_R(self, ID, obj):\n        'Send one reply.'\n        if self.__error:\n            raise self.__error\n        self.__ZSP.send((True, ID, obj))\n\n    def recv_R(self, ID, timeout=None):\n        'Receive one reply.'\n        if self.__error:\n            raise self.__error\n        if timeout is not None:\n            if not isinstance(timeout, (float, int)):\n                raise TypeError('timeout must be of type float or int')\n            if not timeout &gt;= 0:\n                raise ValueError('timeout must be greater than or equal to 0')\n        anchor = [thread.allocate_lock()]\n        anchor[0].acquire()\n        self.__R_lock.acquire()\n        try:\n            try:\n                self.__R_anchor[ID] = anchor\n            finally:\n                self.__R_lock.release()\n        except AttributeError:\n            raise self.__error\n        if timeout:\n            thread.start_new_thread(self.__R_thread, (timeout, ID))\n        anchor[0].acquire()\n        try:\n            R = anchor[1]\n        except IndexError:\n            if self.__error:\n                raise self.__error\n            raise Warning\n        return R\n\n    def __thread(self):\n        'Private class method.'\n        try:\n            while True:\n                R, ID, obj = self.__ZSP.recv()\n                if R:\n                    self.__R_lock.acquire()\n                    if self.__R_anchor:\n                        self.__R_anchor[ID].append(obj)\n                        self.__R_anchor[ID][0].release()\n                        del self.__R_anchor[ID]\n                    self.__R_lock.release()\n                else:\n                    self.__Q_lock.acquire()\n                    if self.__Q_anchor:\n                        anchor = self.__Q_anchor.pop()\n                        anchor.append((ID, obj))\n                        anchor[0].release()\n                    else:\n                        self.__Q_packet.append((ID, obj))\n                    self.__Q_lock.release()\n        except Exception:\n            error = sys.exc_info()[1]\n            if isinstance(error, EOFError):\n                self.__error = EOFError\n            else:\n                self.__error = IOError\n            self.__Q_lock.acquire()\n            for anchor in self.__Q_anchor:\n                anchor[0].release()\n            del self.__Q_anchor\n            del self.__Q_packet\n            self.__Q_lock.release()\n            self.__R_lock.acquire()\n            for key in self.__R_anchor:\n                self.__R_anchor[key][0].release()\n            del self.__R_anchor\n            self.__R_lock.release()\n\n    def __Q_thread(self, timeout, anchor):\n        'Private class method.'\n        time.sleep(timeout)\n        self.__Q_lock.acquire()\n        if not self.__error and anchor in self.__Q_anchor:\n            anchor[0].release()\n            self.__Q_anchor.remove(anchor)\n        self.__Q_lock.release()\n\n    def __R_thread(self, timeout, ID):\n        'Private class method.'\n        time.sleep(timeout)\n        self.__R_lock.acquire()\n        if not self.__error and ID in self.__R_anchor:\n            self.__R_anchor[ID][0].release()\n            del self.__R_anchor[ID]\n        self.__R_lock.release()\n\n################################################################################\n\nclass QRI:\n\n    'QRI(QRP) -&gt; QRI'\n\n    def __init__(self, QRP):\n        'Initialize the Query/Reply Interface object.'\n        self.__QRP = QRP\n        self.__ID = 0\n        self.__lock = thread.allocate_lock()\n\n    def call(self, obj, timeout=None):\n        'Send one query and receive one reply.'\n        self.__lock.acquire()\n        ID = ''.join(chr(self.__ID &gt;&gt; shift &amp; 0xFF) for shift in range(24, -8, -8))\n        self.__ID = (self.__ID + 1) % (2 ** 32)\n        self.__lock.release()\n        self.__QRP.send_Q(ID, obj)\n        return self.__QRP.recv_R(ID, timeout)\n\n    def query(self, timeout=None):\n        'Receive one query.'\n        return self.__QRP.recv_Q(timeout)\n\n    def reply(self, ID, obj):\n        'Send one reply.'\n        self.__QRP.send_R(ID, obj)\n\n################################################################################\n\ndef qri(socket):\n    'Construct a QRI object.'\n    return QRI(QRP(ZSP(socket)))\n\n################################################################################\n\ndef main():\n    global hold, fill, draw, look\n    hold = []\n    fill = '#000000'\n    connect()\n    root = Tk()\n    root.title('Paint 1.0')\n    root.resizable(False, False)\n    upper = LabelFrame(root, text='Your Canvas')\n    lower = LabelFrame(root, text='Their Canvas')\n    draw = Canvas(upper, bg='#ffffff', width=400, height=300, highlightthickness=0)\n    look = Canvas(lower, bg='#ffffff', width=400, height=300, highlightthickness=0)\n    cursor = Button(upper, text='Cursor Color', command=change_cursor)\n    canvas = Button(upper, text='Canvas Color', command=change_canvas)\n    draw.bind('&lt;Motion&gt;', motion)\n    draw.bind('&lt;ButtonPress-1&gt;', press)\n    draw.bind('&lt;ButtonRelease-1&gt;', release)\n    draw.bind('&lt;Button-3&gt;', delete)\n    upper.grid(padx=5, pady=5)\n    lower.grid(padx=5, pady=5)\n    draw.grid(row=0, column=0, padx=5, pady=5, columnspan=2)\n    look.grid(padx=5, pady=5)\n    cursor.grid(row=1, column=0, padx=5, pady=5, sticky=EW)\n    canvas.grid(row=1, column=1, padx=5, pady=5, sticky=EW)\n    root.mainloop()\n\n################################################################################\n\ndef connect():\n    try:\n        start_client()\n    except:\n        start_server()\n    thread.start_new_thread(processor, ())\n\ndef start_client():\n    global QRI\n    server = socket.socket()\n    server.connect((HOST, PORT))\n    QRI = qri(server)\n\ndef start_server():\n    global QRI\n    server = socket.socket()\n    server.bind(('', PORT))\n    server.listen(1)\n    QRI = qri(server.accept()[0])\n\ndef processor():\n    while True:\n        ID, (func, args, kwargs) = QRI.query()\n        getattr(look, func)(*args, **kwargs)\n\ndef call(func, *args, **kwargs):\n    try:\n        QRI.call((func, args, kwargs), 0.05)\n    except:\n        pass\n\n################################################################################\n\ndef change_cursor():\n    global fill\n    color = tkColorChooser.askcolor(color=fill)[1]\n    if color is not None:\n        fill = color\n\ndef change_canvas():\n    color = tkColorChooser.askcolor(color=draw['bg'])[1]\n    if color is not None:\n        draw['bg'] = color\n        draw.config(bg=color)\n        call('config', bg=color)\n\n################################################################################\n\ndef motion(event):\n    if hold:\n        hold.extend([event.x, event.y])\n        event.widget.create_line(hold[-4:], fill=fill, tag='TEMP')\n        call('create_line', hold[-4:], fill=fill, tag='TEMP')\n\ndef press(event):\n    global hold\n    hold = [event.x, event.y]\n\ndef release(event):\n    global hold\n    if len(hold) &gt; 2:\n        event.widget.delete('TEMP')\n        event.widget.create_line(hold, fill=fill, smooth=True)\n        call('delete', 'TEMP')\n        call('create_line', hold, fill=fill, smooth=True)\n    hold = []\n\ndef delete(event):\n    event.widget.delete(ALL)\n    call('delete', ALL)\n\n################################################################################\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}]]