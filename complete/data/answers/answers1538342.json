[[{"text": ["Objects do not necessarily have names in python, so you can't get the name.", "It's not unusual for objects to have a __name__ attribute in those cases that they do have a name, but this is not a part of standard python, and most built in types do not have one."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__name__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["When you create a variable, like the x, y, z above then those names just act as \"pointers\" or \"references\" to the objects.", "The objects itself do not know what names you are using for it, and you can not easily (if at all) get the names of all references to an object."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Update: However, functions do have a __name__ (unless they are lambdas) so, in this case you can do:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__name__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n dict([(t.__name__, t) for t in fun_list])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["That's not really possible, as there could be multiple variables that have the same value, or a value might have no variable, or a value might have the same value as a variable only by chance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you really want to do that, you can use"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def variable_for_value(value):\n    for n,v in globals().keys():\n        if v == value:\n            return n\n    return None\n</code>\n</pre>\n", "senID": 2}, {"text": ["However, it would be better if you would iterate over names in the first place:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n my_list = [\"x\", \"y\", \"z\"] # x, y, z have been previously defined\n\nfor name in my_list:\n    print \"handling variable \", name\n    bla = globals()[name]\n    # do something to bla\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Note that while, as noted, objects in general do not and cannot know what variables are bound to them, functions defined with def do have names in the __name__ attribute (the name used in def).", "Also if the functions are defined in the same module (as in your example) then globals() will contain a superset of the dictionary you want. "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "def", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__name__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "globals()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def fun1:\n  pass\ndef fun2:\n  pass\ndef fun3:\n  pass\n\nfun_dict = {}\nfor f in [fun1, fun2, fun3]:\n  fun_dict[f.__name__] = f\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For this purpose you have a wonderful getattr function, that allows you to get an object by known name.", "So you could do for example:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "getattr", "tag": "a", "pos": 0, "childList": [{"text": "getattr", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#getattr"}, {"text": "getattr", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["funcs.py:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "funcs.py:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def func1(): pass\ndef func2(): pass\n</code>\n</pre>\n", "senID": 2}, {"text": ["main.py:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "main.py:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import funcs\noption = command_line_option()\ngetattr(funcs, option)()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Variable names can be found in the globals() and locals() dicts.", "But they won't give you what you're looking for above.", "\"bla\" will contain the value of each item of my_list, not the variable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Generally when you are wanting to do something like this, you create a class to hold all of these functions and name them with some clear prefix cmd_ or the like.", "You then take the string from the command, and try to get that attribute from the class with the cmd_ prefixed to it.", "Now you only need to add a new function/method to the class, and it's available to your callers.", "And you can use the doc strings for automatically creating the help text."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "cmd_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cmd_", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["As described in other answers, you may be able to do the same approach with globals() and regular functions in your module to more closely match what you asked for."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "globals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Something like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Tasks:\n    def cmd_doit(self):\n        # do it here\n\nfunc_name = parse_commandline()\ntry:\n    func = getattr('cmd_' + func_name, Tasks())\nexcept AttributeError:\n    # bad command: exit or whatever\nfunc()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's another way to think about it.", "Suppose there were a name() function that returned the name of its argument.", "Given the following code:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "name()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def f(a):\n    return a\n\nb = \"x\"\nc = b\nd = f(c)\n\ne = [f(b), f(c), f(d)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["What should name(e[2]) return, and why?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "name(e[2])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Use a reverse dict."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fun_dict = {'fun1': fun1,\n            'fun2': fun2,\n            'fun3': fun3}\n\nr_dict = dict(zip(fun_dict.values(), fun_dict.keys()))\n</code>\n</pre>\n", "senID": 1}, {"text": ["The reverse dict will map each function reference to the exact name you gave it in fun_dict, which may or may not be the name you used when you defined the function.", "And, this technique generalizes to other objects, including integers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For extra fun and insanity, you can store the forward and reverse values in the same dict.", "I wouldn't do that if you were mapping strings to strings, but if you are doing something like function references and strings, it's not too crazy."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]