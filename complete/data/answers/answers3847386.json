[[{"text": ["After OP's edit:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def contains(small, big):\n    for i in xrange(1 + len(big) - len(small)):\n        if small == big[i:i+len(small)]:\n            return i, i + len(small) - 1\n    return False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is my version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def contains(small, big):\n    for i in xrange(len(big)-len(small)+1):\n        for j in xrange(len(small)):\n            if big[i+j] != small[j]:\n                break\n        else:\n            return i, i+len(small)\n    return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["It returns a tuple of (start, end+1) since I think that is more pythonic, as Andrew Jaffe points out in his comment.", "It does not slice any sublists so should be reasonably efficient."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["One point of interest for newbies is that it uses the else clause on the for statement - this is not something I use very often but can be invaluable in situations like this."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "else clause on the for statement", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops"}]}, {"text": ["This is identical to finding substrings in a string, so for large lists it may be more efficient to implement something like the Boyer-Moore algorithm."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Boyer-Moore algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Boyer_moore"}]}], [{"text": ["[Note this answer doesn't work.", "My bad."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "[Note this answer doesn't work. My bad.]", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["If all items are unique, you can use sets."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; items = set([-1, 0, 1, 2])\n&gt;&gt;&gt; items.issubset(set([1, 2]))\nTrue\n&gt;&gt;&gt; items.issubset(set([1, 3]))\nFalse\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This works and is fairly fast since it does the linear searching using the builtin list.index() method and == operator:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list.index()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "==", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def contains(sub, pri):\n    M, N = len(pri), len(sub)\n    i, LAST = 0, M-N+1\n    while True:\n        try:\n            found = pri.index(sub[0], i, LAST) # find first elem in sub\n        except ValueError:\n            return False\n        if pri[found:found+N] == sub:\n            return [found, found+N-1]\n        else:\n            i = found+1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I tried to make this as efficient as possible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It uses a generator; those unfamiliar with these beasts are advised to check out their documentation and that of yield expressions."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "their documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#generators"}, {"href": "http://docs.python.org/reference/expressions.html#yield-expressions", "text": "yield expressions", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Basically it creates a generator of values from the subsequence that can be reset by sending it a true value.", "If the generator is reset, it starts yielding again from the beginning of sub."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "sub", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Then it just compares successive values of sequence with the generator yields, resetting the generator if they don't match."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "sequence", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["When the generator runs out of values, i.e.", "reaches the end of sub without being reset, that means that we've found our match."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "sub", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Since it works for any sequence, you can even use it on strings, in which case it behaves similarly to str.find, except that it returns False instead of -1."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "str.find", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}, {"text": "-1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As a further note: I think that the second value of the returned tuple should, in keeping with Python standards, normally be one higher.", "i.e.", "\"string\"[0:2] == \"st\".", "But the spec says otherwise, so that's how this works."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "\"string\"[0:2] == \"st\"", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["It depends on if this is meant to be a general-purpose routine or if it's implementing some specific goal; in the latter case it might be better to implement a general-purpose routine and then wrap it in a function which twiddles the return value to suit the spec."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def reiterator(sub):\n    \"\"\"Yield elements of a sequence, resetting if sent ``True``.\"\"\"\n    it = iter(sub)\n    while True:\n        if (yield it.next()):\n            it = iter(sub)\n\ndef find_in_sequence(sub, sequence):\n    \"\"\"Find a subsequence in a sequence.\n\n    &gt;&gt;&gt; find_in_sequence([2, 1], [-1, 0, 1, 2])\n    False\n    &gt;&gt;&gt; find_in_sequence([-1, 1, 2], [-1, 0, 1, 2])\n    False\n    &gt;&gt;&gt; find_in_sequence([0, 1, 2], [-1, 0, 1, 2])\n    (1, 3)\n    &gt;&gt;&gt; find_in_sequence(\"subsequence\",\n    ...                  \"This sequence contains a subsequence.\")\n    (25, 35)\n    &gt;&gt;&gt; find_in_sequence(\"subsequence\", \"This one doesn't.\")\n    False\n\n    \"\"\"\n    start = None\n    sub_items = reiterator(sub)\n    sub_item = sub_items.next()\n    for index, item in enumerate(sequence):\n        if item == sub_item:\n            if start is None: start = index\n        else:\n            start = None\n        try:\n            sub_item = sub_items.send(start is None)\n        except StopIteration:\n            # If the subsequence is depleted, we win!\n            return (start, index)\n    return False\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Here's a straightforward algorithm that uses list methods:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\ndef list_find(what, where):\n    \"\"\"Find `what` list in the `where` list.\n\n    Return index in `where` where `what` starts\n    or -1 if no such index.\n\n    &gt;&gt;&gt; f = list_find\n    &gt;&gt;&gt; f([2, 1], [-1, 0, 1, 2])\n    -1\n    &gt;&gt;&gt; f([-1, 1, 2], [-1, 0, 1, 2])\n    -1\n    &gt;&gt;&gt; f([0, 1, 2], [-1, 0, 1, 2])\n    1\n    &gt;&gt;&gt; f([1,2], [-1, 0, 1, 2])\n    2\n    &gt;&gt;&gt; f([1,3], [-1, 0, 1, 2])\n    -1\n    &gt;&gt;&gt; f([1, 2], [[1, 2], 3])\n    -1\n    &gt;&gt;&gt; f([[1, 2]], [[1, 2], 3])\n    0\n    \"\"\"\n    if not what: # empty list is always found\n        return 0\n    try:\n        index = 0\n        while True:\n            index = where.index(what[0], index)\n            if where[index:index+len(what)] == what:\n                return index # found\n            index += 1 # try next position\n    except ValueError:\n        return -1 # not found\n\ndef contains(what, where):\n    \"\"\"Return [start, end+1] if found else empty list.\"\"\"\n    i = list_find(what, where)\n    return [i, i + len(what)] if i &gt;= 0 else [] #NOTE: bool([]) == False\n\nif __name__==\"__main__\":\n    import doctest; doctest.testmod()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["From this thread, I found the built-in any function in python.", "This will work perfectly for you."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "this thread", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/101268/hidden-features-of-python"}, {"text": "any", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["From the help page of any:\n"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n any(...)\n    any(iterable) -&gt; bool\n\n    Return True if bool(x) is True for any x in the iterable.\n</code>\n</pre>\n", "senID": 2}, {"senID": 3}, {"code": "<pre>\n<code>\n def isAList(x):\n    return type(x) == type([])\n\ndef containsAList(L):\n    return any([isAList(x) for x in L])\n</code>\n</pre>\n", "senID": 4}, {"text": ["You could also shorten the code by using lambda and map like so:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map like so:", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\nany(map(lambda x: type(x) == type([]), L))\n</pre>\n", "senID": 6}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I think this one is fast..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def issublist(subList, myList, start=0):\n    if not subList: return 0\n    lenList, lensubList = len(myList), len(subList)\n    try:\n        while lenList - start &gt;= lensubList:\n            start = myList.index(subList[0], start)\n            for i in xrange(lensubList):\n                if myList[start+i] != subList[i]:\n                    break\n            else:\n                return start, start + lensubList\n            start += 1\n        return False\n    except:\n        return False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["May I humbly suggest the Rabin-Karp algorithm if the big list is really big.", "The link even contains almost-usable code in almost-Python."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Rabin-Karp algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_string_search_algorithm"}, {"text": "big", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]