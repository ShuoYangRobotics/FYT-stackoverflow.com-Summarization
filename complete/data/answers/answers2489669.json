[[{"text": ["Python is strongly typed because every object has a type, every object knows its type, it's impossible to accidentally or deliberately use an object of a type \"as if\" it was an object of a different type, and all elementary operations on the object are delegated to its type."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "has", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "knows", "childNum": 0, "tag": "em", "childList": []}, {"text": "different", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["This has nothing to do with names.", "A name in Python doesn't \"have a type\": if and when a name's defined, the name refers to an object, and the object does have a type (but that doesn't in fact force a type on the name: a name is a name is a name)."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "names", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "name", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "object", "childNum": 0, "tag": "em", "childList": []}, {"text": "object", "childNum": 0, "tag": "em", "childList": []}, {"text": "name", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["A name in Python can perfectly well refer to different objects at different times (as in most programming languages, though not all) -- and there is no constraint on the name such that, if it has once referred to an object of type X, it's then forevermore constrained to refer only to other objects of type X.", "Constraints on names are not part of the concept of \"strong typing\", though some enthusiasts of static typing (where names do get constrained, and in a static, AKA compile-time, fashion, too) do misuse the term this way."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "names", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "static", "childNum": 0, "tag": "strong", "childList": []}, {"text": "do", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Python is not strongly typed in the sense of static or compile-time type checking."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Most Python code falls under so-called \"Duck Typing\" -- for example, you look for a method read on an object -- you don't care if the object is a file on disk or a socket, you just want to read N bytes from it."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "\"Duck Typing\"", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Duck_typing"}, {"text": "read", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You don't specify a type.", "The method will only fail (at runtime) if it tries to access attributes that are not defined on the parameters that are passed in."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So this simple function:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def no_op(param1, param2):\n    pass\n</code>\n</pre>\n", "senID": 2}, {"text": ["... will not fail no matter what two args are passed in."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["However, this function:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def call_quack(param1, param2):\n    param1.quack()\n    param2.quack()\n</code>\n</pre>\n", "senID": 5}, {"text": ["... will fail at runtime if param1 and param2 do not both have callable attributes named quack."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "param1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "param2", "childNum": 0, "tag": "code", "childList": []}, {"text": "quack", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["In python everything has a type.", "Python function will do anything it is asked to do if the type of arguments support it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example: foo will add everything that can be __add__ed ;) without worrying much about its type.", "So that means ,to avoid failure ,you should provide only those things that support addition."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__add__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def foo(a,b):\n    return a + b\n\nclass Bar(object):\n    pass\n\nclass Zoo(object):\n    def __add__(self,other):\n        return 'zoom'\n\nif __name__=='__main__':\n    print foo(1,2)\n    print foo('james','bond')\n    print foo(Zoo(),Zoo())\n    print foo(Bar(),Bar()) # should fail\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You never specify the type; Python has the concept of duck typing; basically the code that processes the parameters will make certain assumptions about them - perhaps by calling certain methods that a parameter is expected to implement.", "If the parameter is of the wrong type, then an exception will be thrown."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "duck typing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Duck_typing"}]}, {"text": ["In general it is up to your code to ensure that you are passing around objects of the proper type - there is no compiler to enforce this ahead of time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Python doesn't care what you pass in to its functions.", "When you call my_func(a,b), the param1 and param2 variables will then hold the values of a and b. Python doesn't know that you are calling the function with the proper types, and excepts the programmer to take care of that.", "If your function will be called with different types of parameters, you can wrap code accessing them with try/except blocks and evaluate the parameters in whatever way you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["As Alex Martelli explains,"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Alex Martelli explains", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1549801/differences-between-isinstance-and-type-in-python/1549854#1549854"}]}, {"text": ["Read the rest of his post for helpful information."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Many languages have variables, which are of a specific type and have a value.", "Python does not have variables; it has objects, and you use names to refer to these objects."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In other languages, when you say:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = 1\n</code>\n</pre>\n", "senID": 2}, {"text": ["then a (typically integer) variable changes its contents to the value 1."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In Python,"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a = 1\n</code>\n</pre>\n", "senID": 5}, {"text": ["means \u201cuse the name a to refer to the object 1\u201d.", "You can do the following in an interactive Python session:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "a", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "1", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; type(1)\n&lt;type 'int'&gt;\n</code>\n</pre>\n", "senID": 7}, {"text": ["The function type is called with the object 1; since every object knows its type, it's easy for type to find out said type and return it."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}, {"text": "type", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Likewise, whenever you define a function"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def funcname(param1, param2):\n</code>\n</pre>\n", "senID": 10}, {"text": ["the function receives two objects, and names them param1 and param2, regardless of their types.", "If you want to make sure the objects received are of a specific type, code your function as if they are of the needed type(s) and catch the exceptions that are thrown if they aren't.", "The exceptions thrown are typically TypeError (you used an invalid operation) and AttributeError (you tried to access an inexistent member (methods are members too) )."], "childNum": 4, "tag": "p", "senID": 11, "childList": [{"text": "param1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "param2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "TypeError", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "AttributeError", "childNum": 0, "tag": "code", "childList": []}]}]]