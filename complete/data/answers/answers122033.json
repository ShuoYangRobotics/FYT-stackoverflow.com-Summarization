[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; import random\n&gt;&gt;&gt; print random.sample(xrange(100), 5)\n[61, 54, 91, 72, 85]\n</code>\n</pre>\n", "senID": 0}, {"text": ["This should yield 5 unique values in the range 0 \u2014 99.", "The xrange object generates values as requested so no memory is used for values that aren't sampled."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "0 \u2014 99", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["In Ruby:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = (0..100).entries.sort_by {rand}.slice! 0, 5\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update: Here is a slightly different way:\n    a = (0...100).entries.sort_by{rand}[0...5]"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["EDIT:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["and In Ruby 1.9 you can do this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n Array(0..100).sample(5)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Hmm... How about (Python):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = set()\nwhile len(s) &lt;= N: s.update((random.random(),))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I will forgo the simplest solutions using the 'random' module since I take it that's not really what you are after.", "Here's what I think you are looking for in Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import random\n&gt;&gt;&gt; \n&gt;&gt;&gt; def getUniqueRandomNumbers(num, highest):\n...     seen = set()\n...     while len(seen) &lt; num:\n...         i = random.randrange(0, highest)\n...         if i not in seen:\n...             seen.add(i)  \n...             yield i\n... \n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["To show you how it works:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(getUniqueRandomNumbers(10, 100))\n[81, 57, 98, 47, 93, 31, 29, 24, 97, 10]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["EDIT : Ok, just for fun, a shorter and faster one (and still using iterators)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def getRandomNumbers(max, size) :\n    pool = set()\n    return ((lambda x :  pool.add(x) or x)(random.randrange(max)) for x in xrange(size) if len(a) &lt; size)\n\nprint [x for x in gen(100, 5)]\n[0, 10, 19, 51, 18]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Yeah, I know, one-liners should be left to perl lovers, but I think this one is quite powerful isn't it ?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Old message here :"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["My god, how complicated is all that !", "Let's be pythonic :"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import random\ndef getRandomNumber(max, size, min=0) :\n   # using () and xrange = using iterators\n   return (random.randrange(min, max) for x in xrange(size))\n\nprint set(getRandomNumber(100, 5)) # set() removes duplicates\nset([88, 99, 29, 70, 23])\n</code>\n</pre>\n", "senID": 5}, {"text": ["Enjoy"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["EDIT : As commentators noticed, this is an exact translation of the question's code."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["To avoid the problem we got by removing duplicates after generating the list, resulting in too little data, you can choose another way :"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def getRandomNumbers(max, size) :\n    pool = []\n    while len(pool) &lt; size :\n        tmp = random.randrange(max)\n        if tmp not in pool :\n            yield pool.append(tmp) or tmp\n\nprint [x for x in getRandomNumbers(5, 5)]\n[2, 1, 0, 3, 4]\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Here's another Ruby solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = (1..5).collect { rand(100) }\na &amp; a\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think, with your LINQ statement, the Distinct will remove duplicates after 5 have already been taken, so you aren't guaranteed to get 5 back.", "Someone can correct me if I'm wrong, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Python with Numeric Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from numpy import *\na = random.random_integers(0, 100, 5)\nb = unique(a)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Voil\u00e0!", "Sure you could do something similar in a functional programming style but... why?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n import random\n\ndef makeRand(n):\n   rand = random.Random()\n   while 1:\n      yield rand.randint(0,n)\n   yield rand.randint(0,n)      \n\ngen = makeRand(100)      \nterms = [ gen.next() for n in range(5) ]\n\nprint \"raw list\"\nprint terms\nprint \"de-duped list\"\nprint list(set(terms))\n\n# produces output similar to this\n#\n# raw list\n# [22, 11, 35, 55, 1]\n# de-duped list\n# [35, 11, 1, 22, 55]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Well, first you rewrite LINQ in Python.", "Then your solution is a one-liner :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from random import randrange\n\ndef Distinct(items):\n    set = {}\n    for i in items:\n        if not set.has_key(i):\n            yield i\n            set[i] = 1\n\ndef Take(num, items):\n    for i in items:\n        if num &gt; 0:\n            yield i\n            num = num - 1\n        else:\n            break\n\ndef ToArray(items):\n    return [i for i in items]\n\ndef GetRandomNumbers(max):\n    while 1:\n        yield randrange(max)\n\nprint ToArray(Take(5, Distinct(GetRandomNumbers(100))))\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you put all the simple methods above into a module called LINQ.py, you can impress your friends."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(Disclaimer: of course, this is not actually rewriting LINQ in Python.", "People have the misconception that LINQ is just a bunch of trivial extension methods and some new syntax.", "The really advanced part of LINQ, however, is automatic SQL generation so that when you're querying a database, it's the database that implements Distinct() rather than the client side."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "actually", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Here's a transliteration from your solution to Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, a generator that creates Random numbers.", "This isn't very Pythonic, but it's a good match with your sample code. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import random\n&gt;&gt;&gt; def getRandomNumbers( max ):\n...     while True:\n...             yield random.randrange(0,max)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here's a client loop that collects a set of 5 distinct values.", "This is -- again -- not the most Pythonic implementation."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; distinctSet= set()\n&gt;&gt;&gt; for r in getRandomNumbers( 100 ):\n...     distinctSet.add( r )\n...     if len(distinctSet) == 5: \n...             break\n... \n&gt;&gt;&gt; distinctSet\nset([81, 66, 28, 53, 46])\n</code>\n</pre>\n", "senID": 4}, {"text": ["It's not clear why you want to use a generator for random numbers -- that's one of the few things that's so simple that a generator doesn't simplify it.  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["A more Pythonic version might be something like:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n distinctSet= set()\nwhile len(distinctSet) != 5:\n    distinctSet.add( random.randrange(0,100) )\n</code>\n</pre>\n", "senID": 7}, {"text": ["If the requirements are to generate 5 values and find distinct among those 5, then something like"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n distinctSet= set( [random.randrange(0,100) for i in range(5) ] )\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Maybe this will suit your needs and look a bit more linqish:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from numpy import random,unique\n\ndef GetRandomNumbers(total=5):\n    while True:\n    \tyield unique(random.random(total*2))[:total]\n\nrandomGenerator = GetRandomNumbers()\n\nmyRandomNumbers = randomGenerator.next()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's another python version, more closely matching the structure of your C# code.", "There isn't a builtin for giving distinct results, so I've added a function to do this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools, random\n\ndef distinct(seq):\n    seen=set()\n    for item in seq:\n        if item not in seen:\n            seen.add(item)\n            yield item\n\ndef getRandomNumbers(max):\n    while 1:\n        yield random.randint(0,max)\n\nfor item in itertools.islice(distinct(getRandomNumbers(100)), 5):\n    print item\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Ruby 1.9:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Array(0..100).sample(5)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I can't really read your LINQ, but I think you're trying to get 5 random numbers up to 100 and then remove duplicates."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's a solution for that:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def random(max)\n    (rand * max).to_i\nend\n\n# Get 5 random numbers between 0 and 100\na = (1..5).inject([]){|acc,i| acc &lt;&lt; random( 100)}\n# Remove Duplicates\na = a &amp; a\n</code>\n</pre>\n", "senID": 2}, {"text": ["But perhaps you're actually looking for 5 distinct random numbers between 0 and 100.", "In which case:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def random(max)\n    (rand * max).to_i\nend\n\na = []\nwhile( a.size &lt; 5)\n    a &lt;&lt; random( 100)\n    a = a &amp; a\nend\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now, this one might violate your sense of \"not too many loops,\" but presumably Take and Distinct are just hiding the looping from you.", "It would be easy enough to just add methods to Enumerable to hide the while loop."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]