[[{"text": ["What you request cannot be done in Python 2.whatever, for a very specific reason.", "You want to write:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "whatever", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Task(model): \n    title = ''\n    isDone = False\n</code>\n</pre>\n", "senID": 1}, {"text": ["In Python 2.anything, whatever model may possibly be, this cannot ever allow you to predict any \"ordering\" for the two fields, because the semantics of a class statement are:"], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "anything", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "whatever", "childNum": 0, "tag": "strong", "childList": []}, {"text": "model", "childNum": 0, "tag": "code", "childList": []}, {"text": "ever", "childNum": 0, "tag": "strong", "childList": []}, {"text": "class", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Whatever the metaclass may be, step 1 has destroyed any predictability of the fields' order.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Therefore, your desired use of positional parameters, in the snippet:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n Task('Illustrate different syntax modes', True)\n</code>\n</pre>\n", "senID": 5}, {"text": ["cannot associate the arguments' values with the model's various fields.", "(Trying to guess by type association -- hoping no two fields ever have the same type -- would be even more horribly unpythonic than your expressed desire to use db.tasklist and db['tasklist'] indifferently and interchangeably)."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "db.tasklist", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "db['tasklist']", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["One of the backwards-incompatible changes in Python 3 was introduced specifically to deal with situations of this ilk.", "In Python 3, a custom metaclass can define a __prepare__ function which runs before \"step 1\" in the above simplified list, and this lets it have more control about the class's body.", "Specifically, quoting PEP 3115...:"], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "__prepare__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "before", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "PEP 3115", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3115/"}]}, {"code": "<pre>\n<code>\n ...\n</code>\n</pre>\n", "senID": 8}, {"text": ["You don't want to \"create a C struct\" as in this example, but the order of fields is crucial (to allow the use of positional parameters that you want) and so the custom metaclass (obtained through base model) would have a __prepare__ classmethod returning an ordered dictionary.", "This removes the specific issue, but, of course, only if you're willing to switch all of your code using this \"magic ORM\" to Python 3.", "Would you be?"], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "model", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__prepare__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "only", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Once that's settled, the issue is, what database operations do you want to perform, and how.", "Your example, of course, does not clarify this at all.", "Is the taskList attribute name special, or should any other attribute assigned to the db object be \"autosaved\" (by name and, what other characteristic[s]?", ") and \"autoretrieved\" upon use?", "Are there to be ways to remove entities, alter them, locate them (otherwise than by having once been listed in the same attribute of the db object)?", "How does your sample code know what DB service to use and how to authenticate to it (e.g.", "by userid and password) if it requires authentication?"], "childNum": 4, "tag": "p", "senID": 10, "childList": [{"text": "taskList", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "any", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "db", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "db", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The specific tasks you list would not be hard to implement (e.g.", "on top of Google App Engine's storage service, which does not require authentication nor specification of \"what DB service to use\").", "model's metaclass would introspect the class's fields and generate a GAE Model for the class, the db object would use __setattr__ to set an atexit trigger for storing the final value of an attribute (as an entity in a different kind of Model of course), and __getattr__ to fetch that attribute's info back from storage.", "Of course without some extra database functionality this all would be pretty useless;-)."], "childNum": 7, "tag": "p", "senID": 11, "childList": [{"text": "model", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "Model", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "db", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__setattr__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "atexit", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Model", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__getattr__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Edit: so I did a little prototype (Python 2.6, and based on sqlite) and put it up on http://www.aleax.it/lustdb.zip -- it's a 3K zipfile including 225-lines lustdb.py (too long to post here) and two small test files roughly equivalent to the OP's originals: test0.py is...:"], "childNum": 4, "tag": "p", "senID": 12, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://www.aleax.it/lustdb.zip", "text": "http://www.aleax.it/lustdb.zip", "childNum": 0, "tag": "a", "childList": []}, {"text": "lustdb.py", "childNum": 0, "tag": "code", "childList": []}, {"text": "test0.py", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from lustdb import *  \n\nclass Task(Model): \n    title = ''\n    done = False\n\ndb.taskList = []    \ndb.taskList.append(Task(title='Beat old sql interfaces', done=False))\ndb.taskList.append(Task(title='Illustrate different syntax modes', done=True))\n</code>\n</pre>\n", "senID": 13}, {"text": ["and test1.p1 is...:"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "test1.p1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from lustdb import *\n\nprint 'Done tasks:'\nfor task in db.taskList:\n    if task.done:\n        print task\n</code>\n</pre>\n", "senID": 15}, {"text": ["Running test0.py (on a machine with a writable /tmp directory -- i.e., any Unix-y OS, or, on Windows, one on which a mkdir \\tmp has been run at any previous time;-) has no output; after that, running test1.py outputs:"], "childNum": 4, "tag": "p", "senID": 16, "childList": [{"text": "test0.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "/tmp", "childNum": 0, "tag": "code", "childList": []}, {"text": "mkdir \\tmp", "childNum": 0, "tag": "code", "childList": []}, {"text": "test1.py", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n Done tasks:\nTask(done=True, title=u'Illustrate different syntax modes')\n</code>\n</pre>\n", "senID": 17}, {"text": ["Note that these are vastly less \"crazily magical\" than the OP's examples, in many ways, such as...:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n 1. no (expletive delete) redundancy whereby `db.taskList` is a synonym of `db['taskList']`, only the sensible former syntax (attribute-access) is supported\n2. no mysterious (and totally crazy) way whereby a `done` attribute magically becomes `isDone` instead midway through the code\n3. no mysterious (and utterly batty) way whereby a `print task` arbitrarily (or magically?) picks and prints just one of the attributes of the task\n4. no weird gyrations and incantations to allow positional-attributes in lieu of named ones (this one the OP agreed to)\n</code>\n</pre>\n", "senID": 19}, {"text": ["The prototype of course (as prototypes will;-) leaves a lot to be desired in many respects (clarity, documentation, unit tests, optimization, error checking and diagnosis, portability among different back-ends, and especially DB features beyond those implied in the question).", "The missing DB features are legion (for example, the OP's original examples give no way to identify a \"primary key\" for a model, or any other kinds of uniqueness constraints, so duplicates can abound; and it only gets worse from there;-).", "Nevertheless, for 225 lines (190 net of empty lines, comments and docstrings;-), it's not too bad in my biased opinion."], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["The proper way to continue playing with this project would of course be to initiate a new lustdb open source project on the hosting part of code.google.com (or any other good open source hosting site with issue tracker, wiki, code reviews support, online browsing, DVCS support, etc, etc) - I'd do it myself but I'm close to the limit in terms of number of open source projects I can initiate on code.google.com and don't want to \"burn\" the last one or two in this way;-)."], "childNum": 1, "tag": "p", "senID": 21, "childList": [{"text": "lustdb", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["BTW, the lustdb name for the module is a play of word with the OP's initials (first two letters each of first and last names), in the tradition of awk and friends -- I think it sounds nicely (and most other obvious names such as simpledb and dumbdb are taken;-)."], "childNum": 4, "tag": "p", "senID": 22, "childList": [{"text": "lustdb", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "awk", "childNum": 0, "tag": "code", "childList": []}, {"text": "simpledb", "childNum": 0, "tag": "code", "childList": []}, {"text": "dumbdb", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I think you should try ZODB.", "It is object oriented database designed for storing python objects.", "Its API is quite close to example you have provided in your question, just take a look at tutorial."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "ZODB", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://zodb.org/"}, {"text": "look", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.zodb.org/documentation/articles/ZODB1.html#a-simple-example"}]}], [{"text": ["What about using Elixir?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Elixir", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://elixir.ematia.de/trac/wiki"}]}], [{"text": ["Forget ORM!", "I like vanilla SQL.", "The python wrappers like psycopg2 for postgreSQL do automatic type conversion, offer pretty good protection against SQL injection, and are nice and simple."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "psycopg2", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n sql = \"SELECT * FROM table WHERE id=%s\"\ndata = (5,)\ncursor.execute(sql, data)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The more I think on't the more the Smalltalk model of operation seems more relevant.", "Indeed the OP may not have reached far enough by using the term \"database\" to describe a thing which should have no need for naming. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A running Python interpreter has a pile of objects that live in memory.", "Their inter-relationships can be arbitrarily complex, but namespaces and the \"tags\" that objects are bound to are very flexible.", "And as pickle can explicitly serialize arbitrary structures for persistence, it doesn't seem that much of a reach to consider each Python interpreter living in that object space.", "Why should that object space evaporate with the interpreter's close?", "Semantically, this could be viewed as an extension of the anydbm tied dictionaries.", "And since most every thing in Python is dictionary-like, the mechanism is almost already there."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pickle", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "anydbm", "tag": "a", "pos": 4, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/anydbm.html#module-anydbm"}]}, {"text": ["I think this may be the generic model that Alex Martelli was proposing above, it might be nice to say something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Book:\n    def __init__(self, attributes):\n        self.attributes = attributes\n    def __getattr__(....): pass\n\n$ python\n&gt;&gt;&gt; import book\n&gt;&gt;&gt; my_stuff.library = {'garp': \n    Book({'author': 'John Irving', 'title': 'The World According to Garp', \n      'isbn': '0-525-23770-4', 'location': 'kitchen table', \n      'bookmark': 'page 127'}),\n    ...\n    }\n&gt;&gt;&gt; exit\n</code>\n</pre>\n", "senID": 3}, {"text": ["[sometime next week]"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "[sometime next week]", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python\n&gt;&gt;&gt; import my_stuff\n&gt;&gt;&gt; print my_stuff.library['garp'].location\n'kitchen table'\n# or even\n&gt;&gt;&gt; for book in my_stuff.library where book.location.contains('kitchen'):\n   print book.title\n</code>\n</pre>\n", "senID": 5}, {"text": ["I don't know that you'd call the resultant language Python, but it seems like it is not that hard to implement and makes backing store equivalent to active store."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["There is a natural tension between the inherent structure imposed - and sometimes desired - by RDBMs and the rather free-form navel-gazing put here, but NoSQLy databases are already approaching the content addressable memory model and probably better approximates how our minds keep track of things.", "Contrariwise, you wouldn't want to keep all the corporate purchase orders such a storage system, but perhaps you might."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I've been busy, here it is, released under LGPL:\nhttp://github.com/lukestanley/lustdb"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://github.com/lukestanley/lustdb", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/lukestanley/lustdb"}]}, {"text": ["It uses JSON as it's backend at the moment."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This is not the same codebase Alex Martelli did.", "I wanted to make the code more readable and reusable with different\nbackends and such."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Alex Martelli", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.aleax.it/lustdb.zip"}]}, {"text": ["Elsewhere I have been working on object oriented HTML elements\naccessable in Python in similar ways, AND a library for making web.py\nmore minimalist."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I'm thinking of ways of using all 3 elements together with automatic\nMVC prototype construction or smart mapping."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["While old fashioned text based template web programming will be around\nfor a while still because of legacy systems and because it doesn't\nrequire any particular library or implementation, I feel soon we'll\nhave a lot more efficent ways of building robust, prototype friendly\nweb apps."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Please see the mailing list for those interested."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "mailing list", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://groups.google.com/group/lustdb"}]}], [{"text": ["How about you give an example of how \"simple\" you want your \"dealing with database\" to be, and I then tell you all the stuff that is needed for that \"simplicity\" to get working ?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "needed", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["(And of which it will still be YOU that will be required to give the information/config to the database interface engine, somewhere, somehow."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "YOU", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "will be", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["To name but one example :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If your database management engine is some external machine with which you/your app interfaces over IP or some such, there is no way around the fact that the IP identity of where that database engine is running, will have to be provided by your app's database interface client, somewhere, somehow.", "Regardless of whether that gets explicitly exposed in the code or not."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you like CherryPy, you might like the complementary ORMs I wrote: GeniuSQL (which follows a Table Data gateway model) and Dejavu (which is a complete Data Mapper)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "GeniuSQL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.aminus.net/geniusql/"}, {"href": "http://www.aminus.net/dejavu/", "text": "Dejavu", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["There's far too much in this question and all its subcomments to address completely, but one thing I wanted to point out was that GeniuSQL and Dejavu have a very robust system for mapping native Python types to the types that your particular backend is using.", "There are very sane defaults, which can be overridden as needed, and even extended if you make a new backend or use types from a backend that isn't yet supported.", "See http://www.aminus.net/geniusql/chrome/common/doc/trunk/advanced.html#custom for more discussion on that."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.aminus.net/geniusql/chrome/common/doc/trunk/advanced.html#custom", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.aminus.net/geniusql/chrome/common/doc/trunk/advanced.html#custom"}]}]]