[[{"text": ["Actually we are not giving the answer anijhaw is looking for.", "Here is the one liner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n all(l[i] &lt;= l[i+1] for i in xrange(len(l)-1))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This iterator form is 10-15% faster than using integer indexing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip\nisSorted = lambda l : all(a &lt;= b for a,b in izip(l[:-1],l[1:]))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would just use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if sorted(lst) == lst:\n    # code here\n</code>\n</pre>\n", "senID": 1}, {"text": ["unless it's a very big list in which case you might want to create a custom function."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["if you are just going to sort it if it's not sorted, then forget the check and sort it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n lst.sort()\n</code>\n</pre>\n", "senID": 4}, {"text": ["and don't think about it too much."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["if you want a custom function, you can do something like"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def is_sorted(lst, key=lambda x, y: x &lt; y):\n    for i, el in enumerate(lst[1:]):\n        if key(el, lst[i-1]):\n            return False\n    return True\n</code>\n</pre>\n", "senID": 7}, {"text": ["This will be O(n) if the list is already sorted though (and O(n) in a for loop at that!", ") so, unless you expect it to be not sorted (and fairly random) most of the time, I would, again, just sort the list."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["SapphireSun is quite right.", "You can just use lst.sort().", "Python's sort implementation (TimSort) check if the list is already sorted.", "If so sort() will completed in linear time.", "Sounds like a Pythonic way to ensure a list is sorted ;)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "SapphireSun", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "lst.sort()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I ran a benchmark andsorted(lst, reverse=True) == lstwas the fastest for long lists, andall(l[i] &gt;= l[i+1] for i in xrange(len(l)-1))was the fastest for short lists.", "These benchmarks were run on a MacBook Pro 2010 13\" (Core2 Duo 2.66GHz, 4GB 1067MHz DDR3 RAM, Mac OS X 10.6.5)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "andsorted(lst, reverse=True) == lstwas the fastest for long lists, andall(l[i] &gt;= l[i+1] for i in xrange(len(l)-1))was the fastest for short lists", "childNum": 2, "tag": "strike", "pos": 0, "childList": [{"text": "sorted(lst, reverse=True) == lst", "tag": "code"}, {"text": "all(l[i] &gt;= l[i+1] for i in xrange(len(l)-1))", "tag": "code"}]}, {"text": "sorted(lst, reverse=True) == lst", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "all(l[i] &gt;= l[i+1] for i in xrange(len(l)-1))", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["UPDATE:I revised the script so that you can run it directly on your own system.", "The previous version had bugs.", "Also, I have added both sorted and unsorted inputs."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "UPDATE:I revised the script so that you can run it directly on your own system. The previous version had bugs. Also, I have added both sorted and unsorted inputs.", "childNum": 1, "tag": "strike", "pos": -1, "childList": [{"text": "UPDATE:", "tag": "strong"}]}, {"text": "UPDATE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 4, "lis": [{"text": "Best for short sorted lists: ", "tag": "none", "senID": 2}, {"text": "Best for long sorted lists: ", "tag": "none", "senID": 3}, {"text": "Best for short unsorted lists: ", "tag": "none", "senID": 4}, {"text": "Best for long unsorted lists: ", "tag": "none", "senID": 5}]}, {"text": ["So in most cases there is a clear winner."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["UPDATE: aaronsterling's answers (#6 and #7) are actually the fastest in all cases.", "#7 is the fastest because it doesn't have a layer of indirection to lookup the key."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "UPDATE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport itertools\nimport time\n\ndef benchmark(f, *args):\n    t1 = time.time()\n    for i in xrange(1000000):\n        f(*args)\n    t2 = time.time()\n    return t2-t1\n\nL1 = range(4, 0, -1)\nL2 = range(100, 0, -1)\nL3 = range(0, 4)\nL4 = range(0, 100)\n\n# 1.\ndef isNonIncreasing(l, key=lambda x,y: x &gt;= y): \n    return all(key(l[i],l[i+1]) for i in xrange(len(l)-1))\nprint benchmark(isNonIncreasing, L1) # 2.47253704071\nprint benchmark(isNonIncreasing, L2) # 34.5398209095\nprint benchmark(isNonIncreasing, L3) # 2.1916718483\nprint benchmark(isNonIncreasing, L4) # 2.19576501846\n\n# 2.\ndef isNonIncreasing(l):\n    return all(l[i] &gt;= l[i+1] for i in xrange(len(l)-1))\nprint benchmark(isNonIncreasing, L1) # 1.86919999123\nprint benchmark(isNonIncreasing, L2) # 21.8603689671\nprint benchmark(isNonIncreasing, L3) # 1.95684289932\nprint benchmark(isNonIncreasing, L4) # 1.95272517204\n\n# 3.\ndef isNonIncreasing(l, key=lambda x,y: x &gt;= y): \n    return all(key(a,b) for (a,b) in itertools.izip(l[:-1],l[1:]))\nprint benchmark(isNonIncreasing, L1) # 2.65468883514\nprint benchmark(isNonIncreasing, L2) # 29.7504849434\nprint benchmark(isNonIncreasing, L3) # 2.78062295914\nprint benchmark(isNonIncreasing, L4) # 3.73436689377\n\n# 4.\ndef isNonIncreasing(l):\n    return all(a &gt;= b for (a,b) in itertools.izip(l[:-1],l[1:]))\nprint benchmark(isNonIncreasing, L1) # 2.06947803497\nprint benchmark(isNonIncreasing, L2) # 15.6351969242\nprint benchmark(isNonIncreasing, L3) # 2.45671010017\nprint benchmark(isNonIncreasing, L4) # 3.48461818695\n\n# 5.\ndef isNonIncreasing(l):\n    return sorted(l, reverse=True) == l\nprint benchmark(isNonIncreasing, L1) # 2.01579380035\nprint benchmark(isNonIncreasing, L2) # 5.44593787193\nprint benchmark(isNonIncreasing, L3) # 2.01813793182\nprint benchmark(isNonIncreasing, L4) # 4.97615599632\n\n# 6.\ndef isNonIncreasing(l, key=lambda x, y: x &gt;= y): \n    for i, el in enumerate(l[1:]):\n        if key(el, l[i-1]):\n            return False\n    return True\nprint benchmark(isNonIncreasing, L1) # 1.06842684746\nprint benchmark(isNonIncreasing, L2) # 1.67291283607\nprint benchmark(isNonIncreasing, L3) # 1.39491200447\nprint benchmark(isNonIncreasing, L4) # 1.80557894707\n\n# 7.\ndef isNonIncreasing(l):\n    for i, el in enumerate(l[1:]):\n        if el &gt;= l[i-1]:\n            return False\n    return True\nprint benchmark(isNonIncreasing, L1) # 0.883186101913\nprint benchmark(isNonIncreasing, L2) # 1.42852401733\nprint benchmark(isNonIncreasing, L3) # 1.09229516983\nprint benchmark(isNonIncreasing, L4) # 1.59502696991\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Here's an other way with eval and chained comparison from python :"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "chained comparison", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a=[3,4,5,1]\nisSorted = eval(\"&lt;\".join([str(v) for v in a]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT : Limitations :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This way is actually more a funny way to use chained comparison because there's a lot of problems : "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "For a=[x] it returns x", "tag": "none", "senID": 4}, {"text": "For big arrays, it raises a SystemError (com_backpatch: offset too large) (cf. ", "tag": "none", "senID": 5}]}]]