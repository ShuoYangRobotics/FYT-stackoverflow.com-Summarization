[[{"code": "<pre>\n<code>\n #!/bin/bash\nfind -type f -print0 | while read -d $'\\0' file\ndo\n    md5sum=`md5sum \"${file}\" | sed -r 's/ .*//'`\n    filename=`echo \"${file}\" | sed -r 's/\\.[^./]*$//'`\n    extension=\"${file:${#filename}}\"\n    filename=`echo \"${filename}\" | sed -r 's/\\.md5sum-[^.]+//'`\n    if [[ \"${file}\" != \"${filename}.md5sum-${md5sum}${extension}\" ]]; then\n        echo \"Handling file: ${file}\"\n        mv \"${file}\" \"${filename}.md5sum-${md5sum}${extension}\"\n    fi\ndone\n</code>\n</pre>\n", "senID": 0}, {"tag": "ul", "num": 5, "lis": [{"text": "Tested on files containing spaces like 'a b'", "tag": "none", "senID": 1}, {"text": "Tested on files containing multiple extensions like 'a.b.c'", "tag": "none", "senID": 2}, {"text": "Tested with directories containing spaces and/or dots.", "tag": "none", "senID": 3}, {"text": "Tested on files containing no extension inside directories containing dots, such as 'a.b/c'", "tag": "none", "senID": 4}, {"text": ["Updated"], "childNum": 0, "tag": "em", "senID": 5, "childList": []}]}, {"text": ["Key points:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Use of ", "tag": "none", "senID": 7}, {"text": "md5sum can be replaced with your favourite hash function. The sed removes the first space and everything after it from the output of md5sum.", "tag": "none", "senID": 8}, {"text": "The base filename is extracted using a regular expression that finds the last period that isn't followed by another slash (so that periods in directory names aren't counted as part of the extension).", "tag": "none", "senID": 9}, {"text": "The extension is found by using a substring with starting index as the length of the base filename.", "tag": "none", "senID": 10}]}], [{"text": ["Updated to fix:\n1.", "File names with '[' or ']' in their name (really, any character now.", "See comment)\n2.", "Handling of md5sum when hashing a file with a backslash or newline in its name\n3.", "Functionized hash-checking algo for modularity\n4.", "Refactored hash-checking logic to remove double-negatives"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "Updated to fix:", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "", "tag": "br"}]}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 3, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 4, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 5, "childList": []}]}, {"code": "<pre>\n<code>\n #!/bin/bash\nif (($# != 1)) || ! [[ -d \"$1\" ]]; then\n    echo \"Usage: $0 /path/to/directory\"\n    exit 1\nfi\n\nis_hash() {\n md5=${1##*.} # strip prefix\n [[ \"$md5\" == *[^[:xdigit:]]* || ${#md5} -lt 32 ]] &amp;&amp; echo \"$1\" || echo \"${1%.*}\"\n}\n\nwhile IFS= read -r -d $'\\0' file; do\n    read hash junk &lt; &lt;(md5sum \"$file\")\n    basename=\"${file##*/}\"\n    dirname=\"${file%/*}\"\n    pre_ext=\"${basename%.*}\"\n    ext=\"${basename:${#pre_ext}}\"\n\n    # File already hashed?\n    pre_ext=$(is_hash \"$pre_ext\")\n    ext=$(is_hash \"$ext\")\n\n    mv \"$file\" \"${dirname}/${pre_ext}.${hash}${ext}\" 2&gt; /dev/null\n\ndone &lt; &lt;(find \"$1\" -path \"*/.*\" -prune -o \\( -type f -print0 \\))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code has the following benefits over other entries thus far"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 11, "lis": [{"text": ["It is fully compliant with Bash versions 2.0.2 and beyond"], "childNum": 0, "tag": "strong", "senID": 3, "childList": []}, {"text": "No superfluous calls to other binaries like sed or grep; uses builtin parameter expansion instead", "tag": "none", "senID": 4}, {"text": "Uses process substitution for 'find' instead of a pipe, no sub-shell is made this way", "tag": "none", "senID": 5}, {"text": "Takes the directory to work on as an argument and does a sanity check on it", "tag": "none", "senID": 6}, {"text": "Uses $() rather than `` notation for command substitution, the latter is deprecated", "tag": "none", "senID": 7}, {"text": "Works with files with spaces", "tag": "none", "senID": 8}, {"text": "Works with files with newlines", "tag": "none", "senID": 9}, {"text": "Works with files with multiple extensions", "tag": "none", "senID": 10}, {"text": ["Works with files with no extension"], "childNum": 0, "tag": "strong", "senID": 11, "childList": []}, {"text": "Does not traverse hidden directories", "tag": "none", "senID": 12}, {"text": ["Does NOT skip pre-hashed files, it will recalculate the hash as per the spec"], "childNum": 1, "tag": "strong", "senID": 13, "childList": [{"text": "NOT", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}]}, {"code": "<pre>\n$ tree -a a\na\n|-- .hidden_dir\n|   `-- foo\n|-- b\n|   `-- c.d\n|       |-- f\n|       |-- g.5236b1ab46088005ed3554940390c8a7.ext\n|       |-- h.d41d8cd98f00b204e9800998ecf8427e\n|       |-- i.ext1.5236b1ab46088005ed3554940390c8a7.ext2\n|       `-- j.ext1.ext2\n|-- c.ext^Mnewline\n|   |-- f\n|   `-- g.with[or].ext\n`-- f^Jnewline.ext\n\n4 directories, 9 files\n</pre>\n", "senID": 14}, {"code": "<pre>\n$ tree -a a\na\n|-- .hidden_dir\n|   `-- foo\n|-- b\n|   `-- c.d\n|       |-- f.d41d8cd98f00b204e9800998ecf8427e\n|       |-- g.d41d8cd98f00b204e9800998ecf8427e.ext\n|       |-- h.d41d8cd98f00b204e9800998ecf8427e\n|       |-- i.ext1.d41d8cd98f00b204e9800998ecf8427e.ext2\n|       `-- j.ext1.d41d8cd98f00b204e9800998ecf8427e.ext2\n|-- c.ext^Mnewline\n|   |-- f.d41d8cd98f00b204e9800998ecf8427e\n|   `-- g.with[or].d41d8cd98f00b204e9800998ecf8427e.ext\n`-- f^Jnewline.d3b07384d113edec49eaa6238ad5ff00.ext\n\n4 directories, 9 files\n</pre>\n", "senID": 15}], [{"text": ["The logic of the requirements is complex enough to justify the use of Python instead of bash.", "It should provide a more readable, extensible, and maintainable solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport hashlib, os\n\ndef ishash(h, size):\n    \"\"\"Whether `h` looks like hash's hex digest.\"\"\"\n    if len(h) == size: \n        try:\n            int(h, 16) # whether h is a hex number\n            return True\n        except ValueError:\n            return False\n\nfor root, dirs, files in os.walk(\".\"):\n    dirs[:] = [d for d in dirs if not d.startswith(\".\")] # skip hidden dirs\n    for path in (os.path.join(root, f) for f in files if not f.startswith(\".\")):\n        suffix = hash_ = \".\" + hashlib.md5(open(path).read()).hexdigest()\n        hashsize = len(hash_) - 1\n        # extract old hash from the name; add/replace the hash if needed\n        barepath, ext = os.path.splitext(path) # ext may be empty\n        if not ishash(ext[1:], hashsize):\n            suffix += ext # add original extension\n            barepath, oldhash = os.path.splitext(barepath) \n            if not ishash(oldhash[1:], hashsize):\n               suffix = oldhash + suffix # preserve 2nd (not a hash) extension\n        else: # ext looks like a hash\n            oldhash = ext\n        if hash_ != oldhash: # replace old hash by new one\n           os.rename(path, barepath+suffix)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's a test directory tree.", "It contains:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "files without extension inside directories with a dot in their name", "tag": "none", "senID": 3}, {"text": "filename which already has a hash in it (test on idempotency)", "tag": "none", "senID": 4}, {"text": "filename with two extensions", "tag": "none", "senID": 5}, {"text": "newlines in names", "tag": "none", "senID": 6}]}, {"code": "<pre>\n$ tree a\na\n|-- b\n|   `-- c.d\n|       |-- f\n|       |-- f.ext1.ext2\n|       `-- g.d41d8cd98f00b204e9800998ecf8427e\n|-- c.ext^Mnewline\n|   `-- f\n`-- f^Jnewline.ext1\n\n7 directories, 5 files\n</pre>\n", "senID": 7}, {"code": "<pre>\n$ tree a\na\n|-- b\n|   `-- c.d\n|       |-- f.0bee89b07a248e27c83fc3d5951213c1\n|       |-- f.ext1.614dd0e977becb4c6f7fa99e64549b12.ext2\n|       `-- g.d41d8cd98f00b204e9800998ecf8427e\n|-- c.ext^Mnewline\n|   `-- f.0bee89b07a248e27c83fc3d5951213c1\n`-- f^Jnewline.b6fe8bb902ca1b80aaa632b776d77f83.ext1\n\n7 directories, 5 files\n</pre>\n", "senID": 8}, {"text": ["The solution works correctly for all cases."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"tag": "hr", "senID": 10}, {"text": ["Whirlpool hash is not in Python's stdlib, but there are both pure Python and C extensions that support it e.g., python-mhash."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "python-mhash", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To install it:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n $ sudo apt-get install python-mhash\n</code>\n</pre>\n", "senID": 13}, {"text": ["To use it:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n import mhash\n\nprint mhash.MHASH(mhash.MHASH_WHIRLPOOL, \"text to hash here\").hexdigest()\n</code>\n</pre>\n", "senID": 15}, {"text": ["Output:\n    cbdca4520cc5c131fc3a86109dd23fee2d7ff7be56636d398180178378944a4f41480b938608ae98da7eccbf39a4c79b83a8590c4cb1bace5bc638fc92b3e653"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"tag": "hr", "senID": 17}, {"code": "<pre>\n<code>\n from subprocess import PIPE, STDOUT, Popen\n\ndef getoutput(cmd):\n    return Popen(cmd, stdout=PIPE, stderr=STDOUT).communicate()[0]\n\nhash_ = getoutput([\"whirlpooldeep\", \"-q\", path]).rstrip()\n</code>\n</pre>\n", "senID": 18}, {"tag": "hr", "senID": 19}, {"text": ["git can provide with leverage for the problems that need to track set of files based on their hashes. "], "childNum": 2, "tag": "p", "senID": 20, "childList": [{"text": "git", "tag": "a", "pos": 0, "childList": [{"text": "git", "tag": "code"}], "childNum": 1, "href": "http://git-scm.com/"}, {"text": "git", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I wasn't really happy with my first answer, since as I said there, this problem looks like it's best solved with perl.", "You already said in one edit of your question that you have perl on the OS X machine you want to run this on, so I gave it a shot."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's hard to get it all right in bash, i.e.", "avoiding any quoting problems with odd filenames, and behaving nicely with corner-case filenames."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So here it is in perl, a complete solution to your problem.", "It runs over all the files/directories listed on its command line."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl -w\n# whirlpool-rename.pl\n# 2009 Peter Cordes &lt;peter@cordes.ca&gt;.  Share and Enjoy!\n\nuse Fcntl;      # for O_BINARY\nuse File::Find;\nuse Digest::Whirlpool;\n\n# find callback, called once per directory entry\n# $_ is the base name of the file, and we are chdired to that directory.\nsub whirlpool_rename {\n    print \"find: $_\\n\";\n#    my @components = split /\\.(?:[[:xdigit:]]{128})?/; # remove .hash while we're at it\n    my @components = split /\\.(?!\\.|$)/, $_, -1; # -1 to not leave out trailing dots\n\n    if (!$components[0] && $_ ne \".\") { # hidden file/directory\n        $File::Find::prune = 1;\n        return;\n    }\n\n    # don't follow symlinks or process non-regular-files\n    return if (-l $_ || ! -f _);\n\n    my $digest;\n    eval {\n        sysopen(my $fh, $_, O_RDONLY | O_BINARY) or die \"$!\";\n        $digest = Digest->new( 'Whirlpool' )->addfile($fh);\n    };\n    if ($@) {  # exception-catching structure from whirlpoolsum, distributed with Digest::Whirlpool.\n        warn \"whirlpool: couldn't hash $_: $!\\n\";\n        return;\n    }\n\n    # strip old hashes from the name.  not done during split only in the interests of readability\n    @components = grep { !/^[[:xdigit:]]{128}$/ }  @components;\n    if ($#components == 0) {\n        push @components, $digest->hexdigest;\n    } else {\n        my $ext = pop @components;\n        push @components, $digest->hexdigest, $ext;\n    }\n\n    my $newname = join('.', @components);\n    return if $_ eq $newname;\n    print \"rename  $_ ->  $newname\\n\";\n    if (-e $newname) {\n        warn \"whirlpool: clobbering $newname\\n\";\n        # maybe unlink $_ and return if $_ is older than $newname?\n        # But you'd better check that $newname has the right contents then...\n    }\n    # This could be link instead of rename, but then you'd have to handle directories, and you can't make hardlinks across filesystems\n    rename $_, $newname or warn \"whirlpool: couldn't rename $_ -> $newname:  $!\\n\";\n}\n\n\n#main\n$ARGV[0] = \".\" if !@ARGV;  # default to current directory\nfind({wanted => \\&whirlpool;_rename, no_chdir => 0}, @ARGV );\n</code>\n</pre>\n", "senID": 3}, {"text": ["Advantages:\n- actually uses whirlpool, so you can use this exact program directly.", "(after installing libperl-digest-whirlpool).", "Easy to change to any digest function you want, because instead of different programs with different output formats, you have the perl Digest common interface."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 9, "lis": [{"text": ["implements all other requirements: ignore hidden files (and files under hidden directories)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["able to handle any possible filename without error or security problem.", "(Several people got this right in their shell scripts)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["follows best practices for traversing a directory tree, by chdiring down into each directory (like my previous answer, with find -execdir).", "This avoids problems with PATH_MAX, and with directories being renamed while you're running."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["clever handling of filenames that end with .", "foo..txt... -> foo..hash.txt..."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Handles old filenames containing hashes already without renaming them and then renaming them back.", "(It strips any sequence of 128 hex digits that's surrounded by \".", "\" characters.", ")  In the everything-correct case, no disk write activity happens, just reads of every file.", "Your current solution runs mv twice in the already-correctly-named case, causing directory metadata writes.", "And being slower, because that's two processes that have to be execced."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["efficient.", "No programs are fork/execed, while most of the solutions that would actually work ended up having to sed something per-file.", "Digest::Whirlpool is implemented with a natively-compiled shared lib, so it's not slow pure-perl.", "This should be faster than running a program on every file, esp.", "for small files."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Perl supports UTF-8 strings, so filenames with non-ascii characters shouldn't be a problem.", "(not sure if any multi-byte sequences in UTF-8 could include the byte that means ASCII '.", "' on its own.", "If that is possible, then you need UTF-8 aware string handling.", "sed doesn't know UTF-8.", "Bash's glob expressions may."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["easily extensible.", "When you go to put this into a real program, and you want to handle more corner cases, you can do so quite easily.", "e.g.", "decide what to do when you want to rename a file but the hash-named filename already exists."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["good error reporting.", "Most shell scripts have this, though, by passing along errors from the progs they run."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}]}], [{"code": "<pre>\n<code>\n find . -type f -print | while read file\ndo\n    hash=`$hashcommand \"$file\"`\n    filename=${file%.*}\n    extension=${file##*.}\n    mv $file \"$filename.$hash.$extension\"\ndone\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You might want to store the results in one file, like in"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n find . -type f -exec md5sum {} \\; &gt; MD5SUMS\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you really want one file per hash:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n find . -type f | while read f; do g=`md5sum $f` &gt; $f.md5; done\n</code>\n</pre>\n", "senID": 3}, {"text": ["or even"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n find . -type f | while read f; do g=`md5sum $f | awk '{print $1}'`; echo \"$g $f\"&gt; $f-$g.md5; done\n</code>\n</pre>\n", "senID": 5}], [{"text": ["In sh or bash, two versions.", "One limits itself to files with extensions..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n hash () {\n  #openssl md5 t.sh | sed -e 's/.* //'\n  whirlpool \"$f\"\n}\n\nfind . -type f -a -name '*.*' | while read f; do\n  # remove the echo to run this for real\n  echo mv \"$f\" \"${f%.*}.whirlpool-`hash \"$f\"`.${f##*.}\"\ndone\n</code>\n</pre>\n", "senID": 1}, {"text": ["Testing..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ...\nmv ./bash-4.0/signames.h ./bash-4.0/signames.whirlpool-d71b117a822394a5b273ea6c0e3f4dc045b1098326d39864564f1046ab7bd9296d5533894626288265a1f70638ee3ecce1f6a22739b389ff7cb1fa48c76fa166.h\n...\n</code>\n</pre>\n", "senID": 3}, {"text": ["And this more complex version processes all plain files, with or without extensions, with or without spaces and odd characters, etc, etc..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n hash () {\n  #openssl md5 t.sh | sed -e 's/.* //'\n  whirlpool \"$f\"\n}\n\nfind . -type f | while read f; do\n  name=${f##*/}\n  case \"$name\" in\n    *.*) extension=\".${name##*.}\" ;;\n    *)   extension=   ;;\n  esac\n  # remove the echo to run this for real\n  echo mv \"$f\" \"${f%/*}/${name%.*}.whirlpool-`hash \"$f\"`$extension\"\ndone\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here's my take on it, in bash.", "Features: skips non-regular files; correctly deals with files with weird characters (i.e.", "spaces) in their names; deals with extensionless filenames; skips already-hashed files, so it can be run repeatedly (although if files are modified between runs, it adds the new hash rather than replacing the old one).", "I wrote it using md5 -q as the hash function; you should be able to replace this with anything else, as long as it only outputs the hash, not something like filename => hash."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n find -x . -type f -print0 | while IFS=\"\" read -r -d $'\\000' file; do\n    hash=\"$(md5 -q \"$file\")\" # replace with your favorite hash function\n    [[ \"$file\" == *.\"$hash\" ]] &amp;&amp; continue # skip files that already end in their hash\n    dirname=\"$(dirname \"$file\")\"\n    basename=\"$(basename \"$file\")\"\n    base=\"${basename%.*}\"\n    [[ \"$base\" == *.\"$hash\" ]] &amp;&amp; continue # skip files that already end in hash + extension\n    if [[ \"$basename\" == \"$base\" ]]; then\n            extension=\"\"\n    else\n            extension=\".${basename##*.}\"\n    fi\n    mv \"$file\" \"$dirname/$base.$hash$extension\"\ndone\n</code>\n</pre>\n", "senID": 1}], [{"text": ["whirlpool isn't a very common hash.", "You'll probably have to install a program to compute it.", "e.g.", "Debian/Ubuntu include a \"whirlpool\" package.", "The program prints the hash of one file by itself.", "apt-cache search whirlpool  shows that some other packages support it, including the interesting md5deep."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Some of the earlier anwsers will fail on filenames with spaces in them.", "If this is the case, but your files don't have any newlines in the filename, then you can safely use \\n as a delimiter."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n oldifs=\"$IFS\"\nIFS=\"\n\"\nfor i in $(find -type f); do echo \"$i\";done\n#output\n# ./base\n# ./base2\n# ./normal.ext\n# ./trick.e \"xt\n# ./foo bar.dir ext/trick' (name \"- }$foo.ext{}.ext2\nIFS=\"$oldifs\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["try without setting IFS to see why it matters."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I was going to try something with IFS=\".", "\"; find -print0 | while read -a array,  to split on \".", "\" characters, but I normally never use array variables.", "There's no easy way that I see in the man page to insert the hash as the second-last array index, and push down the last element (the file extension, if it had one.", ")  Any time bash array variables look interesting, I know it's time to do what I'm doing in perl instead!", "See the gotchas for using read:\nhttp://tldp.org/LDP/abs/html/gotchas.html#BADREAD0"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://tldp.org/LDP/abs/html/gotchas.html#BADREAD0", "tag": "a", "pos": 5, "childList": [], "childNum": 0, "href": "http://tldp.org/LDP/abs/html/gotchas.html#BADREAD0"}]}, {"text": ["I decided to use another technique I like: find -exec sh -c.  It's the safest, since you're not parsing filenames."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["This should do the trick:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n find -regextype posix-extended -type f -not -regex '.*\\.[a-fA-F0-9]{128}.*'  \\\n-execdir bash -c 'for i in \"${@#./}\";do \n hash=$(whirlpool \"$i\");\n ext=\".${i##*.}\"; base=\"${i%.*}\";\n [ \"$base\" = \"$i\" ] && ext=\"\";\n newname=\"$base.$hash$ext\";\n echo \"ext:$ext  $i -> $newname\";\n false mv --no-clobber \"$i\" \"$newname\";done' \\\ndummy {} +\n# take out the \"false\" before the mv, and optionally take out the echo.\n# false ignores its arguments, so it's there so you can\n# run this to see what will happen without actually renaming your files.\n</code>\n</pre>\n", "senID": 7}, {"text": ["-execdir bash -c 'cmd' dummy {} +  has the dummy arg there because the first arg after the command becomes $0 in the shell's positional parameters, not part of \"$@\" that  for  loops over.", "I use execdir instead of exec so I don't have to deal with directory names (or the possibility of exceeding PATH_MAX for nested dirs with long names, when the actual filenames are all short enough."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["-not -regex prevents this from being applied twice to the same file.", "Although whirlpool is an extremely long hash, and mv says File name too long if I run it twice without that check.", "(on an XFS filesystem."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Files with no extension get basename.hash.", "I had to check specially to avoid appending a trailing ., or getting the basename as the extension.", "${@#./} strips out the leading ./ that find puts in front of every filename, so there is no \".", "\" in the whole string for files with no extension."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["mv --no-clobber may be a GNU extension.", "If you don't have GNU mv, do something else if you want to avoid deleting existing files (e.g.", "you run this once, some of the same file are added to the directory with their old names; you run it again.", ")  OTOH, if you want that behaviour, just take it out."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["My solution should work even when filenames contain a newline (they can, you know!", "), or any other possible character.", "It would be faster and easier in perl, but you asked for shell."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["wallenborn's solution for making one file with all the checksums (instead of renaming the original) is pretty good, but inefficient.", "Don't run md5sum once per file, run it on as many files at once as will fit on its command line:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["find dir -type f -print0 | xargs -0 md5sum > dir.md5\nor with GNU find, xargs is built in (note the + instead of ';')\n find dir -type f -exec md5sum {} + > dir.md5"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["if you just use find -print | xargs -d'\\n',  you will be screwed up by file names with quote marks in them, so be careful.", "If you don't know what files you might someday run this script on, always try to use print0 or -exec.", "This is esp.", "true if filenames are supplied by untrusted users (i.e.", "could be an attack vector on your server."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"text": ["Hm, interesting problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Try the following (the mktest function is just for testing -- TDD for bash!", ":)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Added support for whirlpool hashes.", "tag": "none", "senID": 3}, {"text": "code cleanup", "tag": "none", "senID": 4}, {"text": "better quoting of filenames", "tag": "none", "senID": 5}, {"text": "changed array-syntax for test part-- should now work with most korn-like shells. Note that pdksh does not support :-based parameter expansion (or rather\nit means something else)", "tag": "none", "senID": 6}]}, {"text": ["Note also that when in md5-mode it fails for filenames with whirlpool-like hashes, and\npossibly vice-versa."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["In response to your updated question:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can avoid hidden directories with find by using"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n find -name '.?*' -prune -o \\( -type f -print0 \\)\n</code>\n</pre>\n", "senID": 2}, {"text": ["-name '.", "*' -prune  will prune \".", "\", and stop without doing anything.", ":/"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "-name '.*' -prune", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I'd still recommend my Perl version, though.", "I updated it...  You may still need to install Digest::Whirlpool from CPAN, though."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["using zsh:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ ls\na.txt\nb.txt\nc.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["The magic:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ FILES=**/*(.) \n$ # */ stupid syntax coloring thinks this is a comment\n$ for f in $FILES; do hash=`md5sum $f | cut -f1 -d\" \"`; mv $f \"$f:r.$hash.$f:e\"; done\n$ ls\na.60b725f10c9c85c70d97880dfe8191b3.txt\nb.3b5d5c3712955042212316173ccf37be.txt\nc.2cd6ee2c70b0bde53fbe6cac3c8b8bb1.txt\n</code>\n</pre>\n", "senID": 3}, {"text": ["Happy deconstruction!"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit: added files in subdirectories and quotes around mv argument"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "mv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Ruby:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env ruby\nrequire 'digest/md5'\n\nDir.glob('**/*') do |f|\n  next unless File.file? f\n  next if /\\.md5sum-[0-9a-f]{32}/ =~ f\n  md5sum = Digest::MD5.file f\n  newname = \"%s/%s.md5sum-%s%s\" %\n    [File.dirname(f), File.basename(f,'.*'), md5sum, File.extname(f)]\n  File.rename f, newname\nend\n</code>\n</pre>\n", "senID": 1}, {"text": ["Handles filenames that have spaces, no extension, and that have already been hashed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Ignores hidden files and directories \u2014 add File::FNM_DOTMATCH as the second argument of glob if that's desired."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "File::FNM_DOTMATCH", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "glob", "childNum": 0, "tag": "code", "childList": []}]}]]