[[{"text": ["Python and Java have vastly different approaches to exceptions.", "In Python, exceptions are normal.", "Look up EAFP (Easier to ask for forgiveness than permission) in the Python glossary.", "Also check what Wikipedia has to say."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "EAFP", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/glossary.html#term-eafp"}, {"text": "Wikipedia", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Exceptions"}]}, {"text": ["StopIteration is just an example of EAFP \u2013 just go ahead and get the next thing from the iterator, and if that fails, handle the error."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If the code is more readable with a non-local exit, in Python you use an exception.", "You don't write checks, you just deal with failures if things don't work out.", "There's absolutely nothing shameful about it, in fact it's encouraged.", "Unlike in Java."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Now for a specific case of StopIteration: Consider generator functions."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "generator functions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/Generators"}]}, {"code": "<pre>\n<code>\n def generator():\n    yield 1\n    print 'Side effect'\n    yield 2\n</code>\n</pre>\n", "senID": 4}, {"text": ["To support some kind of has_next() method, the generator would have to check for the next value, triggering the print before the 2 is asked for.", "The value (or exception raised) would have to be remembered in the iterator.", "If has_next was called twice, only the first one would trigger the side effect.", "Or the next value could always be precomputed, even if it's not needed."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "has_next()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "print", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "has_next", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["I find Python's semantics \u2013 computing only whenever the next value is needed \u2013 the nicest alternative."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Of course Java doesn't have resumable generators, so it's hard to compare here.", "But it's some anecdotal evidence that StopIteration generalizes better than hasNext()."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["There is nothing that stops you from using exceptions like that in java, \nit just looks ugly, at least to a java developer."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "stops", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The main reason is that stacktraces from exceptions are expensive, \nand possibly also that java developers might be slightly more concerned\nabout spending computing resources than Python developers."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Java is also a rather \"clean\" language - some would say fundamentalistic,\nwhich is one of the reasons it's a nice language.", "(* see comment) "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Anyway.", "Fundamentalists (and some normal people) thinks that  using exceptions for normal flow just isn't The Right Way... :-)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["But besides that, recent jvm's detects that you are generating a lot of stacktraces\nfor the same spot of code, and will actually throw exceptions without them \"after a while\" to speed up things."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Java sometimes does it, too: \"All implementations of DataInput methods use EOFException instead of return values.", "\" In this case there's no way to use the usual sentinel value, -1."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "does it", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://download.oracle.com/javase/tutorial/essential/io/datastreams.html"}, {"text": "DataInput", "tag": "a", "pos": -1, "childList": [{"text": "DataInput", "tag": "code"}], "childNum": 1, "href": "http://download.oracle.com/javase/7/docs/api/java/io/DataInput.html"}, {"text": "DataInput", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "EOFException", "tag": "a", "pos": -1, "childList": [{"text": "EOFException", "tag": "code"}], "childNum": 1, "href": "http://download.oracle.com/javase/7/docs/api/java/io/EOFException.html"}, {"text": "EOFException", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "-1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["The reason its not recommended is because in java, exception handling is generally expensive to process and recover from.", "When an exception is thrown, it causes a the jvm to go backtrack what is was doing in order to provide a stack trace which is never a good thing for performance.", "In short, it's language misuse - there will usually be a cleaner, more efficient way of handling logic.", "Consider the following code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try {\n\n    int x = service.getValue();\n\n    if(x &gt; 5)\n        throw new NumberTooBigException(\"Too Big\");\n    else\n        throw new NumberTooSmallException(\"Too Small\");\n\n} catch (NumberTooBigException e) {\n\n    System.out.println(\"i think it's too big...\");\n\n} catch (NumberTooSmallException e) {\n\n    System.out.println(\"i think it's too small...\");\n\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["A better approach is to use just use java's intended control logic:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if(x &gt; 5)\n    System.out.println(\"i think it's too big...\");\nelse\n    System.out.println(\"i think it's too small...\");\n</code>\n</pre>\n", "senID": 3}, {"text": ["As you can see from comparing these two snippets, exception handling is kind of ridiculous - overkill for what the sample intends to do.", "A better approach for the example you posted would be something like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n String[] args = {\"one\", \"two\", \"three\"};\nfor(String arg : args)\n    System.out.println(args);\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["Exceptions are better used for when things really go wrong, like IOException(\"no space left on device\"), ClassNotFoundException(\"can't find your code to run\") or NoRouteToHostException(\"Can't connect to host\")."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["StopIteration exists in Python for simple iteration over any sequence."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "StopIteration", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Using an exception to implement this was a design choice, and it really isn't that inconsistent with Java's exception mentality.", "An iterator's next() method being called when there are no more elements is an exceptional condition, and catching that exception behind the scenes in a for loop is a pretty simple way to implement \"take items until there aren't any left\"."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "next()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There is no right or wrong answer to this.", "Exception handling is a neutral control flow construct, and the best use of it depends on context and style."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In this case, both Java and Python do the same thing, for the same reasons: java.util.Iterator's next() uses NoSuchElementException to signal end-of-iterator.", "This is simply good style, in both languages: the alternative of using a special sentinel return value is is much worse, for various reasons."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "java.util.Iterator", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "next()", "tag": "a", "pos": -1, "childList": [{"text": "next()", "tag": "code"}], "childNum": 1, "href": "http://download.oracle.com/javase/1,5.0/docs/api/java/util/Iterator.html#next%28%29"}, {"text": "next()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "NoSuchElementException", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["As a rule of thumb, you should consider the use of exceptions whenever you write a function that wants to signal more than one kind of control flow return.", "This includes abnormal error conditions, but good use of exception signalling is certainly not limited to that."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "more than one kind of control flow return", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}]]