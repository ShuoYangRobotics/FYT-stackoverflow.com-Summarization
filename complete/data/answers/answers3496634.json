[[{"text": ["Well, here is the solutions with yield:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # transform forwards\ndef transform_pairs( lst ):\n    it = iter(lst)\n    a,last = next(it)\n    yield [a]\n    for a,b in it:\n        yield last, a\n        last = b\n    yield [last]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Transforming the list back should look very similar, but I'll leave that to the reader."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here is another slightly more complicated one that can transform in both directions.", "It yield tuples because lists of fixed length are lame."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "lame", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import chain\n\ndef transform( iterable, offset):\n    it = chain.from_iterable(iterable) # turn it back to one long list.\n    if offset:\n        yield next(it), # the trailing `,` makes this a tuple.\n    for item in it:\n        try:\n            x = next(it)\n        except StopIteration: # there is no 2nd item left\n            yield item,\n        else:\n             yield item, x # yield the pair\n\nprint list(transform(transform([[1,2],[3,4],[5,6],[7,8]], True), False))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Going for the 'another, better way' option (even gets the OP's exception correct):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def compress_task_list(tasks):\n    tasks = list(tasks)\n    tasks.sort(key=lambda item: item[0]) # make sure list is in order by start time\n    result = []\n    first_start = tasks[0][0]\n    final_stop = tasks[0][1]\n    for start, stop in tasks[1:]:\n        if start &gt; final_stop:\n            result.append((first_start, final_stop))\n            first_start = start\n            final_stop = stop\n        elif stop &gt; final_stop:\n            final_stop = stop\n    result.append((first_start, final_stop))\n    return tuple(result)\n\nif __name__ == '__main__':\n    import unittest\n\n    class Test_Compress_Task_List(unittest.TestCase):\n        def test_01(self):\n            \"completely separate\"\n            initial = ((8.0, 9.5), (10.0, 12.0), (13.0, 15.5), (16.0, 17.0))\n            expected = ((8.0, 9.5), (10.0, 12.0), (13.0, 15.5), (16.0, 17.0))\n            self.assertEqual(compress_task_list(initial), expected)\n        def test_02(self):\n            \"end equals start\"\n            initial = ((8.0, 9.5), (9.5, 12.0), (13.0, 15.5), (15.5, 17.0))\n            expected = ((8.0, 12.0), (13.0, 17.0))\n            self.assertEqual(compress_task_list(initial), expected)\n        def test_03(self):\n            \"end equals start (with more empty times)\"\n            initial = ((8.0, 8.5), (8.5, 10.0), (10.25, 12.0), (12.5, 13.75), (13.75, 15.0), (15.25, 16.0), (16.0, 17.0))\n            expected = ((8.0, 10.0), (10.25, 12.0), (12.5, 15.0), (15.25, 17.0))\n            self.assertEqual(compress_task_list(initial), expected)\n        def test_04(self):\n            \"out of order, cross-overs, and tasks completely inside other tasks\"\n            initial = ((8.0, 8.5), (8.0, 10.0), (10.25, 12.0), (10.0, 11.5), (13.0, 15.5), (14.0, 15.0), (16.0, 17.0))\n            expected = ((8.0, 12.0), (13.0, 15.5), (16.0, 17.0))\n            self.assertEqual(compress_task_list(initial), expected)\n\n    unittest.main()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Remember, this is Python, and readability counts.", ";)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This works, but it feels like something more Pythonic is out there:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = [[1,2], [3,4], [5,6], [7,8]]\no = []\nlast = []\nfor a, b in l:\n    o.append(last+[a])\n    last = [b]\no.append(last)\n\nprint o\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [[1], [2, 3], [4, 5], [6, 7], [8]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This body also works:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n o = [[l[0][0]]]\nfor i in range(len(l)-1):\n    o.append([l[i][1], l[i+1][0]])\no.append([l[-1][1]])\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n l = [[1,2], [3,4], [5,6], [7,8]]\nm = [([] if i==0 else [l[i-1][1]] )+([] if i==len(l) else [l[i][0]]) for i in xrange(len(l)+1)]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Do you mean:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n pairs = [[1,2], [3,4], [5,6], [7,8]]\nprint pairs, '-&gt;',\ntransformed = ([[pairs[0][0]]]+\n               [[a,b] for a,b in zip(\n                   (second for first, second in pairs[:-1]),\n                   (first for first, second in pairs[1:]))]+\n               [[pairs[-1][-1]]]\n               )\nprint transformed\n\"\"\" Output:\n[[1, 2], [3, 4], [5, 6], [7, 8]] -&gt; [[1], [2, 3], [4, 5], [6, 7], [8]]\n\"\"\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is a generator that can work with a generator or list input, so you don't have to keep everything in memory:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def shift_pairs(inPairs):\n    lastPair = None\n    for pair in inPairs:\n        if lastPair:\n            yield [lastPair[1], pair[0]]\n        else:\n            yield [pair[0]]\n        lastPair = pair\n    yield [lastPair[1]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I must point out that, in Python, lists of short, fixed length are usually done as tuples:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def shift_pairs(inPairs):\n    lastPair = None\n    for pair in inPairs:\n        if lastPair:\n            yield (lastPair[1], pair[0])\n        else:\n            yield (pair[0],)\n        lastPair = pair\n    yield (lastPair[1],)\n</code>\n</pre>\n", "senID": 3}]]