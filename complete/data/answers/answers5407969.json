[[{"text": ["It is more convenient to rewrite your distance() function to take two (x, y) tuples as parameters:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "distance()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(x, y)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def distance(p0, p1):\n    return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now you want to iterate over all pairs of points from your list fList.", "The function iterools.combinations() is handy for this purpose:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "fList", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "iterools.combinations()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n min_distance = distance(fList[0], fList[1])\nfor p0, p1 in itertools.combinations(fList, 2):\n    min_distance = min(min_distance, distance(p0, p1))\n</code>\n</pre>\n", "senID": 3}, {"text": ["An alternative is to define distance() to accept the pair of points in  a single parameter"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "distance()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def distance(points):\n    p0, p1 = points\n    return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)\n</code>\n</pre>\n", "senID": 5}, {"text": ["and use the key parameter to the built-in min() function:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "key", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "min()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n min_pair = min(itertools.combinations(fList, 2), key=distance)\nmin_distance = distance(min_pair)\n</code>\n</pre>\n", "senID": 7}], [{"text": ["First, some notes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a**2 # squares a\n(xi - xii)**2 # squares the expression in parentheses.\n</code>\n</pre>\n", "senID": 1}, {"text": ["mInput doesn't need to be declared in advance.", "fList.append((x, y)) is more pythonic than using +=."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "fList.append((x, y))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Now you have fList.", "Your distance function can be rewritten to take 2 2-tuple (point) arguments, which I won't bother with here."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "fList", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Then you can just write:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n shortest = float('inf')\nfor pair in itertools.combinations(fList, 2):\n    shortest = min(shortest, distance(*pair))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Note that the math.sqrt function is both slow and, in this case, unnecessary.", "Try comparing the distance squared to speed it up (sorting distances vs. distance squared will always produce the same ordering):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "math.sqrt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def distSquared(p0, p1):\n    return (p0[0] - p1[0])**2 + (p0[1] - p1[1])**2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your fixed code.", "No efficient algorithm, just the brute force one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import math # math needed for sqrt\n\n# distance function\ndef dist(p1, p2):\n    return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\n\n# run through input and reorder in [(x, y), (x,y) ...] format\ninput = [\"9.5 7.5\", \"10.2 19.1\", \"9.7 10.2\"] # original input list (entered by spacing the two points)\npoints = [map(float, point.split()) for point in input] # final list\n\n# http://en.wikipedia.org/wiki/Closest_pair_of_points\nmindist = float(\"inf\")\nfor p1, p2 in itertools.combinations(points, 2):\n    if dist(p1, p2) &lt; mindist:\n        mindist = dist(p1, p2)\n        closestpair = (p1, p2)\n\nprint(closestpair)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This might work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n oInput = [\"9.5 7.5\", \"10.2 19.1\", \"9.7 10.2\"]\n\n# parse inputs\ninp = [(float(j[0]), float(j[1])) for j in [i.split() for i in oInput]]\n\n# initialize results with a really large value\nmin_distance = float('infinity')\nmin_pair = None\n\n# loop over inputs\nlength = len(inp)\nfor i in xrange(length):\n    for j in xrange(i+1, length):\n        point1 = inp[i]\n        point2 = inp[j]\n\n        if math.hypot(point1[0] - point2[0], point1[1] - point2[0]) &lt; min_distance:\n            min_pair = [point1, point2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["once the loops are done, min_pair should be the pair with the smallest distance."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Using float() to parse the text leaves room for improvement."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["math.hypot is about a third faster than calculating the distance in a handwritten python-function"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I realize that there are library constraints on this question, but for completeness if you have N points in an Nx2 numpy ndarray (2D system):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "N", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from scipy.spatial.distance import pdist\nx = numpy.array([[9.5,7.5],[10.2,19.1],[9.7,10.2]])\nmindist = numpy.min(pdist(x))\n</code>\n</pre>\n", "senID": 1}, {"text": ["I always try to encourage people to use numpy/scipy if they are dealing with data that is best stored in a numerical array and it's good to know that the tools are out there for future reference."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]