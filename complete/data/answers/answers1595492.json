[[{"text": ["I found out how to do it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It is not about threads, and not about select()."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["When I run the first process (grep), it creates two low-level file descriptors, one for each pipe.", "Lets call those a and b."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "grep", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["When I run the second process, b gets passed to cut sdtin.", "But there is a brain-dead default on Popen - close_fds=False. "], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cut", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sdtin", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Popen", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "close_fds=False", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The effect of that is that cut also inherits a.", "So grep can't die even if I close a, because stdin is still open on cut's process (cut ignores it)."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "cut", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "grep", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "cut", "childNum": 0, "tag": "code", "childList": []}, {"text": "cut", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The following code now runs perfectly."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from subprocess import Popen, PIPE\n\np1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE, close_fds=True)\np1.stdin.write('Hello World\\n')\np1.stdin.close()\nresult = p2.stdout.read() \nassert result == \"Hello Worl\\n\"\n</code>\n</pre>\n", "senID": 6}, {"text": ["close_fds=TrueSHOULD BE THE DEFAULT on unix systems.", "On windows it closes all fds, so it prevents piping."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "close_fds=TrueSHOULD BE THE DEFAULT", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "close_fds=True", "tag": "code"}]}, {"text": "close_fds=True", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "all", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["EDIT:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["PS: For people with a similar problem reading this answer: As pooryorick said in a comment, that also could block if data written to p1.stdin is bigger than the buffers.", "In that case you should chunk the data into smaller pieces, and use select.select() to know when to read/write.", "The code in the question should give a hint on how to implement that."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "p1.stdin", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "select.select()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["EDIT2: Found another solution, with more help from pooryorick - instead of using close_fds=True and close ALL fds, one could close the fds that belongs to the first process, when executing the second, and it will work.", "The closing must be done in the child so the preexec_fn function from Popen comes very handy to do just that.", "On executing p2 you can do:"], "childNum": 4, "tag": "p", "senID": 10, "childList": [{"text": "close_fds=True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ALL", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "fd", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "preexec_fn", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n p2 = Popen(cmd2, stdin=p1.stdout, stdout=PIPE, stderr=devnull, preexec_fn=p1.stdin.close)\n</code>\n</pre>\n", "senID": 11}], [{"text": ["You must do this in several threads.", "Otherwise, you'll end up in a situation where you can't send data: child p1 won't read your input since p2 doesn't read p1's output because you don't read p2's output."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So you need a background thread that reads what p2 writes out.", "That will allow p2 to continue after writing some data to the pipe, so it can read the next line of input from p1 which again allows p1 to process the data which you send to it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Alternatively, you can send the data to p1 with a background thread and read the output from p2 in the main thread.", "But either side must be a thread."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I think you may be examining the wrong problem.", "Certainly as Aaron says if you try to be both a producer to the beginning of a pipeline, and a consumer of the end of the pipeline, it is easy to get into a deadlock situation.", "This is the problem that communicate() solves."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["communicate() isn't exactly correct for you since stdin and stdout are on different subprocess objects; but if you take a look at the implementation in subprocess.py you'll see that it does exactly what Aaron suggested."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Once you see that communicate both reads and writes, you'll see that in your second try communicate() competes with p2 for the output of p1:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n p1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\n# ...\np1.communicate('data\\n')       # reads from p1.stdout, as does p2\n</code>\n</pre>\n", "senID": 3}, {"text": ["I am running on win32, which definitely has different i/o and buffering characteristics, but this works for me:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n p1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\nt = threading.Thread(target=get_output, args=(p2,)) \nt.start()\np1.stdin.write('hello world\\n' * 100000)\np1.stdin.close()\nt.join()\n</code>\n</pre>\n", "senID": 5}, {"text": ["I tuned the input size to produce a deadlock when using a naive unthreaded p2.read()"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["You might also try buffering into a file, eg"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n fd, _ = tempfile.mkstemp()\nos.write(fd, 'hello world\\r\\n' * 100000)\nos.lseek(fd, 0, os.SEEK_SET)\np1 = Popen([\"grep\", \"-v\", \"not\"], stdin=fd, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\nprint p2.stdout.read()\n</code>\n</pre>\n", "senID": 8}, {"text": ["That also works for me without deadlocks."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["What about using a SpooledTemporaryFile ?", "This bypasses (but perhaps doesn't solve) the issue:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.python.org/library/tempfile.html#tempfile.SpooledTemporaryFile"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/tempfile.html#tempfile.SpooledTemporaryFile", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/tempfile.html#tempfile.SpooledTemporaryFile"}]}, {"text": ["You can write to it like a file, but it's actually a memory block."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Or am I totally misunderstanding..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There are three main tricks to making pipes work as expected"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The examples in the Python \"pipeline\" module (I'm the author) fit your scenario\nexactly, and make the low-level steps fairly clear."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://pypi.python.org/pypi/pipeline/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://pypi.python.org/pypi/pipeline/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/pipeline/"}]}, {"text": ["More recently, I used the subprocess module as part of a\nproducer-processor-consumer-controller pattern:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["http://www.darkarchive.org/w/Pub/PythonInteract"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://www.darkarchive.org/w/Pub/PythonInteract", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.darkarchive.org/w/Pub/PythonInteract"}]}, {"text": ["This example deals with buffered stdin without resorting to using a pty, and\nalso illustrates which pipe ends should be closed where.", "I prefer processes to\nthreading, but the principle is the same.", "Additionally, it illustrates\nsynchronizing Queues to which feed the producer and collect output from the consumer,\nand how to shut them down cleanly (look out for the sentinels inserted into the\nqueues).", "This pattern allows new input to be generated based on recent output,\nallowing for recursive discovery and processing."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Nosklo's offered solution will quickly break if too much data is written to the receiving end of the pipe:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from subprocess import Popen, PIPE\n\np1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE, close_fds=True)\np1.stdin.write('Hello World\\n' * 20000)\np1.stdin.close()\nresult = p2.stdout.read() \nassert result == \"Hello Worl\\n\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["If this script doesn't hang on your machine, just increase \"20000\" to something that exceeds the size of your operating system's pipe buffers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This is because the operating system is buffering the input to \"grep\", but once that buffer is full, the p1.stdin.write call will block until something reads from p2.stdout.", "In toy scenarios, you can get way with writing to/reading from a pipe in the same process, but in normal usage, it is necessary to write from one thread/process and read from a separate thread/process.", "This is true for subprocess.popen, os.pipe, os.popen*, etc."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "p1.stdin.write", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "p2.stdout", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Another twist is that sometimes you want to keep feeding the pipe with items generated from earlier output of the same pipe.", "The solution is to make both the pipe feeder and the pipe reader asynchronous to the man program, and implement two queues:  one between the main program and the pipe feeder and one between the main program and the pipe reader.", "PythonInteract is an example of that."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "PythonInteract", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.darkarchive.org/w/Pub/PythonInteract"}]}, {"text": ["Subprocess is a nice convenience model, but because it hides the details of the os.popen and os.fork calls it does under the hood, it can sometimes be more difficult to deal with than the lower-level calls it utilizes.", "For this reason, subprocess is not a good way to learn about how inter-process pipes really work."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["In one of the comments above, I challenged nosklo to either post some code to back up his assertions about select.select or to upvote my responses he had previously down-voted.", "He responded with the following code:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "select.select", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from subprocess import Popen, PIPE\nimport select\n\np1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE, close_fds=True)\n\ndata_to_write = 100000 * 'hello world\\n'\nto_read = [p2.stdout]\nto_write = [p1.stdin]\nb = [] # create buffer\nwritten = 0\n\n\nwhile to_read or to_write:\n    read_now, write_now, xlist = select.select(to_read, to_write, [])\n    if read_now:\n        data = p2.stdout.read(1024)\n        if not data:\n            p2.stdout.close()\n            to_read = []\n        else:\n            b.append(data)\n\n    if write_now:\n        if written &lt; len(data_to_write):\n            part = data_to_write[written:written+1024]\n            written += len(part)\n            p1.stdin.write(part); p1.stdin.flush()\n        else:\n            p1.stdin.close()\n            to_write = []\n\nprint b\n</code>\n</pre>\n", "senID": 1}, {"text": ["One problem with this script is that it second-guesses the size/nature of the\nsystem pipe buffers.", "The script would experience fewer failures if it could remove\nmagic numbers like 1024."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The big problem is that this script code only works consistently with the right\ncombination of data input and external programs.", "grep and cut both work with\nlines, and so their internal buffers behave a bit differently.", "If we use a\nmore generic command like \"cat\", and write smaller bits of data into the pipe,\nthe fatal race condition will pop up more often:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from subprocess import Popen, PIPE\nimport select\nimport time\n\np1 = Popen([\"cat\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cat\"], stdin=p1.stdout, stdout=PIPE, close_fds=True)\n\ndata_to_write = 'hello world\\n'\nto_read = [p2.stdout]\nto_write = [p1.stdin]\nb = [] # create buffer\nwritten = 0\n\n\nwhile to_read or to_write:\n    time.sleep(1)\n    read_now, write_now, xlist = select.select(to_read, to_write, [])\n    if read_now:\n        print 'I am reading now!'\n        data = p2.stdout.read(1024)\n        if not data:\n            p1.stdout.close()\n            to_read = []\n        else:\n            b.append(data)\n\n    if write_now:\n        print 'I am writing now!'\n        if written &lt; len(data_to_write):\n            part = data_to_write[written:written+1024]\n            written += len(part)\n            p1.stdin.write(part); p1.stdin.flush()\n        else:\n            print 'closing file'\n            p1.stdin.close()\n            to_write = []\n\nprint b\n</code>\n</pre>\n", "senID": 4}, {"text": ["In this case, two different results will manifest:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n write, write, close file, read -&gt; success\nwrite, read -&gt; hang\n</code>\n</pre>\n", "senID": 6}, {"text": ["So again, I challenge nosklo to either post code showing the use of\nselect.select to handle arbitrary input and pipe buffering from a\nsingle thread, or to upvote my responses."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "select.select", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Bottom line:  don't try to manipulate both ends of a pipe from a single thread.", "It's just not worth it.", "See\npipeline for a nice low-level\nexample of how to do this correctly."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "pipeline", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/pipeline/0.1"}]}], [{"text": ["Responding to nosklo's assertion (see other comments to this question) that it can't be done without close_fds=True:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "close_fds=True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["close_fds=True is only necessary if you've left other file\ndescriptors open.", "When opening multiple child processes, it's always good to\nkeep track of open files that might get inherited, and to explicitly close any\nthat aren't needed:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "close_fds=True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from subprocess import Popen, PIPE\n\np1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np1.stdin.write('Hello World\\n')\np1.stdin.close()\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\nresult = p2.stdout.read() \nassert result == \"Hello Worl\\n\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["close_fds defaults to False because subprocess\nprefers to trust the calling program to know what it's doing with open file\ndescriptors, and just provide the caller with an easy option to close them all\nif that's what it wants to do."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "close_fds", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["But the real issue is that pipe buffers will bite you for all but toy examples.", "As I have said in my other answers to this question, the rule of thumb is to\nnot have your reader and your writer open in the same process/thread.", "Anyone\nwho wants to use the subprocess module for two-way communication would be\nwell-served to study os.pipe and os.fork, first.", "They're actually not that\nhard to use if you have a good example to look at."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "good example", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/pipeline/0.1"}]}], [{"text": ["Here's an example of using Popen together with os.fork to accomplish the same\nthing.", "Instead of using close_fds it just closes the pipes at the\nright places.", "Much simpler than trying to use select.select, and\ntakes full advantage of system pipe buffers."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "close_fds", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "select.select", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n from subprocess import Popen, PIPE\nimport os\nimport sys\n\np1 = Popen([\"cat\"], stdin=PIPE, stdout=PIPE)\n\npid = os.fork()\n\nif pid: #parent\n    p1.stdin.close()\n    p2 = Popen([\"cat\"], stdin=p1.stdout, stdout=PIPE)\n    data = p2.stdout.read()\n    sys.stdout.write(data)\n    p2.stdout.close()\n\nelse: #child\n    data_to_write = 'hello world\\n' * 100000\n    p1.stdin.write(data_to_write)\n    p1.stdin.close()\n</code>\n</pre>\n", "senID": 1}]]