[[{"text": ["As of Django 1.1 you can use the ORM's F() expressions.", "For more details see the documentation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.djangoproject.com/en/1.1/ref/models/instances/#updating-attributes-based-on-existing-fields"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.djangoproject.com/en/1.1/ref/models/instances/#updating-attributes-based-on-existing-fields", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/1.1/ref/models/instances/#updating-attributes-based-on-existing-fields"}]}], [{"text": ["If you truly want the counter to be accurate you could use a transaction but the amount of concurrency required will really drag your application and database down under any significant load.", "Instead think of going with a more messaging style approach and just keep dumping count records into a table for each visit where you'd want to increment the counter.", "Then when you want the total number of visits do a count on the visits table.", "You could also have a background process that ran any number of times a day that would sum the visits and then store that in the parent table.", "To save on space it would also delete any records from the child visits table that it summed up.", "You'll cut down on your concurrency costs a huge amount if you don't have multiple agents vying for the same resources (the counter)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Two suggestions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Add a unique_together to your model, and wrap the creation in an exception handler to catch duplicates:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class VisitorDayTypeCounter(models.Model):\n    visitType = models.CharField(max_length=60)\n    visitDate = models.DateField('Visit Date')\n    counter = models.IntegerField()\n    class Meta:\n        unique_together = (('visitType', 'visitDate'))\n</code>\n</pre>\n", "senID": 2}, {"text": ["After this, you could stlll have a minor race condition on the counter's update.", "If you get enough traffic to be concerned about that, I would suggest looking into transactions for finer grained database control.", "I don't think the ORM has direct support for locking/synchronization.", "The transaction documentation is available here. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "here", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/topics/db/transactions/"}]}], [{"text": ["This is a bit of a hack.", "The raw SQL will make your code less portable, but it'll get rid of the race condition on the counter increment.", "In theory, this should increment the counter any time you do a query.", "I haven't tested this, so you should make sure the list gets interpolated in the query properly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class VisitorDayTypeCounterManager(models.Manager):\n    def get_query_set(self):\n        qs = super(VisitorDayTypeCounterManager, self).get_query_set()\n\n        from django.db import connection\n        cursor = connection.cursor()\n\n        pk_list = qs.values_list('id', flat=True)\n        cursor.execute('UPDATE table_name SET counter = counter + 1 WHERE id IN %s', [pk_list])\n\n        return qs\n\nclass VisitorDayTypeCounter(models.Model):\n    ...\n\n    objects = VisitorDayTypeCounterManager()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can use path from http://code.djangoproject.com/ticket/2705 for support database level locking."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.djangoproject.com/ticket/2705", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/ticket/2705"}]}, {"text": ["With path this code will be atomic:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n visitors = VisitorDayTypeCounter.objects.get(day=curday).for_update()\nvisitors.counter += 1\nvisitors.save()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Why not use the database as the concurrency layer ?", "Add a primary key or unique constraint the table to visitType and visitDate.", "If I'm not mistaken, django does not exactly support this in their database Model class or at least I've not seen an example."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Once you've added the constraint/key to the table, then all you have to do is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It's nasty to do it this way, but it seems quick enough and would cover most situations."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Your should use database transactions to avoid this kind of race condition.", "A transaction lets you perform the whole operation of creating, reading, incrementing and saving the counter on an \"all or nothing\" base.", "If anything goes wrong it will roll back the whole thing and you can try again."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Check out the Django docs.", "There is a transaction middle ware, or you can use decorators around views or methods to create transactions."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "docs.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/topics/db/transactions/?from=olddocs"}]}]]