[[{"text": ["First off, if you want to learn about parsing, then write your own recursive descent parser.", "The language you've defined only requires a handful of productions.", "I suggest using Python's tokenize library to spare yourself the boring task of converting a stream of bytes into a stream of tokens."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "tokenize", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["For practical parsing options, read on..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["A quick and dirty solution is to use python itself:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n NINETY_NINE = 99       # Defines the constant `NINETY_NINE` to have the value `99`\n\nrules = {\n  '*': {     # Applies to all data\n    'isYummy': {},      # Everything must be yummy\n\n    'chocolate': {        # To validate, say `validate(\"chocolate\", object)`\n      'sweet': {},        # chocolate must be sweet (but not necessarily chocolate.*)\n\n      'lindt': {          # To validate, say `validate(\"chocolate.lindt\", object)`\n        'tasty':{}        # Applies only to chocolate.lindt (and not to chocolate.lindt.dark, for e.g.)\n\n        '*': {            # Applies to all data under chocolate.lindt\n          'smooth': {}  # Could also be written smooth()\n          'creamy': 1   # Level 1 creamy\n        },\n# ...\n    }\n  }\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["There are several ways to pull off this trick, e.g., here's a cleaner (albeit somewhat unusual) approach using classes:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class _:\n    class isYummy: pass\n\n    class chocolate:\n        class sweet: pass\n\n        class lindt:\n            class tasty: pass\n\n            class _:\n                class smooth: pass\n                class creamy: level = 1\n# ...\n</code>\n</pre>\n", "senID": 5}, {"text": ["As an intermediate step to a full parser, you can use the \"batteries-included\" Python parser, which parses Python syntax and returns an AST.", "The AST is very deep with lots of (IMO) unnecessary levels.", "You can filter these down to a much simpler structure by culling any nodes that have only one child.", "With this approach you can do something like this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import parser, token, symbol, pprint\n\n_map = dict(token.tok_name.items() + symbol.sym_name.items())\n\ndef clean_ast(ast):\n    if not isinstance(ast, list):\n        return ast\n    elif len(ast) == 2: # Elide single-child nodes.\n        return clean_ast(ast[1])\n    else:\n        return [_map[ast[0]]] + [clean_ast(a) for a in ast[1:]]\n\nast = parser.expr('''{\n\n'*': {     # Applies to all data\n  isYummy: _,    # Everything must be yummy\n\n  chocolate: {        # To validate, say `validate(\"chocolate\", object)`\n    sweet: _,        # chocolate must be sweet (but not necessarily chocolate.*)\n\n    lindt: {          # To validate, say `validate(\"chocolate.lindt\", object)`\n      tasty: _,        # Applies only to chocolate.lindt (and not to chocolate.lindt.dark, for e.g.)\n\n      '*': {            # Applies to all data under chocolate.lindt\n        smooth: _,  # Could also be written smooth()\n        creamy: 1   # Level 1 creamy\n      }\n# ...\n    }\n  }\n}\n\n}''').tolist()\npprint.pprint(clean_ast(ast))\n</code>\n</pre>\n", "senID": 7}, {"text": ["This approach does have its limitations.", "The final AST is still a bit noisy, and the language you define has to be interpretable as valid python code.", "For instance, you couldn't support this..."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n *:\n    isYummy\n</code>\n</pre>\n", "senID": 9}, {"text": ["...because this syntax doesn't parse as python code.", "Its big advantage, however, is that you control the AST conversion, so it is impossible to inject arbitrary Python code."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["If your goal is to learn about parsing, I'd highly recommend an OO style library like PyParsing.", "They are not as fast as the more sophisticated antler, lex, yac options, but you get started with the parsing right away.   "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PyParsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}]}], [{"text": ["Again not teaching you about parsing, but your format is so close to legal YAML that you might want to just redefine your language as a subset of YAML and use a standard YAML parser."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "YAML", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.yaml.org/"}, {"href": "http://pyyaml.org/", "text": "standard YAML parser", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["The language you've shown an example for is probably too complex to write a simple (and bug-free) parsing fuction for.", "I'd suggest reading up on parsing techniques such as recursive-descent or table-driven parsing such as LL(1), LL(k), etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But that may be too general and/or complicated.", "It might be easier to simplify your rules language to something simple like delimited text."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For example, something like"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["chocolate:sweet\nchocolate.lindt:tasty\nchocolate.lindt.", "*:smooth,creamy(1)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"text": ["This would be easier to parse and could be done without formal parsers."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["There are libraries and tools to make parsing easier.", "One of the more well known is lex / yacc.", "There's a python library called 'lex' and a tutorial on using it."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "lex", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/ply/"}, {"text": "tutorial", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.dalkescientific.com/writings/NBN/parsing_with_ply.html"}]}], [{"text": ["As 'Marcelo Cantos' suggested you can use python dict, benefit is that you do not have to parse any thing, you can use same rules on server side as python dict and on client side using  javascript objects, and can pass them from server to client or viceversa as JSON."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you really want to do parsing yourself see this\nhttp://nedbatchelder.com/text/python-parsers.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://nedbatchelder.com/text/python-parsers.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://nedbatchelder.com/text/python-parsers.html"}]}, {"text": ["but I am not sure you will be easily able to parse a indented language."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["what is the motivation for the customized file structure?", "Would it be possible to remodel your data into a better known structure like XML?", "If so you could use one of a multitude to parse your file.", "Using an accepted parsing tool may save you a lot of time debugging, and it may make your file more readable if that is a consideration"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]