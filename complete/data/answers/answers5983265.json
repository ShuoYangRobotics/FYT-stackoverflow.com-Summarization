[[{"text": ["Here's an enumerate-like generator that skips ahead one; it returns -1 for the last element."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def annotate(gen):\n...     prev_i, prev_val = 0, gen.next()\n...     for i, val in enumerate(gen, start=1):\n...         yield prev_i, prev_val\n...         prev_i, prev_val = i, val\n...     yield '-1', prev_val\n&gt;&gt;&gt; for i, val in annotate(iter(range(4))):\n...     print i, val\n... \n0 0\n1 1\n2 2\n-1 3\n</code>\n</pre>\n", "senID": 1}, {"text": ["It can't tell whether the generator passed to it is \"fresh\" or not, but it still tells you when the end is nigh:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; used_iter = iter(range(5))\n&gt;&gt;&gt; used_iter.next()\n0\n&gt;&gt;&gt; for i, val in annotate(used_iter):\n...     print i, val\n... \n0 1\n1 2\n2 3\n-1 4\n</code>\n</pre>\n", "senID": 3}, {"text": ["Once an iterator is used up, it raises StopIteration as usual. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "StopIteration", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; annotate(used_iter).next()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 2, in annotate\nStopIteration\n</code>\n</pre>\n", "senID": 5}], [{"text": ["For the first, use a flag to tell whether or not you've processed any.", "For the last, hold the next value in a variable, and if there are no more then that's the last one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Well, as for the first element:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for n, item in enumerate(generator()):\n  if n == 0:\n    # item is first\n# out of the loop now: item is last\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Turn it into a sequence, example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; gen = (x for x in range(5))\n&gt;&gt;&gt; L = list(gen)\n&gt;&gt;&gt; L[0]\n0\n&gt;&gt;&gt; L[-1]\n4\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you need to do this during the loop:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; gen = (x for x in range(5))\n&gt;&gt;&gt; L = list(gen)\n&gt;&gt;&gt; for idx, item in enumerate(L):\n...    if idx == 0:\n...        print(u'{item} is first'.format(item=item))\n...    if idx == len(L) - 1:\n...        print(u'{item} is last'.format(item=item))\n...\n0 is first\n4 is last\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Clearly, this is not the solution, if you are the one who created the generator, and need it to stay that way (for memory savings), but if you don't care, this is more Pythonic per se than setting flags (which is implicit at best, sine it relies on the last element during iteration persisting), and enumerate won't get you any closer to finding the last element."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "you", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "enumerate", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Of course, it violates all generator's advantages, but if your iterable is not large, you should use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list(gener)[1:-1]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you're concerned about potentially large collections built dynamically, so that you don't want to temporarily place it into a single data structure, here's a different way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n FLAGMASK_FIRST = 1\nFLAGMASK_LAST = 2\n\ndef flag_lastfirst(collection):\n    first_flag = FLAGMASK_FIRST\n    first = True\n    index = 0\n    for element in collection:\n        if not first:\n            yield index, first_flag, current\n            index += 1\n            first_flag = 0\n        current = element\n        first = False\n    if not first:\n        yield index, first_flag | FLAGMASK_LAST, current\n\nl = [1, 2, 3, 4]\nfor k in flag_lastfirst(l):\n    print(k)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The function will produce a sequence of tuples, one for each element from the original collection."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The contents of the tuple:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["t[0]"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": ["t[1]"], "childNum": 0, "tag": "code", "senID": 5, "childList": []}, {"text": ["t[2]"], "childNum": 0, "tag": "code", "senID": 6, "childList": []}]}, {"text": ["Sample output from the code above:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n +-- 0-based index\n v\n(0, 1, 1)\n(1, 0, 2)\n(2, 0, 3)\n(3, 2, 4)\n    ^  ^\n    |  +-- the element from the original collection\n    |\n    +-- 1 means first, 2 means last,\n        3 means both first and last, 0 is everything else\n</code>\n</pre>\n", "senID": 8}, {"text": ["I'm sure there are nicer ways to build this kinda thing, but this is my contribution anyway."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]