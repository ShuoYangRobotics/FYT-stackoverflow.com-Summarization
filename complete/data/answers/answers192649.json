[[{"text": ["No, you cannot.", "In Python, all data (classes, methods, functions, etc) defined in C extension modules (including builtins) are immutable.", "This is because C modules are shared between multiple interpreters in the same process, so monkeypatching them would also affect unrelated interpreters in the same process."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, classes defined in Python code may be monkeypatched because they are local to that interpreter."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["What exactly do you mean by Monkey Patch here?", "There are several slightly different definitions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "several slightly different definitions", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://wikipedia.org/wiki/Monkey_patch"}]}, {"text": ["If you mean, \"can you change a class's methods at runtime?", "\", then the answer is emphatically yes:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Foo:\n  pass # dummy class\n\nFoo.bar = lambda self: 42\n\nx = Foo()\nprint x.bar()\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you mean, \"can you change a class's methods at runtime and make all of the instances of that class change after-the-fact?", "\" then the answer is yes as well.", "Just change the order slightly:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "make all of the instances of that class change after-the-fact", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo:\n  pass # dummy class\n\nx = Foo()\n\nFoo.bar = lambda self: 42\n\nprint x.bar()\n</code>\n</pre>\n", "senID": 4}, {"text": ["But you can't do this for certain built-in classes, like int or float.", "These classes' methods are implemented in C and there are certain abstractions sacrificed in order to make the implementation easier and more efficient."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I'm not really clear on why you would want to alter the behavior of the built-in numeric classes anyway.", "If you need to alter their behavior, subclass them!"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "why", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Python's core types are immutable by design, as other users have pointed out:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; int.frobnicate = lambda self: whatever()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: can't set attributes of built-in/extension type 'int'\n</code>\n</pre>\n", "senID": 1}, {"text": ["You certainly could achieve the effect you describe by making a subclass, since user-defined types in Python are mutable by default."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "could", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class MyInt(int):\n...   def frobnicate(self):\n...     print 'frobnicating %r' % self\n... \n&gt;&gt;&gt; five = MyInt(5)\n&gt;&gt;&gt; five.frobnicate()\nfrobnicating 5\n&gt;&gt;&gt; five + 8\n13\n</code>\n</pre>\n", "senID": 3}, {"text": ["There's no need to make the MyInt subclass public, either; one could just as well define it inline directly in the function or method that constructs the instance."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "MyInt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["There are certainly a few situations where Python programmers who are fluent in the idiom consider this sort of subclassing the right thing to do.", "For instance, os.stat() returns a tuple subclass that adds named members, precisely in order to address the sort of readability concern you refer to in your example."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "os.stat()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import os\n&gt;&gt;&gt; st = os.stat('.')\n&gt;&gt;&gt; st\n(16877, 34996226, 65024L, 69, 1000, 1000, 4096, 1223697425, 1223699268, 1223699268)\n&gt;&gt;&gt; st[6]\n4096\n&gt;&gt;&gt; st.st_size\n4096\n</code>\n</pre>\n", "senID": 6}, {"text": ["That said, in the specific example you give, I don't believe that subclassing float in item.price (or elsewhere) would be very likely to be considered the Pythonic thing to do.", "I can easily imagine somebody deciding to add a price_should_equal() method to item if that were the primary use case; if one were looking for something more general, perhaps it might make more sense to use named arguments to make the intended meaning clearer, as in"], "childNum": 5, "tag": "p", "senID": 7, "childList": [{"text": "float", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "item.price", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "can", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "price_should_equal()", "childNum": 0, "tag": "code", "childList": []}, {"text": "item", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n should_equal(observed=item.price, expected=19.99)\n</code>\n</pre>\n", "senID": 8}, {"text": ["or something along those lines.", "It's a bit verbose, but no doubt it could be improved upon.", "A possible advantage to such an approach over Ruby-style monkey-patching is that should_equal() could easily perform its comparison on any type, not just int or float.", "But perhaps I'm getting too caught up in the details of the particular example that you happened to provide."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "should_equal()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["No, you can't do that in Python.", "I consider it to be a good thing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["What does should_equal do?", "Is it a boolean returning True or False?", "In that case, it's spelled:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "should_equal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n item.price == 19.99\n</code>\n</pre>\n", "senID": 1}, {"text": ["There's no accounting for taste, but no regular python developer would say that's less readable than your version."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Does should_equal instead set some sort of validator?", "(why would a validator be limited to one value?", "Why not just set the value and not update it after that?", ")  If you want a validator, this could never work anyway, since you're proposing to modify either a particular integer or all integers.", "(A validator that requires 18.99 to equal 19.99 will always fail.", ") Instead, you could spell it like this:"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "should_equal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "18.99", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "19.99", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n item.price_should_equal(19.99)\n</code>\n</pre>\n", "senID": 4}, {"text": ["or this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n item.should_equal('price', 19.99)\n</code>\n</pre>\n", "senID": 6}, {"text": ["and define appropriate methods on item's class or superclasses."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["If you really really really want to do a monkey patch in Python, you can do a (sortof) hack with the \"import foo as bar\" technique."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["If you have a class such as TelnetConnection, and you want to extend it, subclass it in a separate file and call it something like TelnetConnectionExtended."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then, at the top of your code, where you would normally say:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import TelnetConnection\n</code>\n</pre>\n", "senID": 3}, {"text": ["change that to be:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import TelnetConnectionExtended as TelnetConnection\n</code>\n</pre>\n", "senID": 5}, {"text": ["and then everywhere in your code that you reference TelnetConnection will actually be referencing TelnetConnectionExtended."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Sadly, this assumes that you have access to that class, and the \"as\" only operates within that particular file (it's not a global-rename), but I've found it to be useful from time to time."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Here's an example of implementing item.price.should_equal, although I'd use Decimal instead of float in a real program:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "item.price.should_equal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Price(float):\n    def __init__(self, val=None):\n        float.__init__(self)\n        if val is not None:\n            self = val\n\n    def should_equal(self, val):\n        assert self == val, (self, val)\n\nclass Item(object):\n    def __init__(self, name, price=None):\n        self.name = name\n        self.price = Price(price)\n\nitem = Item(\"spam\", 3.99)\nitem.price.should_equal(3.99)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def should_equal_def(self, value):\n    if self != value:\n        raise ValueError, \"%r should equal %r\" % (self, value)\n\nclass MyPatchedInt(int):\n    should_equal=should_equal_def\n\nclass MyPatchedStr(str):\n    should_equal=should_equal_def\n\nimport __builtin__\n__builtin__.str = MyPatchedStr\n__builtin__.int = MyPatchedInt\n\nint(1).should_equal(1)\nstr(\"44\").should_equal(\"44\")\n</code>\n</pre>\n", "senID": 0}, {"text": ["Have fun ;)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["No but you have UserDict UserString and UserList which were made with exactly this in mind."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you google you will find examples for other types, but this are builtin."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In general monkey patching is less used in Python than in Ruby."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can't patch core types in python.", "However, you could use pipe to write a more human readable code:  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from pipe import *\n\n@Pipe\ndef should_equal(obj, val):\n    if obj==val: return True\n    return False\n\nclass dummy: pass\nitem=dummy()\nitem.value=19.99\n\nprint item.value | should_equal(19.99)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It seems what you really wanted to write is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n assert item.price == 19.99\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Of course comparing floats for equality, or using floats for prices, is a bad idea, so you'd write assert item.price == Decimal(19.99) or whatever numeric class you were using for the price."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "a bad idea", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html"}, {"text": "assert item.price == Decimal(19.99)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You could also use a testing framework like py.test to get more info on failing asserts in your tests."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "py.test", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://doc.pytest.org/en/latest/example/reportingdemo.html"}]}]]