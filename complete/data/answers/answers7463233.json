[[{"text": ["Outside of the syntax clarification on re.match, I think I am understanding that you are struggling with taking two or more unknown (user input) regex expressions and classifying which is a more 'specific' match against a string. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re.match", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Recall for a moment that a Python regex really is a type of computer program.", "Most modern forms, including Python's regex, are based on Perl.", "Perl's regex's have recursion, backtracking, and other forms that defy trivial inspection.", "Indeed a rogue regex can be used as a form of denial of service attack. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "denial of service attack", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/ReDoS"}]}, {"text": ["To see of this on your own computer, try:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; re.match(r'^(a+)+$','a'*24+'!')\n</code>\n</pre>\n", "senID": 3}, {"text": ["That takes about 1 second on my computer.", "Now increase the 24 in 'a'*24 to a bit larger number, say 28.", "That take a lot longer.", "Try 48... You will probably need to CTRL+C now.", "The time increase as the number of a's increase is, in fact, exponential. "], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "24", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'a'*24", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "28", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "48", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "CTRL", "childNum": 0, "tag": "kbd", "pos": -1, "childList": []}, {"text": "C", "childNum": 0, "tag": "kbd", "pos": -1, "childList": []}]}, {"text": ["You can read more about this issue in Russ Cox's wonderful paper on 'Regular Expression Matching Can Be Simple And Fast'.", "Russ Cox is the Goggle engineer that built Google Code Search in 2006.", "As Cox observes, consider matching the regex 'a?", "'*33 + 'a'*33 against the string of 'a'*99 with awk and Perl (or Python or PCRE or Java or PHP or ...) Awk matches in 200 microseconds but Perl would require 1015 years because of exponential back tracking."], "childNum": 7, "tag": "p", "senID": 5, "childList": [{"text": "Russ Cox", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://swtch.com/~rsc/"}, {"text": "'Regular Expression Matching Can Be Simple And Fast'", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://swtch.com/~rsc/regexp/regexp1.html"}, {"text": "Google Code Search", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.google.com/codesearch"}, {"text": "'a?'*33 + 'a'*33", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'a'*99", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "15", "childNum": 0, "tag": "sup", "childList": []}, {"text": "years", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["So the conclusion is: it depends!", "What do you mean by a more specific match?", "Look at some of Cox's regex simplification techniques in RE2.", "If your project is big enough to write your own libraries (or use RE2) and you are willing to restrict the regex grammar used (i.e., no backtracking or recursive forms), I think the answer is that you would classify 'a better match' in a variety of ways.   "], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "it depends!", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "more specific", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "RE2", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://swtch.com/~rsc/regexp/regexp3.html"}]}, {"text": ["If you are looking for a simple way to state that (regex_3 &lt; regex_1 &lt; regex_2) when matched against some string using Python or Perl's regex language, I think that the answer is it is very very hard (i.e., this problem is NP Complete)"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "this problem", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://perl.plover.com/NPC/NPC-3SAT.html"}, {"href": "http://en.wikipedia.org/wiki/NP-complete", "text": "NP Complete", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Edit"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Everything I said above is true!", "However, here is a stab at sorting matching regular expressions based on one form of 'specific': How many edits to get from the regex to the string.", "The greater number of edits (or the higher the Levenshtein distance) the less 'specific' the regex is.  "], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Everything I said above is true!", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You be the judge if this works (I don't know what 'specific' means to you for your application):"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef ld(a,b):\n    \"Calculates the Levenshtein distance between a and b.\"\n    n, m = len(a), len(b)\n    if n &gt; m:\n        # Make sure n &lt;= m, to use O(min(n,m)) space\n        a,b = b,a\n        n,m = m,n\n\n    current = range(n+1)\n    for i in range(1,m+1):\n        previous, current = current, [i]+[0]*n\n        for j in range(1,n+1):\n            add, delete = previous[j]+1, current[j-1]+1\n            change = previous[j-1]\n            if a[j-1] != b[i-1]:\n                change = change + 1\n            current[j] = min(add, delete, change)      \n    return current[n]\n\ns='Mary had a little lamb'    \nd={}\nregs=[r'.*', r'Mary', r'lamb', r'little lamb', r'.*little lamb',r'\\b\\w+mb',\n        r'Mary.*little lamb',r'.*[lL]ittle [Ll]amb',r'\\blittle\\b',s,r'little']\n\nfor reg in regs:\n    m=re.search(reg,s)\n    if m:\n        print \"'%s' matches '%s' with sub group '%s'\" % (reg, s, m.group(0))\n        ld1=ld(reg,m.group(0))\n        ld2=ld(m.group(0),s)\n        score=max(ld1,ld2)\n        print \"  %i edits regex-&gt;match(0), %i edits match(0)-&gt;s\" % (ld1,ld2)\n        print \"  score: \", score\n        d[reg]=score\n        print\n    else:\n        print \"'%s' does not match '%s'\" % (reg, s)   \n\nprint \"   ===== %s =====    === %s ===\" % ('RegEx'.center(10),'Score'.center(10))\n\nfor key, value in sorted(d.iteritems(), key=lambda (k,v): (v,k)):\n    print \"   %22s        %5s\" % (key, value)\n</code>\n</pre>\n", "senID": 11}, {"text": ["The program is taking a list of regex's and matching against the string Mary had a little lamb. "], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "Mary had a little lamb", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here is the sorted ranking from \"most specific\" to \"least specific\":"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n =====   RegEx    =====    ===   Score    ===\n   Mary had a little lamb            0\n        Mary.*little lamb            7\n            .*little lamb           11\n              little lamb           11\n      .*[lL]ittle [Ll]amb           15\n               \\blittle\\b           16\n                   little           16\n                     Mary           18\n                  \\b\\w+mb           18\n                     lamb           18\n                       .*           22\n</code>\n</pre>\n", "senID": 14}, {"text": ["This based on the (perhaps simplistic) assumption that: a) the number of edits (the Levenshtein distance) to get from the regex itself to the matching substring is the result of wildcard expansions or replacements; b) the edits to get from the matching substring to the initial string.", "(just take one)"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["As two simple examples: "], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["As stated, this is simplistic.", "Anchors should increase specificity but they do not in this case.", "Very short stings don't work because the wild-card may be longer than the string. "], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["Edit 2"], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "Edit 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I got anchor parsing to work pretty darn well using the undocumented sre_parse module in Python.", "Type &gt;&gt;&gt; help(sre_parse) if you want to read more..."], "childNum": 2, "tag": "p", "senID": 19, "childList": [{"text": "sre_parse", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&gt;&gt;&gt; help(sre_parse)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This is the goto worker module underlying the re module.", "It has been in every Python distribution since 2001 including all the P3k versions.", "It may go away, but I don't think it is likely..."], "childNum": 2, "tag": "p", "senID": 20, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "may", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Here is the revised listing:"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"code": "<pre>\n<code>\n import re\nimport sre_parse\n\ndef ld(a,b):\n    \"Calculates the Levenshtein distance between a and b.\"\n    n, m = len(a), len(b)\n    if n &gt; m:\n        # Make sure n &lt;= m, to use O(min(n,m)) space\n        a,b = b,a\n        n,m = m,n\n\n    current = range(n+1)\n    for i in range(1,m+1):\n        previous, current = current, [i]+[0]*n\n        for j in range(1,n+1):\n            add, delete = previous[j]+1, current[j-1]+1\n            change = previous[j-1]\n            if a[j-1] != b[i-1]:\n                change = change + 1\n            current[j] = min(add, delete, change)      \n    return current[n]\n\ns='Mary had a little lamb'    \nd={}\nregs=[r'.*', r'Mary', r'lamb', r'little lamb', r'.*little lamb',r'\\b\\w+mb',\n        r'Mary.*little lamb',r'.*[lL]ittle [Ll]amb',r'\\blittle\\b',s,r'little',\n        r'^.*lamb',r'.*.*.*b',r'.*?.*',r'.*\\b[lL]ittle\\b \\b[Ll]amb',\n        r'.*\\blittle\\b \\blamb$','^'+s+'$']\n\nfor reg in regs:\n    m=re.search(reg,s)\n    if m:\n        ld1=ld(reg,m.group(0))\n        ld2=ld(m.group(0),s)\n        score=max(ld1,ld2)\n        for t, v in sre_parse.parse(reg):\n            if t=='at':      # anchor...\n                if v=='at_beginning' or 'at_end':\n                    score-=1   # ^ or $, adj 1 edit\n\n                if v=='at_boundary': # all other anchors are 2 char\n                    score-=2\n\n        d[reg]=score\n    else:\n        print \"'%s' does not match '%s'\" % (reg, s)   \n\nprint\nprint \"   ===== %s =====    === %s ===\" % ('RegEx'.center(15),'Score'.center(10))\n\nfor key, value in sorted(d.iteritems(), key=lambda (k,v): (v,k)):\n    print \"   %27s        %5s\" % (key, value)\n</code>\n</pre>\n", "senID": 22}, {"text": ["And soted RegEx's:"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"code": "<pre>\n<code>\n =====      RegEx      =====    ===   Score    ===\n        Mary had a little lamb            0\n      ^Mary had a little lamb$            0\n          .*\\blittle\\b \\blamb$            6\n             Mary.*little lamb            7\n     .*\\b[lL]ittle\\b \\b[Ll]amb           10\n                    \\blittle\\b           10\n                 .*little lamb           11\n                   little lamb           11\n           .*[lL]ittle [Ll]amb           15\n                       \\b\\w+mb           15\n                        little           16\n                       ^.*lamb           17\n                          Mary           18\n                          lamb           18\n                       .*.*.*b           21\n                            .*           22\n                         .*?.*           22\n</code>\n</pre>\n", "senID": 24}], [{"text": ["That certainly is possible.", "Use parenthetical match groups joined by | for alteration.", "If you arrange the parenthetical match groups by most specific regex to least specific, the rank in the returned tuple from m.groups() will show how specific your match is.", "You can also use named groups to name how specific your match is, such as s10 for very specific and s0 for a not so specific match. "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "|", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "m.groups()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "s10", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "s0", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s1='google.com/maps2text'\n&gt;&gt;&gt; s2='I forgot my goggles at the house'\n&gt;&gt;&gt; s3='blah blah blah'\n&gt;&gt;&gt; m1=re.match(r'(^google\\.com\\/maps\\dtext$)|(.*go[a-z]+)',s1)\n&gt;&gt;&gt; m2=re.match(r'(^google\\.com\\/maps\\dtext$)|(.*go[a-z]+)',s2)\n&gt;&gt;&gt; m1.groups()\n('google.com/maps2text', None)\n&gt;&gt;&gt; m2.groups()\n(None, 'I forgot my goggles')\n&gt;&gt;&gt; patt=re.compile(r'(?P&lt;s10&gt;^google\\.com\\/maps\\dtext$)|\n... (?P&lt;s5&gt;.*go[a-z]+)|(?P&lt;s0&gt;[a-z]+)')\n&gt;&gt;&gt; m3=patt.match(s3)\n&gt;&gt;&gt; m3.groups()\n(None, None, 'blah')\n&gt;&gt;&gt; m3.groupdict()\n{'s10': None, 's0': 'blah', 's5': None}\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you do not know ahead of time which regex is more specific, this is a much harder problem to solve.", "You want to have a look at this paper covering security of regex matches against file system names.  "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this paper", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.cs.umbc.edu/~ugrad/honors/theses/DonMiner.pdf"}]}], [{"text": ["It depends on what kind of regular expressions you have; as @carrot-top suggests, if you actually aren't dealing with \"regular expressions\" in the CS sense, and instead have crazy extensions, then you are definitely out of luck."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, if you do have traditional regular expressions, you might make a bit more progress.", "First, we could define what \"more specific\" means.", "Say R is a regular expression, and L(R) is the language generated by R.  Then we might say R1 is more specific than R2 if L(R1) is a (strict) subset of L(R2) (L(R1) &lt; L(R2)).", "That only gets us so far: in many cases, L(R1) is neither a subset nor a superset of L(R2), and so we might imagine that the two are somehow incomparable.", "An example, trying to match \"mary had a little lamb\", we might find two matching expressions: .", "*mary and lamb.", "*."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": ".*mary", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "lamb.*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["One non-ambiguous solution is to define specificity via implementation.", "For instance, convert your regular expression in a deterministic (implementation-defined) way to a DFA and simply count states.", "Unfortunately, this might be relatively opaque to a user."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "define specificity via implementation", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Indeed, you seem to have an intuitive notion of how you want two regular expressions to compare, specificity-wise.", "Why not simple write down a definition of specificity, based on the syntax of regular expressions, that matches your intuition reasonably well?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Totally arbitrary rules follow:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Anyway, just food for thought, as the other answers do a good job of outlining some of the issues you're facing; hope it helps."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I don't think it's possible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["An alternative would be to try to calculate the number of strings of length n that the regular expression also matches.", "A regular expression that matches 1,000,000,000 strings of length 15 characters is less specific than one that matches only 10 strings of length 15 characters."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Of course, calculating the number of possible matches is not trivial unless the regular expressions are simple."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Option 1:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Since users are supplying the regexes, perhaps ask them to also submit some test strings which they think are illustrative of their regex's specificity.", "(i.e.", "that show their regex is more specific than a competitor's regex.", ") Collect all the user's submitted test strings, and then test all the regexes against the complete set of test strings."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["To design a good regex, the author must have put thought into what strings match and don't match their regex, so it should be easy for them to supply good test strings."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Option 2:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You might try a Monte Carlo approach: Starting with the string that both regexes match, write a generator which generates mutations of that string (permute characters, add/remove characters, etc.", ") If both regexes match or don't match the same way for each mutation, then the regexes \"probably tie\".", "If one matches a mutations that the other doesn't, and vice versa, then they \"absolutely tie\". "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "probably tie", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "absolutely tie", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["But if one matches a strict superset of mutations then it is \"probably less specific\" than the other."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "probably less specific", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The verdict after a large number of mutations may not always be correct, but may be reasonable."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Option 3:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Use ipermute or pyParsing's invert to generate strings which match each regex.", "This will only work on a regexes that use a limited subset of regex syntax."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "ipermute", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.mail-archive.com/python-list@python.org/msg125198.html"}, {"text": "invert", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/file/view/invRegex.py"}]}], [{"text": ["I think you could do it by looking the result of matching with the longest result"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; m = re.match(r'google\\.com\\/maps','google.com/maps/hello')\n&gt;&gt;&gt; len(m.group(0))\n15\n\n&gt;&gt;&gt; m = re.match(r'google\\.com\\/maps2','google.com/maps/hello')\n&gt;&gt;&gt; print (m)\nNone\n\n&gt;&gt;&gt; m = re.match(r'google\\.com\\/maps','google.com/maps2/hello')\n&gt;&gt;&gt; len(m.group(0))\n15\n\n&gt;&gt;&gt; m = re.match(r'google\\.com\\/maps2','google.com/maps2/hello')\n&gt;&gt;&gt; len(m.group(0))\n16\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n re.match('google\\.com\\/maps', 'google\\.com\\/maps2', re.IGNORECASE)\n</code>\n</pre>\n", "senID": 0}, {"text": ["The second item to re.match() above is a string -- that's why it's not working:  the regex says to match a period after google, but instead it finds a backslash.", "What you need to do is double up the backslashes in the regex that's being used as a regex:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "re.match()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "is", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def compare_regexes(regex1, regex2):\n    \"\"\"returns regex2 if regex1 is 'smaller' than regex2\n    returns regex1 if they are the same\n    returns regex1 if regex1 is 'bigger' than regex2\n    otherwise returns None\"\"\"\n    regex1_mod = regex1.replace('\\\\', '\\\\\\\\')\n    regex2_mod = regex2.replace('\\\\', '\\\\\\\\')\n    if regex1 == regex2:\n        return regex1\n    if re.match(regex1_mod, regex2):\n        return regex2\n    if re.match(regex2_mod, regex1):\n        return regex1\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can change the returns to whatever suits your needs best.", "Oh, and make sure you are using raw strings with re.", "r'like this, for example'"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "r'like this, for example'", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I realize that this is a non-solution, but as there is no unambiguous way to tell which is the \"most specific match\", certainly when it depends on what your users \"meant\", the easiest thing to do would be to ask them to provide their own priority.", "For example just by putting the regexes in the right order.", "Then you can simply take the first one that matches.", "If you expect the users to be comfortable with regular expressions anyway, this is maybe not too much to ask?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]