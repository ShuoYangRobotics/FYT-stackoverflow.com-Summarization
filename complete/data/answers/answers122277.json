[[{"text": ["Using named groups and a dispatch table:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n r = re.compile(r'(?P&lt;cmd&gt;foo|bar|baz)(?P&lt;data&gt;.+)')\n\ndef do_foo(data):\n    ...\n\ndef do_bar(data):\n    ...\n\ndef do_baz(data):\n    ...\n\ndispatch = {\n    'foo': do_foo,\n    'bar': do_bar,\n    'baz': do_baz,\n}\n\n\nm = r.match(var)\nif m:\n    dispatch[m.group('cmd')](m.group('data'))\n</code>\n</pre>\n", "senID": 1}, {"text": ["With a little bit of introspection you can auto-generate the regexp and the dispatch table."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'd suggest this, as it uses the least regex to accomplish your goal.", "It is still functional code, but no worse then your old Perl."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nvar = \"barbazfoo\"\n\nm = re.search(r'(foo|bar|baz)(.+)', var)\nif m.group(1) == 'foo':\n    print m.group(1)\n    # do something with m.group(1)\nelif m.group(1) == \"bar\":\n    print m.group(1)\n    # do something with m.group(1)\nelif m.group(1) == \"baz\":\n    print m.group(2)\n    # do something with m.group(2)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Yeah, it's kind of annoying.", "Perhaps this will work for your case.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nclass ReCheck(object):\n    def __init__(self):\n        self.result = None\n    def check(self, pattern, text):\n        self.result = re.search(pattern, text)\n        return self.result\n\nvar = 'bar stuff'\nm = ReCheck()\nif m.check(r'foo(.+)',var):\n    print m.result.group(1)\nelif m.check(r'bar(.+)',var):\n    print m.result.group(1)\nelif m.check(r'baz(.+)',var):\n    print m.result.group(1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: Brian correctly pointed out that my first attempt did not work.", "Unfortunately, this attempt is longer."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Alternatively, something not using regular expressions at all:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n prefix, data = var[:3], var[3:]\nif prefix == 'foo':\n    # do something with data\nelif prefix == 'bar':\n    # do something with data\nelif prefix == 'baz':\n    # do something with data\nelse:\n    # do something with var\n</code>\n</pre>\n", "senID": 1}, {"text": ["Whether that is suitable depends on your actual problem.", "Don't forget, regular expressions aren't the swiss army knife that they are in Perl; Python has different constructs for doing string manipulation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n def find_first_match(string, *regexes):\n    for regex, handler in regexes:\n        m = re.search(regex, string):\n        if m:\n            handler(m)\n            return\n    else:\n        raise ValueError\n\nfind_first_match(\n    foo, \n    (r'foo(.+)', handle_foo), \n    (r'bar(.+)', handle_bar), \n    (r'baz(.+)', handle_baz))\n</code>\n</pre>\n", "senID": 0}, {"text": ["To speed it up, one could turn all regexes into one internally and create the dispatcher on the fly.", "Ideally, this would be turned into a class then."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n r\"\"\"\nThis is an extension of the re module. It stores the last successful\nmatch object and lets you access it's methods and attributes via\nthis module.\n\nThis module exports the following additional functions:\n    expand  Return the string obtained by doing backslash substitution on a\n            template string.\n    group   Returns one or more subgroups of the match.\n    groups  Return a tuple containing all the subgroups of the match.\n    start   Return the indices of the start of the substring matched by\n            group.\n    end     Return the indices of the end of the substring matched by group.\n    span    Returns a 2-tuple of (start(), end()) of the substring matched\n            by group.\n\nThis module defines the following additional public attributes:\n    pos         The value of pos which was passed to the search() or match()\n                method.\n    endpos      The value of endpos which was passed to the search() or\n                match() method.\n    lastindex   The integer index of the last matched capturing group.\n    lastgroup   The name of the last matched capturing group.\n    re          The regular expression object which as passed to search() or\n                match().\n    string      The string passed to match() or search().\n\"\"\"\n\nimport re as re_\n\nfrom re import *\nfrom functools import wraps\n\n__all__ = re_.__all__ + [ \"expand\", \"group\", \"groups\", \"start\", \"end\", \"span\",\n        \"last_match\", \"pos\", \"endpos\", \"lastindex\", \"lastgroup\", \"re\", \"string\" ]\n\nlast_match = pos = endpos = lastindex = lastgroup = re = string = None\n\ndef _set_match(match=None):\n    global last_match, pos, endpos, lastindex, lastgroup, re, string\n    if match is not None:\n        last_match = match\n        pos = match.pos\n        endpos = match.endpos\n        lastindex = match.lastindex\n        lastgroup = match.lastgroup\n        re = match.re\n        string = match.string\n    return match\n\n@wraps(re_.match)\ndef match(pattern, string, flags=0):\n    return _set_match(re_.match(pattern, string, flags))\n\n\n@wraps(re_.search)\ndef search(pattern, string, flags=0):\n    return _set_match(re_.search(pattern, string, flags))\n\n@wraps(re_.findall)\ndef findall(pattern, string, flags=0):\n    matches = re_.findall(pattern, string, flags)\n    if matches:\n        _set_match(matches[-1])\n    return matches\n\n@wraps(re_.finditer)\ndef finditer(pattern, string, flags=0):\n    for match in re_.finditer(pattern, string, flags):\n        yield _set_match(match)\n\ndef expand(template):\n    if last_match is None:\n        raise TypeError, \"No successful match yet.\"\n    return last_match.expand(template)\n\ndef group(*indices):\n    if last_match is None:\n        raise TypeError, \"No successful match yet.\"\n    return last_match.group(*indices)\n\ndef groups(default=None):\n    if last_match is None:\n        raise TypeError, \"No successful match yet.\"\n    return last_match.groups(default)\n\ndef groupdict(default=None):\n    if last_match is None:\n        raise TypeError, \"No successful match yet.\"\n    return last_match.groupdict(default)\n\ndef start(group=0):\n    if last_match is None:\n        raise TypeError, \"No successful match yet.\"\n    return last_match.start(group)\n\ndef end(group=0):\n    if last_match is None:\n        raise TypeError, \"No successful match yet.\"\n    return last_match.end(group)\n\ndef span(group=0):\n    if last_match is None:\n        raise TypeError, \"No successful match yet.\"\n    return last_match.span(group)\n\ndel wraps  # Not needed past module compilation\n</code>\n</pre>\n", "senID": 0}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if gre.match(\"foo(.+)\", var):\n  # do something with gre.group(1)\nelif gre.match(\"bar(.+)\", var):\n  # do something with gre.group(1)\nelif gre.match(\"baz(.+)\", var):\n  # do something with gre.group(1)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["With thanks to this other SO question:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this other SO question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1663995/python-variable-assignment-and-if-statement"}]}, {"code": "<pre>\n<code>\n import re\n\nclass DataHolder:\n    def __init__(self, value=None, attr_name='value'):\n        self._attr_name = attr_name\n        self.set(value)\n    def __call__(self, value):\n        return self.set(value)\n    def set(self, value):\n        setattr(self, self._attr_name, value)\n        return value\n    def get(self):\n        return getattr(self, self._attr_name)\n\ninput = u'test bar 123'\nsave_match = DataHolder(attr_name='match')\nif save_match(re.search('foo (\\d+)', input)):\n    print \"Foo\"\n    print save_match.match.group(1)\nelif save_match(re.search('bar (\\d+)', input)):\n    print \"Bar\"\n    print save_match.match.group(1)\nelif save_match(re.search('baz (\\d+)', input)):\n    print \"Baz\"\n    print save_match.match.group(1)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's the way I solved this issue:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n matched = False;\n\nm = re.match(\"regex1\");\nif not matched and m:\n    #do something\n    matched = True;\n\nm = re.match(\"regex2\");\nif not matched and m:\n    #do something else\n    matched = True;\n\nm = re.match(\"regex3\");\nif not matched and m:\n    #do yet something else\n    matched = True;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Not nearly as clean as the original pattern.", "However, it is simple, straightforward and doesn't require extra modules or that you change the original regexs."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["how about using a dictionary?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n match_objects = {}\n\nif match_objects.setdefault( 'mo_foo', re_foo.search( text ) ):\n  # do something with match_objects[ 'mo_foo' ]\n\nelif match_objects.setdefault( 'mo_bar', re_bar.search( text ) ):\n  # do something with match_objects[ 'mo_bar' ]\n\nelif match_objects.setdefault( 'mo_baz', re_baz.search( text ) ):\n  # do something with match_objects[ 'mo_baz' ]\n\n...\n</code>\n</pre>\n", "senID": 1}, {"text": ["however, you must ensure there are no duplicate match_objects dictionary keys ( mo_foo, mo_bar, ... ), best by giving each regular expression its own name and naming the match_objects keys accordingly, otherwise match_objects.setdefault() method would return existing match object instead of creating new match object by running re_xxx.search( text )."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Thanks guys, these are all pretty good solutions.", "I guess I sort of wish that Python had a \"global\" groups() function that did what Perl's $1, $2, $3 variables do."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I know it's not so Pythonic, but Python has bent the rules a bit in other modules like fileinput which keeps a global state in Perl-ish fashion, and is very convenient for text-processing scripts."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Ah well, basically I should just take what Thomas says to heart about regular expressions not being the Swiss Army Knife of Python.", "Which is a good thing."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]