[[{"text": ["Ah, the old \".5\" problem.", "Here's the answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're going to divide 10 things into two equal parts, you need 5 things in each part.", "0 thru 4 in the first part, 5-9 in the second part.", "So... &lt; .5 is correct."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "equal", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "&lt; .5", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["To a first approximation, either works."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The best way is to choose a random generator that specifically emits booleans or integers with range.", "Then you can nail the range exactly."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Operations like \"equality\" with floating point is iffy anyway."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n if random() &lt; .5\n</code>\n</pre>\n", "senID": 0}, {"text": ["In binary, .5 is .10000000000....", "So, basically, the question reduces to, \"What is the first binary digit after the radix point... 0 (for &lt;.5) or 1 (for .5 or more) ?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Why do it yourself?", "Python has random.choice :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["random.choice([0, 1]) will give you 0/1 with equal chances -- and it is a standard part of Python, coded up by the same people who wrote random.random (and thus know more about its semantics than anyone else)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For a particular system you should test it, if you really want to find out.", "Could take a while though :-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I agree with the other posters that to the first order, it doesn't matter.", "If it does matter, you'll need a better RNG anyway."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["EDIT:  I just tried the default RNG in C# with 1,000,000,000 attempts and the answers were identical..."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n import random\ndef fifty_fifty():\n    \"Return 0 or 1 with 50% chance for each\"\n    return random.randrange(2)\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &lt; .5\n</code>\n</pre>\n", "senID": 0}, {"text": ["but that assumes that your floating point support is good enough to satisfy your precision demands (since it's never exactly)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "exactly", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["If I want 50% chance, I'd just check for the LSB (Least Significant Bit)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you need truly random numbers, you can try random.org.", "They offer a web service connected to a device that detects noise coming from the universe.", "Still not random technically speaking, but close enough I guess. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "random.org", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://random.org/"}]}, {"text": ["They have all sort of way to make the query such as black and white images."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you're going to be that fussy about your random numbers, don't rely on anything that comes built-in.", "Get a well-documented RNG from a place you trust (I trust Boost, for what that's worth), and read the documentation.", "It used to be that standard RNGs were notoriously bad, and I still wouldn't trust them."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Alternately, use an integer RNG that gives you discrete values within a range, and divide the range in half.", "RNGs, in my experience, are integral, and the floating-point function simply divides by the top of the range."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Of course, if this is true, you've got your answer.", "If the integer RNG produces 0, 1, 2, and 3, the floating-point equivalent will be 0.0, 0.25, 0.5, and 0.75, so the answer is to test &lt; 0.5."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If the RNG isn't based on integral calculations, then it's based on floating-point calculations, and hence is inexact.", "In that case, it doesn't matter whether you test &lt;= or &lt;, since there is no guarantee that a calculation that should be a precise 0.5 will be."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["So, the answer is probably to test &lt; 0.5, which will likely be the correct one if it makes a difference."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["It doesn't matter.", "Both formulas yield the desired result."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]