[[{"text": ["After thinking about it a while a few days ago, and coming up with nothing worth posting, I came back to it now and came up with some syntax I rather like, because it nearly looks like python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n macro PrintMacro:\n  syntax:\n    \"print\", OneOrMore(Var(), name='vars')\n\n  return Printnl(vars, None)\n</code>\n</pre>\n", "senID": 1}, {"tag": "ul", "num": 2, "lis": [{"text": "Make all the macro \"keywords\" look like creating python objects (", "tag": "none", "senID": 2}, {"text": ["Pass the name of elements as a \"keyword parameter\" to items we want a name for.", "It should still be easy to find all the names in the parser, since this syntax definition anyway needs to be interpreted in some way to fill the macro classes syntax variable."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]}, {"text": ["The internal syntax representation could also look the same:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class PrintMacro(Macro):\n  syntax = 'print', OneOrMore(Var(), name='vars')\n  ...\n</code>\n</pre>\n", "senID": 5}, {"text": ["The internal syntax classes like OneOrMore would follow this pattern to allow subitems and an optional name:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "OneOrMore", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class MacroSyntaxElement(object):\n  def __init__(self, *p, name=None):\n    self.subelements = p\n    self.name = name\n</code>\n</pre>\n", "senID": 7}, {"text": ["When the macro matches, you just collect all items that have a name and pass them as keyword parameters to the handler function:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n class Macro():\n   ...\n   def parse(self, ...):\n     syntaxtree = []\n     nameditems = {}\n     # parse, however this is done\n     # store all elements that have a name as\n     #   nameditems[name] = parsed_element\n     self.handle(syntaxtree, **nameditems)\n</code>\n</pre>\n", "senID": 9}, {"text": ["The handler function would then be defined like this:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n class PrintMacro(Macro):\n  ...\n  def handle(self, syntaxtree, vars):\n    return Printnl(vars, None)\n</code>\n</pre>\n", "senID": 11}, {"text": ["I added the syntaxtree as a first parameter that is always passed, so you wouldn't need to have any named items if you just want to do very basic stuff on the syntax tree."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Also, if you don't like the decorators, why not add the macro type like a \"base class\"?", "IfMacro would then look like this:"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "IfMacro", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n macro IfMacro(MultiLine):\n  syntax:\n    Group(\"if\", Var(), \":\", Var(), name='if_')\n    ZeroOrMore(\"elif\", Var(), \":\", Var(), name='elifs')\n    Optional(\"else\", Var(name='elseBody'))\n\n  return If(\n      [(cond, Stmt(body)) for keyword, cond, colon, body in [if_] + elifs],\n      None if elseBody is None else Stmt(elseBody)\n    )\n</code>\n</pre>\n", "senID": 14}, {"text": ["And in the internal representation:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n class IfMacro(MultiLineMacro):\n  syntax = (\n      Group(\"if\", Var(), \":\", Var(), name='if_'),\n      ZeroOrMore(\"elif\", Var(), \":\", Var(), name='elifs'),\n      Optional(\"else\", Var(name='elseBody'))\n    )\n\n  def handle(self, syntaxtree, if_=None, elifs=None, elseBody=None):\n    # Default parameters in case there is no such named item.\n    # In this case this can only happen for 'elseBody'.\n    return If(\n        [(cond, Stmt(body)) for keyword, cond, body in [if_] + elifs],\n        None if elseNody is None else Stmt(elseBody)\n      )\n</code>\n</pre>\n", "senID": 16}, {"text": ["I think this would give a quite flexible system.", "Main advantages:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "Easy to learn (looks like standard python)", "tag": "none", "senID": 18}, {"text": "Easy to parse (parses like standard python)", "tag": "none", "senID": 19}, {"text": "Optional items can be easily handled, since you can have a default parameter ", "tag": "none", "senID": 20}, {"text": "Flexible use of named items:\n", "tag": "none", "senID": 21}, {"text": "Easily extensible if you want to add more features to the macro constructs. For example ", "tag": "none", "senID": 22}]}, {"text": ["I'm not sure about the quote/unquote syntax with \"quote:\" and \"$\", but some syntax for this is needed, since it makes life much easier if you don't have to manually write syntax trees.", "Probably its a good idea to require (or just permit?", ") parenthesis for \"$\", so that you can insert more complicated syntax parts, if you want.", "Like $(Stmt(a, b, c))."], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "$(Stmt(a, b, c))", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["The ToMacro would look something like this:"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"code": "<pre>\n<code>\n # macro definition\nmacro ToMacro(Partial):\n  syntax:\n    Var(name='start'), \"to\", Var(name='end'), Optional(\"inclusive\", name='inc'), Optional(\"step\", Var(name='step'))\n\n  if step == None:\n    step = quote(1)\n  if inclusive:\n    return quote:\n      xrange($(start), $(end)+1, $(step))\n  else:\n    return quote:\n      xrange($(start), $(end), $(step))\n\n# resulting macro class\nclass ToMacro(PartialMacro):\n  syntax = Var(name='start'), \"to\", Var(name='end'), Optional(\"inclusive\", name='inc'), Optional(\"step\", Var(name='step'))\n\n  def handle(syntaxtree, start=None, end=None, inc=None, step=None):\n    if step is None:\n      step = Number(1)\n    if inclusive:\n      return ['xrange', ['(', start, [end, '+', Number(1)], step, ')']]\n    return ['xrange', ['(', start, end, step, ')']]\n</code>\n</pre>\n", "senID": 25}], [{"text": ["You might consider looking at how Boo (a .NET-based language with a syntax largely inspired by Python) implements macros, as described at http://boo.codehaus.org/Syntactic+Macros."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://boo.codehaus.org/Syntactic+Macros", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://boo.codehaus.org/Syntactic+Macros"}]}], [{"text": ["You should take a look at MetaPython to see if it accomplishes what you're looking for."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "MetaPython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://metapython.org"}]}], [{"text": ["Incorporating BNF"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "BNF", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Backus-Naur_form"}]}, {"code": "<pre>\n<code>\n class IfMacro(Macro):\n    syntax: \"if\" expression \":\" suite (\"elif\" expression \":\" suite )* [\"else\" \":\" suite] \n\n    def handle(self, if_, elifs, elseBody):\n        return If(\n            [(expression, Stmt(suite)) for expression, suite in [if_] + elifs],\n            elseBody != None and Stmt(elseBody) or None\n            )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm posting a bit of floating ideas to see if it inspires.", "I don't know much python, and I'm not using real python syntax, but it beats nothing :p"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n macro PrintMacro:\n  syntax:  \n          print $a\n  rules:  \n        a: list(String),  as vars\n  handle:\n       # do something with 'vars' \n\nmacro IfMacro:\n  syntax: \n      if $a :\n          $b\n      $c \n   rules: \n        a: 1 boolean  as if_cond \n        b: 1 coderef     as if_code \n        c: optional macro(ElseIf) as else_if_block \n\n    if( if_cond ):\n          if_code();\n    elsif( defined else_if_block ): \n          else_if_block();\n</code>\n</pre>\n", "senID": 1}, {"text": ["More ideas: "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Implementing Perl quote style, but in Python!", "( its a very bad implementation, and note: whitespace is significant in the rule ) "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n macro stringQuote:\n  syntax:  \n          q$open$content$close\n  rules:  \n        open:  anyOf('[{(/_') or anyRange('a','z') or anyRange('0','9');\n        content: string\n        close:  anyOf(']})/_') or anyRange('a','z') or anyRange('0','9');\n  detect: \n      return 1 if open == '[' and close == ']' \n      return 1 if open == '{' and close == '}'\n      return 1 if open == '(' and close  == ')'\n      return 1 if open == close \n      return 0\n  handle: \n      return content;\n</code>\n</pre>\n", "senID": 4}], [{"text": ["This is a new macro syntax I've come up with based on Kent Fredric's ideas.", "It parses the syntax into a list just like the code is parsed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Print macro:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n macro PrintMacro:\n    syntax:\n      print $stmts\n\n  if not isinstance(stmts, list):\n    stmts = [stmts]\n  return Printnl(stmts, None)\n</code>\n</pre>\n", "senID": 2}, {"text": ["If macro:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n @MultiLine\nmacro IfMacro:\n  syntax:\n    @if_ = if $cond: $body\n    @elifs = ZeroOrMore(elif $cond: $body)\n    Optional(else: $elseBody)\n\n  return If(\n      [(cond, Stmt(body)) for cond, body in [if_] + elifs],\n      elseBody != None and Stmt(elseBody) or None\n    )\n</code>\n</pre>\n", "senID": 4}, {"text": ["X to Y [inclusive] [step Z] macro:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n @Partial\nmacro ToMacro:\n  syntax:\n    $start to $end Optional(inclusive) Optional(step $step)\n\n  if step == None:\n    step = quote 1\n  if inclusive:\n    return quote:\n      xrange($start, $end+1, $step)\n  else:\n    return quote:\n      xrange($start, $end, $step)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Aside from the minor issue of using decorators to identify macro type, my only real issue with this is the way you can name groups, e.g.", "in the if case.", "I'm using @name = ..., but this just reeks of Perl.", "I don't want to just use name = ... because that could conflict with a macro pattern to match.", "Any ideas?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["If you're only asking about the syntax (not implementation) of macros within Python, then I believe the answer is obvious.", "The syntax should closely match what Python already has (i.e., the \"def\" keyword)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "def", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Whether you implement this as one of the following is up to you:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def macro largest(lst):\ndefmac largest(lst):\nmacro largest(lst):\n</code>\n</pre>\n", "senID": 2}, {"text": ["but I believe it should be exactly the same as a normal function with respect to the rest so that:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def twice_second(a,b):\n    glob_i = glob_i + 1\n    return b * 2\nx = twice_second (1,7);\n</code>\n</pre>\n", "senID": 4}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n defmac twice_second(a,b):\n    glob_i = glob_i + 1\n    return b * 2\nx = twice_second (1,7);\n</code>\n</pre>\n", "senID": 6}, {"text": ["are functionally equivalent."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["The way I would implement this is with a pre-processor (a la C) which would:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "ul", "num": 9, "lis": [{"text": "replace all defmac's with defs in the input file.", "tag": "none", "senID": 9}, {"text": "pass it through Python to check syntax (sneaky bit, this).", "tag": "none", "senID": 10}, {"text": "put the defmac's back in.", "tag": "none", "senID": 11}, {"text": "find all uses of each macro and \"inline\" them, using your own reserved variables, such as converting local var ", "tag": "none", "senID": 12}, {"text": "return value should be a special variable as well (macro_second_retval).", "tag": "none", "senID": 13}, {"text": "global variables would keep their real names.", "tag": "none", "senID": 14}, {"text": "parameter can be given _macro_second_param_XXX names.", "tag": "none", "senID": 15}, {"text": "once all inlining is done, remove the defmac 'functions' entirely.", "tag": "none", "senID": 16}, {"text": "pass the resultant file through Python.", "tag": "none", "senID": 17}]}, {"text": ["No doubt there'll be some nigglies to take care of (like tuples or multiple return points) but Python is sufficiently robust to handle that in my opinion."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["So:"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n x = twice_second (1,7);\n</code>\n</pre>\n", "senID": 20}, {"text": ["becomes:"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"code": "<pre>\n<code>\n # These lines are the input params.\n__macro_second_param_a = 1\n__macro_second_param_b = 7\n\n# These lines are the inlined macro.\nglob_i = glob_i + 1\n__macro_second_retval = __macro_second_param_b * 2\n\n# Modified call to macro.\nx = __macro_second_retval\n</code>\n</pre>\n", "senID": 22}], [{"text": ["This is the current mechanism for defining syntax by use of a standard Python class."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Print macro:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class PrintMacro(Macro):\n  syntax = 'print', Var\n  def handle(self, stmts):\n    if not isinstance(stmts, list):\n      stmts = [stmts]\n    return Printnl(stmts, None)\n</code>\n</pre>\n", "senID": 2}, {"text": ["If/elif/else macro class:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class IfMacro(MLMacro):\n  syntax = (\n      ('if', Var, Var),\n      ZeroOrMore('elif', Var, Var),\n      Optional('else', Var)\n    )\n  def handle(self, if_, elifs, elseBody):\n    return If(\n        [(cond, Stmt(body)) for cond, body in [if_] + elifs],\n        elseBody != None and Stmt(elseBody) or None\n      )\n</code>\n</pre>\n", "senID": 4}, {"text": ["X to Y [inclusive] [step Z] macro class:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class ToMacro(PartialMacro):\n  syntax = Var, 'to', Var, Optional('inclusive'), Optional('step', Var)\n  def handle(self, start, end, inclusive, step):\n    if inclusive:\n      end = ['(', end, '+', Number(1), ')']\n    if step == None: step = Number(1)\n    return ['xrange', ['(', start, end, step, ')']]\n</code>\n</pre>\n", "senID": 6}, {"text": ["My issues with this design is that things are very verbose and don't feel pythonic in the least.", "In addition, the lack of quotation ability makes complex macros difficult."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["This is the macro syntax I've come up with for my Python superset."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Print macro:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n macro PrintMacro:\n    syntax:\n    \tstmts = 'print', Var\n\n  if not isinstance(stmts, list):\n    stmts = [stmts]\n  return Printnl(stmts, None)\n</code>\n</pre>\n", "senID": 2}, {"text": ["If macro:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n @MultiLine\nmacro IfMacro:\n  syntax:\n    if_ = 'if', Var, Var\n    elifs = ZeroOrMore('elif', Var, Var)\n    else_ = Optional('else', Var)\n\n  return If(\n      [(cond, Stmt(body)) for cond, body in [if_] + elifs],\n      elseBody != None and Stmt(elseBody) or None\n    )\n</code>\n</pre>\n", "senID": 4}, {"text": ["X to Y [inclusive] [step Z] macro:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n @Partial\nmacro ToMacro:\n  syntax:\n    start = Var\n    'to'\n    end = Var\n    inclusive = Optional('inclusive')\n    step = Optional('step', Var)\n\n  if step == None:\n    step = quote 1\n  if inclusive:\n    return quote:\n      xrange($start, $end+1, $step)\n  else:\n    return quote:\n      xrange($start, $end, $step)\n</code>\n</pre>\n", "senID": 6}, {"text": ["My primary issue with this is that the syntax block is unclear, particularly the 'to' line in the last example.", "I'm also not a big fan of using decorators to differentiate macro types."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]