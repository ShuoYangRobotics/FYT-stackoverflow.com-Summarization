[[{"text": ["To match at least two hashes at either end:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n pattern='##+(.*?)##+'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your problem is with your inner match.", "You use ., which matches any character that isn't a line end, and that means it matches # as well.", "So when it gets ###hey##, it matches (.*?", ") to #hey."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": ".", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "any", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "#", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "###hey##", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(.*?)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "#hey", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["The easy solution is to exclude the # character from the matchable set:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "#", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n prog = re.compile(r'##([^#]*)##')\n</code>\n</pre>\n", "senID": 2}, {"text": ["Protip: Use raw strings (e.g.", "r'') for regular expressions so you don't have to go crazy with backslash escapes."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "r''", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Trying to allow # inside the hashes will make things much more complicated."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "#", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "much", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["EDIT: If you do not want to allow blank inner text (i.e.", "\"####\" shouldn't match with an inner text of \"\"), then change it to:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n prog = re.compile(r'##([^#]+)##')\n</code>\n</pre>\n", "senID": 6}, {"text": ["+ means \"one or more."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["'^#{2,}([^#]*)#{2,}'    -- any number of # >= 2 on either end"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "'^#{2,}([^#]*)#{2,}'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["be careful with using lazy quantifiers like (.*?", ") because it'd match '##abc#####' and capture 'abc###'.", "also lazy quantifiers are very slow"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Try the \"block comment trick\": /##((?:[^#]|#[^#])+?", ")##/\n"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "/##((?:[^#]|#[^#])+?)##/", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}]}], [{"text": ["Adding + to regex, which means to match one or more character."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n pattern='#+(.*?)#+'\nprog=re.compile(pattern)\n\nstring='###HEY##'\nresult=prog.search(string)\nprint result.group(1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n HEY\n</code>\n</pre>\n", "senID": 3}], [{"text": ["have you considered doing it non-regex way?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; string='lala ####hey## there'\n&gt;&gt;&gt; string.split(\"####\")[1].split(\"#\")[0]\n'hey'\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; text= 'lala ###hey## there'\n&gt;&gt;&gt; matcher= re.compile(r\"##[^#]+##\")\n&gt;&gt;&gt; print matcher.sub(\"FOUND\", text)\nlala #FOUND there\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}]]