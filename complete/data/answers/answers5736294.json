[[{"text": ["What you're missing isn't so much about greediness as about regular expression engines:  they work from left to right, so the / matches as early as possible and the .*?", "is then forced to work from there.", "In this case, the best regex doesn't involve greediness at all (you need backtracking for that to work; it will, but could take a really long time to run if there are a lot of slashes), but a more explicit pattern:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".*?", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n '/([^/]*)\\.bar$'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would suggest changing your regex so that it doesn't rely on greedyness."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You want only the filename before the extension .bar and everything after the final /.", "This should do:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": ".bar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "/", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n re.search(`/[^/]*\\.bar$`, '/def_params/param_1M56/param/foo.bar')\n</code>\n</pre>\n", "senID": 2}, {"text": ["What this does is it matches /, then zero or more characters (as much as possible) that are not / and then .bar."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "childList": []}, {"text": "/", "childNum": 0, "tag": "code", "childList": []}, {"text": ".bar", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I don't claim to understand the non-greedy operators all that well, but a solution for that particular problem would be to use ([^/]*?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The regular expressions starts from the right.", "Put a .", "* at the start and it should work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I like regex but there is no need of one here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n path = '/def_params/param_1M56/param/foo.bar'\nprint  path.rsplit('/',1)[1].rsplit('.')[0]\n\npath = '/def_params/param_1M56/param/fululu'\nprint  path.rsplit('/',1)[1].rsplit('.')[0]\n\npath = '/def_params/param_1M56/param/one.before.two.dat'\nprint  path.rsplit('/',1)[1].rsplit('.',1)[0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n foo\nfululu\none.before.two\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Other people have answered the regex question, but in this case there's a more efficient way than regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n file_name = path[path.rindex('/')+1 : path.rindex('.')]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["try this one on for size:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["match = re.search('.*/(.*?", ").bar$', '/def_params/param_1M56/param/foo.bar')"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]