[[{"text": ["Why not Zoidberg a decorator?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Zoidberg", "childNum": 0, "tag": "del", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def argsnotempty(**requiredargs):\n\n    def decorator(func):\n\n        def wrapper(*args, **kwargs):\n            code     = func.func_code\n            argsreq  = code.co_argcount - 1\n            argsrec  = len(args)\n            posargs  = code.co_varnames[1:argsreq + 1]\n            errs     = []\n\n            # validate positional args\n            for i, arg in enumerate(args):\n                if i == len(posargs):\n                    break\n                # falsy but not False: 0, '', None, [], etc.\n                if not (arg or arg is False):\n                    argname = posargs[i]\n                    if argname in requiredargs:\n                        errs.append(argname + \" (\" + requiredargs[argname] + \")\")\n\n            # validate keyword args\n            for argname, arg in kwargs.iteritems():\n                if argname in requiredargs:\n                    if not (arg or arg is False):\n                        errs.append(argname + \" (\" + requiredargs[argname] + \")\")\n\n            # make sure all required args are present\n            for argname in requiredargs:\n                if argname not in kwargs and argname not in posargs:\n                    errs.append(argname + \" (\" + requiredargs[argname] + \")\")\n\n            return func(errs, *args, **kwargs)\n\n        wrapper.__name__, wrapper.__doc__ = func.__name__, func.__doc__\n\n        return wrapper\n\n    return decorator\n</code>\n</pre>\n", "senID": 1}, {"text": ["The decorator checks to make sure the specified arguments are not empty, then calls the wrapped function with the list of \"friendly\" argument names which are blank as the first argument.", "It also tries to check keyword arguments.", "Arguments that aren't specified to the decorator aren't checked."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n @argsnotempty(a=\"alpha\", b=\"beta\", g=\"gamma\")\ndef foo(errs, a, b, g):\n    print errs\n\nfoo(3.14, \"blarney\", None)    # prints \"['g (gamma)']\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["Here's an example of raising an exception if you don't get the values you need:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n @argsnotempty(a=\"alpha\", b=\"beta\", g=\"gamma\")\ndef bar(errs, a, b, g):\n    if errs:\n       raise ValueError(\"arguments \" + \", \".join(errs) + \" cannot be empty\")\n\nbar(0, None, \"\")\n</code>\n</pre>\n", "senID": 6}, {"text": ["Of course, you could tweak the decorator to do this for you, instead of including boilerplate code in each function."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Edit: Fixed some buggage"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I'm pretty sure I don't understand the question or how what you posted as your 'best solution' meets the requirements, but working just from:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's an easy way to do what that line seems to ask for:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def validate_parameters(args):\n    unset = []\n    for k in args:\n        if args[k] is None or args[k]==\"\":\n            unset.append(k)\n    return unset\n</code>\n</pre>\n", "senID": 2}, {"text": ["and then just call validate_parameters from the first line of a function:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "first", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def foo(a, b, c):\n    print \"Unset:\", validate_parameters(locals())\n\n&gt;&gt;&gt; foo(1, None, 3)\nUnset: ['b']\n&gt;&gt;&gt; foo(1, None, \"\")\nUnset: ['c', 'b']\n</code>\n</pre>\n", "senID": 4}, {"text": ["If it wasn't for the Python 2.2 requirement you could do it all in a single line list comprehension.", "The important thing is that you have to call it from the very first line of the function to ensure that locals() only picks up parameters and not any other local variables."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "locals()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["To check that all required parameters are being passed into your function, you could create a dictionary that maps all of the required parameters to None, and then copy and update that dictionary at the start of every method. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n needed_params = {'one': None, 'two': None, 'three': None}\n\ndef my_func(**kwargs):\n    params = needed_params.copy()\n    params.update(kwargs)\n    for key, value in params.iteritems():\n        if not value:\n            raise TypeError(\"You need to provide the argument %s\" % key)\n    result = do_stuff_here\n    return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["As noted in the comments, it's probably not a great idea to return a \"user-friendly\" description.", "Instead, you'll probably want to raise an error if a parameter is missing.", "Then you'll be able to handle this error elsewhere in your UI."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Kindall suggests a decorator.", "Depending on how complicated you want the checking to be, I think you could get by with something a little simpler than his suggestion:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def check_needed_params(target):\n    needed_params = {'one': None, 'two': None, 'three': ''}\n    def wrapper(*args, **kwargs):\n        params = needed_params.copy()\n        params.update(kwargs)\n        for key, value in params.iteritems():\n            if not value:\n                raise TypeError(\"You need to provide the argument '%s'\" % key)\n        return target(**params)\n    return wrapper\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can use this to identify functions that need to have their parameters checked like so:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n @check_needed_params\ndef adder(**kwargs):\n    return kwargs[\"one\"] + kwargs[\"two\"] + kwargs[\"three\"]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Then, when this function is called, it will work seamlessly if you provide all the results, but will raise an error if you don't."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; adder(one=1, two=2, three=3)\n6\n&gt;&gt;&gt; adder(one=1, two=2)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"c:/Users/.../python-6940fCr.py\", line 8, in wrapper\nTypeError: You need to provide the argument three\n</code>\n</pre>\n", "senID": 8}], [{"text": ["From you question it seems you want to validate command line arguments.", "In such a case have you considered using getopt"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "getopt", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/getopt.html"}]}], [{"text": ["This is a common \"lots of variables\" pattern.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def function( variable1, variable2, variable3, ..., variablen ):\n   \"\"\"user-friendly description of the function.\n   :param variable1: meaning, units, range, whatever.\n   :param variable2: meaning, units, range, whatever.\n   ...\n   :param variablen: meaning, units, range, whatever.\n   :returns: range, type, whatever.\n   \"\"\"\n   # do the processing\n</code>\n</pre>\n", "senID": 1}, {"text": ["Do NOT check for missing or invalid parameters.", "Python already does all the type checking ever needed.", "Just write your code.", "Do nothing special or extra to \"validate\" the inputs.", "When exceptions arise, that means the inputs were bad."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It's just that simple."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Don't make it more complex by rewriting all of Python's type checking in extraneous if-statements."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Also.  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["NEVER mix \"error returns\" with valid returns.", "Any kind of bad input must lead to an exception.", "Good inputs return good values.", "Bad inputs raise exceptions."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "must", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["It's just that simple.", "Don't make it more complex."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["When calling this function, you can do this:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n the_variables = { \n    'variable1': some value,\n    'variable2': some value,\n    ...\n    'variablen': some value,\n}\ntry:\n    function( **the_variables )\nexcept Exception:\n    print( function.__doc__ )\n</code>\n</pre>\n", "senID": 9}, {"text": ["Anything missing?", "You get a TypeError.", "Anything incorrectly None or empty?", "You get a ValueError (or a TypeError, it depends)."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "TypeError", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["When something goes wrong, you print the user-friendly description of the function."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["This works pretty well and doesn't require very much programming at all."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["Your function sounds quite large.", "Have you considered if it's appropriate to break it up or possibly turning it into a separate class?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This is the best answer I could come up with.", "It requires doing a lot of prep work before calling the function, so I don't like it.", "However, it meets all the requirements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Thanks to everyone who participated, and I apologize that the question needed so many amendments!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def validate_parameters(params_map):\n    \"\"\"\n    map is like {foo: \"this is foo\"}\n    \"\"\"\n    missing_params_info = []\n    for k,v in params_map.items():\n        if not v:\n            missing_params_info.append(k)\n    return missing_params_info\n# or do this if you want to use exceptions:\n#    if missing_params_info:\n#        raise TypeError('These parameters were unset: %s' % missing_params_info)\n\nparams = {}\nparams['foo'] = '1'\nparams['bar'] = '2'\nparams['empty'] = ''\nparams['empty2'] = ''\nparams['None'] = None\n\nreverse_params_map = {\n    'this is foo' : params['foo'],\n    'this is bar' : params['bar'],\n    'this is empty' : params['empty'],\n    'this is empty2' : params['empty2'],\n    'this is None' : params['None'],\n}\n\nprint validate_parameters(reverse_params_map)\n\nbash-3.00# python /var/tmp/ck.py\n['this is empty2', 'this is empty', 'this is None']\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The question remains very confusing.", "Very.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It could be that you're asking about introspection into the function's code object:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def noisy_typerror( func ):\n    def fix_exception( **kw ):\n        try:\n            # This is generally needless; mostly a waste of CPU cycles.\n            if not all(kw[arg] for arg in kw  ):\n                raise TypeError\n            # Simply apply the function and see if a TypeError occurs \n            return func( **kw )\n        except TypeError:\n            required= \", \".join( func.func_code.co_varnames[:func.func_code.co_argcount] )\n            provided= \", \".join( \"{0}={1!r}\".format(k,v) for k,v in kw.items() )\n            raise TypeError( \"{2}( {0} ) got {1}\".format(required, provided,func.func_name) )\n    return fix_exception\n\n@noisy_typerror\ndef some_func( this, that, the_other ):\n    a= this\n    b= that\n    print( this, that, the_other )\n</code>\n</pre>\n", "senID": 2}, {"text": ["To apply decorators in older version of Python"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def the_real_func( this, that, the_other ):\n   etc.\n\nsome_func= noisy_typerror( the_real_func )\n</code>\n</pre>\n", "senID": 4}, {"text": ["Here are some use cases for this decorator"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n try:\n    some_func( this=2, that=3 )\nexcept TypeError, e:\n    print e \ntry:\n    some_func( this=4 )\nexcept TypeError, e:\n    print e \ntry:\n    some_func( this=2, that=3, the_other='' )\nexcept TypeError, e:\n    print e\n</code>\n</pre>\n", "senID": 6}, {"text": ["I get these kinds of results from printing the TypeError strings."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n some_func( this, that, the_other ) got this=2, that=3\nsome_func( this, that, the_other ) got this=4\nsome_func( this, that, the_other ) got this=2, the_other='', that=3\n</code>\n</pre>\n", "senID": 8}]]