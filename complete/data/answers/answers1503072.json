[[{"text": ["Here is my tweak of your code"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Use list() to copy perm1 - this means you can pass tuples, etc into the function, making it more generic", "tag": "none", "senID": 1}, {"text": "Use enumerate() in the for loop instead of len(..) and array lookups for neater code", "tag": "none", "senID": 2}, {"text": "Make a perm1_map and keep it up to date to stop an expensive O(N) search on perm1, and an expensive list slice", "tag": "none", "senID": 3}, {"text": "return the boolean directly rather than the if ... return True else return False", "tag": "none", "senID": 4}]}, {"text": ["Here is it"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def arePermsEqualParity(perm0, perm1):\n    \"\"\"Check if 2 permutations are of equal parity.\n\n    Assume that both permutation lists are of equal length\n    and have the same elements. No need to check for these\n    conditions.\n    \"\"\"\n    perm1 = list(perm1) ## copy this into a list so we don't mutate the original\n    perm1_map = dict((v, i) for i,v in enumerate(perm1))\n    transCount = 0\n    for loc, p0 in enumerate(perm0):\n        p1 = perm1[loc]\n        if p0 != p1:\n            sloc = perm1_map[p0]                       # Find position in perm1\n            perm1[loc], perm1[sloc] = p0, p1           # Swap in perm1\n            perm1_map[p0], perm1_map[p1] = sloc, loc   # Swap the map\n            transCount += 1\n    # Even number of transpositions means equal parity\n    return (transCount % 2) == 0\n</code>\n</pre>\n", "senID": 6}], [{"text": ["If we combine both permutations, the result will have even parity when each permutation has the same parity, and odd parity if they have different parity.", "So if we solve the parity problem it's trivial to compare two different permutations."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "parity problem", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Parity can be determined as follows: pick an arbitrary element, find the position that the permutation moves this to, repeat until you get back to the one you started with.", "You have now found a cycle: the permutation rotates all these elements round by one position.", "You need one swap less than the number of elements in the cycle to undo it.", "Now pick another element you haven't dealt with yet and repeat until you've seen every element.", "Observe that in total you needed one swap per element minus one swap per cycle."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Parity", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Time complexity is O(N) in the size of the permutation.", "Note that although we have a loop within a loop, the inner loop can only ever iterate once for any element in the permutation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def parity(permutation):\n    permutation = list(permutation)\n    length = len(permutation)\n    elements_seen = [False] * length\n    cycles = 0\n    for index, already_seen in enumerate(elements_seen):\n        if already_seen:\n            continue\n        cycles += 1\n        current = index\n        while not elements_seen[current]:\n            elements_seen[current] = True\n            current = permutation[current]\n    return (length-cycles) % 2 == 0\n\ndef arePermsEqualParity(perm0, perm1):\n    perm0 = list(perm0)\n    return parity([perm0[i] for i in perm1])\n</code>\n</pre>\n", "senID": 3}, {"text": ["Also, just for fun, here's a much less efficient but much shorter implementation of the parity function based on the definition in Wikipedia (returning True for even and False for odd):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def parity(p):\n    return sum(\n        1 for (x,px) in enumerate(p)\n          for (y,py) in enumerate(p)\n          if x&lt;y and px&gt;py\n        )%2==0\n</code>\n</pre>\n", "senID": 5}], [{"text": ["My naive solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def arePermsEqualParity(perm0, perm1):\n    \"\"\"Check if 2 permutations are of equal parity.\n\n    Assume that both permutation lists are of equal length\n    and have the same elements. No need to check for these\n    conditions.\n    \"\"\"\n\n    transCount = 0\n    for loc in range(len(perm0) - 1):                         # Do (len - 1) transpositions\n        if perm0[loc] != perm1[loc]:\n            sloc = perm1.index(perm0[loc])                    # Find position in perm1\n            perm1[loc], perm1[sloc] = perm1[sloc], perm1[loc] # Swap in perm1\n            transCount += 1\n\n    # Even number of transpositions means equal parity\n    if (transCount % 2) == 0:\n        return True\n    else:\n        return False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A minor variant of the previous answer - copy perm1, and save array lookups."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def arePermsEqualParity(perm0, perm1):\n    \"\"\"Check if 2 permutations are of equal parity.\n\n    Assume that both permutation lists are of equal length\n    and have the same elements. No need to check for these\n    conditions.\n    \"\"\"\n    perm1 = perm1[:] ## copy this list so we don't mutate the original\n\n    transCount = 0\n    for loc in range(len(perm0) - 1):                         # Do (len - 1) transpositions\n        p0 = perm0[loc]\n        p1 = perm1[loc]\n        if p0 != p1:\n            sloc = perm1[loc:].index(p0)+loc          # Find position in perm1\n            perm1[loc], perm1[sloc] = p0, p1          # Swap in perm1\n            transCount += 1\n\n    # Even number of transpositions means equal parity\n    if (transCount % 2) == 0:\n        return True\n    else:\n        return False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's slightly refactored Weeble's answer:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Weeble's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1503072/how-to-check-if-permutations-have-equal-parity/1504565#1504565"}]}, {"code": "<pre>\n<code>\n def arePermsEqualParity(perm0, perm1):\n    \"\"\"Whether permutations are of equal parity.\"\"\"\n    return parity(combine(perm0, perm1))\n\ndef combine(perm0, perm1):\n    \"\"\"Combine two permutations into one.\"\"\"\n    return map(perm0.__getitem__, perm1)\n\ndef parity(permutation):\n    \"\"\"Return even parity for the `permutation`.\"\"\"\n    return (len(permutation) - ncycles(permutation)) % 2 == 0\n\ndef ncycles(permutation):\n    \"\"\"Return number of cycles in the `permutation`.\"\"\"\n    ncycles = 0\n    seen = [False] * len(permutation)\n    for i, already_seen in enumerate(seen):\n        if not already_seen:\n            ncycles += 1\n            # mark indices that belongs to the cycle\n            j = i \n            while not seen[j]: \n                seen[j] = True\n                j = permutation[j]\n    return ncycles\n</code>\n</pre>\n", "senID": 1}], [{"text": ["My intuition tells me that, just counting the differences between the two permutations will give you one more than the number of swaps need to get from one to the other.", "This in turn will give you the parity."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This means that you don't need to do the swaps in your code at all."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ABCD, BDCA.\n</code>\n</pre>\n", "senID": 3}, {"text": ["There are three differences, hence two swaps are needed to permute one into the other, hence you have even parity."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Another:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n ABCD, CDBA.\n</code>\n</pre>\n", "senID": 6}, {"text": ["There are four differences, hence three swaps, hence odd parity. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["The solution with the dictionary is bugged.", "This is the debug version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def arePermsEqualParity(perm0, perm1):\n    \"\"\"Check if 2 permutations are of equal parity.\n\n    Assume that both permutation lists are of equal length\n    and have the same elements. No need to check for these\n    conditions.\n    \"\"\"\n    perm1 = list(perm1) ## copy this into a list so we don't mutate the original\n    perm1_map = dict((v, i) for i,v in enumerate(perm1))\n    transCount = 0\n    for loc, p0 in enumerate(perm0):\n        p1 = perm1[loc]\n        if p0 != p1:\n            sloc = perm1_map[p0]                       # Find position in perm1\n            perm1[loc], perm1[sloc] = p0, p1           # Swap in perm1\n            perm1_map[p0], perm1_map[p1] = loc, sloc   # Swap the map\n            transCount += 1\n    # Even number of transpositions means equal parity\n    return (transCount % 2) == 0\n</code>\n</pre>\n", "senID": 1}, {"text": ["The only differences is that the swap in the dictionary was not made correctly."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n def equalparity(p,q):\n    return sum([p[q[i]] &gt; p[q[j]] for i in range(len(p)) for j in range(i)]) % 2 == 0\n</code>\n</pre>\n", "senID": 0}]]