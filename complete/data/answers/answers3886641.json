[[{"code": "<pre>\n<code>\n message = { 'create':msg(some_data or ''),\n            'update':msg(other_data or '')\n            # can have more\n          }\n</code>\n</pre>\n", "senID": 0}, {"text": ["Better yet, to prevent msg from being executed just to fill the dict:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "msg", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n message = { 'create':(msg,some_data),\n            'update':(msg,other_data),\n            # can have more\n          }\nfunc,data=message[msg_type]\nfunc(data)\n</code>\n</pre>\n", "senID": 2}, {"text": ["and now you are free to define a more sensible msg function which can deal with an argument equal to None:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "msg", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def msg(data):\n    if data is None: data=''\n    ...\n</code>\n</pre>\n", "senID": 4}], [{"text": ["It sounds like you're complicating this more than you need to.", "You want simple?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if mytype == 'create':\n    return msg(some_data)\nelif mytype == 'update':\n    return msg(other_data)\nelse:\n    return msg(default_data)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You don't have to use dicts and function references just because you can.", "Sometimes a boring, explicit if/else block is exactly what you need.", "It's clear to even the newest programmers on your team and won't call msg() unnecessarily, ever.", "I'm also willing to bet that this will be faster than the other solution you were working on unless the number of cases grows large and msg() is lightning fast."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "have", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "can", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "if/else", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Turns out the jokes on me and I was pwned in the switch inventing game 5 years before I even learned python: Readable switch construction without lambdas or dictionaries.", "Oh well.", "Read below for another way to do it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Readable switch construction without lambdas or dictionaries", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/410692-readable-switch-construction-without-lambdas-or-di/"}]}, {"text": ["Here.", "Have a switch statement.", "(with some nice cleanups by @martineau)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n with switch(foo):\n\n    @case(1)\n    def _():\n        print \"1\"\n\n    @case(2)\n    def _():\n        print \"2\"\n\n    @case(3)\n    def _():\n        print \"3\"\n\n    @case(5)\n    @case(6)\n    def _():\n        print '5 and 6'\n\n    @case.default\n    def _():\n        print 'default'\n</code>\n</pre>\n", "senID": 2}, {"text": ["I'll toss in the (moderately) hacked stack, abused decorators and questionable context manager for free.", "It's ugly but functional (and not in the good way).", "Essentially, all it does is wrap the dictionary logic up in an ugly wrapper. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import inspect\n\nclass switch(object):\n    def __init__(self, var):\n        self.cases = {}\n        self.var = var\n\n\n    def __enter__(self):\n        def case(value):\n            def decorator(f):\n                if value not in self.cases:\n                    self.cases[value] = f\n                return f\n            return decorator\n\n        def default(f):\n            self.default = f\n            return f\n        case.default = default \n\n        f_locals = inspect.currentframe().f_back.f_locals\n        self.f_locals = f_locals.copy()\n        f_locals['case'] = case\n\n    def __exit__(self, *args, **kwargs):\n        new_locals = inspect.currentframe().f_back.f_locals\n        new_items = [key for key in new_locals if key not in self.f_locals]\n        for key in new_items:\n             del new_locals[key]              # clean up\n        new_locals.update(self.f_locals)      # this reverts all variables to their\n        try:                                  # previous values\n            self.cases[self.var]()\n        except KeyError:\n            try:\n                getattr(self, 'default')()\n            except AttributeError:\n                pass\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note that the hacked stack isn't actually necessary.", "We just use it to create a scope so that definitions that occur in the switch statement don't leak out into the enclosing scope and to get case into the namespace.", "If you don't mind leaks, (loops leak for instance), then you can remove the stack hack and return the case decorator from __enter__, using the as clause on the with statement to receive it in the enclosing scope."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "case", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "case", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__enter__", "childNum": 0, "tag": "code", "childList": []}, {"text": "as", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You could hide the evaluation inside a lambda:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n message = { 'create': lambda: msg(some_data),\n            'update': lambda: msg(other_data),\n          }\nreturn message[type]()\n</code>\n</pre>\n", "senID": 1}, {"text": ["As long as the names are all defined (so you don\u2019t get a NameError), you could also structure it like this:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "NameError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n message = { 'create': (msg, some_data),\n            'update': (other_func, other_data),\n          }\nfunc, arg = message[type]\nreturn func(arg)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's something a little different (although somewhat similar to @Tumbleweed's) and arguably more \"object-oriented\".", "Instead of explicitly using a dictionary to handle the various cases, you could use a Python class (which contains a dictionary). "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This approach  provides a fairly natural looking translation of C/C++ switch statements into Python code.", "Like the latter it defers execution of the code that handles each case and allows a default one to be provided."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "switch", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The code for each switch class method that corresponds to a case can consist of more than one line of code instead of the single return &lt;expression&gt; ones shown here and are all compiled only once.", "One difference or limitation though, is that the handling in one method won't and can't be made to automatically \"fall-though\" into the code of the following one (which isn't an issue in the example, but would be nice)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "switch", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return &lt;expression&gt;", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class switch:\n    def create(self): return \"blabla %s\" % msg(some_data)\n    def update(self): return \"blabla %s\" % msg(other_data)\n    def delete(self): return \"blabla %s\" % diff(other_data, some_data)\n    def _default(self): return \"unknown type_\"\n    def __call__(self, type_): return getattr(self, type_, self._default)()\n\nswitch = switch() # only needed once\n\nreturn switch(type_)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can delay execution of the match using lambda:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n return {\n    'create': lambda: msg(some_data),\n    'update': lambda: msg(other_data),\n    # ...\n}[type]()\n</code>\n</pre>\n", "senID": 1}, {"text": ["If all the cases are just calling msg with different arguments, you can simplify this to:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "msg", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n return msg({\n    'create': some_data,\n    'update': other_data,\n    # ...\n}[type])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["what about creating new class and wrap the data/arguments in object  - so instead of binding data by passing arguments - you could just let function decide which parameters it needs..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyObj(object):\n        def __init__(self, data, other_data):\n                self.data = data\n                self.other_data = other_data\n\n        def switch(self, method_type):\n                return {\n                                \"create\": self.msg,\n                                \"update\": self.msg,\n                                \"delete\": self.delete_func,\n                        }[method_type]()\n\n        def msg(self):\n                #process self.data\n                return \"Hello, World  !!\"\n\n        def delete_func(self):\n                #process other data self.other_data or anything else....\n                return True\n\nif \"__main__\" == __name__:\n        m1 = MyObj(1,2)\n        print m1.switch('create')\n        print m1.switch('delete')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Ah never mind, this explained it.", "I was thinking of elif\nhttp://bytebaker.com/2008/11/03/switch-case-statement-in-python/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://bytebaker.com/2008/11/03/switch-case-statement-in-python/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://bytebaker.com/2008/11/03/switch-case-statement-in-python/"}]}], [{"text": ["Since the code you want to execute in each case is from a safe source, you could store each snippet in a separate string expression in a dictionary and do something along these lines:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n message = { 'create': '\"blabla %s\" % msg(some_data)',\n            'update': '\"blabla %s\" % msg(other_data)',\n            'delete': '\"blabla %s\" % diff(other_data, some_data)'\n          }\n\nreturn eval(message[type_])\n</code>\n</pre>\n", "senID": 1}, {"text": ["The expression on the last line could also be eval(message.get(type_, '\"unknown type_\"')) to provide a default.", "Either way, to keep things readable the ugly details could be hidden:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "eval(message.get(type_, '\"unknown type_\"'))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n switch = lambda type_: eval(message.get(type_, '\"unknown type_\"'))\n\nreturn switch(type_)\n</code>\n</pre>\n", "senID": 3}, {"text": ["The code snippets can even be precompiled for a little more speed:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from compiler import compile # deprecated since version 2.6: Removed in Python 3\n\nfor k in message:\n    message[k] = compile(message[k], 'message case', 'eval')\n</code>\n</pre>\n", "senID": 5}]]