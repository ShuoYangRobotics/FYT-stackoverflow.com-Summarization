[[{"text": ["I would sort the array by number of duplicates, starting from the most duplicated element, spread those elements as far apart as possible"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["in your example, duck is duplicated 4 times, so duck will be put in position n*8/4 for n from 0 to 3 inclusive."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then put the next most repeated one (goose) in positions n*8/3 + 1 for n from 0 to 2 inclusive, If something is already placed there, just put it in the next empty spot.", "etc etc"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I think something like this is the general idea:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n L = \"duck duck duck duck goose goose goose dog \".split() \n\nfrom itertools import cycle, islice, groupby\n\n# from: http://docs.python.org/library/itertools.html#recipes\ndef roundrobin(*iterables):\n    \"roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C\"\n    # Recipe credited to George Sakkis\n    pending = len(iterables)\n    nexts = cycle(iter(it).next for it in iterables)\n    while pending:\n        try:\n            for next in nexts:\n                yield next()\n        except StopIteration:\n            pending -= 1\n            nexts = cycle(islice(nexts, pending))\n\ngroups = [list(it) for k,it in groupby(sorted(L))]\n\n# some extra print so you get the idea\nprint L\nprint groups\nprint list(roundrobin(*groups))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['dog', 'duck', 'duck', 'duck', 'duck', 'goose', 'goose', 'goose']\n[['dog'], ['duck', 'duck', 'duck', 'duck'], ['goose', 'goose', 'goose']]\n['dog', 'duck', 'goose', 'duck', 'goose', 'duck', 'goose', 'duck']\n</code>\n</pre>\n", "senID": 3}, {"text": ["So you want some kind of round robin :-)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Well, round-robin is not perfect. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Here is the brute force (aka horribly inefficient) version of what you where thinking about. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n # this is the function we want to maximize\ndef space_sum( L ):\n    \"\"\" return the sum of all spaces between all elements in L\"\"\"\n    unique = set(L)\n    def space(val):\n        \"\"\" count how many elements are between two val \"\"\"\n        c = 0\n        # start with the first occurrence of val, then count\n        for x in L[1+L.index(val):]: \n            if x==val:\n                yield c\n                c = 0\n            else:\n                c += 1\n    return sum(sum(space(val)) for val in unique)\n\nprint max((space_sum(v), v) for v in permutations(L))\n\n# there are tons of equally good solutions\nprint sorted(permutations(L), key=space_sum, reverse=True)[:100]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["How to measure sparsity actually?", "By the way a simple random shuffle may work."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "random shuffle", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.sgi.com/tech/stl/random_shuffle.html"}]}], [{"text": ["Sort you types by count."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There are good answers above about sorting and separating the most common strings the farthest.", "But if you have so much data that you can't sort or don't want to take the time, look into quasirandom numbers (http://mathworld.wolfram.com/QuasirandomSequence.html).", "There's a simple implementation of this in the Numerical Recipes book.", "These are numbers that \"look\" random, i.e., fill a space but try to avoid each other as much as possible.", "It's used a lot in applications where you want to \"randomly\" sample something, but rather than true random you want to sample the whole space efficiently."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If I understood correctly your definition of \u201csparse\u201d, this function should be exactly what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # python \u2265 2.5\nimport itertools, heapq\n\ndef make_sparse(sequence):\n    grouped= sorted(sequence)\n    item_counts= []\n    for item, item_seq in itertools.groupby(grouped):\n        count= max(enumerate(item_seq))[0] + 1\n        item_counts.append( (-count, item) ) # negative count for heapq purposes\n    heapq.heapify(item_counts)\n\n    count1, item1= heapq.heappop(item_counts)\n    yield item1; count1+= 1\n    while True:\n        try:\n            count2, item2= heapq.heappop(item_counts)\n        except IndexError: # no other item remains\n            break\n        yield item2; count2+= 1\n        if count1 &lt; 0:\n            heapq.heappush(item_counts, (count1, item1))\n        item1, count1= item2, count2\n\n    # loop is done, produce remaining item1 items\n    while count1 &lt; 0:\n        yield item1; count1+= 1\n\nif __name__ == \"__main__\":\n    # initial example\n    print list(make_sparse(\n        \"duck duck duck duck goose goose goose dog\".split()))\n    # updated example\n    print list(make_sparse([\n        'duck', 'duck', 'duck', 'duck', 'duck', 'duck',\n        'goose', 'goose', 'goose', 'goose', 'dog', 'dog']))\n    # now a hard case: item 'a' appears more than:\n    # &gt; total_len//2 times if total_len is even\n    # &gt; total_len//2+1 times if total_len is odd\n    print list(make_sparse(\"aaaaaabbcc\"))\n</code>\n</pre>\n", "senID": 1}, {"text": ["These examples produce this output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['duck', 'goose', 'duck', 'goose', 'duck', 'dog', 'duck', 'goose']\n['duck', 'goose', 'duck', 'goose', 'duck', 'dog', 'duck', 'goose', 'duck', 'dog', 'duck', 'goose']\n['a', 'b', 'a', 'c', 'a', 'b', 'a', 'c', 'a', 'a']\n</code>\n</pre>\n", "senID": 3}, {"text": ["A subtle note: in the first and second examples, reversing the output order might look more optimal."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "reversing", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "look", "childNum": 0, "tag": "em", "childList": []}]}]]