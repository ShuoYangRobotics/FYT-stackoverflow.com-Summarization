[[{"text": ["You can do this without touching Perl.", "You were on the right track, but with a regex you can search by name, not position."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, you should put quotes around $line so you don't get burned by any pipes or semicolons hanging around."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n pro=`echo \"$line\" | grep -o 'PROTO=\\w+\\+' | cut -d '=' -f 2`;\n</code>\n</pre>\n", "senID": 2}, {"text": ["Of course, if you did want to use Perl, you could make a much slicker solution:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "did", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\nwhile(&lt;&gt;) {\n    /IN=(\\S*) .*OUT=(\\S*) .*SRC=(\\S*) .*DST=(\\S*) .*PROTO=(\\S*)/\n       and print \"$1,$2,$3,$4,$5\\n\";\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then call:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n ./thatScript.pl logFile.txt &gt;&gt;output.csv\n</code>\n</pre>\n", "senID": 6}], [{"text": ["you don't even need to cut:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n grep -Po \"(?&lt;=PROTO=)\\w+\" yourFile\n</code>\n</pre>\n", "senID": 1}, {"text": ["OR"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n sed -r 's/.*PROTO=(\\w+).*/\\1/' yourFile\n</code>\n</pre>\n", "senID": 3}, {"text": ["OR"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n awk -F'PROTO=' '{split($2,a,\" \");print a[1]}' yourfile\n</code>\n</pre>\n", "senID": 5}, {"text": ["test:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n kent$  echo \"Oct  6 17:29:52 FW kernel: [ 5470.058450] ipTables: IN= OUT=eth0 SRC=192.168.1.116 DST=192.168.1.110 LEN=516 TOS=0x10 PREC=0x00 TTL=64 ID=4949 DF PROTO=TCP SPT=22 DPT=46216 WINDOW=446 RES=0x00 ACK PSH URGP=0\"|grep -Po \"(?&lt;=PROTO=)\\w+\"\nTCP\n\nkent$  echo \"Oct  6 17:29:52 FW kernel: [ 5470.058450] ipTables: IN= OUT=eth0 SRC=192.168.1.116 DST=192.168.1.110 LEN=516 TOS=0x10 PREC=0x00 TTL=64 ID=4949 DF PROTO=TCP SPT=22 DPT=46216 WINDOW=446 RES=0x00 ACK PSH URGP=0\"|sed -r 's/.*PROTO=(\\w+).*/\\1/'\nTCP\n\nkent$  echo \"Oct  6 17:29:52 FW kernel: [ 5470.058450] ipTables: IN= OUT=eth0 SRC=192.168.1.116 DST=192.168.1.110 LEN=516 TOS=0x10 PREC=0x00 TTL=64 ID=4949 DF PROTO=TCP SPT=22 DPT=46216 WINDOW=446 RES=0x00 ACK PSH URGP=0\"|awk -F'PROTO=' '{split($2,a,\" \");print a[1]}'\nTCP\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Python does this conveniently.", "A general solution that gets all the KEY=value pairs is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nimport fileinput\n\npair_re = re.compile('([^ ]+)=([^ ]+)')  # Matches KEY=value pair\n\nfor line in fileinput.input():  # The script accepts both data from stdin or a filename \n\n    line = line.rstrip()  # Removes final spaces and newlines\n    data = dict(pair_re.findall(line))  # Fetches all the KEY=value pairs and puts them in a dictionary\n\n    # Example of usage:\n    print \"PROTO =\", data['PROTO'], \"SRC =\", data['SRC']  # Easy access to any value\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is arguably more legible, flexible and convenient than a shell script."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A straightforward Perl solution might be the most readable one:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env perl\n\nuse strict; use warnings;\n\nmy $s = q{Oct  6 17:29:52 FW kernel: [ 5470.058450] ipTables: IN= OUT=eth0\nSRC=192.168.1.116 DST=192.168.1.110 LEN=516 TOS=0x10 PREC=0x00 TTL=64\nID=4949 DF PROTO=TCP SPT=22 DPT=46216 WINDOW=446 RES=0x00 ACK PSH URGP=0};\n\nwhile ($s =~ /(?&lt;k&gt; [A-Z]+) = (?&lt;v&gt; \\S*)/xg)  {\n    print \"'$+{k}' = '$+{v}'\\n\";\n}\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\nC:\\Temp> z\n'IN' = ''\n'OUT' = 'eth0'\n'SRC' = '192.168.1.116'\n'DST' = '192.168.1.110'\n'LEN' = '516'\n'TOS' = '0x10'\n'PREC' = '0x00'\n'TTL' = '64'\n'ID' = '4949'\n'PROTO' = 'TCP'\n'SPT' = '22'\n'DPT' = '46216'\n'WINDOW' = '446'\n'RES' = '0x00'\n'URGP' = '0'\n</pre>\n", "senID": 2}, {"text": ["You can also assign the information in the log line to a hash:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n my %entry = ($s =~ /(?&lt;k&gt; [A-Z]+) = (?&lt;v&gt; \\S*)/xg);\n</code>\n</pre>\n", "senID": 4}], [{"text": ["In perl this should do it"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #consider the $a variable has the log file my\n$a = &lt;&lt;log file&gt;&gt;;\nmy $desired_answer;\n#regex \nif ($a =~ m/PROTO=(.*?) /ig) \n{  $desired_answer=$1; }\n</code>\n</pre>\n", "senID": 1}], [{"text": ["thanks for all the responses!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["i chose the way of shellscripting using egrep and regex..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n in_if=`echo \"$line\" | egrep -Eo 'IN=eth[0-9]*\\b' | cut -d '=' -f 2`;\nout_if=`echo \"$line\" | egrep -Eo 'OUT=eth[0-9]*\\b' | cut -d '=' -f 2`;\nsrc_ip=`echo \"$line\" | egrep -Eo 'SRC=[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}' | cut -d '=' -f 2`;\ndst_ip=`echo \"$line\" | egrep -Eo 'DST=[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}' | cut -d '=' -f 2`;\npro=`echo \"$line\" | grep -o 'PROTO=[A-Z]*\\b' | cut -d '=' -f 2`;\n</code>\n</pre>\n", "senID": 2}]]