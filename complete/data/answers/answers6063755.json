[[{"text": ["You are not crazy and you should be able to do this.", "It is a current shortcoming of the Python math library, sadly, both in Python 2.X and Python3000.", "There should be a math.nextafter(x,y) in Python but there isn't.", "It would be trivial to add since most C compilers have the functions. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "math.nextafter(x,y)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The nextafter(x,y) functions return the next discretely different representable floating-point value following x in the direction of y.", "The nextafter() functions are guaranteed to work on the platform or to return a sensible value to indicate that the next value is not possible. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "nextafter(x,y)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.kernel.org/doc/man-pages/online/pages/man3/nextafter.3.html"}]}, {"text": ["The nextafter() functions are part of POSIX and ISO C99 standards and is _nextafter() in Visual C. C99 compliant standard math libraries, Visual C, C++, Boost and Java all implement the IEEE recommended nextafter() functions or methods.", "(I do not honestly know if .NET has nextafter().", "Microsoft does not care much about C99 or POSIX."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "nextafter()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "POSIX", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://pubs.opengroup.org/onlinepubs/9699919799/functions/nextafter.html#"}, {"href": "http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf", "text": "C99", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://www.johndcook.com/math_h.html", "text": "_nextafter() in Visual C", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Since Python seems to be heading in the direction of supporting most C99 math functions and behaviors for the math module, the exclusion of nextafter() is curious.", "Luckily there are easy workarounds. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "nextafter()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["None of the bit twiddling functions here fully or correctly deal with the edge cases, such as values going though 0.0, negative 0.0, subnormals, infinities, negative values, over or underflows, etc.", "Here is a reference implementation of nextafter() in C to give an idea of how to do the correct bit twiddling if that is your direction. "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "None", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Here is a reference implementation of nextafter() in C", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.google.com/codesearch/p?hl=en#xQlobzjVCWM/s_nextafter.c&q=nextafter%20lang%3ac&sa=N&cd=1&ct=rc"}]}, {"text": ["There are two solid work arounds to get nextafter() or other excluded POSIX math functions in Python:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "nextafter()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Use Numpy:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Use Numpy:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy\n&gt;&gt;&gt; numpy.nextafter(0,1)\n4.9406564584124654e-324\n&gt;&gt;&gt; numpy.nextafter(.1, 1)\n0.10000000000000002\n&gt;&gt;&gt; numpy.nextafter(1e6, -1)\n999999.99999999988\n&gt;&gt;&gt; numpy.nextafter(-.1, 1)\n-0.099999999999999992\n</code>\n</pre>\n", "senID": 7}, {"text": ["Link directly to the system math DLL:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Link directly to the system math DLL:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import ctypes\nimport sys\nfrom sys import platform as _platform\n\nif _platform == \"linux\" or _platform == \"linux2\":\n    _libm = ctypes.cdll.LoadLibrary('libm.so.6')\n    _funcname = 'nextafter'\nelif _platform == \"darwin\":\n    _libm = ctypes.cdll.LoadLibrary('libSystem.dylib')\n    _funcname = 'nextafter'\nelif _platform == \"win32\":\n    _libm = ctypes.cdll.LoadLibrary('msvcrt.dll')\n    _funcname = '_nextafter'\nelse:\n    # these are the ones I have access to...\n    # fill in library and function name for your system math dll\n    print \"Platform\", repr(_platform), \"is not supported\"\n    sys.exit(0)\n\n_nextafter = getattr(_libm, _funcname)\n_nextafter.restype = ctypes.c_double\n_nextafter.argtypes = [ctypes.c_double, ctypes.c_double]\n\ndef nextafter(x, y):\n    \"Returns the next floating-point number after x in the direction of y.\"\n    return _nextafter(x, y)\n\nassert nextafter(0, 1) - nextafter(0, 1) == 0\nassert 0.0 + nextafter(0, 1) &gt; 0.0\n</code>\n</pre>\n", "senID": 9}, {"text": ["And if you really really want a pure Python solution:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "And if you really really want a pure Python solution:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # handles edge cases correctly on MY computer \n# not extensively QA'd...\nimport math\n# 'double' means IEEE 754 double precision -- c 'double'\nepsilon  = math.ldexp(1.0, -53) # smallest double that 0.5+epsilon != 0.5\nmaxDouble = float(2**1024 - 2**971)  # From the IEEE 754 standard\nminDouble  = math.ldexp(1.0, -1022) # min positive normalized double\nsmallEpsilon  = math.ldexp(1.0, -1074) # smallest increment for doubles &lt; minFloat\ninfinity = math.ldexp(1.0, 1023) * 2\n\ndef nextafter(x,y):    \n    \"\"\"returns the next IEEE double after x in the direction of y if possible\"\"\"\n    if y==x:\n       return y         #if x==y, no increment\n\n    # handle NaN\n    if x!=x or y!=y:\n        return x + y       \n\n    if x &gt;= infinity:\n        return infinity\n\n    if x &lt;= -infinity:\n        return -infinity\n\n    if -minDouble &lt; x &lt; minDouble:\n        if y &gt; x:\n            return x + smallEpsilon\n        else:\n            return x - smallEpsilon  \n\n    m, e = math.frexp(x)        \n    if y &gt; x:\n        m += epsilon\n    else:\n        m -= epsilon\n\n    return math.ldexp(m,e)\n</code>\n</pre>\n", "senID": 11}, {"text": ["Obviously the Numpy solution is the easiest. "], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "Numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}], [{"code": "<pre>\n<code>\n import sys\n&gt;&gt;&gt; sys.float_info.epsilon\n2.220446049250313e-16\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Insead of incrementing the value, just use a tuple for the colliding key.", "If you need to keep them in order, every key should be a tuple, not just the duplicates."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["First, this \"respond to a collision\" is a pretty bad idea."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If they collide, the values in the dictionary should have been lists of items with a common key, not individual items."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Your \"hash probing\" algorithm will have to loop through more than one \"tiny increments\" to resolve collisions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["And sequential hash probes are known to be inefficient."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Read this: http://en.wikipedia.org/wiki/Quadratic_probing"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://en.wikipedia.org/wiki/Quadratic_probing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Quadratic_probing"}]}, {"text": ["Second, use math.frexp and sys.float_info.epsilon to fiddle with mantissa and exponent separately."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "math.frexp", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sys.float_info.epsilon", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; m, e = math.frexp(4.0)\n&gt;&gt;&gt; (m+sys.float_info.epsilon)*2**e\n4.0000000000000018\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I recommend against assuming that floats (or timestamps) will be unique if at all possible.", "Use a counting iterator, database sequence or other service to issue unique identifiers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Instead of modifying your float timestamp, use a tuple for every key as Mark Ransom suggests where the tuple (x,y) is composed of x=your_unmodified_time_stamp and y=(extremely unlikely to be a same value twice). "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "Mark Ransom suggests", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/6063755/increment-a-python-floating-point-value-by-the-smallest-possible-amount/6063831#6063831"}, {"text": "(x,y)", "childNum": 0, "tag": "code", "childList": []}, {"text": "x=your_unmodified_time_stamp", "childNum": 0, "tag": "code", "childList": []}, {"text": "y=(extremely unlikely to be a same value twice)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["While 2.1 (random int from a large range) there works great for ethernet, I would use 2.2 (serializer) or 2.3 (UUID).", "Easy, fast, bulletproof.", "For 2.2 and 2.3 you don't even need collision detection (you might want to still have it for 2.1 as ethernet does."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The advantage of 2.2 is that you can also tell, and sort, data elements that have the same float time stamp. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Then just extract x from the tuple for any sorting type operations and the tuple itself is a collision free key for the hash / dictionary. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I guess example code will help:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport time\nimport sys\nimport random\n\n#generator for ints from 0 to maxinteger on system:\nserializer=(sn for sn in xrange(0,sys.maxint))\n\n#a list with guranteed collisions:\ntimes=[]\nfor c in range(0,35):\n   t=time.clock()\n   for i in range(0,random.choice(range(0,4))):\n      times.append(t)\n\nprint len(set(times)), \"unique items in a list of\",len(times)      \n\n#dictionary of tuples; no possibilities of collisions:\ndi={}   \nfor time in times:\n    sn=serializer.next()\n    di[(time,sn)]='Element {}'.format(sn)\n\n#for tuples of multiple numbers, Python sorts\n# as you expect: first by t[0] then t[1], until t[n]\nfor key in sorted(di.keys()):\n    print \"{:&gt;15}:{}\".format(key, di[key])\n</code>\n</pre>\n", "senID": 7}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n 26 unique items in a list of 55\n  (0.042289, 0):Element 0\n  (0.042289, 1):Element 1\n  (0.042289, 2):Element 2\n  (0.042305, 3):Element 3\n  (0.042305, 4):Element 4\n  (0.042317, 5):Element 5\n  # and so on until Element n...\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Forgetting about why we would want to increment a floating point value for a moment, I would have to say I think Autopulated's own answer is probably correct."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "why", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["But for the problem domain, I share the misgivings of most of the responders to the idea of using floats as dictionary keys.", "If the objection to using Decimal (as proposed in the main comments) is that it is a \"heavyweight\" solution, I suggest a do-it-yourself compromise:  Figure out what the practical resolution is on the timestamps, pick a number of digits to adequately cover it, then multiply all the timestamps by the necessary amount so that you can use integers as the keys.", "If you can afford an extra digit or two beyond the timer precision, then you can be even more confident that there will be no or fewer collisions, and that if there are collisions, you can just add 1 (instead of some rigamarole to find the next floating point value)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I think you mean \"by as small an amount possible to avoid a hash collision\", since for example the next-highest-float may already be a key!", "=)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while toInsert.key in myDict: # assumed to be positive\n    toInsert.key *= 1.000000000001\nmyDict[toInsert.key] = toInsert\n</code>\n</pre>\n", "senID": 1}, {"text": ["That said you probably don't want to be using timestamps as keys."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Instead of resolving the collisions by changing the key, how about collecting the collisions?", "IE: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collecting", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n bag = {}\nbag[1234.] = 'something'\n</code>\n</pre>\n", "senID": 1}, {"text": ["becomes"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n bag = collections.defaultdict(list)\nbag[1234.].append('something')\n</code>\n</pre>\n", "senID": 3}, {"text": ["would that work?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here it part of it.", "This is dirty and slow, but maybe that is how you like it.", "It is missing several corner cases, but maybe this gets someone else close."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The idea is to get the hex string of a floating point number.", "That gives you a string with the mantissa and exponent bits to twiddle.", "The twiddling is a pain since you have to do all it manually and keep converting to/from strings.", "Anyway, you add(subtract) 1 to(from) the last digit for positive(negative) numbers.", "Make sure you carry through to the exponent if you overflow.", "Negative numbers are a little more tricky to make you don't waste any bits."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def increment(f):\n    h = f.hex()\n    # decide if we need to increment up or down\n    if f &gt; 0:\n        sign = '+'\n        inc = 1\n    else:\n        sign = '-'\n        inc = -1\n    # pull the string apart\n    h = h.split('0x')[-1]\n    h,e = h.split('p')\n    h = ''.join(h.split('.'))\n    h2 = shift(h, inc)\n    # increase the exponent if we added a digit\n    h2 = '%s0x%s.%sp%s' % (sign, h2[0], h2[1:], e)\n    return float.fromhex(h2)\n\ndef shift(s, num):\n    if not s:\n        return ''\n    right = s[-1]\n    right = int(right, 16) + num\n    if right &gt; 15:\n        num = right // 16\n        right = right%16\n    elif right &lt; 0:\n        right = 0\n        num = -1\n    else:\n        num = 0\n    # drop the leading 0x\n    right = hex(right)[2:]\n    return shift(s[:-1], num) + right\n\na = 1.4e4\nprint increment(a) - a\na = -1.4e4\nprint increment(a) - a\n\na = 1.4\nprint increment(a) - a\n</code>\n</pre>\n", "senID": 2}], [{"text": ["For colliding key k, add:  k / 250"], "childNum": 3, "tag": "h2", "senID": 0, "childList": [{"text": "k", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "k / 250", "childNum": 1, "tag": "em", "childList": [{"text": "50", "tag": "sup"}]}, {"text": "50", "childNum": 0, "tag": "sup", "childList": []}]}, {"text": ["Interesting problem.", "The amount you need to add obviously depends on the magnitude of the colliding value, so that a normalized add will affect only the least significant bits."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It's not necessary to determine the smallest value that can be added.", "All you need to do is approximate it.", "The FPU format provides 52 mantissa bits plus a hidden bit for 53 bits of precision.", "No physical constant is known to anywhere near this level of precision.", "No sensor is able measure anything near it.", "So you don't have a hard problem."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "No physical constant is known to anywhere near this level of precision. No sensor is able measure anything near it.", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["In most cases, for key k, you would be able to add k/253, because of that 52-bit fraction plus the hidden bit."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "k", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "k/253,", "childNum": 1, "tag": "em", "childList": [{"text": "53", "tag": "sup"}]}, {"text": "53", "childNum": 0, "tag": "sup", "childList": []}]}, {"text": ["But it's not necessary to risk triggering library bugs or exploring rounding issues by shooting for the very last bit or anything near it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["1.", "Possibly more than once until it doesn't collide any more, at least to foil any diabolical unit test authors."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "1. Possibly more than once until it doesn't collide any more, at least to foil any diabolical unit test authors.", "childNum": 0, "tag": "sup", "pos": -1, "childList": []}]}], [{"text": ["A better answer (now I'm just doing this for fun...), motivated by twiddling the bits.", "Handling the carry and overflows between parts of the number of negative values is somewhat tricky."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import struct\n\ndef floatToieee754Bits(f):\n    return struct.unpack('&lt;Q', struct.pack('&lt;d', f))[0]\n\ndef ieee754BitsToFloat(i):\n    return struct.unpack('&lt;d', struct.pack('&lt;Q', i))[0]\n\ndef incrementFloat(f):\n    i = floatToieee754Bits(f)\n    if f &gt;= 0:\n        return ieee754BitsToFloat(i+1)\n    else:\n        raise Exception('f not &gt;= 0: unsolved problem!')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["After Looking at Autopopulated's answer I came up with a slightly different answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import math, sys\n\ndef incrementFloatValue(value):\n    if value == 0:\n        return sys.float_info.min                                \n    mant, exponent = math.frexp(value)                                                   \n    epsilonAtValue = math.ldexp(1, exponent - sys.float_info.mant_dig)                \n    return math.fsum([value, epsilonAtValue])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Disclaimer: I'm really not as great at maths as I think I am ;)  Please verify this is correct before using it.", "Also I'm not sure about performance"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Disclaimer: I'm really not as great at maths as I think I am ;)  Please verify this is correct before using it. Also I'm not sure about performance", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["some notes:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "some notes:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["epsilonAtValue"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": "I'm not sure if the ", "tag": "none", "senID": 5}]}], [{"text": ["It turns out that this is actually quite complicated (maybe why seven people have answered without actually providing an answer yet...)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think this is the right solution, it certainly seems to handle 0 and positive values correctly:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import math\nimport sys\n\ndef incrementFloat(f):\n    if f == 0.0:\n        return sys.float_info.min\n    m, e = math.frexp(f)\n    return math.ldexp(m + sys.float_info.epsilon / 2, e)\n</code>\n</pre>\n", "senID": 2}]]