[[{"code": "<pre>\n<code>\n if not name.startswith('doc'):\n     print name\n</code>\n</pre>\n", "senID": 0}, {"text": ["If you have more prefixes to exclude you can even do this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if not name.startswith(('prefix', 'another', 'yetanother')):\n     print name\n</code>\n</pre>\n", "senID": 2}, {"text": ["startswith can accept a tuple of prefixes."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "startswith", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.startswith"}]}], [{"code": "<pre>\n<code>\n for name in files:\n    if not name.startswith(\"doc\"):\n        print name\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If you find functional programming matches your style better, Python makes it simple to filter lists with the filter() function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; files = [\"doc1.html\", \"doc2.html\", \"doc3.html\", \"index.html\", \"image.jpeg\"]\n&gt;&gt;&gt; filter_function = lambda name: not name.startswith(\"doc\")\n&gt;&gt;&gt; filter(filter_function, files)\n['index.html', 'image.jpeg']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also take a look at apply(), map(), reduce(), and zip()."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n import os\nos.chdir(\"/home\")\nfor file in os.listdir(\".\"):\n   if os.path.isfile(file) and not file.startswith(\"doc\"):\n      print file\n</code>\n</pre>\n", "senID": 0}], [{"text": ["looks like this problem might be a better fit for list stuff \nso like Troy said (Although I prefer putting the function directly into the filter)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n filter(lambda filename: not filename.startswith(\"doc\"),files)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [filename for filename in files if not filename.startswith(\"doc\")]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You could also use a list comprehension."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}, {"code": "<pre>\n<code>\n cleaned_list = [filename for filename in files if not filename.startswith('doc')]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n for name in files:\n    if name[0:3] == \"doc\":\n         continue\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If all of them start the same (i.e.", "with \"doc\") you could use python's string's startswith() method."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for name in files:\n    if not name.startswith(\"doc\"):\n       print name\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Since you didn't say if there are good files starting with 'doc' and ending with '.html' you will have to declare a set of bad filenames and process only files not in that set."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n bad_files = set([\"doc1.html\", \"doc2.html\", \"doc3.html\"])\n\nfor file in files:\n  if file not in bad_files:\n    print file\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you need to dynamically change the list of filenames use a list."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["An alternate take to a functional solution to this issue, with the advantage of using recent additions to the standard library (using the same example filenames as Troy J. Farrell in another answer) :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import operator, itertools\n&gt;&gt;&gt; filter_fun= operator.methodcaller(\"startswith\", \"doc\")\n&gt;&gt;&gt; files = [\"doc1.html\", \"doc2.html\", \"doc3.html\", \"index.html\", \"image.jpeg\"]\n&gt;&gt;&gt; list(itertools.ifilterfalse(filter_fun, files))\n['index.html', 'image.jpeg']\n</code>\n</pre>\n", "senID": 1}, {"text": ["operator.methodcaller called with methodname, [optional arguments] returns a function that, when called with an object obj as its argument, returns the result of obj.methodname(optional_arguments).", "itertools.ifilterfalse, unlike filter, returns an iterator instead of a list and the filter decision is negated."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "operator.methodcaller", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "methodname, [optional arguments]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "obj", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "obj.methodname(optional_arguments)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools.ifilterfalse", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["This is my 2 cents:\nA bit of list comprehension.It's always better for effeciency."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n file_list = [file for file in directory if not file.startswith((\"name1\", \"name2\", \"name3\"))]\n</code>\n</pre>\n", "senID": 1}]]