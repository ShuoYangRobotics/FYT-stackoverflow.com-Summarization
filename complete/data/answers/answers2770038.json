[[{"text": ["Python passes everything the same way, but calling it \"by value\" or \"by reference\" will not clear everything up, since Python's semantics are different than the languages for which those terms usually apply.", "If I was to describe it, I would say that all passing was by value, and that the value was an object reference.", "(This is why I didn't want to say it!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to filter out some stuff from a list, you build a new list"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n foo = range(100000)\nnew_foo = []\nfor item in foo:\n    if item % 3 != 0: # Things divisble by 3 don't get through\n        new_foo.append(item)\n</code>\n</pre>\n", "senID": 2}, {"text": ["or, using the list comprehension syntax"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n new_foo = [item for item in foo if item % 3 != 0]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Python will not copy the objects in the list, but rather both foo and new_foo will reference the same objects.", "(Python never implicitly copies any objects."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "new_foo", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["You have suggested you have performance concerns about this operation.", "Using repeated  del statements from the old list will result in not code that is less idiomatic and more confusing to deal with, but it will introduce quadratic performance because the whole list must be reshuffled each time. "], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "del", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["To address performance:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["Get it up and running.", "You can't figure out what your performance is like unless you have code working.", "This will also tell you whether it is speed or space that you must optimize for; you mention concerns about both in your code, but oftentimes optimization  involves getting one at the cost of the other."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Get it up and running.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Profile.", "You can use the stdlib tools for performance in time.", "There are various third-party memory profilers that can be somewhat useful but aren't quite as nice to work with."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "Profile.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "the stdlib tools", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/profile.html"}]}, {"text": ["Measure.", "Time or reprofile memory when you make a change to see if a change makes an improvement and if so what that improvement is."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "Measure.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Time", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/timeit.html"}]}, {"text": ["To make your code more memory-sensitive, you will often want a paradigm shift in how you store your data, not microoptimizastions like not building a second list to do filtering.", "(The same is true for time, really: changing to a better algorithm will almost always give the best speedup.", "However, it's harder to generalize about speed optimizations)."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}]}], [{"text": ["In Python, lists are always passed by reference."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The size of the objects in the list doesn't affect the lists performance, because the lists only stores references to the objects.", "However, the number of items in the list does affect the performance of some operations - such as removing an element, which is O(n)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As written, listCleanup is worst-case O(n**2), since you have the O(n) del operation within a loop that is potentially O(n) itself."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If the order of the elements doesn't matter, you may be able to use the built-in set type instead of a list.", "The set has O(1) deletions and insertions.", "However, you will have to ensure that your objects are immutable and hashable."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Otherwise, you're better off recreating the list.", "That's O(n), and your algorithm needs to be at least O(n) since you need to examine every element.", "You can filter the list in one line like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n listOfElements[:] = [el for el in listOfElements if el.MeetsCriteria()]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Looks like premature optimization.", "You should try to get a better understanding of how python works before trying to optimize."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In this particular case you don't need to worry about object size.", "Copying a list is using list comprehension or slice will only perform surface copy (copy references to objects even if the term does not really apply well to python).", "But the number of items in the list may matter because del is O(n).", "There may be other solutions, like replacing an item with None or a conventional Null object, or using another data structure like a set or a dictionary where cost of deleting item is much lower."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Deleting list elements in-situ is possible, but not by going forwards through the list.", "Your code just plain doesn't work -- as the list shrinks, you can miss out examining elements.", "You need to go backwards, so that the shrinking part is behind you, with rather horrid code.", "Before I show you that, there are some preliminary considerations:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, how did that rubbish get into the list?", "Prevention is better than cure."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Second, how many elements in the list, and what percentage are likely to need deletion?", "The higher the percentage, the greater the likelihood that it's better to create a new list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["OK, if you still want to do it in-situ, contemplate this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def list_cleanup_fail(alist, is_bad):\n    i = 0\n    for element in alist:\n        print \"i=%d alist=%r alist[i]=%d element=%d\" % (i, alist, alist[i], element)\n        if is_bad(element):\n            del alist[i]\n        i += 1\n\ndef list_cleanup_ok(alist, is_bad):\n    for i in xrange(len(alist) - 1, -1, -1):\n        print \"i=%d alist=%r alist[i]=%d\" % (i, alist, alist[i])\n        if is_bad(alist[i]):\n            del alist[i]\n\ndef is_not_mult_of_3(x):\n    return x % 3 != 0\n\nfor func in (list_cleanup_fail, list_cleanup_ok):\n    print\n    print func.__name__\n    mylist = range(11)\n    func(mylist, is_not_mult_of_3)\n    print \"result\", mylist\n</code>\n</pre>\n", "senID": 4}, {"text": ["and here is the output:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n list_cleanup_fail\ni=0 alist=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] alist[i]=0 element=0\ni=1 alist=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] alist[i]=1 element=1\ni=2 alist=[0, 2, 3, 4, 5, 6, 7, 8, 9, 10] alist[i]=3 element=3\ni=3 alist=[0, 2, 3, 4, 5, 6, 7, 8, 9, 10] alist[i]=4 element=4\ni=4 alist=[0, 2, 3, 5, 6, 7, 8, 9, 10] alist[i]=6 element=6\ni=5 alist=[0, 2, 3, 5, 6, 7, 8, 9, 10] alist[i]=7 element=7\ni=6 alist=[0, 2, 3, 5, 6, 8, 9, 10] alist[i]=9 element=9\ni=7 alist=[0, 2, 3, 5, 6, 8, 9, 10] alist[i]=10 element=10\nresult [0, 2, 3, 5, 6, 8, 9]\n\nlist_cleanup_ok\ni=10 alist=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] alist[i]=10\ni=9 alist=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] alist[i]=9\ni=8 alist=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] alist[i]=8\ni=7 alist=[0, 1, 2, 3, 4, 5, 6, 7, 9] alist[i]=7\ni=6 alist=[0, 1, 2, 3, 4, 5, 6, 9] alist[i]=6\ni=5 alist=[0, 1, 2, 3, 4, 5, 6, 9] alist[i]=5\ni=4 alist=[0, 1, 2, 3, 4, 6, 9] alist[i]=4\ni=3 alist=[0, 1, 2, 3, 6, 9] alist[i]=3\ni=2 alist=[0, 1, 2, 3, 6, 9] alist[i]=2\ni=1 alist=[0, 1, 3, 6, 9] alist[i]=1\ni=0 alist=[0, 3, 6, 9] alist[i]=0\nresult [0, 3, 6, 9]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Just to be clear: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def listCleanup(listOfElements):\n    i = 0\n    for element in listOfElements:\n        if(element.meetsCriteria()):\n            del(listOfElements[i])\n        i += 1\n    return listOfElements\n\nmyList = range(10000)\nmyList = listCleanup(listOfElements)\n</code>\n</pre>\n", "senID": 1}, {"text": ["is the same as"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def listCleanup(listOfElements):\n    i = 0\n    for element in listOfElements:\n        if(element.meetsCriteria()):\n            del(listOfElements[i])\n        i += 1\n\nmyList = range(10000)\nlistCleanup(listOfElements)\n</code>\n</pre>\n", "senID": 3}, {"text": [], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["modifying your data structure as you're iterating over it is like shooting yourself in the foot... iteration fails.", "you might as well take others' advice and just make a new list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n myList = [element for element in listOfElements if not element.meetsCriteria()]\n</code>\n</pre>\n", "senID": 1}, {"text": ["the old list -- if there are no other references to it -- will be deallocated and the memory reclaimed.", "better yet, don't even make a copy of the list.", "change the above to a generator expression for a more memory-friendly version:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "generator expression", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n myList = (element for element in listOfElements if not element.meetsCriteria())\n</code>\n</pre>\n", "senID": 3}, {"text": ["all Python object access is by reference.", "objects are created and variables are just references to those objects.", "however, if someone wanted to ask the purist question, \"what type of call semantics does Python use, call-by-reference or call-by-value?", "\" the answer will have to be, \"Neither... and both.", "\" the reason is because calling conventions are less important to Python than object type."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["if an object is mutable, it can be modified regardless of what scope you're in... as long as you have a valid object reference, the object can be changed.", "if the object is immutable, then that object cannot be changed no matter where you are or what reference you have."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "immutable", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["I don't think anyone mentioned actually using filter.", "Since a lot of the answers came from well respected people, I'm sure that I'm the one that's missing something.", "Could someone explain what would be wrong with this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["new_list = filter(lambda o: o.meetsCriteria(), myList)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "new_list = filter(lambda o: o.meetsCriteria(), myList)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]