[[{"text": ["Performance comparison"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Note: time in the table doesn't include the time it takes to load files."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n | approach       | american-english, |      big.txt, | time w.r.t. defaultdict |\n|                |     time, seconds | time, seconds |                         |\n|----------------+-------------------+---------------+-------------------------|\n| Counter        |             0.451 |         3.367 |                     3.6 |\n| setdefault     |             0.348 |         2.320 |                     2.5 |\n| list           |             0.277 |         1.822 |                       2 |\n| try/except     |             0.158 |         1.068 |                     1.2 |\n| defaultdict    |             0.141 |         0.925 |                       1 |\n| numpy          |             0.012 |         0.076 |                   0.082 |\n| S.Mark's ext.  |             0.003 |         0.019 |                   0.021 |\n| ext. in Cython |             0.001 |         0.008 |                  0.0086 |\n#+TBLFM: $4=$3/@7$3;%.2g\n</code>\n</pre>\n", "senID": 2}, {"text": ["The files used: '/usr/share/dict/american-english' and 'big.txt'."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "'/usr/share/dict/american-english'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://norvig.com/big.txt", "text": "'big.txt'", "childNum": 1, "tag": "a", "childList": [{"text": "'big.txt'", "tag": "code"}]}, {"text": "'big.txt'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The script that compares 'Counter', 'setdefault', 'list', 'try/except', 'defaultdict', 'numpy', 'cython' -based, and @S.Mark's solutions is at http://gist.github.com/347000"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://gist.github.com/347000", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gist.github.com/347000"}]}, {"text": ["The fastest solution is Python extension written in Cython:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import cython\n\n@cython.locals(\n    chars=unicode,\n    i=cython.Py_ssize_t,\n    L=cython.Py_ssize_t[0x10000])\ndef countchars_cython(chars):\n    for i in range(0x10000): # unicode code points &gt; 0xffff are not supported\n        L[i] = 0\n\n    for c in chars:\n        L[c] += 1\n\n    return {unichr(i): L[i] for i in range(0x10000) if L[i]}\n</code>\n</pre>\n", "senID": 6}, {"code": "<pre>\n<code>\n * python (dict) : 0.5  seconds\n* python (list) : 0.5  (ascii) (0.2 if read whole file in memory)\n* perl          : 0.5\n* python (numpy): 0.07 \n* c++           : 0.05\n* c             : 0.008 (ascii)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Input data:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n $ tail /usr/share/dict/american-english\n\u00e9clat's\n\u00e9lan\n\u00e9lan's\n\u00e9migr\u00e9\n\u00e9migr\u00e9s\n\u00e9p\u00e9e\n\u00e9p\u00e9es\n\u00e9tude\n\u00e9tude's\n\u00e9tudes\n\n$ du -h /usr/share/dict/american-english\n912K    /usr/share/dict/american-english\n</code>\n</pre>\n", "senID": 9}, {"code": "<pre>\n<code>\n #!/usr/bin/env python3.1\nimport collections, fileinput, textwrap\n\nchars = (ch for word in fileinput.input() for ch in word.rstrip())\n# faster (0.4s) but less flexible: chars = open(filename).read()\nprint(textwrap.fill(str(collections.Counter(chars)), width=79))\n</code>\n</pre>\n", "senID": 10}, {"text": ["Run it:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n $ time -p python3.1 count_char.py /usr/share/dict/american-english\n</code>\n</pre>\n", "senID": 12}, {"code": "<pre>\nCounter({'e': 87823, 's': 86620, 'i': 66548, 'a': 62778, 'n': 56696, 'r':\n56286, 't': 51588, 'o': 48425, 'l': 39914, 'c': 30020, 'd': 28068, 'u': 25810,\n\"'\": 24511, 'g': 22262, 'p': 20917, 'm': 20747, 'h': 18453, 'b': 14137, 'y':\n12367, 'f': 10049, 'k': 7800, 'v': 7573, 'w': 6924, 'z': 3088, 'x': 2082, 'M':\n1686, 'C': 1549, 'S': 1515, 'q': 1447, 'B': 1387, 'j': 1376, 'A': 1345, 'P':\n974, 'L': 912, 'H': 860, 'T': 858, 'G': 811, 'D': 809, 'R': 749, 'K': 656, 'E':\n618, 'J': 539, 'N': 531, 'W': 507, 'F': 502, 'O': 354, 'I': 344, 'V': 330, 'Z':\n150, 'Y': 140, '\u00e9': 128, 'U': 117, 'Q': 63, 'X': 42, '\u00e8': 29, '\u00f6': 12, '\u00fc': 12,\n'\u00f3': 10, '\u00e1': 10, '\u00e4': 7, '\u00ea': 6, '\u00e2': 6, '\u00f1': 6, '\u00e7': 4, '\u00e5': 3, '\u00fb': 3, '\u00ed':\n2, '\u00f4': 2, '\u00c5': 1})\nreal 0.44\nuser 0.43\nsys 0.01\n</pre>\n", "senID": 13}, {"code": "<pre>\n<code>\n time -p perl -MData::Dumper -F'' -lanwe'$c{$_}++ for (@F);\nEND{ $Data::Dumper::Terse = 1; $Data::Dumper::Indent = 0; print Dumper(\\%c) }\n' /usr/share/dict/american-english\n</code>\n</pre>\n", "senID": 14}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n{'S' => 1515,'K' => 656,'' => 29,'d' => 28068,'Y' => 140,'E' => 618,'y' => 12367,'g' => 22262,'e' => 87823,'' => 2,'J' => 539,'' => 241,'' => 3,'' => 6,'' => 4,'' => 128,'D' => 809,'q' => 1447,'b' => 14137,'z' => 3088,'w' => 6924,'Q' => 63,'' => 10,'M' => 1686,'C' => 1549,'' => 10,'L' => 912,'X' => 42,'P' => 974,'' => 12,'\\'' => 24511,'' => 6,'a' => 62778,'T' => 858,'N' => 531,'j' => 1376,'Z' => 150,'u' => 25810,'k' => 7800,'t' => 51588,'' => 6,'W' => 507,'v' => 7573,'s' => 86620,'B' => 1387,'H' => 860,'c' => 30020,'' => 12,'I' => 344,'' => 3,'G' => 811,'U' => 117,'F' => 502,'' => 2,'r' => 56286,'x' => 2082,'V' => 330,'h' => 18453,'f' => 10049,'' => 1,'i' => 66548,'A' => 1345,'O' => 354,'n' => 56696,'m' => 20747,'l' => 39914,'' => 7,'p' => 20917,'R' => 749,'o' => 48425}\nreal 0.51\nuser 0.49\nsys 0.02\n</pre>\n", "senID": 16}, {"text": ["Based on Ants Aasma's answer (modified to support unicode):"], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "Ants Aasma's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2522152/python-is-a-dictionary-slow-to-find-frequency-of-each-character/2524913#2524913"}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport codecs, itertools, operator, sys\nimport numpy\n\nfilename = sys.argv[1] if len(sys.argv)&gt;1 else '/usr/share/dict/american-english'\n\n# ucs2 or ucs4 python?\ndtype = {2: numpy.uint16, 4: numpy.uint32}[len(buffer(u\"u\"))]\n\n# count ordinals\ntext = codecs.open(filename, encoding='utf-8').read()\na = numpy.frombuffer(text, dtype=dtype)\ncounts = numpy.bincount(a)\n\n# pretty print\ncounts = [(unichr(i), v) for i, v in enumerate(counts) if v]\ncounts.sort(key=operator.itemgetter(1))\nprint ' '.join('(\"%s\" %d)' % c for c in counts  if c[0] not in ' \\t\\n')\n</code>\n</pre>\n", "senID": 18}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n (\"\u00c5\" 1) (\"\u00ed\" 2) (\"\u00f4\" 2) (\"\u00e5\" 3) (\"\u00fb\" 3) (\"\u00e7\" 4) (\"\u00e2\" 6) (\"\u00ea\" 6) (\"\u00f1\" 6) (\"\u00e4\" 7) (\"\u00e1\" 10) (\"\u00f3\" 10) (\"\u00f6\" 12) (\"\u00fc\" 12) (\"\u00e8\" 29) (\"X\" 42) (\"Q\" 63) (\"U\" 117) (\"\u00e9\" 128) (\"Y\" 140) (\"Z\" 150) (\"V\" 330) (\"I\" 344) (\"O\" 354) (\"F\" 502) (\"W\" 507) (\"N\" 531) (\"J\" 539) (\"E\" 618) (\"K\" 656) (\"R\" 749) (\"D\" 809) (\"G\" 811) (\"T\" 858) (\"H\" 860) (\"L\" 912) (\"P\" 974) (\"A\" 1345) (\"j\" 1376) (\"B\" 1387) (\"q\" 1447) (\"S\" 1515) (\"C\" 1549) (\"M\" 1686) (\"x\" 2082) (\"z\" 3088) (\"w\" 6924) (\"v\" 7573) (\"k\" 7800) (\"f\" 10049) (\"y\" 12367) (\"b\" 14137) (\"h\" 18453) (\"m\" 20747) (\"p\" 20917) (\"g\" 22262) (\"'\" 24511) (\"u\" 25810) (\"d\" 28068) (\"c\" 30020) (\"l\" 39914) (\"o\" 48425) (\"t\" 51588) (\"r\" 56286) (\"n\" 56696) (\"a\" 62778) (\"i\" 66548) (\"s\" 86620) (\"e\" 87823)\nreal 0.07\nuser 0.06\nsys 0.01\n</code>\n</pre>\n", "senID": 20}, {"code": "<pre>\n<code>\n // $ g++ *.cc -lboost_program_options \n// $ ./a.out /usr/share/dict/american-english    \n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cstdlib&gt; // exit\n\n#include &lt;boost/program_options/detail/utf8_codecvt_facet.hpp&gt;\n#include &lt;boost/tr1/unordered_map.hpp&gt;\n#include &lt;boost/foreach.hpp&gt;\n\nint main(int argc, char* argv[]) {\n  using namespace std;\n\n  // open input file\n  if (argc != 2) {\n    cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" &lt;filename&gt;\\n\";\n    exit(2);\n  }\n  wifstream f(argv[argc-1]); \n\n  // assume the file has utf-8 encoding\n  locale utf8_locale(locale(\"\"), \n      new boost::program_options::detail::utf8_codecvt_facet);\n  f.imbue(utf8_locale); \n\n  // count characters frequencies\n  typedef std::tr1::unordered_map&lt;wchar_t, size_t&gt; hashtable_t;  \n  hashtable_t counts;\n  for (wchar_t ch; f &gt;&gt; ch; )\n    counts[ch]++;\n\n  // print result\n  wofstream of(\"output.utf8\");\n  of.imbue(utf8_locale);\n  BOOST_FOREACH(hashtable_t::value_type i, counts) \n    of &lt;&lt; \"(\" &lt;&lt; i.first &lt;&lt; \" \" &lt;&lt; i.second &lt;&lt; \") \";\n  of &lt;&lt; endl;\n}\n</code>\n</pre>\n", "senID": 21}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"code": "<pre>\n<code>\n $ cat output.utf8\n</code>\n</pre>\n", "senID": 23}, {"code": "<pre>\n(\u00ed 2) (O 354) (P 974) (Q 63) (R 749) (S 1,515) (\u00f1 6) (T 858) (U 117) (\u00f3 10) (\u00f4 2) (V 330) (W 507) (X 42) (\u00f6 12) (Y 140) (Z 150) (\u00fb 3) (\u00fc 12) (a 62,778) (b 14,137) (c 30,020) (d 28,068) (e 87,823) (f 10,049) (g 22,262) (h 18,453) (i 66,548) (j 1,376) (k 7,800) (l 39,914) (m 20,747) (n 56,696) (o 48,425) (p 20,917) (q 1,447) (r 56,286) (s 86,620) (t 51,588) (u 25,810) (\u00c5 1) (' 24,511) (v 7,573) (w 6,924) (x 2,082) (y 12,367) (z 3,088) (A 1,345) (B 1,387) (C 1,549) (\u00e1 10) (\u00e2 6) (D 809) (E 618) (F 502) (\u00e4 7) (\u00e5 3) (G 811) (H 860) (\u00e7 4) (I 344) (J 539) (\u00e8 29) (K 656) (\u00e9 128) (\u00ea 6) (L 912) (M 1,686) (N 531)\n</pre>\n", "senID": 24}, {"code": "<pre>\n<code>\n // $ gcc -O3 cc_ascii.c -o cc_ascii &amp;&amp; time -p ./cc_ascii &lt; input.txt\n#include &lt;stdio.h&gt;\n\nenum { N = 256 };\nsize_t counts[N];\n\nint main(void) {\n  // count characters\n  int ch = -1;\n  while((ch = getchar()) != EOF)\n    ++counts[ch];\n\n  // print result\n  size_t i = 0;\n  for (; i &lt; N; ++i) \n    if (counts[i])\n      printf(\"('%c' %zu) \", (int)i, counts[i]);\n  return 0;\n}\n</code>\n</pre>\n", "senID": 25}], [{"text": ["How about avoiding float operations inside the loop and do it after everything is done?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["By that way, you could just do +1 everytime, and its should be faster."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["And better use collections.defaultdict as S.Lott advised."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n freqs=collections.defaultdict(int)\n\nfor char in text: \n   freqs[char]+=1\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or You may want to try, collections.Counter in python 2.7+"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "collections.Counter", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/collections.html#collections.Counter"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; collections.Counter(\"xyzabcxyz\")\nCounter({'y': 2, 'x': 2, 'z': 2, 'a': 1, 'c': 1, 'b': 1})\n</code>\n</pre>\n", "senID": 5}, {"text": ["Or"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["You may try psyco, which do just-in-time compiling for python.", "You have loops, so I think you would get some performance gain with psyco"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "psyco", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/psyco/files/"}, {"text": "psyco", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/psyco/files/"}]}, {"text": ["Edit 1:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["I did some benchmarks base on big.txt (~6.5 MB) which is used in spelling corrector by peter norvig"], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "big.txt", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://norvig.com/big.txt"}, {"href": "http://norvig.com/spell-correct.html", "text": "spelling corrector", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://norvig.com", "text": "peter norvig", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n Text Length: 6488666\n\ndict.get : 11.9060001373 s\n93 chars {u' ': 1036511, u'$': 110, u'(': 1748, u',': 77675, u'0': 3064, u'4': 2417, u'8': 2527, u'&lt;': 2, u'@': 8, ....\n\nif char in dict : 9.71799993515 s\n93 chars {u' ': 1036511, u'$': 110, u'(': 1748, u',': 77675, u'0': 3064, u'4': 2417, u'8': 2527, u'&lt;': 2, u'@': 8, ....\n\ndict try/catch : 7.35899996758 s\n93 chars {u' ': 1036511, u'$': 110, u'(': 1748, u',': 77675, u'0': 3064, u'4': 2417, u'8': 2527, u'&lt;': 2, u'@': 8, ....\n\ncollections.default : 7.29699993134 s\n93 chars defaultdict(&lt;type 'int'&gt;, {u' ': 1036511, u'$': 110, u'(': 1748, u',': 77675, u'0': 3064, u'4': 2417, u'8': 2527, u'&lt;': 2, u'@': 8, ....\n</code>\n</pre>\n", "senID": 10}, {"text": ["CPU Specs: 1.6GHz Intel Mobile Atom CPU"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "CPU Specs: 1.6GHz Intel Mobile Atom CPU", "childNum": 0, "tag": "sub", "pos": 0, "childList": []}]}, {"text": ["According to that, dict.get is slowest and collections.defaultdict is fastest, try/except is also the fast one."], "childNum": 4, "tag": "p", "senID": 12, "childList": [{"text": "dict.get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "slowest", "childNum": 0, "tag": "s", "childList": []}, {"text": "collections.defaultdict", "childNum": 0, "tag": "code", "childList": []}, {"text": "try/except", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit 2:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Added collections.Counter benchmarks, Its slower than dict.get and took 15s in my laptop"], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "collections.Counter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict.get", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n collections.Counter : 15.3439998627 s\n93 chars Counter({u' ': 1036511, u'e': 628234, u't': 444459, u'a': 395872, u'o': 382683, u'n': 362397, u'i': 348464,\n</code>\n</pre>\n", "senID": 15}], [{"text": ["I've written Char Counter C Extension to Python, looks like 300x faster than collections.Counter and 150x faster than collections.default(int)"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "300x", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "collections.Counter", "childNum": 0, "tag": "code", "childList": []}, {"text": "150x", "childNum": 0, "tag": "strong", "childList": []}, {"text": "collections.default(int)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n C Char Counter : 0.0469999313354 s\n93 chars {u' ': 1036511, u'$': 110, u'(': 1748, u',': 77675, u'0': 3064, u'4': 2417, u'8': 2527, u'&lt;': 2, u'@': 8,\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is Char Counter C Extension Codes"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n static PyObject *\nCharCounter(PyObject *self, PyObject *args, PyObject *keywds)\n{\n    wchar_t *t1;unsigned l1=0;\n\n    if (!PyArg_ParseTuple(args,\"u#\",&amp;t1,&amp;l1)) return NULL;\n\n    PyObject *resultList,*itemTuple;\n\n    for(unsigned i=0;i&lt;=0xffff;i++)char_counter[i]=0;\n\n    unsigned chlen=0;\n\n    for(unsigned i=0;i&lt;l1;i++){\n        if(char_counter[t1[i]]==0)char_list[chlen++]=t1[i];\n        char_counter[t1[i]]++;\n    }\n\n    resultList = PyList_New(0);\n\n    for(unsigned i=0;i&lt;chlen;i++){\n        itemTuple = PyTuple_New(2);\n\n        PyTuple_SetItem(itemTuple, 0,PyUnicode_FromWideChar(&amp;char_list[i],1));\n        PyTuple_SetItem(itemTuple, 1,PyInt_FromLong(char_counter[char_list[i]]));\n\n        PyList_Append(resultList, itemTuple);\n        Py_DECREF(itemTuple);\n\n    };\n\n    return resultList;\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["Where char_counter, and char_list are malloc-ated at module level, so no need to malloc every time when function calls."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n char_counter=(unsigned*)malloc(sizeof(unsigned)*0x10000);\nchar_list=(wchar_t*)malloc(sizeof(wchar_t)*0x10000);\n</code>\n</pre>\n", "senID": 5}, {"text": ["It returns a List with Tuples"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n [(u'T', 16282), (u'h', 287323), (u'e', 628234), (u' ', 1036511), (u'P', 8946), (u'r', 303977), (u'o', 382683), ...\n</code>\n</pre>\n", "senID": 7}, {"text": ["To convert to dict format, just dict() will do."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "dict()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n dict(CharCounter(text))\n</code>\n</pre>\n", "senID": 9}, {"text": ["PS: Benchmark included the time converting to dict"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["CharCounter accept only Python Unicode String u\"\", if the text is utf8, need to do .decode(\"utf8\") in advance."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "CharCounter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "u\"\"", "childNum": 0, "tag": "code", "childList": []}, {"text": ".decode(\"utf8\")", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Input Supports Unicode until Basic Multilingual Plane (BMP) - 0x0000 to 0xFFFF"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["No it's not the fastest, because you know that the characters have a limited range and you could use a list and direct indexing, using the numeric representation of the character, to store the frequencies."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I'm not familiar with python, but for finding frequencies, unless you know the range of frequencies (in which case you can use an array), dictionary is the way to go.", "If you know your characters in a unicode, ASCII, etc.", "range, you can define an array with the correct number of values.", "However, this will change the space complexity of this from O(n) to O(possible n), but you will earn a time complexity improvement from O(n*(dictionary extraction/insertion time)) to O(n)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["It is very, very hard to beat dict.", "It is very highly tuned since almost everything in Python is dict-based."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you are really concerned about speed, you might consider first counting characters with integers and then obtaining frequencies through (float) division."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "integers", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Here are the numbers:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n python -mtimeit -s'x=0' 'x+=1'      \n10000000 loops, best of 3: 0.0661 usec per loop\n\npython -mtimeit -s'x=0.' 'x+=1.'\n10000000 loops, best of 3: 0.0965 usec per loop\n</code>\n</pre>\n", "senID": 2}], [{"text": ["well, you can do it in the old fashioned style... as we know that there are not too many different characters and they are contiguous, we can use a plain array (or list here) and use the characters ordinal numbering for indexing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = 1.0*len(text)\ncounts = [0]*256 # change this if working with unicode\nfor char in text: \n    freqs[ord(char)]+=1\n\nfreqs = dict((chr(i), v/s) for i,v in enumerate(counts) if v)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will be probably faster, but just by a constant factor, both methods should have the same complexity."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Using this code on Alice in Wonderland (163793 chars) and \"The Bible, Douay-Rheims Version\" (5649295 chars) from Project Gutenberg:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\nimport timeit\n\ndef countchars():\n    f = open('8300-8.txt', 'rb')\n    #f = open('11.txt')\n    s = f.read()\n    f.close()\n    charDict = defaultdict(int)\n    for aChar in s:\n        charDict[aChar] += 1\n\n\nif __name__ == '__main__':\n    tm = timeit.Timer('countchars()', 'from countchars import countchars')  \n    print tm.timeit(10)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I get:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 2.27324003315 #Alice in Wonderland\n74.8686217403 #Bible\n</code>\n</pre>\n", "senID": 3}, {"text": ["The ratio between the number of chars for both books is 0.029 and the ratio between the times is 0.030, so, the algorithm is O(n) with a very small constant factor.", "Fast enough for most (all?", ") purposes, I should think."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "0.029", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0.030", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["To avoid the try except overhead you can use a defaultdict."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Small speed up will be usage of dict.setdefault method, that way you will not pay rather big price for every new encountered character:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "dict.setdefault", "tag": "a", "pos": 0, "childList": [{"text": "dict.setdefault", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#dict.setdefault"}, {"text": "dict.setdefault", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for char in text:\n    freq[char] = freq.setdefault(char, 0.0) + P\n</code>\n</pre>\n", "senID": 1}, {"text": ["As a sidenote: having bare except: is considered very bad practice."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "except:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If the data is in a single byte encoding you can use numpy to accelerate the count process:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\n\ndef char_freq(data):\n    counts = np.bincount(np.frombuffer(data, dtype=np.byte))\n    freqs = counts.astype(np.double) / len(data)\n    return dict((chr(idx), freq) for idx, freq in enumerate(freqs) if freq &gt; 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Some quick benchmarking shows that this is about 10x faster than aggregating to a defaultdict(int)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]