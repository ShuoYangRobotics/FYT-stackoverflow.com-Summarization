[[{"text": ["It can also appear if you have a circular structure with a list pointing to itself.", "Like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [1,2]\n&gt;&gt;&gt; a.append(a)\n&gt;&gt;&gt; a\n[1, 2, [...]]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Since python can't print out the structure (it would be an infinite loop) it uses the ellipsis to show that there is recursion in the structure."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "hr", "senID": 3}, {"text": ["I'm not quite sure if the question was what what going on or how to fix it, but I'll try to correct the functions above."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In both of them, you first make two recursive calls, which add data to the list y, and then AGAIN append the returned data to y.", "This means the same data will be present several times in the result."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Either just collect all the data without adding to any y, with something like"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n return [x[2]]+keys(x[0])+keys(x[1])\n</code>\n</pre>\n", "senID": 7}, {"text": ["or just do the appending in the calls, with something like"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n y += [x[2]]\nkeys(x[0], y) #Add left children to y...\nkeys(x[1], y) #Add right children to y...\nreturn y\n</code>\n</pre>\n", "senID": 9}, {"text": ["(Of course, both these snippets need handling for empty lists etc)"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["@Abgan also noted that you really don't want y=[] in the initializer."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "y=[]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I believe, that your 'tree' contains itself, therefore it contains cycles."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Try this code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\na = [1,2,3,4]\n   print a\n   a.append(a)\n   print a\n</pre>\n", "senID": 2}, {"text": ["The first print outputs:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n[1,2,3,4]\n</pre>\n", "senID": 4}, {"text": ["while the second:\n [1,2,3,4, [...]]"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "[1,2,3,4, [...]]", "childNum": 0, "tag": "pre", "pos": 0, "childList": []}]}, {"text": ["The reason is using \n def Keys(x,y=[]):\nThis is wrong and evil.", "List is a mutable object, and when used as a default parameter, it is preserved between function calls.", "So each y += \"anything\" operation adds to the same list (in all function calls, and since the function is recursive...)"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "def Keys(x,y=[]):", "childNum": 0, "tag": "pre", "pos": 0, "childList": []}]}, {"tag": "hr", "senID": 7}, {"text": ["See the Effbot or Devshed for more details on mutable objects passed as default values for functions."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "Effbot", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/default-values.htm"}, {"href": "http://www.devshed.com/c/a/Python/Python-Parameters-Functions-and-Arguments/", "text": "Devshed", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I don't understand your code above, but the [...] I think is the Python interpreter skipping infinite data structures.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [0, 1]\n&gt;&gt;&gt; a[0] = a\n&gt;&gt;&gt; a\n[[...], 1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It looks like your tree structure is becoming looped."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The answers about slice objects are beside the point."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Look at the following code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [0]\n&gt;&gt;&gt; a.append(a)\n&gt;&gt;&gt; print a\n[0, [...]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["How is Python supposed to print a?", "It is a list that contains a zero and a reference to itself.", "Hence it is a list that contains a zero and a reference to a list"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [0, [...]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["which in turn contains a zero and a reference to a list"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n [0, [0, [...]]]\n</code>\n</pre>\n", "senID": 5}, {"text": ["which in turn contains a zero and a reference to a list,\nand so on, recursively:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n [0, [0, [0, [...]]]]\n[0, [0, [0, [0, [...]]]]]\n[0, [0, [0, [0, [0, [...]]]]]]\n...\n</code>\n</pre>\n", "senID": 7}, {"text": ["There is nothing wrong with the recursive data structure itself.", "The only problem is that it cannot be displayed, for this would imply an infinite recursion.", "Hence Python stops at the first recursion step and deals with the infinity issue printing only the ellipsis, as was pointed out in previous answers."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "displayed", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["EDIT: As mentioned above, this isn't the Ellipsis object, but the result of a looped list.", "I jumped the gun here.", "Knowing about the Ellipsis object is a good bit of back shelf knowledge should you find an Ellipsis in some actual code, rather than the output."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "hr", "senID": 1}, {"text": ["The Ellipsis object in Python is used for extended slice notation.", "It's not used in current Python core libraries, but is available for developers to define in their own libraries.", "For example, NumPy (or SciPy) use this as part of their array object.", "You'll need to look at the documentation for tree() to know exactly how Ellipsis behaves in this object."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["From Python documentation:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Python documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/bltin-ellipsis-object.html"}]}], [{"text": ["Ok, so in points:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Try using the following code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\ndef Keys(x,y=None):\n    if y is None:\n        y = []\n    if len(x):\n        y += [x[2], Keys(x[0],y), Keys(x[1],y)]\n    return y\n</pre>\n", "senID": 2}, {"text": ["But still I guess that it can bite you.", "You're still using the same variable y (I mean the same object) in three places in one expression:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\ny += [x[2], Keys(x[0], y), Keys(x[1], y)]\n</pre>\n", "senID": 4}, {"code": "<pre>\ndef mKeys(x,y=None):\n    if y is None:\n        y = []\n    if len(x):\n       z = [x[2], mKeys(x[0], y), mKeys(x[1],y)]\n       return z\n   return []\n</pre>\n", "senID": 5}], [{"text": ["For the difference between the two versions of the function Keys, note the following difference:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n y+=[x[2]]+Keys(x[0],y)+Keys(x[1],y)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The right side value in this statement is a list which contains x[2], plus the ELEMENTS OF Keys(x[0],y) and the ELEMENTS OF Keys(x[1],y)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n y+=[x[2],Keys(x[0],y),Keys(x[1],y)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["The right side value in this statement is a list which contains x[2], plus the LIST Keys(x[2],y) and the LIST Keys(x[1],y)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["So the version using [a,b] will causing y contains itself as its elements."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Some other notes:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]