[[{"text": ["There is a function assert_approx_equal in numpy.testing (source here)which may be a good starting point. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "assert_approx_equal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "numpy.testing", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://projects.scipy.org/scipy/numpy/browser/trunk/numpy/testing/utils.py", "text": "here)", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; help(assert_approx_equal) Help on function assert_approx_equal in module numpy.testing.utils:\n\nassert_approx_equal(actual, desired, significant=7, err_msg='', verbose=True)\n    Raise an assertion if two items are not\n    equal.  I think this should be part of unittest.py\n    Approximately equal is defined as the number of significant digits\n    correct\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a take."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def nearly_equal(a,b,sig_fig=5):\n    return ( a==b or \n             int(a*10**sig_fig) == int(b*10**sig_fig)\n           )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["\"Significant figures\" in decimal is a matter of adjusting the decimal point and truncating to an integer.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; int(3.1415926 * 10**3)\n3141\n&gt;&gt;&gt; int(1234567 * 10**-3)\n1234\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I believe your question is not enough well defined, and the unit-tests you present prove it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If by 'round to N sig-fig decimal places' you mean 'N decimal places to the right of the decimal point', then the test \"assert nearlyequal(1e9, 1e9 + 1 , 5)\" should fail because even when you round 1000000000 and 1000000001 to 0.00001 accuracy, they are still different."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["And if y 'round to N sig-fig decimal places' you mean 'The N most significant digits, regardless of the decimal point', then the test \"assert nearlyequal(-1e-9, 1e-9, 5)\" should fail, because 0.000000001 and -0.000000001 are totally different when viewed this way."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you meant the first definition, then the first answer on this page (by Triptych) is good.", "If you meant the second definition, please say it, I promise to think about it :-)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I would actually say:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def nearlyequal( a, b, sigfig=5 ):\n    return round(a, sigfig) == round(b, sigfig)\n</code>\n</pre>\n", "senID": 1}, {"text": ["as the methods above using int() always round down (ie.", "int(0.9) goes to 0)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "int()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int(0.9)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["EDIT: This is horribly wrong.", "I just wanted to make the point that int rounds down."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["This is a fairly common issue with floating point numbers.", "I solve it based on the discussion in Section 1.5 of Demmel[1].", "(1) Calculate the roundoff error.", "(2) Check that the roundoff error is less than some epsilon.", "I haven't used python in some time and only have version 2.4.3, but I'll try to get this correct."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Step 1.", "Roundoff error"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def roundoff_error(exact, approximate):\n    return abs(approximate/exact - 1.0)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Step 2.", "Floating point equality"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def float_equal(float1, float2, epsilon=2.0e-9):\n    return (roundoff_error(float1, float2) &lt; epsilon)\n</code>\n</pre>\n", "senID": 4}, {"text": ["There are a couple obvious deficiencies with this code."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Revision 1."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def roundoff_error(exact, approximate):\n    if (exact == 0.0 or approximate == 0.0):\n        return abs(exact + approximate)\n    else:\n        return abs(approximate/exact - 1.0)\n\ndef float_equal(float1, float2, epsilon=2.0e-9):\n    if not isinstance(float1,float):\n        raise TypeError,\"First argument is not a float.\"\n    elif not isinstance(float2,float):\n        raise TypeError,\"Second argument is not a float.\"\n    else:\n        return (roundoff_error(float1, float2) &lt; epsilon)\n</code>\n</pre>\n", "senID": 7}, {"text": ["That's a little better.", "If either the exact or the approximate value is zero, than the error is equal to the value of the other.", "If something besides a floating point value is provided, a TypeError is raised."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["At this point, the only difficult thing is setting the correct value for epsilon.", "I noticed in the documentation for version 2.6.1 that there is an epsilon attribute in sys.float_info, so I would use twice that value as the default epsilon.", "But the correct value depends on both your application and your algorithm."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["[1] James W. Demmel, Applied Numerical Linear Algebra, SIAM, 1997."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Applied Numerical Linear Algebra", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Oren Shemesh got part of the problem with the problem as stated but there's more:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["assert nearlyequal( 0.0, 1e-15, 5 ) "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["also fails the second definition (and that's the definition I learned in school."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["No matter how many digits you are looking at, 0 will not equal a not-zero.", "This could prove to be a headache for such tests if you have a case whose correct answer is zero."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There are already plenty of great answers, but here's a think:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def closeness(a, b):\n  \"\"\"Returns measure of equality (for two floats), in unit\n     of decimal significant figures.\"\"\"\n  if a == b:\n    return float(\"infinity\")\n  difference = abs(a - b)\n  avg = (a + b)/2\n  return math.log10( avg / difference )\n\n\nif closeness(1000, 1000.1) &gt; 3:\n  print \"Joy!\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There is a interesting solution to this by B. Dawson (with C++ code)\nat \"Comparing Floating Point Numbers\".", "His approach relies on strict IEEE representation of two numbers and the enforced lexicographical ordering when said numbers are represented as unsigned integers."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\"Comparing Floating Point Numbers\"", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"}]}]]