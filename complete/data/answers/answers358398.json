[[{"text": ["What you're talking about is establishing a \"session\".", "That is, a way to remember the user and the state of their transaction."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There are several ways of tackling this, all of which rely on techniques for remembering that you're in a session in the first place."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["HTTP provides you no help.", "You have to find some place to save session state on the server, and some place to record session identification on the client.", "The two big techniques are"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["Use a cookie to identify the session.", "Seamless and silent."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Use a query string in the URL to identify the session.", "Obvious because you have a ?sessionid=SomeSessionGUID in your URL's.", "This exposes a lot and makes bookmarking annoying.", "After the session is cleaned up, you still have this session id floating around in people's bookmarks."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "?sessionid=SomeSessionGUID", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In a limited way, you can also use hidden fields in a form.", "This only works if you have forms on every page.", "Not always true."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]}, {"text": ["Here's how it plays out in practice."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["You can do the same thing with a query string instead of a cookie.", "Or a hidden field on a form.  "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["It is not a problem of how the instances are managed.", "Because HTTP is stateless, your program is, virtually, stateless too.", "(For long running processes, like GAE, it is possible to make it otherwise, but I am not sure you would need this complexity here)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You haven't supplied any code, but I am assuming you get a POST and then you redirect to results (which is a GET).", "So it should be easy to preserve the parameter:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "redirect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Post/Redirect/Get"}]}, {"code": "<pre>\n<code>\n def save_foo(request):\n    if request.method == 'POST':\n        save(request.POST)\n        return HttpRedirect(reverse(\n            'Some_Target',\n            {'bar': 'baz', 'foo': request.POST['foo']}))\n    else:\n        # do something else\n</code>\n</pre>\n", "senID": 2}, {"text": ["This view, in case of a POST, casues the client to issue a GET request to whatever URL is aliased Some_Target.", "And this GET will include foo parameter from the POST."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Some_Target", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This solution is for a single view.", "If you need this behaviour project-wise you can use a middleware for it.", "And this time caching the variable makes sense."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["There are two things that make me a little uncomfortable with this approach:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["In any case I would avoid caching on instances."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["HTTP is stateless, so you have no (built-in) way of knowing if the user that loads one page is the same user that loaded another.", "Further, even if you do know that, thanks to session cookies, for example, you have no way of telling if the browser window they're loading the subsequent page in is the same one they loaded the prior page in.", "The user could have multiple tabs accessing your site, and you don't want one page's state change to clobber another's."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With that in mind, your best option is to include query parameters in the link to the page being fetched with GET, encoding the variables you want to send to the 'get' page (make sure they're not sensitive, since the user can modify them!).", "Then  you can access them through self.request.GET in the get request."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I don't know specifically about the google app engine, but normally, here's what happens:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The server would have some kind of thread pool.", "Every time an http request is sent to the server, a thread is selected from the pool or created."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In that thread an instance of some kind of controller object will be created.", "This object will decide what to do with the request (like instantiating other classes and preprocessing the http request parameters).", "Usually, this object is the core of web frameworks.", "The request parameters are also resent by the browser every time (the server cannot guess what the browser wants)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Web servers usually have state stores for objects in a permanent or a session state.", "The session is represented by a unique user (usually by a cookie or a GUID in the url), which expires after a certain time."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Now in your case, you would need to take the values you got from your first function, store that in the session store and in the second function, get those values back from the session store."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Another solution would be to send the items back to the page as url parameters in your generated HTML from the first function and then you would get those back \"as usual\" from your second function."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Why not just use memcache to temporarily store the variable, and then redirect to the POST URL?", "That seems like the easiest solution. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["OK -- Thanks everyone. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'll try some of these ideas out, soon, and get back to you all. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It seems I can work around some these things by doing a lot of writing and reading from the datastore*, but I thought there might be an easier way of keeping that instance of the class around (I'm trying to use my known techniques in a web framework that I don't completely get yet). "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["*For instance, creating a unique record based on the data in the POST, and letting some variables \"tag along\".", "Is this a bad practice? "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]