[[{"text": ["I assume you're using TCP.", "TCP is a stream based protocol with no idea of packets or message boundaries."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This means when you do a read you may get less bytes than you request.", "If your data is 128k for example you may only get 24k on your first read requiring you to read again to get the rest of the data."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For an example in C:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n int read_data(int sock, int size, unsigned char *buf) {\n   int bytes_read = 0, len = 0;\n   while (bytes_read &lt; size &amp;&amp; \n         ((len = recv(sock, buf + bytes_read,size-bytes_read, 0)) &gt; 0)) {\n       bytes_read += len;\n   }\n   if (len == 0 || len &lt; 0) doerror();\n   return bytes_read;\n}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As far as I know, this behaviour is perfectly reasonable.", "Sockets may, and probably will fragment your data as they transmit it.", "You should be prepared to handle such cases by applying appropriate buffering techniques."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "will", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["On other hand, if you are transmitting the data on the localhost and you are indeed getting only 4 bytes it probably means you have a bug somewhere else in your code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["EDIT: An idea - try to fire up a packet sniffer and see whenever the packet transmitted will be full or not; this might give you some insight whenever your bug is in your client or in your server."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT: An idea - try to fire up a packet sniffer and see whenever the packet transmitted will be full or not; this might give you some insight whenever your bug is in your client or in your server.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["The simple answer to your question, \"Read from socket: Is it guaranteed to at least get x bytes?", "\", is no.", "Look at the doc strings for these socket methods:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "no", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import socket\n&gt;&gt;&gt; s = socket.socket()\n&gt;&gt;&gt; print s.recv.__doc__\nrecv(buffersize[, flags]) -&gt; data\n\nReceive up to buffersize bytes from the socket.  For the optional flags\nargument, see the Unix manual.  When no data is available, block until\nat least one byte is available or until the remote end is closed.  When\nthe remote end is closed and all data is read, return the empty string.\n&gt;&gt;&gt; \n&gt;&gt;&gt; print s.settimeout.__doc__\nsettimeout(timeout)\n\nSet a timeout on socket operations.  'timeout' can be a float,\ngiving in seconds, or None.  Setting a timeout of None disables\nthe timeout feature and is equivalent to setblocking(1).\nSetting a timeout of zero is the same as setblocking(0).\n&gt;&gt;&gt; \n&gt;&gt;&gt; print s.setblocking.__doc__\nsetblocking(flag)\n\nSet the socket to blocking (flag is true) or non-blocking (false).\nsetblocking(True) is equivalent to settimeout(None);\nsetblocking(False) is equivalent to settimeout(0.0).\n</code>\n</pre>\n", "senID": 1}, {"text": ["From this it is clear that recv() is not required to return as many bytes as you asked for.", "Also, because you are calling settimeout(10.0), it is possible that some, but not all, data is received near the expiration time for the recv().", "In that case recv() will return what it has read - which will be less than you asked for (but consistenty &lt; 4 bytes does seem unlikely)."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "recv()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "settimeout(10.0)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "recv()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "recv()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You mention datagram in your question which implies that you are using (connectionless) UDP sockets (not TCP).", "The distinction is described here.", "The posted code does not show socket creation so we can only guess here, however, this detail can be important.", "It may help if you could post a more complete sample of your code."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "datagram", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "described here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Packet%5F%28information%5Ftechnology%29#Packets%5Fvs.%5Fdatagrams"}]}, {"text": ["If the problem is reproducible you could disable the timeout (which incidentally you do not seem to be handling) and see if that fixes the problem."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["This is just the way TCP works.", "You aren't going to get all of your data at once.", "There are just too many timing issues between sender and receiver including the senders operating system, NIC, routers, switches, the wires themselves, the receivers NIC, OS, etc.", "There are buffers in the hardware, and in the OS."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can't assume that the TCP network is the same as a OS pipe.", "With the pipe, it's all software so there's no cost in delivering the whole message at once for most messages.", "With the network, you have to assume there will be timing issues, even in a simple network."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["That's why recv() can't give you all the data at once, it may just not be available, even if everything is working right.", "Normally, you will call recv() and catch the output.", "That should tell you how many bytes you've received.", "If it's less than you expect, you need to keep calling recv() (as has been suggested) until you get the correct number of bytes.", "Be aware that in most cases, recv() returns -1 on error, so check for that and check your documentation for ERRNO values.", "EAGAIN in particular seems to cause people problems.", "You can read about it on the internet for details, but if I recall, it means that no data is available at the moment and you should try again."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also, it sounds like from your post that you're sure the sender is sending the data you need sent, but just to be complete, check this:\nhttp://beej.us/guide/bgnet/output/html/multipage/advanced.html#sendall"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://beej.us/guide/bgnet/output/html/multipage/advanced.html#sendall", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://beej.us/guide/bgnet/output/html/multipage/advanced.html#sendall"}]}, {"text": ["You should be doing something similar on the recv() end to handle partial receives.", "If you have a fixed packet size, you should read until you get the amount of data you expect.", "If you have a variable packet size, you should read until you have the header that tells you how much data you send(), then read that much more data."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["From the Linux man page of recv http://linux.about.com/library/cmd/blcmdl2_recv.htm:  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://linux.about.com/library/cmd/blcmdl2_recv.htm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://linux.about.com/library/cmd/blcmdl2%5Frecv.htm"}]}, {"text": ["So, if your sender is still transmitting bytes, the call will only give what has been transmitted so far."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If the sender sends 515 bytes, and your BUFSIZE is 512, then the first recv will return 512 bytes, and the next will return 3 bytes... Could this be what's happening?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(This is just one case amongst many which will result in a 3-byte recv from a larger send...)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you are still interested, patterns like this :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # 4 bytes are needed here ......\n# read remainder of datagram...\n</code>\n</pre>\n", "senID": 1}, {"text": ["may create the silly window thing."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Check this out"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://tangentsoft.net/wskfaq/intermediate.html#silly-window"}]}], [{"text": ["If indeed you are using UDP datagrams, then \"partial\" recv()'s should not be possible as long as your receive buffer is large enough."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Refer to this other StackOverflow post: C: non-blocking udp socket: what do I get?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "C: non-blocking udp socket: what do I get?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2239986/c-non-blocking-udp-socket-what-do-i-get/2240771#2240771"}]}]]