[[{"text": ["This isn't a coding problem, it's a social problem.", "By creating the code you are creating a contract -- give me these arguments in this order and I'll give you a result.", "Sometime later, someone is choosing to break that contract.", "To what end?", "Why would someone on your team think it's OK to make a backwards-incompatible change in such a manner?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Update:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I realized that using **kwargs would not solve the problem.", "If your programmers change function arguments as they wish, one could, for example, change the function to this:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "**kwargs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def info(foo, **kwargs):\n</code>\n</pre>\n", "senID": 2}, {"text": ["and the old code would break again (because now every function call has to include the first argument)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It really comes down to what Bryan says."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In general, when changing functions, new arguments should always go to the end.", "Otherwise it breaks the code.", "Should be obvious.", "If someone changes the function so that the code breaks, this change has to be rejected.", "(As Bryan says, it is like a contract)"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"text": ["By looking at the signature of the function (i.e def info(object, spacing=10, collapse=1) ) one should immediately see that every argument that has not a default value, is mandatory.", "What the argument is for, should go into the docstring."], "childNum": 5, "tag": "p", "senID": 6, "childList": [{"text": "def info(object, spacing=10, collapse=1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "What", "childNum": 1, "tag": "strong", "childList": [{"text": "What", "tag": "em"}]}, {"text": "What", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Old answer (kept for completeness):"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Old answer (kept for completeness)", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["This is probably not a good solution:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "This is probably not a good solution:", "childNum": 0, "tag": "strike", "pos": 0, "childList": []}]}, {"text": ["You can define functions this way:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def info(**kwargs):\n    ''' Some docstring here describing possible and mandatory arguments. '''\n    spacing = kwargs.get('spacing', 15)\n    obj = kwargs.get('object', None)\n    if not obj:\n       raise ValueError('object is needed')\n</code>\n</pre>\n", "senID": 10}, {"text": ["kwargs is a dictionary that contains any keyword argument.", "You can check whether a mandatory argument is present and if not, raise an exception."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "kwargs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The downside is, that it might not be that obvious anymore, which arguments are possible, but with a proper docstring, it should be fine."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"senID": 13}], [{"text": ["You could use the ** operator:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "**", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def info(**kwargs):\n</code>\n</pre>\n", "senID": 1}, {"text": ["this way people are forced to use named parameters."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could declare your functions as receiving **args only.", "That would mandate keyword arguments but you'd have some extra work to make sure only valid names are passed in. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "**args", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def foo(**args):\n   print args\n\nfoo(1,2) # Raises TypeError: foo() takes exactly 0 arguments (2 given)\nfoo(hello = 1, goodbye = 2) # Works fine.\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def cheeseshop(kind, *arguments, **keywords):\n</code>\n</pre>\n", "senID": 0}, {"text": ["in python if use *args that means you can pass n-number of arguments for this parameter - which will be come a list inside function to access"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["and if use **kw that means its keyword arguments, that can be access as dict - you can pass n-number of kw args, and if you want to restrict that user must enter the sequence and arguments in order then don't use * and ** - (its pythonic way to provide generic solutions for big architectures...)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["if you want to restrict your function with default values then you can check inside it"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def info(object, spacing, collapse)\n  spacing = spacing or 10\n  collapse = collapse or 1\n</code>\n</pre>\n", "senID": 4}], [{"text": ["As other answers say, changing function signatures is a bad idea.", "Either add new parameters to the end, or fix every caller if arguments are inserted."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you still want to do it, use a function decorator and the inspect.getargspec function.", "It would be used something like this:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "function decorator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=240808"}, {"text": "inspect.getargspec", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/inspect.html"}]}, {"code": "<pre>\n<code>\n @require_named_args\ndef info(object, spacing=10, collapse=1):\n    ....\n</code>\n</pre>\n", "senID": 2}, {"text": ["Implementation of require_named_args is left as an exercise for the reader."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "require_named_args", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I would not bother.", "It will be slow every time the function is called, and you will get better results from writing code more carefully."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I don't get why a programmer will add a parameter in between two others in the first place. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want the function parameters to be used with names (e.g.", "info(spacing=15, object=odbchelper) ) then it shouldn't matter what order they are defined in, so you might as well put the new parameters at the end. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "info(spacing=15, object=odbchelper)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If you do want the order to matter then can't expect anything to work if you change it!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]