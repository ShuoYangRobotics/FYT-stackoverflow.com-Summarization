[[{"text": ["You could combine all the items into one regexp like this which will be more efficient"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nitem_list = ['item1', 'item2']\nregex = re.compile(\"^(\"+\"|\".join(item_list)+\")\\.\")\nsearch_list = ['item1.exe', 'item2.pdf']\nmatches = []\nfor file in search_list:\n    match = regex.match(file)\n    if match:\n        matches.append((match.group(1), file))\n</code>\n</pre>\n", "senID": 1}, {"text": ["A better solution might be to parse the filenames using os.path functions though to parse out the basenames and look for them in a set."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Use splitext to get the filename without the extension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os.path\n\nfor item in item_list:\n    for filename in search_list:\n        if item == os.path.splitext(filename)[0]:\n            matches.append((item, file))\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's more correct, but it's also easier to understand what your intention is from reading the code.", "Alternatively, if you want to allow foo to match foo.bar.txt then use filename.startswith(item + '.", "') instead."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You do not need to use a regex for this since you are doing exact string matches (no wildcards, groups etc) - you can use str.startswith(..) instead.", "This is equivalent to your code:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "str.startswith(..)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for item in item_list:\n    match = item + \".\"\n    for file in search_list:\n        if file.startswith(match)\n            matches.append((item, file))\n</code>\n</pre>\n", "senID": 1}, {"text": ["However Nick Craig-Wood's suggestion of compiling all the matches into a single regex may be more efficient - I suggest you benchmark both if speed is an issue."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Avoid re unless you really need it.", "For simple string matching, you don't really need it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Mark Byers's answer duplicates the original behaviour of keeping matches in item_list-order.", "If you don't need that, you could do it even more simply/quickly:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "matches", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "item_list", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n for file in search_list:\n    item= os.path.splitext(file)[0]\n    if item in item_list:\n        matches.append((item, file))\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you don't need to keep the (item) matched either (since it's redundant from the filename anyway), you've got a one-liner:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "(item)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n matches= [file for file in search_list if os.path.splitext(file)[0] in item_list]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here's another way to do it that is likely faster than Alex's original code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n item_list = ['item1', 'item2']\nsearch_list = ['item1.exe', 'item2.pdf']\nmatches = []\nfor item in item_list:\n    for filename in search_list:\n        if filename.partition(\".\")[0] == item:\n            matches.append((item,filename))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think you should use .rsplit(\".", "\",1) for that purpose, regex aren't overkill?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": ".rsplit(\".\",1)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; item_list = ['item1', 'item2','item3']\n&gt;&gt;&gt; search_list = ['item1.exe', 'item2.pdf','item9999.txt']\n&gt;&gt;&gt;\n&gt;&gt;&gt; [(x.rsplit(\".\",1)[0],x) for x in search_list if x.rsplit(\".\",1)[0] in item_list]\n[('item1', 'item1.exe'), ('item2', 'item2.pdf')]\n</code>\n</pre>\n", "senID": 1}, {"text": ["or with for loop"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n matches=[]\nfor x in search_list:\n    y=x.rsplit(\".\",1)[0]\n    if y in item_list:\n        matches.append((y,x))\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; for file in search_list:\n...  tomatch=file.split(\".\")[0]\n...  if tomatch in item_list:\n...     found=item_list.index(tomatch)\n...     matches.append( ( file, item_list[found] ) )\n...\n&gt;&gt;&gt; print matches\n[('item1.exe', 'item1'), ('item2.pdf', 'item2')]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}, {"text": ["No need for regex."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]