[[{"code": "<pre>\n<code>\n l1 = [68, 31, 93, 35,10]\nl2 = [93, 0, 22, 10, 99, 33, 21,9]\n\nl1 + [x for x in l2 if not x in l1]\n# [68, 31, 93, 35, 10, 0, 22, 99, 33, 21, 9]\n\n[x for x in l1 if not x in l2]\n# [68, 31, 35]\n</code>\n</pre>\n", "senID": 0}, {"text": ["EDIT: for long lists, you don't want to do all those list lookups.", "Here are two other recipes:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["union:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from collections import OrderedDict\nOrderedDict().fromkeys(l1+l2).keys()\n# [68, 31, 93, 35, 10, 0, 22, 99, 33, 21, 9]\n</code>\n</pre>\n", "senID": 3}, {"text": ["difference:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n s = set(l2)\n[x for x in l1 if not x in s]\n# [68, 31, 35]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Assuming inputs l1 and l2, you can calculate their ordered union with:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "l1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "l2", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n l1 + filter(lambda x: x not in l1, l2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["To get the ordered difference l1 - l2, write"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n filter(lambda x: x not in l2, l1)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Alternatively, use list comprehensions:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l1 = [68,31,93,35,10]\n&gt;&gt;&gt; l2 = [93,0,22,10,99,33,21,9]\n&gt;&gt;&gt; l1 + [el2 for el2 in l2 if el2 not in l1]\n[68, 31, 93, 35, 10, 0, 22, 99, 33, 21, 9]\n&gt;&gt;&gt; [el1 for el1 in l1 if el1 not in l2]\n[68, 31, 35]\n</code>\n</pre>\n", "senID": 5}, {"text": ["If you're doing this with very large list (where performance is an issue), construct a set  for faster lookup:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sl1 = set(s1)\n&gt;&gt;&gt; l1 + [el2 for el2 in l2 if el2 not in sl1]\n[68, 31, 93, 35, 10, 0, 22, 99, 33, 21, 9]\n&gt;&gt;&gt; sl2 = set(s2)\n&gt;&gt;&gt; [el1 for el1 in l1 if el1 not in sl2]\n[68, 31, 35]\n</code>\n</pre>\n", "senID": 7}], [{"code": "<pre>\n<code>\n def unique_chain(*iters):\n    seen = set()\n    for it in iters:\n        for item in it:\n            if item not in seen:\n                yield item\n                seen.add(item)\n\nprint list(unique_chain([68, 31, 93, 35,10], [93, 0, 22, 10, 99, 33, 21,9]))\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [68,31,93,35,10]\n&gt;&gt;&gt; b = [93,0,22,10,99,33,21,9]\n&gt;&gt;&gt; result= []\n&gt;&gt;&gt; temp = a + b\n&gt;&gt;&gt; [result.append(x) for x in temp if x not in result]\n&gt;&gt;&gt; result\n    [68, 31, 93, 35, 10, 0, 22, 99, 33, 21, 9]\n&gt;&gt;&gt; a = set(a)\n&gt;&gt;&gt; b = set(b)\n&gt;&gt;&gt; a - b\n    set([35, 68, 31])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Maybe you could use an OrderedSet"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "OrderedSet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import collections\n\nclass OrderedSet(collections.MutableSet):\n    def __init__(self, iterable, *args, **kwargs):\n        super(OrderedSet, self).__init__(*args, **kwargs)\n        self._data = collections.OrderedDict()\n        self.update(iterable)\n\n    def update(self, iterable):\n        self._data.update((x, None) for x in iterable)\n\n    def __iter__(self):\n        return iter(self._data)\n\n    def __contains__(self, value):\n        return value in self._data\n\n    def __len__(self):\n        return len(self._data)\n\n    def __le__(self, other):\n        if isinstance(other, OrderedSet):\n            return self._data &lt;= other._data\n        return super(OrderedSet, self).__le__(other)\n\n    def __and__(self, other):\n        # Overrided by make the order of self the preferred one\n        if isinstance(other, collections.Set):\n            return self._from_iterable(value for value in self \n                                             if value in other)\n        return self &amp; set(other)\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def add(self, value):\n        self._data[value] = None\n\n    def discard(self, value):\n        self._data.pop(value, None)\n\n    def __repr__(self):\n        return \"%s(%r)\" % (type(self).__name__, self._data.keys())\n</code>\n</pre>\n", "senID": 1}], [{"text": ["After defining the first two lists as such,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [68,31,93,35,10]\nb = [93,0,22,10,99,33,21,9]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is the one-line solution to the first problem,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n c = [x for x in a+b if x not in set(a).intersection(set(b))]\n</code>\n</pre>\n", "senID": 3}, {"text": ["And the one-liner to the second problem,"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n d = [x for x in a+b if x not in b]\n</code>\n</pre>\n", "senID": 5}]]