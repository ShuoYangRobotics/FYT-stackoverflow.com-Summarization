[[{"text": ["This doesn't make much sense.", "You so rarely need to \"check\" a type.", "You simply run unit tests and if you've provided the wrong type object, things fail.", "You never need to \"check\" much, in my experience."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Unexpected None is a plain-old bug.", "80% of the time, I omitted the return.", "Unit tests always reveal these."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Of those that remain, 80% of the time, they're plain old bugs due to an \"early exit\" which returns None because someone wrote an incomplete return statement.", "These if foo: return structures are easy to detect with unit tests.", "In some cases, they should have been if foo: return somethingMeaningful, and in still other cases, they should have been if foo: raise Exception(\"Foo\").  "], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "if foo: return", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "if foo: return somethingMeaningful", "childNum": 0, "tag": "code", "childList": []}, {"text": "if foo: raise Exception(\"Foo\")", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The rest are dumb mistakes misreading the API's.", "Generally, mutator functions don't return anything.", "Sometimes I forget.", "Unit tests find these quickly, since basically, nothing works right."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["That covers the \"unexpected None\" cases pretty solidly.", "Easy to unit test for.", "Most of the mistakes involve fairly trivial-to-write tests for some pretty obvious species of mistakes: wrong return; failure to raise an exception."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Other \"has no attribute X\" errors are really wild mistakes where a totally wrong type was used.", "That's either really wrong assignment statements or really wrong function (or method) calls.", "They always fail elaborately during unit testing, requiring very little effort to fix."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Um...", "Harmless?", "If it's a bug, I pray that it brings down my entire app as quickly as possible so I can find it.", "A  bug that doesn't crash my app is the most horrible situation imaginable.", "\"Harmless\" isn't a word I'd use for a bug that fails to crash my app."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["If you write good unit tests for all of your code, you should find the errors very quickly when testing code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can also use decorators to enforce the type of attributes."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "decorators to enforce the type of attributes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonDecoratorLibrary#TypeEnforcement.28accepts.2BAC8-returns.29"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; @accepts(int, int, int)\n... @returns(float)\n... def average(x, y, z):\n...     return (x + y + z) / 2\n...\n&gt;&gt;&gt; average(5.5, 10, 15.0)\nTypeWarning:  'average' method accepts (int, int, int), but was given\n(float, int, float)\n15.25\n&gt;&gt;&gt; average(5, 10, 15)\nTypeWarning:  'average' method returns (float), but result is (int)\n15\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm not really a fan of them, but I can see their usefulness."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["One advantage of TDD is that you end up writing code that is easier to write tests for."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Writing code first and then the tests can result in code that superficially works the same, but is much harder to write 100% coverage tests for."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Each case is likely to be different"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It might make sense to have a decorator to check whether a particular parameter is None (or some other unexpected value) if you use it in a bunch of places."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Maybe it is appropriate to use the Null pattern - if the code is blowing up because you are setting the initial value to None, you could instead set the initial value to a null version of the object."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Null pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Null_Object_pattern"}]}, {"text": ["More and more wrappers can add up to quite a performance hit though, so it's always better to write code from the start that avoids the corner cases"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["One tool to try to help you keep your pieces fitting together well is interfaces.", "zope.interface is the most notable package in the Python world for using interfaces.", "Check out http://wiki.zope.org/zope3/WhatAreInterfaces and http://glyph.twistedmatrix.com/2009/02/explaining-why-interfaces-are-great.html to start to get an idea how interfaces and z.i in particular work.", "Interfaces can prove very useful in a large Python codebases."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "interfaces", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "zope.interface", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "http://wiki.zope.org/zope3/WhatAreInterfaces", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://wiki.zope.org/zope3/WhatAreInterfaces"}, {"text": "http://glyph.twistedmatrix.com/2009/02/explaining-why-interfaces-are-great.html", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://glyph.twistedmatrix.com/2009/02/explaining-why-interfaces-are-great.html"}]}, {"text": ["Interfaces are no substitute for testing.", "Reasonably comprehensive testing is especially important in highly dynamic languages like Python where there are types of bugs that could not exist in a statically types language.", "Tests will also help you catch the sorts of bugs that are not unique to dynamic languages.", "Fortunately, developing in Python means that testing is easy (due to the flexibility) and you have plenty of time to write them that you saved because you're using Python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["With duck typing, it shouldn't be necessary to check a type.", "But that's theory, in reality you will often want to validate input parameters (e.g.", "checking a UUID with a regex).", "For that purpose, I created myself some handy decorators for simple type and return type checking which are called like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @decorators.params(0, int, 2, str) # first parameter must be integer / third a string\n@decorators.returnsOrNone(int, long) # must return an int/long value or None\ndef doSomething(integerParam, noMatterWhatParam, stringParam):\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["For everything else I mostly use assertions.", "Of course one often forgets to check a parameter, so it's necessary to test and to test often."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Happens to me very seldom.", "Actually I often use methods instead of direct access to attributes (the \"good\" old getter/setter approach sometimes)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["\"Software is always completed at the customers'.", "\" - An anti-pattern which you should solve with unit tests that handle all possible cases in a function.", "Easier said than done, but it helps..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["As for other common Python mistakes (mistyped names, wrong imports, ...), I'm using Eclipse with PyDev for projects (not for small scripts).", "PyDev warns you about most of the simple kinds of mistakes."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I haven\u2019t done a lot of Python programming, but I\u2019ve done no programming at all in staticly typed languages, so I don\u2019t tend to think about things in terms of variable types.", "That might explain why I haven\u2019t come across this problem much.", "(Although the small amount of Python programming I\u2019ve done might explain that too."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I do enjoy Python 3\u2019s revised handling of strings (i.e.", "all strings are unicode, everything else is just a stream of bytes), because in Python 2 you might not notice TypeErrors until dealing with unusual real world string values."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "TypeError", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I tend to use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if x is None:\n    raise ValueError('x cannot be None')\n</code>\n</pre>\n", "senID": 1}, {"text": ["But this will only work with the actual None value."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["A more general approach is to test for the necessary attributes before you try to use them.", "For example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def write_data(f):\n    # Here we expect f is a file-like object.  But what if it's not?\n    if not hasattr(f, 'write'):\n        raise ValueError('write_data requires a file-like object')\n    # Now we can do stuff with f that assumes it is a file-like object\n</code>\n</pre>\n", "senID": 4}, {"text": ["The point of this code is that instead of getting an error message like \"NoneType has no attribute write\", you get \"write_data requires a file-like object\".", "The actual bug isn't in write_data(), and isn't really a problem with NoneType at all.", "The actual bug is in the code that calls write_data().", "The key is to communicate that information as directly as possible."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "write_data()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "NoneType", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "calls", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "write_data()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Something you can use to simplify your code is using the Null Object Design Pattern (to which I was introduced in Python Cookbook)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Null Object Design Pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/68205-null-object-design-pattern/"}, {"href": "http://books.google.com.ar/books?id=Q0s6Vgb98CQC&pg=PT311&lpg=PT311&dq=Null+object+python+cookbook&source=bl&ots=hc3368UkpC&sig=qRrDqvZwg4FIoMuKo3JJhI7Bu_g&hl=es&ei=TiqpS5jZEMuVtgf08YGnAQ&sa=X&oi=book_result&ct=result&resnum=4&ved=0CBYQ6AEwAw#v=onepage&q=&f=false", "text": "Python Cookbook", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["This object just eats the lack of attribute error, and you can avoid checking for their existence."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It's nothing more than"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Null(object):\n\n    def __init__(self, *args, **kwargs):\n        \"Ignore parameters.\"\n        return None\n\n    def __call__(self, *args, **kwargs):\n        \"Ignore method calls.\"\n        return self\n\n    def __getattr__(self, mname):\n        \"Ignore attribute requests.\"\n        return self\n\n    def __setattr__(self, name, value):\n        \"Ignore attribute setting.\"\n        return self\n\n    def __delattr__(self, name):\n        \"Ignore deleting attributes.\"\n        return self\n\n    def __repr__(self):\n        \"Return a string representation.\"\n        return \"&lt;Null&gt;\"\n\n    def __str__(self):\n        \"Convert to a string and return it.\"\n        return \"Null\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["With this, if you do Null(\"any\", \"params\", \"you\", \"want\").attribute_that_doesnt_exists() it won't explode, but just silently become the equivalent of pass."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Null(\"any\", \"params\", \"you\", \"want\").attribute_that_doesnt_exists()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pass", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Normally you'd do something like"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n if obj.attr:\n    obj.attr()\n</code>\n</pre>\n", "senID": 6}, {"text": ["With this, you just do:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n obj.attr()\n</code>\n</pre>\n", "senID": 8}, {"text": ["and forget about it.", "Beware that extensive use of the Null object can potentially hide bugs in your code."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Null", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]