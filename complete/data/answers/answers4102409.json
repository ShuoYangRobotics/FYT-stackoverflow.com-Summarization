[[{"text": ["One option is to do it the other way round: generate a huge number of them in the database whenever you need to, then either fetch a single one from the DB when you need one, or reserve a whole bunch of them for your particular process (i.e.", "mark them as \"potentially used\" in the database) and then dole them out from memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I question that your \"inefficient\" approach is actually inefficient.", "Consider this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "There are 36^8 == 2,821,109,907,456 (2.8 Trillion) possible IDs.", "tag": "none", "senID": 1}, {"text": "If you have N existing IDs, the chance of a new randomly generated ID colliding is N in ~2.8 trillion.", "tag": "none", "senID": 2}, {"text": "Unless N is in the hundreds of billions, you \"generate a unique ID and querying the DB to see if it already exists\" algorithm will almost always terminate in one cycle.", "tag": "none", "senID": 3}]}, {"text": ["With careful design, you should be able to generate a guaranteed unique ID in one database request, almost all of the time ... unless you have an awfully large number of existing IDs.", "(And if you do, just add another couple of characters to the ID and the problem goes away again."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you want to, you can reduce the average number of database operations to less than one per ID by generating the IDs in batches, but their are potential complications, especially if you need to record the number of IDs that are actually in use."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["But, if you have at most 150,000 IDs (I assume, generated over a long period of time) then creating the IDs in batches is not worth the effort ... unless you are doing a bulk upload operation."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["the answer is YES you simply have to generate them randomly, and then, check that you have not used that one already."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "YES", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "YES", "tag": "em"}]}, {"text": "YES", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["This is exactly how your bank account number, and the like, is created.", "(But see below."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(Of course there is only a tiny chance you will get a collision, but you have to check.", "On systems like this, I always have it email the admin or make a note somewhere, if there is a collision.", "Indeed, the fact that there is a collision (or many collisions!", ") is your signal that something has gone wrong."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note that there is absolutely nothing \"inefficient\" about this.", "In the course of establishing a new user you will be doing 10s of 100s of big database lookups (\"that username already exists\" \"your cousin is already a member\" \"that branch ID does not exist\" etc etc).", "It is utterly no big deal to check that the Human-Known-User-Id is unique."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Note that of course you have to lock up the relevant table (or whatever you're working with) while you create one and check that it's unique.", "On a huge world-wide commercial system with multiple access and creation that is a bit of a hassle."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Note that of course you have to lock up the relevant table", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "Note that of course you have to lock up the relevant table", "tag": "strong"}]}, {"text": "Note that of course you have to lock up the relevant table", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Here's a probably BETTER APPROACH, Bradford.", "This is what is usually done in large commercial systems.", "Just make up a big list of them (ie, generate millions of them randomly, beforehand, and check that they are all unique as you generate).", "Then have a little server that shoots them out (being careful to lock up, etc etc).", "That's the actual answer to how it's done on a large commercial system."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "Here's a probably BETTER APPROACH", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "Here's a probably BETTER APPROACH", "tag": "strong"}]}, {"text": "Here's a probably BETTER APPROACH", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["(Really, having gotten a supposedly-not-yet-used new ID from such a server, I would still just check that it has not been used already, as a failsafe.", "It would be crazy not to - it's only one DB call, and you're making 10s/100s DB calls to set up a new account."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "still", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["By the way, normally Human-Readable-Ids are NOT SO RANDOM.", "You would almost certainly not have zeros at the start.", "And many companies don't like zeros at the end.", "Personally I think you should never have three of anything in a row, and most large commercial systems enforce that for IDs (even two in a row is perhaps no good - it's your choice).", "If you are using letters (\"your code is XMJUYTD\") you will almost certainly simply leave out problem letters (I, O, etc).", "If you are mixing letters and numbers, you would probably leave out number zero.", "So, it's not so easy to construct a tasteful human-side-userID that makes you and customers happy!"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["In summary"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["(1) Almost certainly in practice, premake a big list of them and use that."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "(1) Almost certainly in practice, premake a big list of them and use that.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["(2) Don't forget to lock up and so on."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "(2) Don't forget to lock up and so on.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["(3) There is nothing whatsoever \"inefficient\" about what you describe; you describe how it is actually done in real life on big systems."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "(3) There is nothing whatsoever \"inefficient\" about what you describe; you describe how it is actually done in real life on big systems.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Unfortunately, 8 base 36 digits is a bit small.", "It's only 2 million million possible IDs, so if you generate 1.4 million randomly you have about a half chance of a collision."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could possibly use a PRNG with a large period, and map its current state to your ID space via some bijection.", "A 41 bit LFSR wouldn't be uncrackable, but might be reasonably OK if the thing you're protecting isn't all that valuable.", "You could distribute somewhat without having to access the DB all the time, by providing different nodes with a different position to start the cycle."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The trouble with any such deterministic method, of course, is that once it's broken it's completely broken, and you can no longer trust any IDs.", "So doling numbers out of a database is probably the way to go, and distribute by doling them out in batches of a thousand or whatever."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you had a larger ID space, then you could use more secure techniques, for example the ID could consist of something to identify the source, an incrementing serial number for that source, and an HMAC using a key unique to the source."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If there is only one source of IDs (that is: you don't need to coordinate multiple independent sources on different machines) you can do the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["Calculate the maximum number of bits that a number may have so that it doesn't exceed the information contained in an 8-symbol string of 0-9A-Z.", "This would be floor(log2(36^8)) = 41 bits."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "floor(log2(36^8))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Have a counter (with 41 bits) start at zero"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": "Return ", "tag": "none", "senID": 3}]}, {"text": ["The transform function has to be bijective and can be an arbitrarily long sequence of the following operations (which are all bijective themselves when they are calculated modulo 2^41):"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "transform", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2^41", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "ul", "num": 4, "lis": [{"text": "xor with a fixed value", "tag": "none", "senID": 5}, {"text": "rotate left or right by a fixed value", "tag": "none", "senID": 6}, {"text": "reorder the bits by a fixed mapping (a generalization of the rotation above)", "tag": "none", "senID": 7}, {"text": "add or subtract a fixed value", "tag": "none", "senID": 8}]}, {"text": ["When you are finished with that, you only need another function encode(number) to transform the number to base36."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "encode(number)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here's some python code for generating random, base36 IDs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\n\ndef base36encode(number, alphabet='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'):\n    '''\n    Convert positive integer to a base36 string.\n\n    Source: http://en.wikipedia.org/wiki/Base_36#Python_Conversion_Code\n    '''\n    if not isinstance(number, (int, long)):\n        raise TypeError('number must be an integer')\n\n    # Special case for zero\n    if number == 0:\n        return '0'\n\n    base36 = ''\n\n    sign   = \"\"\n    if number &lt; 0:\n        sign  ='-'\n        number=-number\n\n    while number != 0:\n        number, i = divmod(number, len(alphabet))\n        base36 = alphabet[i] + base36\n\n    return sign + base36\n\ndef generateID(length=8):\n    '''Generates a base36 ID.'''\n\n    random.seed()\n    id = base36encode(random.randint(0, (36**length)-1))\n\n    # append 0s to ensure desired length\n    while len(id) &lt; length:\n        id = '0' + id\n\n    return id\n\ndef generateMultipleIDs(n):\n    '''Generate n number of unique, base36 IDs.'''\n\n    output = set()\n\n    while len(output) &lt; n:\n        output.add(generateID())\n\n    return output\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I once solved a similar problem using C++ involving a smaller number of possible IDs, but there might be useful to consider some ways to scale it up.", "Basically I created a big bitmap for all the possible IDs and would just lookup whether one was in use by testing the proper bit for it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To minimize RAM requirements, I stored the bitmap in a raw binary file and used random-access file i/o to seek to the byte with the corresponding bit in it I needed to check and/or set."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Your much larger ID space would require a 328 GB bitmap, which is likely out of the question.", "On the other hand, a Python set of the used IDs might be acceptable, depending on how many IDs you think might actually end up being used.", "Other alternatives might be some sort of sparse file or sparse matrix technique, such as those in scipy.sparse."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sparse file", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sparse_file"}, {"href": "http://docs.scipy.org/doc/scipy/reference/sparse.html", "text": "scipy.sparse", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Hope this helps."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I do something similar to generate activation codes: 8-letter lowercase strings that are single-use.", "They are intended to be used within a short time of being generated (usually within minutes, but possibly not for up to a week), but must be unique.", "When they have been used, they are removed from the database."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I just generate a value and see if it is in use in the database.", "This works for now, because there are not heaps of unused codes sitting in the database, but are still not easy to guess, even if you have been provided with one."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As for the generation code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def _generate_code(self, length):\n    random.seed()\n    candidates = string.lowercase[:26]\n    result = \"\"\n    for i in range(length):\n        result += random.choice(candidates)\n    return result\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Does it need to be cryptographically secure? "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If not, pc(n) = a + bn, where b is prime relative to 36^8 will do.", "Use an array of byte."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n foo(int n, byte[] a, byte[] b) {\n  byte[] r = new byte[8];\n  int carry=0;\n  for(int i = 0; i&lt;8;i++) {\n    int x = carry + a[i] + n*b[i];\n    r[i] = x % 36;\n    carry = x / 36;      \n  }\n}\n</code>\n</pre>\n", "senID": 2}]]