[[{"text": ["Just for information, In python 2.7+, we can use Counter"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\n\nx=[1, 2, 3, 5, 6, 7, 5, 2]\n\n&gt;&gt;&gt; x\n[1, 2, 3, 5, 6, 7, 5, 2]\n\n&gt;&gt;&gt; y=collections.Counter(x)\n&gt;&gt;&gt; y\nCounter({2: 2, 5: 2, 1: 1, 3: 1, 6: 1, 7: 1})\n</code>\n</pre>\n", "senID": 1}, {"text": ["Unique List"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(y)\n[1, 2, 3, 5, 6, 7]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Items found more than 1 time"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [i for i in y if y[i]&gt;1]\n[2, 5]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Items found only one time"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [i for i in y if y[i]==1]\n[1, 3, 6, 7]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Use the in operator instead of calling __contains__ directly."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__contains__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What you have almost works (but is O(n**2)):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for i in xrange(len(list_a)):\n  for j in xrange(i + 1, len(list_a)):\n    if list_a[i] == list_a[j]:\n      print \"duplicate:\", list_a[i]\n</code>\n</pre>\n", "senID": 2}, {"text": ["But it's far easier to use a set (roughly O(n) due to the hash table):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n seen = set()\nfor n in list_a:\n  if n in seen:\n    print \"duplicate:\", n\n  else:\n    seen.add(n)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or a dict, if you want to track locations of duplicates (also O(n)):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import collections\nitems = collections.defaultdict(list)\nfor i, item in enumerate(list_a):\n  items[item].append(i)\nfor item, locs in items.iteritems():\n  if len(locs) &gt; 1:\n    print \"duplicates of\", item, \"at\", locs\n</code>\n</pre>\n", "senID": 6}, {"text": ["Or even just detect a duplicate somewhere (also O(n)):"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n if len(set(list_a)) != len(list_a):\n  print \"duplicate\"\n</code>\n</pre>\n", "senID": 8}], [{"text": ["You could always use a list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dups = [x for x in list_a if list_a.count(x) &gt; 1]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Before Python 2.3, use dict() :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lst = [1, 2, 3, 5, 6, 7, 5, 2]\n&gt;&gt;&gt; stats = {}\n&gt;&gt;&gt; for x in lst : # count occurrences of each letter:\n...     stats[x] = stats.get(x, 0) + 1 \n&gt;&gt;&gt; print stats\n{1: 1, 2: 2, 3: 1, 5: 2, 6: 1, 7: 1} # filter letters appearing more than once:\n&gt;&gt;&gt; duplicates = [dup for (dup, i) in stats.items() if i &gt; 1] \n&gt;&gt;&gt; print duplicates\n</code>\n</pre>\n", "senID": 1}, {"text": ["So a function :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def getDuplicates(iterable):\n    \"\"\"\n       Take an iterable and return a generator yielding its duplicate items.\n       Items must be hashable.\n\n       e.g :\n\n       &gt;&gt;&gt; sorted(list(getDuplicates([1, 2, 3, 5, 6, 7, 5, 2])))\n       [2, 5]\n    \"\"\"\n    stats = {}\n    for x in iterable : \n        stats[x] = stats.get(x, 0) + 1\n    return (dup for (dup, i) in stats.items() if i &gt; 1)\n</code>\n</pre>\n", "senID": 3}, {"text": ["With Python 2.3 comes set(), and it's even a built-in after than :"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def getDuplicates(iterable):\n    \"\"\"\n       Take an iterable and return a generator yielding its duplicate items.\n       Items must be hashable.\n\n       e.g :\n\n       &gt;&gt;&gt; sorted(list(getDuplicates([1, 2, 3, 5, 6, 7, 5, 2])))\n       [2, 5]\n    \"\"\"\n    try: # try using built-in set\n        found = set() \n    except NameError: # fallback on the sets module\n        from sets import Set\n        found = Set()\n\n    for x in iterable:\n        if x in found : # set is a collection that can't contain duplicate\n            yield x\n        found.add(x) # duplicate won't be added anyway\n</code>\n</pre>\n", "senID": 5}, {"text": ["With Python 2.7 and above, you have the collectionsmodule providing the very same function than the dict one, and we can make it shorter (and faster, it's probably C under the hood) than solution 1 :"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "collectionsmodule providing the very same function than the dict one", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "collections", "tag": "code"}]}, {"text": "collections", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import collections\n\ndef getDuplicates(iterable):\n    \"\"\"\n       Take an iterable and return a generator yielding its duplicate items.\n       Items must be hashable.\n\n       e.g :\n\n       &gt;&gt;&gt; sorted(list(getDuplicates([1, 2, 3, 5, 6, 7, 5, 2])))\n       [2, 5]\n    \"\"\"\n    return (dup for (dup, i) in collections.counter(iterable).items() if i &gt; 1)\n</code>\n</pre>\n", "senID": 7}, {"text": ["I'd stick with solution 2."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["If you're looking for one-to-one mapping between your nested loops and Python, this is what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n n = len(list_a)\nfor i in range(n):\n    for j in range(i+1, n):\n        if list_a[i] == list_a[j]:\n            print list_a[i]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The code above is not \"Pythonic\".", "I would do it something like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n seen = set()\nfor i in list_a:\n   if i in seen:\n       print i\n   else:\n       seen.add(i)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Also, don't use __contains__, rather, use in (as above)."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "__contains__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The following requires the elements of your list to be hashable (not just implementing __eq__ ).", "I find it more pythonic to use a defaultdict (and you have the number of repetitions for free):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__eq__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\nimport collections\nl = [1, 2, 4, 1, 3, 3]\nd = collections.defaultdict(int)\nfor x in l:\n   d[x] += 1\nprint [k for k, v in d.iteritems() if v > 1]\n# prints [1, 3]\n</pre>\n", "senID": 1}], [{"text": ["You could just \"translate\" it line by line."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["c++  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for (int i=0;i&lt;=list_a.length;i++)\n    for (int j=i+1;j&lt;=list_a.length;j++)\n        if (list_a[i]==list_a[j])\n            print list_a[i]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Python"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for i in range(0, len(list_a)):\n    for j in range(i + 1, len(list_a))\n        if list_a[i] == list_a[j]:\n            print list_a[i]\n</code>\n</pre>\n", "senID": 4}, {"text": ["c++ for loop:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for(int x = start; x &lt; end; ++x)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Python equivalent:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n for x in range(start, end):\n</code>\n</pre>\n", "senID": 8}], [{"text": ["A little bit more Pythonic implementation (not the most, of course), but in the spirit of your C code could be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i, elem in enumerate(seq):\n    if elem in seq[i+1:]:\n        print elem\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: yes, it prints the elements more than once if there're more than 2 repetitions, but that's what the op's C pseudo code does too."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]