[[{"text": ["The only real way to know would be to profile and measure.", "Your code could be doing anything.", "\"doSomething\" might be a time.sleep(10) in which case, forking off 10000000 processes would make the whole program run in approximately 10 seconds (ignoring the forking overhead and resulting slowdowns). "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "real", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "time.sleep(10)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "10000000", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Use http://docs.python.org/library/profile.html and check to see where the bottle necks are, see if you can optimise the \"fully optimised\" program using better coding.", "If it's already fast enough, stop."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/profile.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/profile.html"}]}, {"text": ["Then, depending on whether it's CPU or I/O bound and the hardware you have, you might want to try multiprocessing or threading.", "You can also try distributing to multiple machines and doing some map/reduce kind of thing if your problem can be broken down. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["To answer your last question first, if you have a problem with performance, then it's worth it.", "That's the only criterion, really."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As for how:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If your algorithm is slow because it's computationally expensive, consider rewriting it as a C extension, or use Cython, which will let you write fast extensions in a Python-esque language.", "Also, PyPy is getting faster and faster and may just be able to run your code without modification."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "C extension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/extending/index.html#extending-index"}, {"text": "Cython", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://cython.org/"}, {"text": "PyPy", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypy.org/"}]}, {"text": ["If the code is not computationally expensive, but it just loops a huge amount, it may be possible to break it down with Multiprocessing, so it gets done in parallel."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Lastly, if this is some kind of basic data splatting task, consider using a fast data store.", "All the major relational databases are optimised up the wazoo, and you may find that your task can be sped up simply by getting the database to do it for you.", "You may even be able to shape it to fit a Redis store, which can aggregate big data sets brilliantly."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Redis", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://redis.io/"}]}], [{"text": ["You could use the PyPy interpreter which has a JIT compiler built into it, it might actually improve performance over loops like this.", "Here is a link that explains some of the speed ups that the PyPy interpreter offers over regular CPython. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PyPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypy.org/"}, {"text": "link", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://speed.pypy.org/"}]}, {"text": ["Or you could write your code using Cython which allows native c extensions inside python.", "Huge chunks of numpy are written this way to get good speed ups."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Cython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cython.org/"}]}, {"text": ["Or you could forget using python and just write it in ASM.", "Sure it will be harder to do but when you see that your program runs ~1% faster than everyone elses?", "You will be happy you went that extra mile."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Besides what was already said you could check out cython.", "But profile before you do.", "Also, pypy might be worth checking out.", "There shouldn't be any work needed to make it work."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "cython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cython.org/"}, {"text": "pypy", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://pypy.org/"}]}], [{"text": ["If the tasks can be worked upon in parallel, you could investigate in using a process pool using the multiprocessing module and have the jobs distributed among the subprocesses."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It really depends on your application, but if doSomething can be threaded nicely (e.g.", "has a lot of heavy C code) then you might be interested to spawn multiple threads to do the work.", "The usual pattern goes something like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "doSomething", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def worker():\n    while True:\n        item = q.get()\n        do_work(item)\n        q.task_done()\n\nq = Queue()\nfor i in range(num_worker_threads):\n     t = Thread(target=worker)\n     t.daemon = True\n     t.start()\n\nfor item in source():\n    q.put(item)\n\nq.join()       # block until all tasks are done\n</code>\n</pre>\n", "senID": 1}]]