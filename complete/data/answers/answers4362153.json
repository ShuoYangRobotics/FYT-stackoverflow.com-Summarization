[[{"text": ["You could use such a construct to do currying:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "currying", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n curry = lambda f, a: lambda x: f(a, x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You might use it like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; add = lambda x, y: x + y\n&gt;&gt;&gt; add5 = curry(add, 5)\n&gt;&gt;&gt; add5(3)\n8\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It can be useful for temporary placeholders.", "Suppose you have a decorator factory:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @call_logger(log_arguments=True, log_return=False)\ndef f(a, b):\n    pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can temporarily replace it with"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n call_logger = lambda *a, **kw: lambda f: f\n</code>\n</pre>\n", "senID": 3}, {"text": ["It can also be useful if it indirectly returns a lambda:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import collections\ncollections.defaultdict(lambda: collections.defaultdict(lambda: collections.defaultdict(int)))\n</code>\n</pre>\n", "senID": 5}, {"text": ["It's also useful for creating callable factories in the Python console."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["And just because something is possible doesn't mean that you have to use it."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["This can be used to pull out some common repetitive code (there are of course other ways to achieve this in python)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Maybe you're writing a a logger, and you need to prepend the level to the log string.", "You might write something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import sys\nprefixer = lambda prefix: lambda message: sys.stderr.write(prefix + \":\" + message + \"\\n\")\nlog_error = prefixer(\"ERROR\")\nlog_warning = prefixer(\"WARNING\")\nlog_info = prefixer(\"INFO\")\nlog_debug = prefixer(\"DEBUG\")\n\nlog_info(\"An informative message\")\nlog_error(\"Oh no, a fatal problem\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["This program prints out"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n INFO:An informative message\n   ERROR:Oh no, a fatal problem\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I did something like this just the other day to disable a test method in a unittest suite."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n disable = lambda fn : lambda *args, **kwargs: None\n\n@disable\ntest_method(self):\n    ... test code that I wanted to disable ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Easy to re-enable it later."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n swap = lambda a,x,y:(lambda f=a.__setitem__:(f(x,(a[x],a[y])),\n       f(y,a[x][0]),f(x,a[x][1])))()\n</code>\n</pre>\n", "senID": 0}, {"text": ["See the () at the end?", "The inner lambda isn't returned, its called. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The function does the equivalent of"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def swap(a, x, y):\n     a[x] = (a[x], a[y])\n     a[y] = a[x][0]\n     a[x] = a[x][1]\n</code>\n</pre>\n", "senID": 3}, {"text": ["But let's suppose that we want to do this in a lambda.", "We cannot use assignments in a lambda.", "However, we can call __setitem__ for the same effect."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "__setitem__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def swap(a, x, y):\n     a.__setitem__(x, (a[x], a[y]))\n     a.__setitem__(y, a[x][0])\n     a.__setitem__(x, a[x][1])\n</code>\n</pre>\n", "senID": 5}, {"text": ["But for a lambda, we can only have one expression.", "But since these are function calls we can wrap them up in a tuple"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def swap(a, x, y):\n     (a.__setitem__(x, (a[x], a[y])),\n     a.__setitem__(y, a[x][0]),\n     a.__setitem__(x, a[x][1]))\n</code>\n</pre>\n", "senID": 7}, {"text": ["However, all those __setitem__'s are getting me down, so let's factor them out:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "__setitem__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def swap(a, x, y):\n     f = a.__setitem__\n     (f(x, (a[x], a[y])),\n     f(y, a[x][0]),\n     f(x, a[x][1]))\n</code>\n</pre>\n", "senID": 9}, {"text": ["Dagnamit, I can't get away with adding another assignment!", "I know let's abuse default parameters."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n def swap(a, x, y):\n     def inner(f = a.__setitem__):\n         (f(x, (a[x], a[y])),\n         f(y, a[x][0]),\n         f(x, a[x][1]))\n     inner()\n</code>\n</pre>\n", "senID": 11}, {"text": ["Ok let's switch over to lambdas:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n swap = lambda a, x, y: lambda f = a.__setitem__: (f(x, (a[x], a[y])), f(y, a[x][0]),  f(x, a[x][1]))()\n</code>\n</pre>\n", "senID": 13}, {"text": ["Which brings us back to the original expression (plus/minus typos)"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["All of this leads back to the question: Why?"], "childNum": 2, "tag": "p", "senID": 15, "childList": [{"text": "Why?", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "Why?", "tag": "em"}]}, {"text": "Why?", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["The function should have been implemented as"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n def swap(a, x, y):\n    a[x],a[y] = a[y],a[x]\n</code>\n</pre>\n", "senID": 17}, {"text": ["The original author went way out of his way to use a lambda rather then a function.", "It could be that he doesn't like nested function for some reason.", "I don't know.", "All I'll say is its bad code.", "(unless there is a mysterious justification for it."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}], [{"text": ["It is most oftenly - at least in code I come accross and that I myself write - used to \"freeze\" a variable with the value it has at the point the lambda function is created.", "Otherwise, nonlocals variable reference a variable in the scope they exist, which can lead to undesied results sometimes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, if I want to create a list of ten functions, each one being a multiplier for a scalar from 0 to 9.", "One might be tempted to write it like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [(lambda j: i * j) for i in range(10)]\n&gt;&gt;&gt; a[9](10)\n90\n</code>\n</pre>\n", "senID": 2}, {"text": ["Whoever, if you want to use any of the other factoried functions you get the same result:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a[1](10)\n90\n</code>\n</pre>\n", "senID": 4}, {"text": ["That is because the \"i\" variable inside the lambda is not resolved when the lambda is created.", "Rather, Python keeps a reference to the \"i\" in the \"for\" statement - on the scope it was created (this reference is kept in the lambda function closure).", "When the lambda is executed, the variable is evaluated, and its value is the final one it had in that scope."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["When one uses two nested lambdas like this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [(lambda k: (lambda j: k * j))(i) for i in range(10)]\n</code>\n</pre>\n", "senID": 7}, {"text": ["The \"i\" variable is evaluated durint the execution of the \"for\" loop.", "It\u015b value is passed to  \"k\" - and \"k\" is used as the non-local variable in the multiplier function we are factoring out.", "For each value of i, there will be a different instance of the enclosing lambda function, and a different value for the \"k\" variable."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["So, it is possible to achieve the original intent :"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [(lambda k: (lambda j: k * j))(i) for i in range(10)]\n&gt;&gt;&gt; a[1](10)\n10\n&gt;&gt;&gt; a[9](10)\n90\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 10}], [{"text": ["It can be used to achieve a more continuation/trampolining style of programming, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["See Continuation-passing style"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Continuation-passing style", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Continuation-passing_style"}]}]]