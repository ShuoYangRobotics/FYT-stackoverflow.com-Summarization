[[{"text": ["From Learning Python, 4th edition -- Chapter 6:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Learning Python, 4th edition", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The question is.. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if x[3] is x[4]:\n    print \"What's the difference?\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If you know you want the second, then do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n x = Ring([1,2,3,4,4])\nx.setTop(4)\nx.turn()\nx.setTop(4)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can enhance setTop() to take an additional parameter and do it inside."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Cpython has an \"integer cache\" for smallish integers, so that values from -5 up to 255 (may vary by version or Python implentation) reuse the same object for a given value.", "That is, all 4s are the same int object with a value of 4.", "This is done to reduce the necessity for object creation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "same", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["There are a few ways to work around this. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "You can use long integers (e.g., write 4L instead of 4). Python does not use the cache for long integers. (You could also use floats, as these are likewise not cached.) If you do a lot of math with the numbers, however, this could incur some performance penalty.", "tag": "none", "senID": 2}, {"text": "You can wrap each item in a list or tuple (reasonably convenient because there is simple syntax for this, though it's more syntax than long integers or floats).", "tag": "none", "senID": 3}, {"text": "You can create your own object to wrap the integer. The object would have all the same methods as an integer (so it works like an integer in math, comparisons, printing, etc.) but each instance would be unique.", "tag": "none", "senID": 4}]}, {"text": ["I personally like using long ints in this case.", "You can easily convert the integers to longs in the constructor, and in any method that adds an item."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["It sounds like you always want to turn at least once, right?", "If so, re-write your setTop method like so:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "always", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def setTop(self, objectReference):\n    if objectReference not in self:\n        raise ValueError, \"object is not in ring\"\n\n    self.turn()\n    while self[0] is not objectReference:\n        self.turn()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then it cycles between the expected states:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = Ring([1,2,3,4,4])\n&gt;&gt;&gt; x\n[1, 2, 3, 4, 4]\n&gt;&gt;&gt; x.setTop(4)\n&gt;&gt;&gt; x\n[4, 4, 1, 2, 3]\n&gt;&gt;&gt; x.setTop(4)\n&gt;&gt;&gt; x\n[4, 1, 2, 3, 4]\n&gt;&gt;&gt; x.setTop(4)\n&gt;&gt;&gt; x\n[4, 4, 1, 2, 3]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I also don't know enough to be sure, but I guess numbers, even though beeing objects, are the same objects when used in different points of your code.", "Why do I think so?", "Look:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; type(2)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; type(lambda x:x)\n&lt;type 'function'&gt;\n&gt;&gt;&gt; 2 is 2\nTrue\n&gt;&gt;&gt; (lambda x: x) is (lambda x: x)\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["2 objects are not identical when created twice.", "But numbers are not created by you, they are already there.", "And it makes no sense to give one 4 a different object from another 4.", "At least I don't see one."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "4", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "4", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["For small numbers, python will have a cache of objects premade to avoid the costs of making new objects.", "They will have the same object identity.", "Java does this as well.", "You need a way to make it avoid doing this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Python reuses small integers and short strings.", "As far as I know, there's no way around this - you'll have to get along with this and the fact that setTop only rotates until the first match.", "I suppose you could add an optinal parameter, n = 1, and turn until the n th match.", "But that's kinda beside the point, isn't it?"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "setTop", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "n = 1", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Unrelatedly, consider this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Point(object):\n...     def __init__(self, x, y):\n...         self.x, self.y = x, y\n...     def __eq__(self, other):\n...         return (self.x == other.x and self.y == other.y)\n... \n&gt;&gt;&gt; a_ring = Ring(Point(1, 2), Point(15, -9), Point(0, 0))\n&gt;&gt;&gt; a_ring.seTop(Point(15, -9))\nTraceback ...\n...\nValueError: object not in ring\n</code>\n</pre>\n", "senID": 2}, {"text": ["Not how it is supposed to work, is it?", "You should use while self[0] != objectReference (which is btw a misleading name) to avoid this."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "while self[0] != objectReference", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]