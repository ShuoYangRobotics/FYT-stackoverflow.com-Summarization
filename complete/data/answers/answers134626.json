[[{"text": ["If you need to assign the lambda to a name, use a def instead.", "defs are just syntactic sugar for an assignment, so the result is the same, and they are a lot more flexible and readable."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["lambdas can be used for use once, throw away functions which won't have a name."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "use once, throw away", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["However, this use case is very rare.", "You rarely need to pass around unnamed function objects."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The builtins map() and filter() need function objects, but list comprehensions and generator expressions are generally more readable than those functions and can cover all use cases, without the need of lambdas. "], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "map()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "filter()", "childNum": 0, "tag": "code", "childList": []}, {"text": "list comprehensions", "childNum": 0, "tag": "strong", "childList": []}, {"text": "generator expressions", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["For the cases you really need a small function object, you should use the operator module functions, like operator.add instead of lambda x, y: x + y"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "operator", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "operator.add", "childNum": 0, "tag": "code", "childList": []}, {"text": "lambda x, y: x + y", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you still need some lambda not covered, you might consider writing a def, just to be more readable.", "If the function is more complex than the ones at operator module, a def is probably better. "], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "operator", "childNum": 0, "tag": "code", "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So, real world good lambda use cases are very rare."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Practically speaking, to me there are two differences:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first is about what they do and what they return:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["def is a keyword that doesn't return anything and creates a 'name' in the local namespace."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["lambda is a keyword that returns a function object and does not create a 'name' in the local namespace."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]}, {"text": ["Hence, if you need to call a function that takes a function object, the only way to do that in one line of python code is with a lambda.", "There's no equivalent with def."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In some frameworks this is actually quite common; for example, I use Twisted a lot, and so doing something like"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Twisted", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/"}]}, {"code": "<pre>\n<code>\n d.addCallback(lambda result: setattr(self, _someVariable, result))\n</code>\n</pre>\n", "senID": 6}, {"text": ["is quite common, and more concise with lambdas."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["The second difference is about what the actual function is allowed to do."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "A function defined with 'def' can contain any python code", "tag": "none", "senID": 9}, {"text": "A function defined with 'lambda' has to evaluate to an expression, and can thus not contain statements like print, import, raise, ... ", "tag": "none", "senID": 10}]}, {"text": ["For example,"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def p(x): print x\n</code>\n</pre>\n", "senID": 12}, {"text": ["works as expected, while"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n lambda x: print x\n</code>\n</pre>\n", "senID": 14}, {"text": ["is a SyntaxError."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["Of course, there are workarounds - substitute print with sys.stdout.write, or import with __import__.", "But usually you're better off going with a function in that case."], "childNum": 4, "tag": "p", "senID": 16, "childList": [{"text": "print", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sys.stdout.write", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "import", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__import__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["In this interview, Guido van Rossum says he wishes he hadn't let 'lambda' into Python:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "In this interview,", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.amk.ca/python/writing/gvr-interview"}]}, {"text": ["IMHO, Iambdas can be convenient sometimes, but usually are convenient at the expense of readibility.", "Can you tell me what this does:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n str(reduce(lambda x,y:x+y,map(lambda x:x**x,range(1,1001))))[-10:]\n</code>\n</pre>\n", "senID": 2}, {"text": ["I wrote it, and it took me a minute to figure it out.", "This is from Project Euler - i won't say which problem because i hate spoilers, but it runs in 0.124 seconds :)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I agree with nosklo's advice: if you need to give the function a name, use def.", "I reserve lambda functions for cases where I'm just passing a brief snippet of code to another function, e.g."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "def", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n a = [ (1,2), (3,4), (5,6) ]\nb = map( lambda x: x[0]+x[1], a )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The primary use of lambda has always been for simple callback functions, and for map, reduce, filter, which require a function as an argument.", "With list comprehensions becoming the norm, and the added allowed if as in:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n x = [f for f in range(1, 40) if f % 2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["it's hard to imagine a real case for the use of lambda in daily use.", "As a result, I'd say, avoid lambda and create nested functions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you are just going to assign the lambda to a variable in the local scope, you may as well use def because it is more readable and can be expanded more easily in the future:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fun = lambda a, b: a ** b # a pointless use of lambda\nmap(fun, someList)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def fun(a, b): return a ** b # more readable\nmap(fun, someList)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["lambda is usefull for generating new functions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def somefunc(x): return lambda y: x+y\nf = somefunc(10)\nf(2)\n&gt;&gt;&gt; 12\nf(4)\n&gt;&gt;&gt; 14\n</code>\n</pre>\n", "senID": 1}], [{"text": ["An important limitation of lambdas is that they cannot contain anything besides an expression.", "It's nearly impossible for a lambda expression to produce anything besides trivial side effects, since it cannot have anywhere near as rich a body as a def'ed function."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "def", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["That being said, Lua influenced my programming style toward the extensive use of anonymous functions, and I litter my code with them.", "On top of that, I tend to think about map/reduce as abstract operators in ways I don't consider list comprehensions or generators, almost as If I'm deferring an implementation decision explicitly by using those operators.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I agree with nosklo.", "By the way, even with a use once, throw away function, most of the time you just want to use something from the operator module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "use once, throw away", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["E.G : "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You have a function with this signature : myFunction(data, callback function)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You want to pass a function that add 2 elements."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Using lambda :"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n myFunction(data, (lambda x, y : x + y))\n</code>\n</pre>\n", "senID": 5}, {"text": ["The pythonic way :"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import operator\nmyFunction(data, operator.add)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Or course this is a simple example, but there is a lot of stuff the operator module provides, including the items setters  / getters for list and dict.", "Really cool."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}]]