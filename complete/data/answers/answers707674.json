[[{"code": "<pre>\n<code>\n isinstance()\n</code>\n</pre>\n", "senID": 0}, {"text": ["In your case, isinstance(\"this is a string\", str) will return True."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "isinstance(\"this is a string\", str)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You may also want to read this: http://www.canonical.org/~kragen/isinstance/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.canonical.org/~kragen/isinstance/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.canonical.org/~kragen/isinstance/"}]}], [{"text": ["isinstance works:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "isinstance", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if isinstance(obj, MyClass): do_foo(obj)\n</code>\n</pre>\n", "senID": 1}, {"text": ["but, keep in mind: if it looks like a duck, and if it sounds like a duck, it is a duck."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "but", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["EDIT:  For the None type, you can simply do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if obj is None: obj = MyClass()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["First, avoid all type comparisons.", "They're very, very rarely necessary.", "Sometimes, they help to check parameter types in a function -- even that's rare.", "Wrong type data will raise an exception, and that's all you'll ever need."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["All of the basic conversion functions will map as equal to the type function."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n type(9) is int\ntype(2.5) is float\ntype('x') is str\ntype(u'x') is unicode\ntype(2+3j) is complex\n</code>\n</pre>\n", "senID": 2}, {"text": ["There are a few other cases."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n isinstance( 'x', basestring )\nisinstance( u'u', basestring )\nisinstance( 9, int )\nisinstance( 2.5, float )\nisinstance( (2+3j), complex )\n</code>\n</pre>\n", "senID": 4}, {"text": ["None, BTW, never needs any of this kind of type checking.", "None is the only instance of NoneType.", "The None object is a Singleton.", "Just check for None"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n variable is None\n</code>\n</pre>\n", "senID": 6}, {"text": ["BTW, do not use the above in general.", "Use ordinary exceptions and Python's own natural polymorphism."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["For other types, check out the types module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "types", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/types.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import types\n&gt;&gt;&gt; x = \"mystring\"\n&gt;&gt;&gt; isinstance(x, types.StringType)\nTrue\n&gt;&gt;&gt; x = 5\n&gt;&gt;&gt; isinstance(x, types.IntType)\nTrue\n&gt;&gt;&gt; x = None\n&gt;&gt;&gt; isinstance(x, types.NoneType)\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["P.S.", "Typechecking is a bad idea."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can always use the type(x) == type(y) trick, where y is something with known type."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "type(x) == type(y)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n # check if x is a regular string\ntype(x) == type('')\n# check if x is an integer\ntype(x) == type(1)\n# check if x is a NoneType\ntype(x) == type(None)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Often there are better ways of doing that, particularly with any recent python.", "But if you only want to remember one thing, you can remember that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In this case, the better ways would be:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # check if x is a regular string\ntype(x) == str\n# check if x is either a regular string or a unicode string\ntype(x) in [str, unicode]\n# alternatively:\nisinstance(x, basestring)\n# check if x is an integer\ntype(x) == int\n# check if x is a NoneType\nx is None\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note the last case: there is only one instance of NoneType in python, and that is None.", "You'll see NoneType a lot in exceptions (TypeError: 'NoneType' object is unsubscriptable -- happens to me all the time..) but you'll hardly ever need to refer to it in code."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "NoneType", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "TypeError: 'NoneType' object is unsubscriptable", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Finally, as fengshaun points out, type checking in python is not always a good idea.", "It's more pythonic to just use the value as though it is the type you expect, and catch (or allow to propagate) exceptions that result from it."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I use type(x) == type(y)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "type(x) == type(y)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For instance, if I want to check something is an array:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n type( x ) == type( [] )\n</code>\n</pre>\n", "senID": 2}, {"text": ["string check:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n type( x ) == type( '' ) or type( x ) == type( u'' )\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you want to check against None, use is"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n x is None\n</code>\n</pre>\n", "senID": 6}], [{"text": ["It is because you have to write"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s=\"hello\"\ntype(s) == type(\"\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["type accepts an instance and returns its type.", "In this case you have to compare two instances' types."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you need to do preemptive checking, it is better if you check for a supported interface than the type. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The type does not really tell you much, apart of the fact that your code want an instance of a specific type, regardless of the fact that you could have another instance of a completely different type which would be perfectly fine because it implements the same interface."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["For example, suppose you have this code"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def firstElement(parameter):\n    return parameter[0]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Now, suppose you say: I want this code to accept only a tuple."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import types\n\ndef firstElement(parameter):\n    if type(parameter) != types.TupleType:\n         raise TypeError(\"function accepts only a tuple\")\n    return parameter[0]\n</code>\n</pre>\n", "senID": 8}, {"text": ["This is reducing the reusability of this routine.", "It won't work if you pass a list, or a string, or a numpy.array.", "Something better would be "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def firstElement(parameter):\n    if not (hasattr(parameter, \"__getitem__\") and callable(getattr(parameter,\"__getitem__\"))):\n        raise TypeError(\"interface violation\")\n    return parameter[0]\n</code>\n</pre>\n", "senID": 10}, {"text": ["but there's no point in doing it: parameter[0] will raise an exception if the protocol is not satisfied anyway... this of course unless you want to prevent side effects or having to recover from calls that you could invoke before failing.", "(Stupid) example, just to make the point:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def firstElement(parameter):\n    if not (hasattr(parameter, \"__getitem__\") and callable(getattr(parameter,\"__getitem__\"))):\n        raise TypeError(\"interface violation\")\n    os.system(\"rm file\")\n    return parameter[0]\n</code>\n</pre>\n", "senID": 12}, {"text": ["in this case, your code will raise an exception before running the system() call.", "Without interface checks, you would have removed the file, and then raised the exception."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["i think this should do it"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if isinstance(obj, str)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You're very close!", "string is a module, not a type.", "You probably want to compare the type of obj against the type object for strings, namely str:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "string", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "obj", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n type(obj) == str  # this works because str is already a type\n</code>\n</pre>\n", "senID": 1}, {"text": ["Alternatively:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n type(obj) == type('')\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note, in Python 2, if obj is a unicode type, then neither of the above will work.", "Nor will isinstance().", "See John's comments to this post for how to get around this...", "I've been trying to remember it for about 10 minutes now, but was having a memory block!"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "obj", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "isinstance()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]