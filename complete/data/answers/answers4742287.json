[[{"text": ["Use re.finditer() "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re.finditer()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html#finding-all-adverbs-and-their-positions"}]}, {"text": ["example 1:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n match = re.finditer('A', 'ABBACDA')\nfor m in match:\n    print m.start(), m.end(), m.group(0)\n</code>\n</pre>\n", "senID": 2}, {"text": ["output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 0 1 A\n3 4 A\n6 7 A\n</code>\n</pre>\n", "senID": 4}, {"text": ["example 2:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n match = re.finditer('BB', 'ABBACDA')\nfor m in match:\n    print m.start(), m.end(), m.group(0)\n</code>\n</pre>\n", "senID": 6}, {"text": ["output :"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n 1 3 BB\n</code>\n</pre>\n", "senID": 8}], [{"text": ["To John Machin"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\u00ab (1) in your \"find\" code, tof is \"A\", in your regex code, tof is \"BB\" \u00bb"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["No.", "There is a 'find' code with tof = 'A' , \nand there is a code comparing 'find' method and 'regex' method with tof = 'BB'.", "There' is not an alone 'regex' code with tof = 'BB'"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The 'find' code presents this solution in an isolated manner to be clearer because in the second code its lisibility is obfsucated."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I put the definition of pat = re.compile(tof) out of the loops in order to not count the time of its creation in the measured time.", "As it is in the beginning of the second code, you believed that it is an entirely 'regex' code.", "That's not so.", "It's a comparison code."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You should read more thoroughly."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["\u00ab (2) ch[prec:].find(tof) instead of ch.find(tof, prec) \u00bb"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Yes."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["In fact I already knew that the index must be put in find() and not used in the string.", "I found it and I already used that way in past codes, but I just had a blank in my brain."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["By the way, the code is hence simpler.", "And secondly, as you pointed out, the corrected 'find' solution now runs faster.", "It runs in T seconds when the regex solution runs in 0.77 * T (0.65 * T before correction):"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n ch = 'jggBBjgjBBBjhgBBBBjjgBBBBBjjggBBBBBBjjjgjBBBBBBB'\ntof = 'BB'\nL = len(tof)\n\nX,Y = [],[]\npat = re.compile(tof)\n\nfor essay in xrange(5):\n\n    te = clock()\n    for i in xrange(1000):\n        li = []\n        x = ch.find(tof)\n        while x+1:\n            li.append(x)\n            x = ch.find(tof,x+L)\n    X.append( clock()-te )\n\n\n    te = clock()\n    for i in xrange(1000):\n        ly = [ m.start() for m in pat.finditer(ch) ]\n    Y.append( clock()-te )\n\nprint li,'\\n',ly,'\\n'\nprint min(X),'\\n',min(Y)\n</code>\n</pre>\n", "senID": 10}, {"text": ["But it's not such a dramatic acceleration though: 18 % faster."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["\u00ab (3) your find code considers overlapping matches, the regex code doesn't  \u00bb"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["I don't think so.", "I precisely tried with 'ABBACDABBmmrteyBBgfrewBBBBBioBByt BBB ggddbBB BBbGtBBBGtbBbGT' containing 'BBBBB' to verify that the 'find' solution gives the same result as the 'regex' solution, because I do know that a regex doesn't return overlapping matches.", "I used L = len(tof) precisely to avoid detection of overlapping slices."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["result of the above code:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n [3, 8, 14, 16, 21, 23, 30, 32, 34, 41, 43, 45]\n[3, 8, 14, 16, 21, 23, 30, 32, 34, 41, 43, 45]\n</code>\n</pre>\n", "senID": 15}, {"text": ["So what does \u00abYour find code considers overlapping matches\u00bb mean, please ?"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["\u00ab (4) etc etc  \u00bb"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["That's unfair.", "If there are etceterae, tell which ones.", "If none... well, I don't know..."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["I think that a ratio of 1 right comment versus a false one, a dubious one and an unfair one isn't enough to downvote."], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["Moreover, it appears to me that on SO the imperfect answers written 1 or 2 hours after the question don't escape to downvotes, while the good similar ones are more rarely upvoted because the questionner have had his solution for a long time."], "childNum": 0, "tag": "p", "senID": 20, "childList": []}], [{"text": ["If you are looking for only one result, use the re.search function instead.", "That returns a MatchObject (http://docs.python.org/library/re.html#re.MatchObject).", "The object has start() and end() functions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You could try timing the following to see if it is faster than the regex approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def multifind(needle, haystack, overlap=False):\n    delta = 1 if overlap else max(1, len(needle))\n    pos = 0\n    find = haystack.find\n    while 1:\n        pos = find(needle, pos)\n        if pos &lt; 0: return\n        yield pos\n        pos += delta\n\n&gt;&gt;&gt; data = 'ABBACDABBmmrteyBBgfrewBBBBBioBBytA BBB ggdAdbBB BBbGtBBABGtbBbGT'\n&gt;&gt;&gt; list(multifind('A', data))\n[0, 3, 6, 33, 42, 55]\n&gt;&gt;&gt; list(multifind('BB', data))\n[1, 7, 15, 22, 24, 29, 35, 45, 48, 53]\n&gt;&gt;&gt; list(multifind('BB', data, overlap=True))\n[1, 7, 15, 22, 23, 24, 25, 29, 35, 36, 45, 48, 53]\n&gt;&gt;&gt; list(multifind('', 'qwerty'))\n[0, 1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Oh, I also knew the use of a generator, and I had forgotten its advantage in such a research.", "It's a fine remark, this one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["And the use of an alias hayfind = haystack.find to make the code faster is very tricky too."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now the 'find with generator' method runs in T and 'regex' method runs in only 0.96 * T"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ch = 'jggBBjgjBBBjhgBBBBjjgBBBBBjjggBBBBBBjjjgjBBBBBBB'\ntof = 'BB'\nL = len(tof)\n\nX,Y = [],[]\npat = re.compile(tof)\n\ndef multifind(needle, haystack):\n    delta = len(needle)\n    pos = 0\n    hayfind = haystack.find\n    while 1:\n        pos = hayfind(needle, pos)\n        if pos &lt; 0:  return\n        yield pos\n        pos += delta\n\nfor essay in xrange(20):\n\n    te = clock()\n    for i in xrange(10000):\n        li = list(multifind(tof,ch))\n    X.append( clock()-te )\n\n\n    te = clock()\n    for i in xrange(10000):\n        ly = [ m.start() for m in pat.finditer(ch) ]\n    Y.append( clock()-te )\n\nprint li,'\\n',ly,'\\n'\nprint min(X),'\\n',min(Y)\n</code>\n</pre>\n", "senID": 3}, {"text": ["The two methods are of equivalent speeds.", "But I finaly prefer the 'regex' solution because it can be modified to obtain more results if needed (start and end, other conditions...) while 'find' solution only give the positions."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I likes regexes but I searched another solution :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ch = 'ABBACDABBmmrteyBBgfrewBBBBBioBBytA BBB ggdAdbBB BBbGtBBABGtbBbGT'\ntof = 'A'\n\nli, prec = [], 0\nx = ch[prec:].find(tof)\n\nwhile x+1:\n    li.append(prec+x)\n    prec += x+1\n    x = ch[prec:].find(tof)\n\nprint li\n</code>\n</pre>\n", "senID": 1}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [0, 3, 6, 33, 42, 55]\n</code>\n</pre>\n", "senID": 3}, {"text": ["I measured the speeds and I am astonished that the solution with regex runs in 0,65 * T when solution with find() runs in T seconds:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n ch = 'ABBACDABBmmrteyBBgfrewBBBBBioBByt BBB ggddbBB BBbGtBBBGtbBbGT'\n\ntof = 'BB'\n\nX,Y = [],[]\npat = re.compile(tof)\n\nfor essay in xrange(50):\n\n    te = clock()\n    for i in xrange(1000):\n        li, prec, L = [], 0, len(tof)\n        x = ch[prec:].find(tof)\n        while x+1:\n            li.append(prec+x)\n            prec += x+L\n            x = ch[prec:].find(tof)\n    X.append( clock()-te )\n\n    te = clock()\n    for i in xrange(1000):\n        ly = [ m.start() for m in pat.finditer(ch) ]\n    Y.append( clock()-te )\n\nprint li\nprint ly\nprint\nprint min(X)\nprint min(Y)\n</code>\n</pre>\n", "senID": 5}]]