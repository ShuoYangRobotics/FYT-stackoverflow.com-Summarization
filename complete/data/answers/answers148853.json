[[{"text": ["This ActiveState Python recipe might be helpful:\nhttp://code.activestate.com/recipes/491261/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/491261/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/491261/"}]}], [{"text": ["If you don't mind working at a slightly lower level, httplib2 (http://code.google.com/p/httplib2/) is an excellent HTTP library that includes caching functionality."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.google.com/p/httplib2/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/httplib2/"}]}], [{"text": ["You could use a decorator function such as:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class cache(object):\n    def __init__(self, fun):\n        self.fun = fun\n        self.cache = {}\n\n    def __call__(self, *args, **kwargs):\n        key  = str(args) + str(kwargs)\n        try:\n            return self.cache[key]\n        except KeyError:\n            self.cache[key] = rval = self.fun(*args, **kwargs)\n            return rval\n        except TypeError: # incase key isn't a valid key - don't cache\n            return self.fun(*args, **kwargs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["and define a function along the lines of:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @cache\ndef get_url_src(url):\n    return urllib.urlopen(url).read()\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is assuming you're not paying attention to HTTP Cache Controls, but just want to cache the page for the duration of the application"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I've always been torn between using httplib2, which does a solid job of handling HTTP caching and authentication, and urllib2, which is in the stdlib, has an extensible interface, and supports HTTP Proxy servers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The ActiveState recipe starts to add caching support to urllib2, but only in a very primitive fashion.", "It fails to allow for extensibility in storage mechanisms, hard-coding the file-system-backed storage.", "It also does not honor HTTP cache headers."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ActiveState recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/491261/"}]}, {"text": ["In an attempt to bring together the best features of httplib2 caching and urllib2 extensibility, I've adapted the ActiveState recipe to implement most of the same caching functionality as is found in httplib2.", "The module is in jaraco.net as jaraco.net.http.caching.", "The link points to the module as it exists at the time of this writing.", "While that module is currently part of the larger jaraco.net package, it has no intra-package dependencies, so feel free to pull the module out and use it in your own projects."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "jaraco.net.http.caching", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://bitbucket.org/jaraco/jaraco.net/src/65af6e442d21/jaraco/net/http/caching.py"}]}, {"text": ["Alternatively, if you have Python 2.6 or later, you can easy_install jaraco.net&gt;=1.3 and then utilize the CachingHandler with something like the code in caching.quick_test()."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "easy_install jaraco.net&gt;=1.3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "caching.quick_test()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n \"\"\"Quick test/example of CacheHandler\"\"\"\nimport logging\nimport urllib2\nfrom httplib2 import FileCache\nfrom jaraco.net.http.caching import CacheHandler\n\nlogging.basicConfig(level=logging.DEBUG)\nstore = FileCache(\".cache\")\nopener = urllib2.build_opener(CacheHandler(store))\nurllib2.install_opener(opener)\nresponse = opener.open(\"http://www.google.com/\")\nprint response.headers\nprint \"Response:\", response.read()[:100], '...\\n'\n\nresponse.reload(store)\nprint response.headers\nprint \"After reload:\", response.read()[:100], '...\\n'\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note that jaraco.util.http.caching does not provide a specification for the backing store for the cache, but instead follows the interface used by httplib2.", "For this reason, the httplib2.FileCache can be used directly with urllib2 and the CacheHandler.", "Also, other backing caches designed for httplib2 should be usable by the CacheHandler."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I was looking for something similar, and came across \"Recipe 491261: Caching and throttling for urllib2\" which danivo posted.", "The problem is I really dislike the caching code (lots of duplication, lots of manually joining of file paths instead of using os.path.join, uses staticmethods, non very PEP8'sih, and other things that I try to avoid)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "\"Recipe 491261: Caching and throttling for urllib2\"", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/491261/"}, {"text": "really", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["The code is a bit nicer (in my opinion anyway) and is functionally much the same, with a few additions - mainly the \"recache\" method (example usage can be seem here, or in the if __name__ == \"__main__\": section at the end of the code)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "can be seem here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/dbr/tvdb%5Fapi/blob/f72c4ad3e53a934c4bade21876b4f7185b645866/tvdb%5Fapi.py#L412-453"}, {"text": "if __name__ == \"__main__\":", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The latest version can be found at http://github.com/dbr/tvdb_api/blob/master/cache.py, and I'll paste it here for posterity (with my application specific headers removed):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://github.com/dbr/tvdb_api/blob/master/cache.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/dbr/tvdb_api/blob/master/cache.py"}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\"\"\"\nurllib2 caching handler\nModified from http://code.activestate.com/recipes/491261/ by dbr\n\"\"\"\n\nimport os\nimport time\nimport httplib\nimport urllib2\nimport StringIO\nfrom hashlib import md5\n\ndef calculate_cache_path(cache_location, url):\n    \"\"\"Checks if [cache_location]/[hash_of_url].headers and .body exist\n    \"\"\"\n    thumb = md5(url).hexdigest()\n    header = os.path.join(cache_location, thumb + \".headers\")\n    body = os.path.join(cache_location, thumb + \".body\")\n    return header, body\n\ndef check_cache_time(path, max_age):\n    \"\"\"Checks if a file has been created/modified in the [last max_age] seconds.\n    False means the file is too old (or doesn't exist), True means it is\n    up-to-date and valid\"\"\"\n    if not os.path.isfile(path):\n        return False\n    cache_modified_time = os.stat(path).st_mtime\n    time_now = time.time()\n    if cache_modified_time &lt; time_now - max_age:\n        # Cache is old\n        return False\n    else:\n        return True\n\ndef exists_in_cache(cache_location, url, max_age):\n    \"\"\"Returns if header AND body cache file exist (and are up-to-date)\"\"\"\n    hpath, bpath = calculate_cache_path(cache_location, url)\n    if os.path.exists(hpath) and os.path.exists(bpath):\n        return(\n            check_cache_time(hpath, max_age)\n            and check_cache_time(bpath, max_age)\n        )\n    else:\n        # File does not exist\n        return False\n\ndef store_in_cache(cache_location, url, response):\n    \"\"\"Tries to store response in cache.\"\"\"\n    hpath, bpath = calculate_cache_path(cache_location, url)\n    try:\n        outf = open(hpath, \"w\")\n        headers = str(response.info())\n        outf.write(headers)\n        outf.close()\n\n        outf = open(bpath, \"w\")\n        outf.write(response.read())\n        outf.close()\n    except IOError:\n        return True\n    else:\n        return False\n\nclass CacheHandler(urllib2.BaseHandler):\n    \"\"\"Stores responses in a persistant on-disk cache.\n\n    If a subsequent GET request is made for the same URL, the stored\n    response is returned, saving time, resources and bandwidth\n    \"\"\"\n    def __init__(self, cache_location, max_age = 21600):\n        \"\"\"The location of the cache directory\"\"\"\n        self.max_age = max_age\n        self.cache_location = cache_location\n        if not os.path.exists(self.cache_location):\n            os.mkdir(self.cache_location)\n\n    def default_open(self, request):\n        \"\"\"Handles GET requests, if the response is cached it returns it\n        \"\"\"\n        if request.get_method() is not \"GET\":\n            return None # let the next handler try to handle the request\n\n        if exists_in_cache(\n            self.cache_location, request.get_full_url(), self.max_age\n        ):\n            return CachedResponse(\n                self.cache_location,\n                request.get_full_url(),\n                set_cache_header = True\n            )\n        else:\n            return None\n\n    def http_response(self, request, response):\n        \"\"\"Gets a HTTP response, if it was a GET request and the status code\n        starts with 2 (200 OK etc) it caches it and returns a CachedResponse\n        \"\"\"\n        if (request.get_method() == \"GET\"\n            and str(response.code).startswith(\"2\")\n        ):\n            if 'x-local-cache' not in response.info():\n                # Response is not cached\n                set_cache_header = store_in_cache(\n                    self.cache_location,\n                    request.get_full_url(),\n                    response\n                )\n            else:\n                set_cache_header = True\n            #end if x-cache in response\n\n            return CachedResponse(\n                self.cache_location,\n                request.get_full_url(),\n                set_cache_header = set_cache_header\n            )\n        else:\n            return response\n\nclass CachedResponse(StringIO.StringIO):\n    \"\"\"An urllib2.response-like object for cached responses.\n\n    To determine if a response is cached or coming directly from\n    the network, check the x-local-cache header rather than the object type.\n    \"\"\"\n    def __init__(self, cache_location, url, set_cache_header=True):\n        self.cache_location = cache_location\n        hpath, bpath = calculate_cache_path(cache_location, url)\n\n        StringIO.StringIO.__init__(self, file(bpath).read())\n\n        self.url     = url\n        self.code    = 200\n        self.msg     = \"OK\"\n        headerbuf = file(hpath).read()\n        if set_cache_header:\n            headerbuf += \"x-local-cache: %s\\r\\n\" % (bpath)\n        self.headers = httplib.HTTPMessage(StringIO.StringIO(headerbuf))\n\n    def info(self):\n        \"\"\"Returns headers\n        \"\"\"\n        return self.headers\n\n    def geturl(self):\n        \"\"\"Returns original URL\n        \"\"\"\n        return self.url\n\n    def recache(self):\n        new_request = urllib2.urlopen(self.url)\n        set_cache_header = store_in_cache(\n            self.cache_location,\n            new_request.url,\n            new_request\n        )\n        CachedResponse.__init__(self, self.cache_location, self.url, True)\n\n\nif __name__ == \"__main__\":\n    def main():\n        \"\"\"Quick test/example of CacheHandler\"\"\"\n        opener = urllib2.build_opener(CacheHandler(\"/tmp/\"))\n        response = opener.open(\"http://google.com\")\n        print response.headers\n        print \"Response:\", response.read()\n\n        response.recache()\n        print response.headers\n        print \"After recache:\", response.read()\n    main()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This article on Yahoo Developer Network - http://developer.yahoo.com/python/python-caching.html - describes how to cache http calls made through urllib to either memory or disk."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://developer.yahoo.com/python/python-caching.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://developer.yahoo.com/python/python-caching.html"}]}], [{"text": ["@dbr: you may need to add also https responses caching with :\n    def https_response(self, request, response):\n        return self.http_response(request,response)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]