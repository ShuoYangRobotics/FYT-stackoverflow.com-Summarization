[[{"text": ["A multidimensional list is simply a list with more lists inside of it.", "So its indices would be lists themselves."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nprint a.index([2, 3, 4])\n# prints 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For two dimensional list; you can iterate over rows and using .index function for looking for item:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def find(l, elem):\n    for row, i in enumerate(l):\n        try:\n            column = i.index(elem)\n        except ValueError:\n            continue\n        return row, column\n    return -1\n\ntl = [[1,2,3],[4,5,6],[7,8,9]]\n\nprint(find(tl, 6)) # (1,2)\nprint(find(tl, 1)) # (0,0)\nprint(find(tl, 9)) # (2,2)\nprint(find(tl, 12)) # -1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't know of an automatic way to do it, but if"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["a = [[1,2],[3,4],[5,6]]"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "a = [[1,2],[3,4],[5,6]]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["and you want to find the location of 3, you can do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["x = [x for x in a if 3 in x][0]"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "x = [x for x in a if 3 in x][0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["print 'The index is (%d,%d)'%(a.index(x),x.index(3))"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "print 'The index is (%d,%d)'%(a.index(x),x.index(3))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The output is:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The index is (1,0)"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "The index is (1,0)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["For multidimensional arrays:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def find(needle,haystack):\n  if needle == haystack: return []\n  # Strings are iterable, too\n  if isinstance(haystack,str) and len(haystack)&lt;=1: return None\n  try:\n    for i,e in enumerate(haystack):\n      r = find(needle,e)\n      if r is not None: \n        r.insert(0,i)\n        return r\n  except TypeError:\n    pass\n  return None    \n\n\nml = [[1,2,3],[4,5,6],[7,8,9]]\nprint find(2,ml)\nml = [3,[[1,2,3],[4,5,6],[7,8,9]]]\nprint find(2,ml)\nml = [[[\"ab\", \"bc\", \"cde\"]]]\nprint find(\"d\",ml)\n</code>\n</pre>\n", "senID": 1}, {"text": ["There should be a better way to avoid the try/except block, but I could not find one: \nIn python, how do I determine if a variable is Iterable?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "In python, how do I determine if a variable is Iterable?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1952464/in-python-how-do-i-determine-if-a-variable-is-iterable"}]}], [{"text": ["For n-dimensional recursive search, you can try something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from copy import copy\ndef scope(word, list, indexes = None):\n    result = []\n    if not indexes:\n        indexes = []\n    for index, item in enumerate(list):\n        try:\n            current_index = indexes + [index]\n            result.append(current_index + [item.index(word)])\n        except ValueError:\n            pass\n\n        if type(item[0]) == type([]):\n            indexes.append(index)\n            result.extend(scope(word, item, copy(indexes)))\n\n    return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["And the result is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d_list = [['a', 'b', 'new', 'mpilgrim', 'new'], [['a', 'b', 'new', 'mpilgrim', 'new'], ['b', 'd', 'new', 'mpilgrim', 'new']]]\n&gt;&gt;&gt; word = 'mpilgrim'\n&gt;&gt;&gt; result = scope(word, d_list)\n[[0, 3], [1, 0, 3], [1, 1, 3]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Probably there are better ways to do it, but that is the one I figured out without getting any library."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["EDIT:\nActually, it was not perfect and one library must be added.", "It's copy.", "Now it's ok."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["You can use the following sample method too:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n data = [[1, 1,2],[12,4],[6]]\n\ndef m_array_index(arr, searchItem):\n    for i,x in enumerate(a):\n        for j,y in enumerate(x):\n            if y == searchItem:\n                return i,j\n    return -1,-1#not found\n\nprint m_array_index(data, 6)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or with all occurrences(sure code could be optimized - modified to work with generators and so on - but here is just a sample):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n occurrences = lambda arr, val: tuple((i,j) for i,x in enumerate(arr) for j,y in enumerate(x) if y == val) or ((-1,-1))\n\nprint occurrences(data, 1) # ((0, 0), (0, 1))\nprint occurrences(data, 12) # ((1, 0),)\nprint occurrences(data, 11) # (-1, -1)\n</code>\n</pre>\n", "senID": 3}]]