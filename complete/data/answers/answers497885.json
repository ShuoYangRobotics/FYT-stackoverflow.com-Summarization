[[{"code": "<pre>\n<code>\n import operator\ntuple(map(operator.add, a, b))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Sort of combined the first two answers, with a tweak to ironfroggy's code so that it returns a tuple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\n\nclass stuple(tuple):\n    def __add__(self, other):\n        return self.__class__(map(operator.add, self, other))\n        # obviously leaving out checking lengths\n\n&gt;&gt;&gt; a = stuple([1,2,3])\n&gt;&gt;&gt; b = stuple([3,2,1])\n&gt;&gt;&gt; a + b\n(4, 4, 4)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note: using self.__class__ instead of stuple to ease subclassing."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "self.__class__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "stuple", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["from numpy import *"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "from numpy import *", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = array( [1,2,3] )\nb = array( [3,2,1] )\n\nprint a + b\n</code>\n</pre>\n", "senID": 1}, {"senID": 2}, {"text": ["gives array([4,4,4])."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["See http://www.scipy.org/Tentative_NumPy_Tutorial"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://www.scipy.org/Tentative_NumPy_Tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scipy.org/Tentative_NumPy_Tutorial"}]}], [{"code": "<pre>\n<code>\n map(sum,zip(a,b))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["What others have said so far is correct, but if you're more generally interested in vectorizing your code, you might want to check out NumPy arrays."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "NumPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}], [{"text": ["Yes.", "But you can't redefine built-in types.", "You have to subclass them:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nclass MyTuple(tuple):\n    def __add__(self, other):\n         if len(self) != len(other):\n             raise ValueError(\"tuple lengths don't match\")\n         return MyTuple(x + y for (x, y) in zip(self, other))\n</pre>\n", "senID": 1}], [{"text": ["simple solution without class definition that returns tuple"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\ntuple(map(operator.add,a,b))\n</code>\n</pre>\n", "senID": 1}]]