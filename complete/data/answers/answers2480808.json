[[{"text": ["simplest way is to just use a group, you don't need to go backwards..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (commentRegex)functionRegex\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then just extract group 1.", "You will need to run in multi-line mode to get it working, i don't know python so i can't be more helpful."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It's also possible with lookahead assertions, but this way is simpler."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I think you should use a regex that only matches doxymentation that's immediately before the function.", "Maybe something like this (simplified example):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ntest = \"\"\"\n\n/**\n    @doxygen comment\n*/\nvoid function()\n{\n}\n\n\"\"\"\n\ndoxygenRegex = r\"(?P&lt;comment&gt;/\\*\\*(?:[^/]|/(?!\\*\\*))*\\*/)\"\nfunctionRegex = r\"(?P&lt;function&gt;\\s\\w+\\s+(?P&lt;functionName&gt;\\w+)\\s*\\()\"\n\nmatch = re.search(doxygenRegex + functionRegex, test)\nprint match.groupdict()\n</code>\n</pre>\n", "senID": 1}, {"text": ["As long as this matches something, you can loop the regex matching - but starting the search at test[match.end():] next time.", "Hope that makes sense to you..."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "test[match.end():]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["BTW if you only want to extract the comment and nothing about the function, you can use lookahead - just replace functionRegex with r\"(?=\\s\\w+\\s+\\w+\\s*\\()\"."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "functionRegex", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "r\"(?=\\s\\w+\\s+\\w+\\s*\\()\"", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["This can be achived using a single reg-ex."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The key is to capture the comment just before the desired function.", "The easy way to do this is to use non-greedy qualifier.", "For example: /\\*\\*(.*?", ")\\*/ with MULTILINE flag;\nhowever, in Python, non-greedy and MULTILINE do not work together (at least on my environment).", "So, you need a little trick like this:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "/\\*\\*(.*?)\\*/", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["/\\*\\*((?:[^\\*]|\\*(?", "!/))*)\\*/."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "/\\*\\*((?:[^\\*]|\\*(?!/))*)\\*/", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["This is to match:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["1: the comment begin /**."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "/**", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["2: everything that is not * OR * that does not follows by /"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "childList": []}, {"text": "/", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["3: the comment end */."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "*/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["From this idea the code you want is:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n function_name  = \"function2\"\nregex_comment  = \"/\\*\\*((?:[^\\*]|\\*(?!/))*)\\*/\"\nregex_static   = \"(?:(\\w+)\\s*::\\s*)?\"\nregex_function = \"(\\w+)\\s+\"+regex_static+\"(?:\"+function_name+\")\\s*\\([^\\)]*\\)\"\nregex = re.compile(regex_comment+\"\\s*\"+regex_function, re.MULTILINE)\ntext  = \"\"\"\n/**\n    @doxygen comment1\n*/\nvoid test::function1()\n{\n}\n\n/**\n    @doxygen comment2\n*/\nvoid test::function2()\n{\n}\n\"\"\"\nmatch = regex.search(text)\nif (match == None): print \"None\"\nelse:               print match.group(1)\n</code>\n</pre>\n", "senID": 8}, {"text": ["When run, you got:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n @doxygen comment2\n</code>\n</pre>\n", "senID": 10}, {"text": ["Variation:\nIf you want to capture /** and */ too, use regex_comment  = \"(/\\*\\*(?:[^\\*]|\\*(?", "!/))*\\*/)\"."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "/**", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "*/", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "regex_comment  = \"(/\\*\\*(?:[^\\*]|\\*(?!/))*\\*/)\"", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Hope this helps."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["Note that C isn't a regular language, so it cannot be parsed by regular expressions.", "Have you considered leveraging doxygen itself to parse this file?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can do look-behind assertions with (?&lt;=...) or (?&lt;!...", "), but in general you can only match forwards."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "(?&lt;=...)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(?&lt;!...)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The question is why are these comments not inside the function, so you can use doc."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "doc", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["But there is no easy way with regex."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["here's a non regex approach, split on */ and find if the function you are looking for is at the next item.", "eg"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "*/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n test = \"\"\"\n\n/**\n    @doxygen comment\n*/\nvoid function()\n{\n}\n\n\"\"\"\n\nt=test.split(\"*/\")\nfor n,comm in enumerate(t):\n    try:\n        if \"void\" in t[n+1]:\n             print t[n]\n    except IndexError: pass\n</code>\n</pre>\n", "senID": 1}]]