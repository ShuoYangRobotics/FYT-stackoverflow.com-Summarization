[[{"text": ["You could do it with collections.Counter to accumulate the results:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "collections.Counter", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "collections.Counter", "tag": "a"}]}, {"href": "http://docs.python.org/library/collections.html#collections.Counter", "text": "collections.Counter", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import Counter, defaultdict\n&gt;&gt;&gt; d = defaultdict(Counter)\n&gt;&gt;&gt; d['operation_one'].update(ival=1, fval=5.67)\n&gt;&gt;&gt; d['operation_two'].update(ival=1, fval=4.56)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["the argument to defaultdict must be a \"callable\" that returns a default value.", "define your default dict like so:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n d = defaultdict(lambda: (0, 0.0))\n</code>\n</pre>\n", "senID": 1}, {"text": ["The fact that int and float types can be called and return zero's is a convenience, but not in any way crucial to the way defaultdict works."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["getting the += to work is going to cause some trouble;  addition across tuples is the concatantion of the tuples, so you'll have to do it the long way:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "+=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n left, right = d[\"key\"]\nd[\"key\"] = (left + 2, right + 3)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Edit:  if you just must use +=, you can do so, so long as you have a collection type that has the desired operations.", "fileoffset suggests using a numpy array type, and that's probably a nice idea, but you can get a close approximation just by subclassing tuple and overriding the operators you need:  Here's a rough sketch of one:"], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "must", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "fileoffset suggests", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/a/8483930/65696"}, {"text": "numpy", "childNum": 0, "tag": "code", "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class vector(tuple):\n    def __add__(self, other):\n        return type(self)(l+r for l, r in zip(self, other))\n    def __sub__(self, other):\n        return type(self)(l-r for l, r in zip(self, other))\n    def __radd__(self, other):\n        return type(self)(l+r for l, r in zip(self, other))\n    def __lsub__(self, other):\n        return type(self)(r-l for l, r in zip(self, other))\n\nfrom collections import defaultdict\n\nd = defaultdict(lambda:vector((0, 0.0)))\nfor k in range(5):\n    for j in range(5):\n        d[k] += (j, j+k)\n\nprint d\n</code>\n</pre>\n", "senID": 6}, {"text": ["we don't need (or want) to actually overload the += operator itself (spelled __iadd__) because tuple is immutable.", "Python will correctly replace the old value with new if you supply addition.  "], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "+=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__iadd__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["If you use numpy array's you can get the desired output:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.scipy.org/Tentative_NumPy_Tutorial#head-4c1d53fe504adc97baf27b65513b4b97586a4fc5"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.scipy.org/Tentative_NumPy_Tutorial#head-4c1d53fe504adc97baf27b65513b4b97586a4fc5", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scipy.org/Tentative_NumPy_Tutorial#head-4c1d53fe504adc97baf27b65513b4b97586a4fc5"}]}], [{"text": ["I assuming you have too many operations to simply store the list of values in each entry?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = defaultdict(list)\nfor z in range(lots_and_lots):\n  d['operation one'].append(5.67)\n  ...\n  ...\n  d['operation two'].append(4.56)\nfor k,v in d.items():\n  print k, 'Called', len(v), 'times, total =', sum(v)\n</code>\n</pre>\n", "senID": 1}, {"text": ["One thing you could do is make a custom incrementor:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Inc(object):\n    def __init__(self):\n        self.i = 0\n        self.t = 0.0\n    def __iadd__(self, f):\n        self.i += 1\n        self.t += f\n        return self\n</code>\n</pre>\n", "senID": 3}, {"text": ["and then"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n d = defaultdict(Inc)\nfor z in range(lots_and_lots):\n  d['operation one'] += 5.67\n  ...\n  ...\n  d['operation two'] += 4.56\nfor k,v in d.items():\n  print k, 'Called', v.i, 'times, total =', v.t\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = (1,0)\nb = (2,3)\n\nres = tuple(sum(x) for x in zip(a,b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["e.g."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n d = defaultdict((int,float))\nfor z in range( lots_and_lots):\n  d['operation one'] = tuple(sum(x) for x in zip(d['operation one'], (1,5.67))\n  ...\n  ...\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Write a class that you can pass into defaultdict that accumulates values as you pass them in:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Tracker(object):\n    def __init__(self):\n        self.values = None\n        self.count = 0\n\n    def __iadd__(self, newvalues):\n        self.count += 1\n        if self.values is None:\n            self.values = newvalues\n        else:\n            self.values = [(old + new) for old, new in zip(self.values, newvalues)]\n        return self\n\n    def __repr__(self):\n        return '&lt;Tracker(%s, %d)&gt;' % (self.values, self.count)\n</code>\n</pre>\n", "senID": 1}, {"text": ["That's a drop-in replacement for (int, float) in your original post.", "Change your output loop to print the instance attributes like so:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "(int, float)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for k,v in d.items():\n    print k, 'Called', v.count, 'times, total =', v.values\n</code>\n</pre>\n", "senID": 3}, {"text": ["...and you're done!"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]