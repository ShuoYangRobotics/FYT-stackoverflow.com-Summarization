[[{"text": ["Regarding several other answers, this doesn't have anything to do with dates being implemented in C per se.", "The __init__ method does nothing because they are immutable objects, therefore the constructor (__new__) should do all the work.", "You would see the same behavior subclassing int, str, etc."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "immutable", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import datetime\n&gt;&gt;&gt; class D(datetime.date):\n        def __new__(cls, year):\n            return datetime.date.__new__(cls, year, 1, 1)\n\n\n&gt;&gt;&gt; D(2008)\nD(2008, 1, 1)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Please read the Python reference on Data model, especially about the __new__ special method."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "Data model", "tag": "a", "pos": 0, "childList": [{"text": "Data model", "tag": "em"}], "childNum": 1, "href": "http://www.python.org/doc/current/reference/datamodel.html"}, {"text": "Data model", "childNum": 0, "tag": "em", "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://www.python.org/doc/current/reference/datamodel.html#object.__new__", "text": "special method", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Excerpt from that page (my italics):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["datetime.datetime is also an immutable type."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "datetime.datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["PS If you think that:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "an object implemented in C cannot be subclassed, or", "tag": "none", "senID": 4}, {"text": ["__init__"], "childNum": 0, "tag": "code", "senID": 5, "childList": []}]}, {"text": ["then please try it:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import array\n&gt;&gt;&gt; array\n&lt;module 'array' (built-in)&gt;\n&gt;&gt;&gt; class A(array.array):\n    def __init__(self, *args):\n    \tsuper(array.array, self).__init__(*args)\n    \tprint \"init is fine for objects implemented in C\"\n\n&gt;&gt;&gt; a=A('c')\ninit is fine for objects implemented in C\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Here's the answer, and a possible solution (use a function or strptime instead of subclassing)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.mail-archive.com/python-list@python.org/msg192783.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.mail-archive.com/python-list@python.org/msg192783.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.mail-archive.com/python-list@python.org/msg192783.html"}]}], [{"text": ["You're function isn't being bypassed; Python just never gets to the point where it would call it.", "Since datetime is implemented in C, it does its initialization in datetime.__new__ not datetime.__init__.", "This is because datetime is immutable.", "You could presumably get around this by overriding __new__ instead of __init__.", "But as other people have suggested, the best way is probably not subclassing datetime at all."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "datetime.__new__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "datetime.__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["You should probably use a factory function instead of creating a subclass:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def first_day_of_the_year(year):\n  return datetime.date(year, 1, 1)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can wrap it and add extended functionality to your wrapper."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "wrap", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here is an example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class D2(object):\n    def __init__(self, *args, **kwargs):\n        self.date_object = datetime.date(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self.date_object, name)\n</code>\n</pre>\n", "senID": 2}, {"text": ["And here is how it works:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d = D2(2005, 10, 20)\n&gt;&gt;&gt; d.weekday()\n3\n&gt;&gt;&gt; dir(d)\n['__class__', '__delattr__', '__dict__', '__doc__', '__getattr__',\n '__getattribute__', '__hash__', '__init__', '__module__', '__new__',\n '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__',\n '__weakref__', 'date_object']\n&gt;&gt;&gt; d.strftime('%d.%m.%Y')\n'20.10.2005'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note that dir() doesn't list datetime.dates attributes."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "dir()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "datetime.date", "childNum": 0, "tag": "code", "childList": []}]}]]