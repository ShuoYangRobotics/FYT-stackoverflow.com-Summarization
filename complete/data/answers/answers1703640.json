[[{"text": ["You can use select to poll for new contents in a file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def tail(filename, bufsize = 1024):\n    fds = [ os.open(filename, os.O_RDONLY) ]\n    while True:\n        reads, _, _ = select.select(fds, [], [])\n        if 0 &lt; len(reads):\n            yield os.read(reads[0], bufsize)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Well, the simplest way would be to constantly read from the file, check what's new and test for hits."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import time\n\ndef watch(fn, words):\n    fp = open(fn, 'r')\n    while True:\n        new = fp.readline()\n        # Once all lines are read this just returns ''\n        # until the file changes and a new line appears\n\n        if new:\n            for word in words:\n                if word in new:\n                    yield (word, new)\n        else:\n            time.sleep(0.5)\n\nfn = 'test.py'\nwords = ['word']\nfor hit_word, hit_sentence in watch(fn, words):\n    print \"Found %r in line: %r\" % (hit_word, hit_sentence)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This solution with readline works if you know your data will appear in lines. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "readline", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If the data is some sort of stream you need a buffer, larger than the largest word you're looking for, and fill it first.", "It gets a bit more complicated that way..."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "word", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you can't constraint the problem to work for a line-based read, you need to resort to blocks."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This should work:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\nneedle = \"needle\"\n\nblocks = []\n\ninf = sys.stdin\n\nif len(sys.argv) == 2:\n    inf = open(sys.argv[1])\n\nwhile True:\n    block = inf.read()\n    blocks.append(block)\n    if len(blocks) &gt;= 2:\n        data = \"\".join((blocks[-2], blocks[-1]))\n    else:\n        data = blocks[-1]\n\n    # attention, this needs to be changed if you are interested\n    # in *all* matches separately, not if there was any match ata all\n    if needle in data:\n        print \"found\"\n        blocks = []\n    blocks[:-2] = []\n\n    if block == \"\":\n        break\n</code>\n</pre>\n", "senID": 2}, {"text": ["The challenge lies in ensuring that you match needle even if it's separated by two block-boundaries."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Either open the file with O_NONBLOCK and use select to poll for read availability and then read to read the new data and the string methods to filter lines on the end of a file...or just use the subprocess module and let tail and grep do the work for you just as you would in the shell."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "O_NONBLOCK", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "select", "childNum": 0, "tag": "code", "childList": []}, {"text": "read", "childNum": 0, "tag": "code", "childList": []}, {"text": "subprocess", "childNum": 0, "tag": "code", "childList": []}, {"text": "tail", "childNum": 0, "tag": "code", "childList": []}, {"text": "grep", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can use collections.deque to implement tail."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collections.deque", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["From http://docs.python.org/library/collections.html#deque-recipes ..."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/collections.html#deque-recipes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#deque-recipes"}]}, {"code": "<pre>\n<code>\n def tail(filename, n=10):\n    'Return the last n lines of a file'\n    return deque(open(filename), n)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Of course, this reads the entire file contents, but it's a neat and terse way of implementing tail."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n def tail(f):\n    f.seek(0, 2)\n\n    while True:\n        line = f.readline()\n\n        if not line:\n            time.sleep(0.1)\n            continue\n\n        yield line\n\ndef process_matches(matchtext):\n    while True:\n        line = (yield)  \n        if matchtext in line:\n            do_something_useful() # email alert, etc.\n\n\nlist_of_matches = ['ERROR', 'CRITICAL']\nmatches = [process_matches(string_match) for string_match in list_of_matches]    \n\nfor m in matches: # prime matches\n    m.next()\n\nwhile True:\n    auditlog = tail( open(log_file_to_monitor) )\n    for line in auditlog:\n        for m in matches:\n            m.send(line)\n</code>\n</pre>\n", "senID": 0}, {"text": ["I use this to monitor log files.", "In the full implementation, I keep list_of_matches in a configuration file so it can be used for multiple purposes.", "On my list of enhancements is support for regex instead of a simple 'in' match."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["To my knowledge there's no equivalent to \"tail\" in the Python function list.", "Solution would be to use tell() (get file size) and read() to work out the ending lines."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This blog post (not by me) has the function written out, looks appropriate to me!", "http://www.manugarg.com/2007/04/real-tailing-in-python.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.manugarg.com/2007/04/real-tailing-in-python.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.manugarg.com/2007/04/real-tailing-in-python.html"}]}], [{"text": ["You might want to take a look at this recipe I've just submitted:\nhttp://code.activestate.com/recipes/577968-log-watcher-tail-f-log/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/577968-log-watcher-tail-f-log/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/577968-log-watcher-tail-f-log/"}]}]]