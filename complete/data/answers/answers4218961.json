[[{"text": ["Because 0.1 isn't 0.1; that value isn't representable in double precision, so it gets rounded to the nearest double-precision number, which is exactly:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "0.1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 0.1000000000000000055511151231257827021181583404541015625\n</code>\n</pre>\n", "senID": 1}, {"text": ["When you call fmod, you get the remainder of division by the value listed above, which is exactly:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "fmod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 0.0999999999999999500399638918679556809365749359130859375\n</code>\n</pre>\n", "senID": 3}, {"text": ["which rounds to 0.1 (or maybe 0.09999999999999995) when you print it."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "0.1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0.09999999999999995", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In other words, fmod works perfectly, but you're not giving it the input that you think you are."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "fmod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: Your own implementation gives you the correct answer because it is less accurate, believe it or not.", "First off, note that fmod computes the remainder without any rounding error; the only source of inaccuracy is the representation error introduced by using the value 0.1.", "Now, let's walk through your implementation, and see how the rounding error that it incurs exactly cancels out the representation error."], "childNum": 4, "tag": "p", "senID": 6, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "less accurate", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "fmod", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "0.1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Evaluate a - floor(a/n) * n one step at a time, keeping track of the exact values computed at each stage:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "a - floor(a/n) * n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["First we evaluate 1.0/n, where n is the closest double-precision approximation to 0.1 as shown above.", "The result of this division is approximately:"], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "1.0/n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "0.1", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n 9.999999999999999444888487687421760603063276150363492645647081359...\n</code>\n</pre>\n", "senID": 9}, {"text": ["Note that this value is not a representable double precision number -- so it gets rounded.", "To see how this rounding happens, let's look at the number in binary instead of decimal:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "rounded", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 1001.1111111111111111111111111111111111111111111111111 10110000000...\n</code>\n</pre>\n", "senID": 11}, {"text": ["The space indicates where the rounding to double precision occurs.", "Since the part after the round point is larger than the exact half-way point, this value rounds up to exactly 10."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "10", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["floor(10.0) is, predictably, 10.0.", "So all that's left is to compute 1.0 - 10.0*0.1."], "childNum": 3, "tag": "p", "senID": 13, "childList": [{"text": "floor(10.0)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "10.0", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "1.0 - 10.0*0.1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In binary, the exact value of 10.0 * 0.1 is:"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "10.0 * 0.1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 1.0000000000000000000000000000000000000000000000000000 0100\n</code>\n</pre>\n", "senID": 15}, {"text": ["again, this value is not representable as a double, and so is rounded at the position indicated by a space.", "This time it rounds down to exactly 1.0, and so the final computation is 1.0 - 1.0, which is of course 0.0."], "childNum": 3, "tag": "p", "senID": 16, "childList": [{"text": "1.0", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "1.0 - 1.0", "childNum": 0, "tag": "code", "childList": []}, {"text": "0.0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Your implementation contains two rounding errors, which happen to exactly cancel out the representation error of the value 0.1 in this case.", "fmod, by contrast, is always exact (at least on platforms with a good numerics library), and exposes the representation error of 0.1."], "childNum": 4, "tag": "p", "senID": 17, "childList": [{"text": "0.1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fmod", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "always", "childNum": 0, "tag": "em", "childList": []}, {"text": "0.1", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["This result is due to machine floating point representation.", "In your method, you are 'casting' (kinda) the float to an int and do not have this issue.", "The 'best' way to avoid such issues (esp for mod) is to multiply by a sufficiently large enough int (only 10 is needed in your case) and perform the operation again."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mod", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["From man fmod:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "man fmod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So what happens is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: As for why it works with floor(x/y), as far as I can tell this seems to be an FPU quirk.", "On x86, fmod uses the fprem instruction, whereas x/y will use fdiv.", "Curiously 1.0/0.1 seems to return exactly 10.0:"], "childNum": 8, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "floor(x/y)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fmod", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "fprem", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x/y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fdiv", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "1.0/0.1", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "10.0", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; struct.pack('d', 1.0/0.1) == struct.pack('d', 10.0)\nTrue\n</code>\n</pre>\n", "senID": 3}, {"text": ["I suppose fdiv uses a more precise algorithm than fprem.", "Some discussion can be found here: http://www.rapideuphoria.com/cgi-bin/esearch.exu?thread=1&amp;fromMonth=A&amp;fromYear=8&amp;toMonth=C&amp;toYear=8&amp;keywords=%22Remainder%22"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "fdiv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fprem", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "http://www.rapideuphoria.com/cgi-bin/esearch.exu?thread=1&amp;fromMonth=A&amp;fromYear=8&amp;toMonth=C&amp;toYear=8&amp;keywords=%22Remainder%22", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.rapideuphoria.com/cgi-bin/esearch.exu?thread=1&fromMonth=A&fromYear=8&toMonth=C&toYear=8&keywords=%22Remainder%22"}]}], [{"text": ["fmod returns x-i*y, which is less than y, and i is an integer.", "0.09.... is because of floating point precision.", "try fmod(0.3, 0.1) -&gt; 0.09... but fmod(0.4, 0.1) -&gt; 0.0 because 0.3 is 0.2999999... as a float."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "fmod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fmod(0.3, 0.1) -&gt; 0.09...", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "fmod(0.4, 0.1) -&gt; 0.0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["fmod(1/(2.", "**n), 1/(2.", "**m) will never produce anything but 0.0 for integer n>=m."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "fmod(1/(2.**n), 1/(2.**m)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "0.0", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["This gives the right answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = 1.0\nb = 0.1\n\na1,a2 = a.as_integer_ratio()\nb1,b2 = b.as_integer_ratio()\ndiv = float(a1*b2) / float(a2*b1)\nmod = a - b*div\nprint mod\n# 0.0\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think it works because by it uses rational equivalents of the two floating point numbers which provides a more accurate answer."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The Python divmod function is instructive here.", "It tells you both the quotient and remainder of a division operation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ python\n&gt;&gt;&gt; 0.1\n0.10000000000000001\n&gt;&gt;&gt; divmod(1.0, 0.1)\n(9.0, 0.09999999999999995)\n</code>\n</pre>\n", "senID": 1}, {"text": ["When you type 0.1, the computer can't represent that exact value in binary floating-point arithmetic, so it chooses the closest number that it can represent, 0.10000000000000001.", "Then when you perform the division operation, floating-point arithmetic decides that the quotient has to be 9, since 0.10000000000000001 * 10 is larger than 1.0.", "This leaves you with a remainder that is slightly less than 0.1."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I would want to use the new Python fractions module to get exact answers."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "fractions", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; Fraction(1, 1) % Fraction(1, 10)\nFraction(0, 1)\n</code>\n</pre>\n", "senID": 4}, {"text": ["IOW, (1/1) mod (1/10) = (0/1), which is equivalent to 1 mod 0.1 = 0."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "(1/1) mod (1/10) = (0/1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1 mod 0.1 = 0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Another option is to implement the modulus operator yourself, allowing you to specify your own policy."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = 1.0\n&gt;&gt;&gt; y = 0.1\n&gt;&gt;&gt; x / y - math.floor(x / y)\n0.0\n</code>\n</pre>\n", "senID": 7}]]