[[{"text": ["You could make a subprocess call to antiword.", "Antiword is a linux commandline utility for dumping text out of a word doc.", "Works pretty well for simple documents (obviously it loses formatting).", "It's available through apt, and probably as RPM, or you could compile it yourself."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "antiword", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Antiword"}]}], [{"text": ["OpenOffice.org can be scripted with Python: see here."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "see here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.services.openoffice.org/wiki/Python"}]}, {"text": ["Since OOo can load most MS Word files flawlessly, I'd say that's your best bet."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Take a look at how the doc format works and create word document using PHP in linux.", "The former is especially useful.", "Abiword is my recommended tool.", "There are limitations though:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "how the doc format works", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/124869/how-does-the-doc-format-work"}, {"text": "create word document using PHP in linux", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/124959/create-word-document-using-php-in-lunux"}, {"text": "Abiword", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.abisource.com/"}, {"text": "limitations", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.abisource.com/wiki/Microsoft_Word_documents"}]}], [{"text": ["I know this is an old question, but I was recently trying to find a way to extract text from MS word files, and the best solution by far I found was with wvLib:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://wvware.sourceforge.net/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://wvware.sourceforge.net/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wvware.sourceforge.net/"}]}, {"text": ["After installing the library, using it in Python is pretty easy:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import commands\n\nexe = 'wvText ' + word_file + ' ' + output_txt_file\nout = commands.getoutput(exe)\nexe = 'cat ' + output_txt_file\nout = commands.getoutput(exe)\n</code>\n</pre>\n", "senID": 3}, {"text": ["And that's it.", "Pretty much, what we're doing is using the commands.getouput function to run a couple of shell scripts, namely wvText (which extracts text from a Word document, and cat to read the file output).", "After that, the entire text from the Word document will be in the out variable, ready to use."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Hopefully this will help anyone having similar issues in the future."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["(Note: I posted this on this question as well, but it seems relevant here, so please excuse the repost."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1184747/rtf-doc-docx-text-extraction-in-program-written-in-c-qt"}]}, {"text": ["Now, this is pretty ugly and pretty hacky, but it seems to work for me for basic text extraction.", "Obviously to use this in a Qt program you'd have to spawn a process for it etc, but the command line I've hacked together is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n unzip -p file.docx | grep '&lt;w:t' | sed 's/&lt;[^&lt;]*&gt;//g' | grep -v '^[[:space:]]*$'\n</code>\n</pre>\n", "senID": 2}, {"text": ["So that's:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["unzip -p file.docx: -p == \"unzip to stdout\""], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "unzip -p file.docx", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["grep '&lt;w:t':  Grab just the lines containing '&lt;w:t' (&lt;w:t&gt; is the Word 2007 XML element for \"text\", as far as I can tell)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "grep '&lt;w:t'", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["sed 's/&lt;[^&lt;]>//g'*: Remove everything inside tags"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "sed 's/&lt;[^&lt;]", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["grep -v '^[[:space:]]$'*: Remove blank lines"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "grep -v '^[[:space:]]", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["There is likely a more efficient way to do this, but it seems to work for me on the few docs I've tested it with."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["As far as I'm aware, unzip, grep and sed all have ports for Windows and any of the Unixes, so it should be reasonably cross-platform.", "Despit being a bit of an ugly hack ;)"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["benjamin's answer is a pretty good one.", "I have just consolidated..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import zipfile, re\n\ndocx = zipfile.ZipFile('/path/to/file/mydocument.docx')\ncontent = docx.read('word/document.xml')\ncleaned = re.sub('&lt;(.|\\n)*?&gt;','',content)\nprint cleaned\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If your intention is to use purely python modules without calling a subprocess, you can use the zipfile python modude."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n content = \"\"\n# Load DocX into zipfile\ndocx = zipfile.ZipFile('/home/whateverdocument.docx')\n# Unpack zipfile\nunpacked = docx.infolist()\n# Find the /word/document.xml file in the package and assign it to variable\nfor item in unpacked:\n    if item.orig_filename == 'word/document.xml':\n        content = docx.read(item.orig_filename)\n\n    else:\n        pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["Your content string however needs to be cleaned up, one way of doing this is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # Clean the content string from xml tags for better search\nfullyclean = []\nhalfclean = content.split('&lt;')\nfor item in halfclean:\n    if '&gt;' in item:\n        bad_good = item.split('&gt;')\n        if bad_good[-1] != '':\n            fullyclean.append(bad_good[-1])\n        else:\n            pass\n    else:\n        pass\n\n# Assemble a new string with all pure content\ncontent = \" \".join(fullyclean)\n</code>\n</pre>\n", "senID": 3}, {"text": ["But there is surely a more elegant way to clean up the string, probably using the re module.", "Hope this helps."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Use the native Python docx module.", "Here's how to extract all the text from a doc:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n document = opendocx('Hello world.docx')\n\n# This location is where most document content lives \ndocbody = document.xpath('/w:document/w:body', namespaces=wordnamespaces)[0]\n\n# Extract all text\nprint getdocumenttext(document)\n</code>\n</pre>\n", "senID": 1}, {"text": ["See http://github.com/mikemaccana/python-docx"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://github.com/mikemaccana/python-docx", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/mikemaccana/python-docx"}]}, {"text": ["Parsing XML with regexs invokes cthulu.", "Don't do it!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I'm not sure if you're going to have much lock without using COM.", "The .doc format is ridiculously complex, and is often called a \"memory dump\" of Word at the time of saving!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["At Swati, that's in HTML, which is fine and dandy, but most word documents aren't so nice!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]