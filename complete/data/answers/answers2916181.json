[[{"text": ["You could give your states constant names instead of using 0, 1, 2, etc.", "for improved readability."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could use a dictionary to map (current_state, input) -&gt; (next_state), but that doesn't really let you do any additional processing during the transitions.", "Unless you include some \"transition function\" too to do extra processing."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "(current_state, input) -&gt; (next_state)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Or you could do a non-FSM approach.", "I think this will work as long as 0xAA 0xAA only appears when it indicates a \"start\" (doesn't appear in data)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "0xAA 0xAA", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n with open(sys.argv[1], 'rb') as f:\n    contents = f.read()\n    for chunk in contents.split('\\xaa\\xaa')[1:]:\n        length = ord(chunk[0])\n        data = chunk[10:10+length]\n        print data\n</code>\n</pre>\n", "senID": 3}, {"text": ["If it does appear in data, you can instead use string.find('\\xaa\\xaa', start) to scan through the string, setting the start argument to begin looking where the last data block ended.", "Repeat until it returns -1."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "string.find('\\xaa\\xaa', start)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "start", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The coolest way I've seen to implement FSMs in Python has to be via generators and coroutines.", "See this Charming Python post for an example.", "Eli Bendersky also has an excellent treatment of the subject."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Charming Python post", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://gnosis.cx/publish/programming/charming_python_b5.html"}, {"text": "an excellent treatment of the subject", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://eli.thegreenplace.net/2009/08/29/co-routines-as-an-alternative-to-state-machines/"}]}, {"text": ["If coroutines aren't familiar territory, David Beazley's A Curious Course on Coroutines and Concurrency is a stellar introduction."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "A Curious Course on Coroutines and Concurrency", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/coroutines/index.html"}]}], [{"text": ["I am a little apprehensive about telling anyone what's Pythonic, but here goes.", "First, keep in mind that in python functions are just objects.", "Transitions can be defined with a dictionary that has the (input, current_state) as the key and the tuple (next_state, action) as the value.", "Action is just a function that does whatever is necessary to transition from the current state to the next state.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There's a nice looking example of doing this at http://code.activestate.com/recipes/146262-finite-state-machine-fsm.", "I haven't used it, but from a quick read it seems like it covers everything."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.activestate.com/recipes/146262-finite-state-machine-fsm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/146262-finite-state-machine-fsm"}]}, {"text": ["A similar question was asked/answered here a couple of months ago: http://stackoverflow.com/questions/2101961/python-state-machine-design.", "You might find looking at those responses useful as well."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://stackoverflow.com/questions/2101961/python-state-machine-design", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2101961/python-state-machine-design"}]}], [{"text": ["I think your solution looks fine, except you should replace count = count - 1 with count -= 1."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "count = count - 1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "count -= 1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This is one of those times where fancy code-show-offs will come up ways of have dicts mapping states to callables, with a small driver function, but it isn't better, just fancier, and using more obscure language features."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I suggest checking out chapter 4 of Text Processing in Python by David Mertz.", "He implements a state machine class in Python that is very elegant."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "chapter 4 of Text Processing in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gnosis.cx/TPiP/chap4.txt"}]}], [{"text": ["I think the most pythonic way would by like what FogleBird suggested, but mapping from (current state, input) to a function which would handle the processing and transition."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can use regexps.", "Something like this code will find the first block of data.", "Then it's just a case of starting the next search from after the previous match."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n find_header = re.compile('\\xaa\\xaa(.).{9}', re.DOTALL)\nm = find_header.search(input_text)\nif m:\n    length = chr(find_header.group(1))\n    data = input_text[m.end():m.end() + length]\n</code>\n</pre>\n", "senID": 1}]]