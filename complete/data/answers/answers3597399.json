[[{"text": ["No, don't avoid regular expressions.", "They're actually quite a nifty little tool and will save you a lot of work if you use them wisely."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What you do need to avoid is trying to use it for everything, a malaise that appears to strike those new to regular expressions before they become a little more tempered and a little less enamoured :-)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["For example, don't use it to validate email addresses.", "The way you validate an email address is to send an email to it with a link that the receiver has to click on to complete the \"transaction\"."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "don't", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["There are billions of valid email addresses (according to the RFCs) that have no physical email receiver behind them.", "The only way to be certain that there is a receiver is to send an email and wait for proof positive that it was received and acted upon."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "only", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["If I find myself writing a regular expression that's more than, let's say, 60 characters, I step back to see if there's a more readable way.", "Similarly, if I write a regular expression and come back a week later and can't instantly recognise what it does, I think about replacing it.", "This particular paragraph consists of my opinions of course, but they've served me well :-)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Regular expressions are a tool.", "They are perfectly suited to some tasks and not to others.", "Like any tool, use them when they are the right tool for the job.", "Don't just avoid them because somebody said they were bad.", "Learn how to use them and then you can decide for yourself rather then depending on someone elses dogma."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you choose to use a more general parsing approach, like pyparsing or PLY, you will never require regular expressions (which can only match a small subset of the languages matchable with such general parsers).", "However, lexers such as the one in PLY are typically built around regular expressions (which are a perfect match for a lexer's needs!", "), so you will probably have to avoid that (as well as powerful tools such as BeautifulSoup when any \"normal\" user would be able to keep using and enjoying it by simply passing a regular expression object as the selector, since BeautifulSoup fully supports that) and will have to recode a lot of such existing parsers with your chosen general-purpose parsing package."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}, {"text": "PLY", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/ply/"}, {"text": "require", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "PLY", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "BeautifulSoup", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "BeautifulSoup", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Performance may suffer greatly, of course, by using extremely general tools in cases where simpler, highly optimized and concise ones would be a perfect solution -- and the size of your code may \"blow up\" to being very large in many common cases.", "But if you don't mind having programs twice as big and twice as slow, and are determined to avoid regular expressions at all costs, you can do that."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "can", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["On the other hand, if your main concern is with readability (quite an understandable and commendable concern, too), then the re.VERBOSE option, by allowing abundant use of whitespace and comments within the RE's pattern, can really do wonders for that goal without removing any of REs' advantages (except by diluting a sometimes-excessive conciseness;-).", "You WILL want to also keep at least one general-purpose parsing system under your belt, of course (rather than stretch REs to do tasks they're wrong for, as so many people unfortunately do!", ") -- but a minimal command of REs will serve you well in so many cases (including, for example, full use of BeautifulSoup and many other tools which can accept REs as parameters to apply them appropriately) that I think it's quite to be recommended."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "re.VERBOSE", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "any", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "also", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "BeautifulSoup", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Just for some comparisions, here my version email format check not with regexp (with test cases) and one readable regexp offered to me as alternative (though sending email after it is accepted, is great idea):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # -*- coding: utf8 -*- \nimport string\nprint(\"Valid letters in this computer are: \"+string.letters)\nimport re \ndef validateEmail(a): \n    sep=[x for x in a if not (x.isalpha() or \n                              x.isdigit() or \n                              x in r\"!#$%&amp;'*+-/=?^_`{|}~]\") ] \n    sepjoined=''.join(sep) \n    ## sep joined must be ..@.... form \n    if len(a)&gt;255 or sepjoined.strip('.') != '@': return False \n    end=a \n    for i in sep: \n        part,i,end=end.partition(i) \n        if len(part)&lt;2: return False \n    return len(end)&gt;1 \n\ndef emailval(address): \n    pattern = \"[\\.\\w]{2,}[@]\\w+[.]\\w+\" \n    return re.match(pattern, address)\n\nif __name__ == '__main__': \n    emails = [ \"test.@web.com\",\"test+john@web.museum\", \"test+john@web.m\", \n               \"a@n.dk\", \"and.bun@webben.de\",\"marjaliisa.h\u00e4m\u00e4l\u00e4inen@hel.fi\", \n               \"marja-liisa.h\u00e4m\u00e4l\u00e4inen@hel.fi\", \"marjaliisah@hel.\",'tony@localhost',\n               '1234@23.45','me@somewhere'] \n\n    print('\\n\\t'.join([\"Valid emails are:\"] + \n                      filter(validateEmail,emails)))\n\n    print('\\n\\t'.join([\"Regexp gives wrong answer:\"] + \n                       filter(emailval,emails)))\n\n\"\"\" Output:\nValid letters in this computer are: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\nValid emails are:\n        test+john@web.museum\n        and.bun@webben.de\n        tony@localhost\n        1234@23.45\n        me@somewhere\nRegexp gives wrong answer:\n        test.@web.com\n        and.bun@webben.de\n        1234@23.45\n\"\"\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: cleaned up the regex filter function from this ancient code, edited for @detly link based more permissive version.", "Good enough for form filling first check for me before sending the confirmation email.", "Finaly put the 255 character length limit check mentioned in comments."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This code by purpose does not accept the normal a@b as valid email address, but does accept me@somewhere.", "Another thing is that it depends of what isalpha returns.", "So this output, which is from Ideone.com has not accepted the scandinavian \u00f6\u00e4 even they are valid nowadays.", "When run in my home computer, those are accepted.", "This is even when coding line is there."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["(Deleted a regular expression which purported to be an \"official\" one but is in fact not found in the RFC it claimed to be from."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This regex may be amusing as it is an attempt to precisely match the e-mail address grammar provided in an older version of the Internet mail standards."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "This", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html"}]}], [{"text": ["Regular expressions are likely the right tool for extracting/validating email addresses..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To extract one or more email addresses from raw text:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\npat_e = re.compile(r'(?P&lt;email&gt;[\\w.+-]+@(?:[\\w-]+\\.)+[a-zA-Z]{2,})')\nemails = []\nfor r in pat_e.finditer(text):\n  emails.append(r.group('email'))\nreturn emails\n</code>\n</pre>\n", "senID": 2}, {"text": ["To see if a single piece of text is a valid email:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import re\npat_m = re.compile(r'([\\w.+-]+@(?:[\\w-]+\\.)+[a-zA-Z]{2,}$)')\nif pat_m.match(text):\n  return True\nreturn False\n</code>\n</pre>\n", "senID": 4}]]