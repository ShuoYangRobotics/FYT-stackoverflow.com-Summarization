[[{"text": ["Try following regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ^[abc]{3}(,[abc]{3})*$\n</code>\n</pre>\n", "senID": 1}, {"text": ["^...$ from the start till the end of the string\n[...] one of the given character\n...{3} three time of the phrase before\n(...)* 0 till n times of the characters in the brackets"], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "^...$", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "[...]", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "...{3}", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "(...)*", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["What you're asking it to find with your regex is \"at least one triple of letters a, b, c\" - that's what \"+\" gives you.", "Whatever follows after that doesn't really matter to the regex.", "You might want to include \"$\", which means \"end of the line\", to be sure that the line must all consist of allowed triples.", "However in the current form your regex would also demand that the last triple ends in a comma, so you should explicitly code that it's not so.", "Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n re.match('([abc][abc][abc],)*([abc][abc][abc])$'\n</code>\n</pre>\n", "senID": 1}, {"text": ["This finds any number of allowed triples followed by a comma (maybe zero), then a triple without a comma, then the end of the line."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: including the \"^\" (start of string) symbol is not necessary, because the match method already checks for a match only at the beginning of the string. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "match", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You need to iterate over sequence of found values."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n data_string = \"abc,bca,df\"\n\nimatch = re.finditer(r'(?P&lt;value&gt;[abc]{3})(,|$)', data_string)\n\nfor match in imatch:\n    print match.group('value')\n</code>\n</pre>\n", "senID": 1}, {"text": ["So the regex to check if the string matches pattern will be"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n data_string = \"abc,bca,df\"\n\nmatch = re.match(r'^([abc]{3}(,|$))+', data_string)\n\nif match:\n    print \"data string is correct\"\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Your result is not surprising since the regular expression"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ([abc][abc][abc],)+\n</code>\n</pre>\n", "senID": 1}, {"text": ["tries to match a string containing three characters of [abc] followed by a comma one ore more times anywhere in the string.", "So the most important part is to make sure that there is nothing more in the string - as scessor suggests with adding ^ (start of string) and $ (end of string) to the regular expression."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "[abc]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "anywhere", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "^", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "$", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["An alternative without using regex (albeit a brute force way):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def matcher(x):\n        total = [\"\".join(p) for p in itertools.product(('a','b','c'),repeat=3)]\n            for i in x.split(','):\n                if i not in total:\n                    return False\n         return True\n\n&gt;&gt;&gt; matcher(\"abc,bca,aaa\")\n    True\n&gt;&gt;&gt; matcher(\"abc,bca,xyz\")\n    False\n&gt;&gt;&gt; matcher(\"abc,aaa,bb\")\n    False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If your aim is to validate a string as being composed of triplet of letters a,b,and c:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for ss in (\"abc,bbc,abb,baa,bbb\",\n           \"acc\",\n           \"abc,bbc,abb,bXa,bbb\",\n           \"abc,bbc,ab,baa,bbb\"):\n    print ss,'   ',bool(re.match('([abc]{3},?)+\\Z',ss))\n</code>\n</pre>\n", "senID": 1}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n abc,bbc,abb,baa,bbb     True\nacc     True\nabc,bbc,abb,bXa,bbb     False\nabc,bbc,ab,baa,bbb     False\n</code>\n</pre>\n", "senID": 3}, {"text": ["\\Z means: the end of the string.", "Its presence obliges the match to be until the very end of the string"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "\\Z", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["By the way, I like the form of Sonya too, in a way it is clearer:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n bool(re.match('([abc]{3},)*[abc]{3}\\Z',ss))\n</code>\n</pre>\n", "senID": 6}], [{"text": ["The obligatory \"you don't need a regex\" solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n all(letter in 'abc,' for letter in data) and all(len(item) == 3 for item in data.split(','))\n</code>\n</pre>\n", "senID": 1}]]