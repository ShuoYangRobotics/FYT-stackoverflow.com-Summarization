[[{"text": ["Have a look at itertools.combinations:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.combinations", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.combinations"}]}, {"text": ["Since 2.6, batteries are included!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Alabaster's answer missed one aspect: Ben asked for ALL combinations... not just combinations of length \"r\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So you'd either have to loop through all lengths \"L\":"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n stuff = [1, 2, 3]\nfor L in range(0, len(stuff)+1):\n  for subset in itertools.combinations(stuff, L):\n    print(subset)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or -- if you want to get snazzy (or bend the brain of whoever reads your code after you) -- you can generate the chain of \"combinations()\" generators, and iterate through that:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from itertools import chain, combinations\ndef all_subsets(ss):\n  return chain(*map(lambda x: combinations(ss, x), range(0, len(ss)+1)))\n\nfor subset in all_subsets(stuff):\n  print(subset)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["If you don't have access to Python 2.6 you might find it in a recipe from the Python Cookbook.", "I'm sure there are some more recipes for this topic."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "recipe from the Python Cookbook", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/190465/"}]}], [{"text": ["Here's a lazy one-liner, also using itertools:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def combinations(iter):\n    return ( set(compress(iter,mask)) for mask in product(*[[0,1]]*len(iter)) )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Main idea behind this answer: there are 2^N combinations -- same as the number of binary strings of length N. For each binary string, you pick all elements corresponding to a \"1\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n abc\n |\n V\n000 -&gt; \n001 -&gt;   c\n010 -&gt;  b\n011 -&gt;  bc\n100 -&gt; a\n101 -&gt; a c\n110 -&gt; ab\n111 -&gt; abc\n</code>\n</pre>\n", "senID": 3}, {"text": ["You may wish to redefine as list(iter) so len will work on generators."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "list(iter)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "len", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Demo"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Demo", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(combinations(range(4)))\n[set(), {3}, {2}, {2, 3}, {1}, {1, 3}, {1, 2}, {1, 2, 3}, {0}, {0, 3}, {0, 2}, {0, 2, 3}, {0, 1}, {0, 1, 3}, {0, 1, 2}, {0, 1, 2, 3}]\n\n&gt;&gt;&gt; list(combinations('abcd'))\n[set(), {'d'}, {'c'}, {'c', 'd'}, {'b'}, {'b', 'd'}, {'c', 'b'}, {'c', 'b', 'd'}, {'a'}, {'a', 'd'}, {'a', 'c'}, {'a', 'c', 'd'}, {'a', 'b'}, {'a', 'b', 'd'}, {'a', 'c', 'b'}, {'a', 'c', 'b', 'd'}]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I agree with Dan H that Ben indeed asked for all combinations.", "itertools.combinations() does not give all combinations."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "all", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "itertools.combinations()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Another issue is, if the input iterable is big, it is perhaps better to return a generator instead of everything in a list:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n iterable = range(10)\nfor s in xrange(len(iterable)+1):\n  for comb in itertools.combinations(iterable, s):\n    yield comb\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Using list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def selfCombine( list2Combine, length ):\n    listCombined = str( ['list2Combine[i' + str( i ) + ']' for i in range( length )] ).replace( \"'\", '' ) \\\n                     + 'for i0 in range(len( list2Combine ) )'\n    if length &gt; 1:\n        listCombined += str( [' for i' + str( i ) + ' in range( i' + str( i - 1 ) + ', len( list2Combine ) )' for i in range( 1, length )] )\\\n            .replace( \"', '\", ' ' )\\\n            .replace( \"['\", '' )\\\n            .replace( \"']\", '' )\n\n    listCombined = '[' + listCombined + ']'\n    listCombined = eval( listCombined )\n\n    return listCombined\n\nlist2Combine = ['A', 'B', 'C']\nlistCombined = selfCombine( list2Combine, 2 )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output would be:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['A', 'A']\n['A', 'B']\n['A', 'C']\n['B', 'B']\n['B', 'C']\n['C', 'C']\n</code>\n</pre>\n", "senID": 3}]]