[[{"text": ["The code as written is largely untestable - and you need to make it testable.", "So, you need the C code to be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n int\nphase_of_the_moon()     /* 0-7, with 0: new, 4: full */\n{\n    register struct tm *lt = getlt();\n    return testable_potm(lt);\n}\n\nstatic int\ntestable_potm(const struct tm *lt)\n{\n    register int epact, diy, goldn;\n\n    diy = lt-&gt;tm_yday;\n    goldn = (lt-&gt;tm_year % 19) + 1;\n    epact = (11 * goldn + 18) % 30;\n    if ((epact == 25 &amp;&amp; goldn &gt; 11) || epact == 24)\n        epact++;\n\n    return( (((((diy + epact) * 6) + 11) % 177) / 22) &amp; 7 );\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now you can run tests with multiple values of time.", "The alternative way to do this is to fake getlt() instead."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "getlt()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You then need parallel changes in your Python code.", "Then you create a file of time_t values which can be read by both Python and C, and then converted into an appropriate structure (via localtime() in C).", "Then you can see where things are deviating."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "time_t", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "localtime()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Edit: Turns out both of the \"problems\" I spotted here were based on a misunderstanding of the tm struct.", "I'll leave the answer intact for the sake of the discussion in the comments, but save your votes for someone who might actually be correct.", ";-)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "tm", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"tag": "hr", "senID": 1}, {"text": ["Caveat: I'm not terribly familiar with C time constructs; I'm mostly going off the field documentation supplied for strftime."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "strftime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I see two \"bugs\" in your port.", "First, I believe tm_year is intended to be the year without century, not the year minus 1900, so, goldn should be ((lt.year % 100) % 19) + 1.", "Secondly, your calculation for diy is zero-based, whereas tm_yday appears (again, from the docs) to be one-based.", "However, I'm not certain about the latter, as fixing just the goldn line gives a correct result (at least for today), where as fixing both gives the wrong answer:"], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "tm_year", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "goldn", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "((lt.year % 100) % 19) + 1", "childNum": 0, "tag": "code", "childList": []}, {"text": "diy", "childNum": 0, "tag": "code", "childList": []}, {"text": "tm_yday", "childNum": 0, "tag": "code", "childList": []}, {"text": "goldn", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def phase_of_the_moon():\n    lt = date.today()\n\n    diy = (lt - date(lt.year, 1, 1)).days\n    goldn = ((lt.year % 100) % 19) + 1\n    epact = (11 * goldn + 18) % 30\n    if ((epact == 25 and goldn &gt; 11) or epact == 24):\n        epact += 1\n    return ( (((((diy + epact) * 6) + 11) % 177) / 22) &amp; 7 )\n\n&gt;&gt;&gt; phase_of_the_moon():\n3\n</code>\n</pre>\n", "senID": 4}, {"text": ["Again, this is mostly guesswork.", "Please be kind.", ":-)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Curiously, when I compile and run the nethack example I get \"2\" as the answer (\"First Quarter\" which is the same as your port)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;time.h&gt;\n\nstatic struct tm *\ngetlt()\n{\n        time_t date;\n        (void) time(&amp;date);\n        return(localtime(&amp;date));\n}\n/*\n * moon period = 29.53058 days ~= 30, year = 365.2422 days\n * days moon phase advances on first day of year compared to preceding year\n *  = 365.2422 - 12*29.53058 ~= 11\n * years in Metonic cycle (time until same phases fall on the same days of\n *  the month) = 18.6 ~= 19\n * moon phase on first day of year (epact) ~= (11*(year%19) + 29) % 30\n *  (29 as initial condition)\n * current phase in days = first day phase + days elapsed in year\n * 6 moons ~= 177 days\n * 177 ~= 8 reported phases * 22\n * + 11/22 for rounding\n */\nint\nphase_of_the_moon()     /* 0-7, with 0: new, 4: full */\n{\n    register struct tm *lt = getlt();\n    register int epact, diy, goldn;\n\n    diy = lt-&gt;tm_yday;\n    goldn = (lt-&gt;tm_year % 19) + 1;\n    epact = (11 * goldn + 18) % 30;\n    if ((epact == 25 &amp;&amp; goldn &gt; 11) || epact == 24)\n        epact++;\n\n    return( (((((diy + epact) * 6) + 11) % 177) / 22) &amp; 7 );\n}\n\nint main(int argc, char * argv[]) {\n    printf (\"phase of the moon %d\\n\\n\", phase_of_the_moon());\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt; a.out\nphase of the moon 2\n</code>\n</pre>\n", "senID": 3}, {"text": ["But that doesn't seem like the right answer, as today, weatherunderground.com and alt.org reports the phase of the moon as \"Waxing Gibbous\" (a.k.a 3)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I tried remove the \"-1900\" but that didn't result in the right answer either."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I like to think I know a thing or two about calendars, so let's see if I can clear a few things up."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The Catholic Church defines the date of Easter in terms of lunar phases (this is why the date jumps around from year to year).", "Because of this, it needs to be able to calculate the approximate moon phase, and its algorithm for doing so is explained here."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Computus"}]}, {"text": ["I have not done very detailed checking, but it appears that the NetHack algorithm is based heavily on the Church's algorithm.", "The NetHack algorithm seems to, like the Church's algorithm, pay attention only to the calendar date, ignoring time zones and the time of day."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The NetHack algorithm uses only the year and the day of the year.", "I can tell from examining the code that, to be Y2K compatible, that tm_year has to be the year minus 1900."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Following code is borrowed from this site, pasting it here for easy reference (and in case the other site goes down).", "Seems to do what you want."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "borrowed from this site", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.daniweb.com/code/post968407.html"}]}, {"code": "<pre>\n<code>\n # Determine the moon phase of a date given\n# Python code by HAB\n\ndef moon_phase(month, day, year):\n    ages = [18, 0, 11, 22, 3, 14, 25, 6, 17, 28, 9, 20, 1, 12, 23, 4, 15, 26, 7]\n    offsets = [-1, 1, 0, 1, 2, 3, 4, 5, 7, 7, 9, 9]\n    description = [\"new (totally dark)\",\n      \"waxing crescent (increasing to full)\",\n      \"in its first quarter (increasing to full)\",\n      \"waxing gibbous (increasing to full)\",\n      \"full (full light)\",\n      \"waning gibbous (decreasing from full)\",\n      \"in its last quarter (decreasing from full)\",\n      \"waning crescent (decreasing from full)\"]\n    months = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n\n    if day == 31:\n        day = 1\n    days_into_phase = ((ages[(year + 1) % 19] + ((day + offsets[month-1]) % 30) + (year &lt; 1900)) % 30)\n    index = int((days_into_phase + 2) * 16/59.0)\n    if index &gt; 7:\n        index = 7\n    status = description[index]\n\n    # light should be 100% 15 days into phase\n    light = int(2 * days_into_phase * 100/29)\n    if light &gt; 100:\n        light = abs(light - 200);\n    date = \"%d%s%d\" % (day, months[month-1], year)\n\n    return date, status, light\n\n# put in a date you want ...\nmonth = 5\nday = 14\nyear = 2006  # use yyyy format\n\ndate, status, light = moon_phase(month, day, year)\nprint \"moon phase on %s is %s, light = %d%s\" % (date, status, light, '%')\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can use the time module to get the current local time.", "Heres how I did it (paste below posted code to testrun):"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "time", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "current local time", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import time\ntm = time.localtime()\nmonth = tm.tm_mon\nday = tm.tm_mday\nyear = tm.tm_year\ndate, status, light = moon_phase(month, day, year)\nprint \"moon phase on %s is %s, light = %d%s\" % (date, status, light, '%')\n</code>\n</pre>\n", "senID": 3}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n moon phase on 22Dec2009 is waxing crescent (increasing to full), light = 34%\n</code>\n</pre>\n", "senID": 5}, {"text": ["Moon stuff is fun.", ":) "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I'm long late on this thread but fwiw, the alt.org server's display of pom via the web only updates on cron a couple times per day so if you're off by just a bit from it, that could be the reason.", "The game itself runs from whatever is in the nethack code itself so doesn't suffer the same caching issue.", "-drew (alt.org owner)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Here is my conversion of it, and I've tested this against the C code by passing in values from xrange(0, 1288578760, 3601), and they both return the same values.", "Note that I've changed it so that you can pass the seconds since epoch, so that I could test it against the C version for a third of a million different values.", "The \"seconds\" value is optional"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def phase_of_the_moon(seconds = None):\n   '0-7, with 0: new, 4: full'\n   import time\n\n   if seconds == None: seconds = time.time()\n   lt = time.localtime(seconds)\n\n   tm_year = lt.tm_year - 1900\n   diy = lt.tm_yday - 1\n   goldn = (tm_year % 19) + 1\n   epact = (11 * goldn + 18) % 30\n\n   if (epact == 25 and goldn > 11) or epact == 24: epact += 1\n\n   return (((((diy + epact) * 6) + 11) % 177) / 22) & 7\n</code>\n</pre>\n", "senID": 1}]]