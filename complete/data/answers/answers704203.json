[[{"text": ["This is in Perl, but you should be able to translate it to Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\n#set times to 0 for infinite times\nmy ($times, $wait, $program, @args) = @ARGV;\n\n$times = -1 unless $times;\nwhile ($times--) {\n    $times = -1 if $times &lt; 0; #catch -2 and turn it back into -1\n    die \"could not fork\" unless defined(my $pid = fork);\n\n    #replace child with the program we want to launch\n    unless ($pid) {\n        exec $program, @args;\n    }\n\n    #parent waits and kills the child if it isn't done yet\n    sleep $wait;\n\n    kill $pid;\n    waitpid $pid, 0; #clean up child\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Because I am trying to teach myself Python, here it is in Python (I do not trust this code):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\nimport os\nimport sys\nimport time\n\ntimes    = int(sys.argv[1])\nwait     = int(sys.argv[2])\nprogram  = sys.argv[3]\nargs     = []\nif len(sys.argv) &gt;= 4:\n    args = sys.argv[3:]\n\nif times == 0:\n    times = -1\n\nwhile times:\n    times = times - 1\n    if times &lt; 0:\n    \ttimes = -1\n\n    pid = os.fork()\n\n    if not pid:\n    \tos.execvp(program, args)\n\n    time.sleep(wait)\n\n    os.kill(pid, 15)\n    os.waitpid(pid, 0)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["With bash:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while true ; do\n    run_proc &amp;\n    PID=$!\n    sleep 3600\n    kill $PID\n    sleep 30\ndone\n</code>\n</pre>\n", "senID": 1}, {"text": ["The $!", "bash variable expands to the PID of the most recently started background process.", "The sleep just waits an hour, then the kill shuts down that process."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "$!", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sleep", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "kill", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The while loop just keeps doing it over and over."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "while", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["One idea: Save the process's PID (returned by fork() in your child process) to a file, then either schedule a cron job to kill it or kill it manually, reading the PID from the file."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "fork()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cron", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Another option: Create a shell script wrapper that automatically kills and restarts the process.", "Same as above, but you can keep the PID in memory, sleep for as long as you need, kill the process, then loop."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Take a look at the start-stop-daemon utility. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "start-stop-daemon", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://olympus.het.brown.edu/cgi-bin/man/man2html?start-stop-daemon"}]}], [{"text": ["You could always write a script to search for those processes and kill them if found.", "Then add a cronjob to execute the script."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Find process ID of a process with known name"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Find process ID of a process with known name", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.faqs.org/faqs/unix-faq/faq/part3/section-10.html"}]}, {"text": ["Kill processes with a known ID"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Kill processes with a known ID", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.unix.com/unix-dummies-questions-answers/5245-script-kill-all-child-process-given-pid.html"}]}, {"text": ["In python os.kill() can be used to kill a process given the id."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "os.kill()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/os.html#os.kill"}]}], [{"text": ["In python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import subprocess\nimport time\n\nwhile True:    \n    p = subprocess.Popen(['/path/to/program', 'param1', 'param2'])\n    time.sleep(2 * 60 * 60) # wait time in seconds - 2 hours\n    p.kill()\n</code>\n</pre>\n", "senID": 1}, {"text": ["p.kill() is python >= 2.6."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "p.kill()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["On python &lt;= 2.5 you can use this instead:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n os.kill(p.pid, signal.SIGTERM)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Not an ideal method but if you know the name of the program and you know it's the only process of that name running on the system you can use this in cron:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n 0 */2 * * * kill `ps -ax | grep programName | grep -v grep | awk '{ print $1 }'` &amp;&amp; ./scriptToStartProcess\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will run every two hours on the hour and kill programName then start the process again."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]