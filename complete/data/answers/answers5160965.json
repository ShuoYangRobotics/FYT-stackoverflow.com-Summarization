[[{"text": ["\"simple string methods\" are the root [pun intended] of all evil -- see examples below."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Update 2 Code and output now show that proposed regexes also don't work very well."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Update 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Use ElementTree.", "The function that you are looking for is iterparse.", "Enable \"start\" events.", "Bale out on the first iteration."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "iterparse", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # coding: ascii\nimport xml.etree.cElementTree as et\n# import xml.etree.ElementTree as et\n# import lxml.etree as et\nfrom cStringIO import StringIO\nimport re\n\nxml_text_1 = \"\"\"\\\n&lt;?xml version=\"1.0\" ?&gt; \n&lt;!--  this is a comment --&gt; \n&lt;root\n&gt;&lt;foo&gt;bar&lt;/foo&gt;&lt;/root\n&gt;\n\"\"\"\n\nxml_text_2 = \"\"\"\\\n&lt;?xml version=\"1.0\" ?&gt; \n&lt;!--  this is a comment --&gt; \n&lt;root\n&gt;&lt;foo&gt;bar&lt;/foo&gt;&lt;/root\n&gt;\n&lt;!--\nThat's all, folks! \n--&gt;\n\"\"\"\n\nxml_text_3 = '''&lt;?xml version=\"1.0\" ?&gt;\n&lt;!-- &lt;mole1&gt; --&gt;\n&lt;root&gt;&lt;foo /&gt;&lt;/root&gt;\n&lt;!-- &lt;/mole2&gt; --&gt;'''\n\nxml_text_4 = '''&lt;?xml version=\"1.0\" ?&gt;&lt;!-- &lt;mole1&gt; --&gt;&lt;root&gt;&lt;foo /&gt;&lt;/root&gt;&lt;!-- &lt;/mole2&gt; --&gt;'''\n\nfor xml_text in (xml_text_1, xml_text_2, xml_text_3, xml_text_4):\n    print\n    chrstr = xml_text.strip()\n    x = max(chrstr.rfind('\\r'),chrstr.rfind('\\n'))\n    lastline = chrstr[x:]\n    print \"*** eyquem 1:\", repr(lastline.strip())\n\n    chrstr = xml_text.strip()\n    x = max(chrstr.rfind('\\r'),chrstr.rfind('\\n'))\n    lastline = chrstr[x+1:]\n    if lastline[0:5]=='&lt;!-- ':\n        chrstr = xml_text[0:x].rstrip()\n        x = max(chrstr.rfind('\\r'),chrstr.rfind('\\n'))\n        print \"*** eyquem 2:\", repr(chrstr[x+1:])\n    else:\n        print \"*** eyquem 2:\", repr(lastline)\n\n    m = None\n    for m in re.finditer('^&lt;/[^&gt;]+&gt;', xml_text, re.MULTILINE):\n        pass\n    if m: print \"*** eyquem 3:\", repr(m.group())\n    else: print \"*** eyquem 3:\", \"FAIL\"\n\n    m = None\n    for m in re.finditer('&lt;/[^&gt;]+&gt;', xml_text):\n        pass\n    if m: print \"*** eyquem 4:\", repr(m.group())\n    else: print \"*** eyquem 4:\", \"FAIL\"\n\n    m = re.search('^&lt;(?![?!])[^&gt;]+&gt;', xml_text, re.MULTILINE)\n    if m: print \"*** eyquem 5:\", repr(m.group())\n    else: print \"*** eyquem 5:\", \"FAIL\"\n\n    m = re.search('&lt;(?![?!])[^&gt;]+&gt;', xml_text)\n    if m: print \"*** eyquem 6:\", repr(m.group())\n    else: print \"*** eyquem 6:\", \"FAIL\"\n\n    filelike_obj = StringIO(xml_text)\n    tree = et.parse(filelike_obj)\n    print \"*** parse:\", tree.getroot().tag\n\n    filelike_obj = StringIO(xml_text)\n    for event, elem in et.iterparse(filelike_obj, ('start', 'end')):\n        print \"*** iterparse:\", elem.tag\n        break\n</code>\n</pre>\n", "senID": 4}, {"text": ["Above ElementTree-related code works with Python 2.5 to 2.7.", "Will work with Python 2.2 to 2.4; you just need to get ElementTree and cElementTree from effbot.org and do some conditional importing.", "Should work with any lxml version."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n *** eyquem 1: '&gt;'\n*** eyquem 2: '&gt;'\n*** eyquem 3: FAIL\n*** eyquem 4: '&lt;/root\\n&gt;'\n*** eyquem 5: '&lt;root\\n&gt;'\n*** eyquem 6: '&lt;root\\n&gt;'\n*** parse: root\n*** iterparse: root\n\n*** eyquem 1: '--&gt;'\n*** eyquem 2: '--&gt;'\n*** eyquem 3: FAIL\n*** eyquem 4: '&lt;/root\\n&gt;'\n*** eyquem 5: '&lt;root\\n&gt;'\n*** eyquem 6: '&lt;root\\n&gt;'\n*** parse: root\n*** iterparse: root\n\n*** eyquem 1: '&lt;!-- &lt;/mole2&gt; --&gt;'\n*** eyquem 2: '&lt;root&gt;&lt;foo /&gt;&lt;/root&gt;'\n*** eyquem 3: FAIL\n*** eyquem 4: '&lt;/mole2&gt;'\n*** eyquem 5: '&lt;root&gt;'\n*** eyquem 6: '&lt;mole1&gt;'\n*** parse: root\n*** iterparse: root\n\n*** eyquem 1: '&gt;'\n*** eyquem 2: '&lt;?xml version=\"1.0\" ?&gt;&lt;!-- &lt;mole1&gt; --&gt;&lt;root&gt;&lt;foo /&gt;&lt;/root&gt;&lt;!-- &lt;/mole2&gt; --&gt;'\n*** eyquem 3: FAIL\n*** eyquem 4: '&lt;/mole2&gt;'\n*** eyquem 5: FAIL\n*** eyquem 6: '&lt;mole1&gt;'\n*** parse: root\n*** iterparse: root\n</code>\n</pre>\n", "senID": 7}, {"text": ["Update 1 The above was demonstration code.", "Below is more like implementation code... just add exception handling.", "Tested with Python 2.7 and 2.2."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Update 1", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n try:\n    import xml.etree.cElementTree as ET\nexcept ImportError:\n    import cElementTree as ET\n\ndef get_root_tag_from_xml_file(xml_file_path):\n    result = f = None\n    try:\n        f = open(xml_file_path, 'rb')\n        for event, elem in ET.iterparse(f, ('start', )):\n            result = elem.tag\n            break\n    finally:\n        if f: f.close()\n    return result\n\nif __name__ == \"__main__\":\n    import sys, glob\n    for pattern in sys.argv[1:]:\n        for filename in glob.glob(pattern):\n            print filename, get_root_tag_from_xml_file(filename)\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Does this seem interesting to a connoisseur of XML ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ch = \"\"\"\\\n&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?&gt; \n&lt;!--  Edited by XMLSpy\u00ae --&gt; \n&lt;CATALOG&gt;\n &lt;CD&gt;\n  &lt;TITLE&gt;Empire Burlesque&lt;/TITLE&gt; \n  &lt;ARTIST&gt;Bob Dylan&lt;/ARTIST&gt; \n  &lt;COUNTRY&gt;USA&lt;/COUNTRY&gt; \n  &lt;COMPANY&gt;Columbia&lt;/COMPANY&gt; \n  &lt;PRICE&gt;10.90&lt;/PRICE&gt; \n  &lt;YEAR&gt;1985&lt;/YEAR&gt; \n &lt;/CD&gt;\n &lt;CD&gt;\n  &lt;TITLE&gt;Hide your heart&lt;/TITLE&gt; \n  &lt;ARTIST&gt;Bonnie Tyler&lt;/ARTIST&gt; \n  &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; \n  &lt;COMPANY&gt;CBS Records&lt;/COMPANY&gt; \n  &lt;PRICE&gt;9.90&lt;/PRICE&gt; \n  &lt;YEAR&gt;1988&lt;/YEAR&gt; \n &lt;/CD&gt;\n&lt;/CATALOG&gt;\n&lt;!-- This is the end of arachni report --&gt; \n\n\"\"\"\n\nchrstr = ch.strip()\nx = max(chrstr.rfind('\\r'),chrstr.rfind('\\n'))\nlastline = chrstr[x+1:]\nif lastline[0:5]=='&lt;!-- ':\n    chrstr = ch[0:x].rstrip()\n    x = max(chrstr.rfind('\\r'),chrstr.rfind('\\n'))\n    print chrstr[x+1:]\nelse:\n    print lastline\n</code>\n</pre>\n", "senID": 1}, {"text": ["result, still"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &lt;/CATALOG&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["If necessary, one could add a verification that the start-tag of tree root is also around the beginning in the file"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["If the file is big, to speed up the treatment, we can move the pointeur of the file near the file's end (say 200 or 600 characters ante the end) to read and search in only a string of 200 or 600 characters long (the end-tag of the tree root of an XL doesn't have a greater length, does it ?"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n from os.path import getsize\n\nwith open('I:\\\\uuu.txt') as f:\n\n    L = getsize('I:\\\\uuu.txt')\n    print 'L==',L\n\n    f.seek( -min(600,L) , 2)\n    ch = f.read()\n    if '\\r' not in ch and '\\n' not in ch:\n        f.seek(0,0)\n        ch = f.read()        \n\n    chrstr = ch.strip()\n    x = max(chrstr.rfind('\\r'),chrstr.rfind('\\n'))\n    lastline = chrstr[x+1:]\n    if lastline[0:5]=='&lt;!-- ':\n        chrstr = ch[0:x].rstrip()\n        x = max(chrstr.rfind('\\r'),chrstr.rfind('\\n'))\n        print chrstr[x+1:]\n    else:\n        print lastline\n</code>\n</pre>\n", "senID": 7}], [{"text": ["My understanding of your problem is this: You want to examine a file to determine if it is one of your recognized formats, and only parse it as XML if you know that it is one of the recognized formats.", "@eyquem is right: you should use simple string methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The simplest thing to do is to read some small amount from the beginning of the file, and see if it has a root element you recognize:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n f = open(the_file)\nhead = f.read(200)\nf.close()\nif \"&lt;arachni_report\" in head:\n    #.. re-open and parse as arachni ..\nelif \"&lt;nmaprun\" in head:\n    #.. re-open and parse as nmaprun ..\n</code>\n</pre>\n", "senID": 2}, {"text": ["This method has the advantage that only a small amount of the file is read before determining whether it's an interesting file or not."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Final edit:\nThanks to John Machin I'll be using this following code (this is a draft) based on his answer (which is the one I selected as correct)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Final edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "John Machin", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["I'd also like to thank eyquem for his responses and his persistence on defending his codes, I really learned a lot :)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom cStringIO import StringIO\n\ntry:\n    import xml.etree.cElementTree as ET\nexcept ImportError:\n    import xml.etree.ElementTree as ET\n\nclass reportRecognizer(object):\n\n    def __init__(self, xml_report_path):\n        self.report_type = \"\"\n\n        root_tag = self.get_root_tag_from_xml_file(xml_report_path)\n\n        if root_tag:\n            self.report_type = self.rType(root_tag)\n\n\n    def get_root_tag_from_xml_file(self, xml_file_path):\n        result = f = None\n        try:\n            f = open(xml_file_path, 'rb')\n            for event, elem in ET.iterparse(f, ('start', )):\n                result = elem.tag\n                break\n        except IOError, err:\n            print \"Error while opening file.\\n%s. %s\" % (err, filepath)\n        finally:\n            if f: f.close()\n        return result\n\n    def rType(self, tag):\n        if \"arachni_report\" == tag:\n            return \"Arachni XML Report\"\n        elif \"nmaprun\" == tag:\n            return \"Nmap XML Report\"\n        else:\n            return \"Unrecognized XML file, sorry.\"\n\nreport = reportRecognizer('report.xml')\nprint report.report_type\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Are you serious, John Machin , when you show that my code wouldn't work correctly ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Since I don't know well the XML format, I went there:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["W3C's XML validator"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "W3C's XML validator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://validator.w3.org/"}]}, {"text": ["Conclusion is that your text samples are not well-formed.", "Hence :"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Did you mean that I was supposed to have written a code able to detect tree root's tag in non-XML files ?", "I didn't know I had this over-requirement to fulfill."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Here's a code that frightens a little less than the one using only string methods.", "I didn't give it before because I would have received notifications that \"..whisp...you MUST not employ regexes to analyse an XML text... whisp whisp\""], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "\"..whisp...you MUST not employ regexes to analyse an XML text... whisp whisp\"", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import re\nfrom os.path import getsize\n\nwith open('I:\\\\uuu.txt') as f:\n\n    L = getsize('I:\\\\uuu.txt')\n    print 'L==',L\n\n    f.seek( -min(600,L) , 2)\n    for mat in re.finditer('^&lt;/[^&gt;]+&gt;',f.read(),re.MULTILINE):\n        pass\n    print mat.group()\n</code>\n</pre>\n", "senID": 7}, {"text": ["It coud be done the same in the more noisy beginning of the XML."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["In fact, I prefer the solution given by John Machin, with the iterparse() function of ElementTree, and that's it !"], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "iterparse()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "ElementTree", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["EDIT"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["After all, I wonder why this wouldn't be enough...."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nwith open('I:\\\\uuu.txt') as f:\n    print re.search('^&lt;(?![?!])[^&gt;]+&gt;',f.read(),re.MULTILINE).group()\n</code>\n</pre>\n", "senID": 13}], [{"text": ["Here is what you were looking for, John Machin: the sequel of our serial .", "I verified that this time my brain was in its correct place, and I continued to think about the problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So you have extended the demonstration code.", "Now, with your several exemplifying texts, it is clear for me that the string methods are far to be sufficient, and I UNDERSTAND why.", "I am very interested to know the underneath of processes and to understand the concrete reasons of affirmations. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then I studied more than I ever did the specifications of XML and performed tests with the W3c's validator to increase my understanding of details of the structure of a XML text.", "It's a rather severe occupation but interesting though.", "I saw that the format of an XML is a mix of very strict rules and of debonair liberties."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "W3c", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["From the tricks you used in your exemples to tear my codes into pieces, I conclude that XML format doesn't require the text to be divided into lines.", "In fact, as the W3c's validator showed me, characters \\n , \\r and \\t can be at many positions in a XML text, provided that they don't break a rule of structure."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "W3c", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\r", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\t", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For exemple they are authorized without any restriction between tags: as a consequence, an element may occupy several lines.", "Also, even tags can be splitted into several lines, or among several tabulations \\t, provided that they occur after the name of one tag.", "There is nor requirement for the lines of a XML text to be indented as I always saw them: I understand now it's only a personal convenience choosen for ease of reading and logical comprehension."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "\\t", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Well, you know all that better than me, John Machin.", "Thanks to you, I am now alerted to the complexity of XML format and I better understand the reasons that make parsing unrealistic by other means than specialized parsers.", "I incidentally wonder if common coders are aware of this awkardness of XML format: the possibility of \\n characters present  here and there in an XML text."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "\\n", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Anyway, as I have been in this conceptual boiling pot for a while now, I continued to search for a solution for your whac_moles, John Machin, as an instructive play."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["String methods being out of the game, I polished my regex. "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["I know, I know: you'll say me that analyzing an XML text can't be done even with a regex.", "Now that I know better why, I agree.", "But I don't pretend to parse an XML text: my regex won't extract any part of an XML tree, it will search only a little chunk of text.", "For the problem asked by OP, I consider the use of regex as non heretical."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": [". "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["From the beginning, I think that searching the end-tag of the root is more easy and natural, because an end-tag hasn't attributes and there is less \"noise\" around it than the start-tag of the root."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["So my solution is now:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["The bigger the file is, the speeder is this algorithm compared to the use of parse or iterparse.", "I wrote and examined all the results of the following codes.", "The first strategy is the faster one."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n # coding: ascii\nimport xml.etree.cElementTree as et\n# import xml.etree.ElementTree as et\n# import lxml.etree as et\nfrom cStringIO import StringIO\nimport re,urllib\n\nxml5 = \"\"\"\\\n&lt;?xml version=\"1.0\" ?&gt; \n&lt;!--  this is a comment --&gt; \n&lt;root\\t\n\\r\\t\\r \\r\n&gt;&lt;foo\n\n&gt;bar&lt;/foo\\t \\r&gt;&lt;/root\n&gt;\n\"\"\"\n\nxml6 = \"\"\"\\\n&lt;?xml version=\"1.0\" ?&gt; \n&lt;!--  this is a comment --&gt; \n&lt;root\n&gt;&lt;foo\n&gt;bar&lt;/foo\\n\\t   \\t&gt;&lt;/root \\t\n\\r&gt;\n&lt;!--  \\r   \\t\nThat's all, folks!\n\n\\t--&gt;\n\"\"\"\n\nxml7 = '''&lt;?xml version=\"1.0\" ?&gt;\n&lt;!-- &lt;mole1&gt; --&gt;  \n&lt;root&gt;&lt;foo\n\n\\t\\t\\r\\r\\t/&gt;&lt;/root  \\t\n&gt;  \n&lt;!-- &lt;/mole2&gt;\\t \\r\n \\r--&gt;\n&lt;!----&gt;\n'''\n\nxml8 = '''&lt;?xml version=\"1.0\" ?&gt;&lt;!-- \\r&lt;mole1&gt; --&gt;&lt;root&gt;  \\t\\t&lt;foo \\t\\r\\r/&gt;&lt;/root&gt;\\t&lt;!-- &lt;/mole2&gt; --&gt;'''\n\n\nsock = urllib.urlopen('http://www.cafeconleche.org/books/bible/examples/18/18-4.xsl')\nxml9 = sock.read()\nsock.close()\n\n\ndef rp(x):\n    return  '\\\\r' if x.group()=='\\r' else '\\\\t'\n\nfor xml_text in (xml5, xml6, xml7, xml8, xml9):\n\n    print '\\\\n\\n'.join(re.sub('\\r|\\t',rp,xml_text).split('\\n'))\n    print '-----------------------------'\n\n    xml_text_noc = re.sub('&lt;!--.*?--&gt;|[\\n\\r\\t]','', xml_text,flags=re.DOTALL)\n    RE11 = '(?&lt;=&lt;/)[^ &gt;]+(?= *&gt;)(?!.*&lt;/[^&gt;]+&gt;)' # with assertions   # ^\n    m  = re.search(RE11, xml_text_noc,re.DOTALL)\n    print \"***  eyquem 11: \" + repr(m.group() if m else \"FAIL\")\n\n    xml_text_noc = re.sub('&lt;!--.*?--&gt;|[\\n\\r\\t]','', xml_text,flags=re.DOTALL)\n    RE12 = '&lt;/([^ &gt;]+) *&gt;(?!.*&lt;/[^&gt;]+&gt;)'  # with group(1)   # ^\n    m  = re.search(RE12, xml_text_noc,re.DOTALL)\n    print \"***  eyquem 12: \" + repr(m.group(1) if m else \"FAIL\")\n\n    xml_text_noc = re.sub('&lt;!--.*?--&gt;|[\\n\\r\\t]','', xml_text,flags=re.DOTALL)\n    RE13 = '&lt;/[^ &gt;]+ *&gt;(?!.*&lt;/[^&gt;]+&gt;)' # without group(1)   # ^\n    m  = re.search(RE13, xml_text_noc,re.DOTALL)\n    print \"***  eyquem 13: \" + repr(m.group()[2:-1].rstrip() if m else \"FAIL\")\n\n\n\n    xml_text_noc = re.sub('&lt;!--.*?--&gt;','', xml_text,flags=re.DOTALL)\n    RE14 = '(?&lt;=&lt;/)[^ \\n\\r\\t&gt;]+(?=[ \\n\\r\\t]*&gt;)(?!.*&lt;/[^&gt;]+&gt;)' # with assertions  # ^\n    m  = re.search(RE14, xml_text_noc,re.DOTALL)\n    print \"***  eyquem 14: \" + repr(m.group() if m else \"FAIL\")\n\n    xml_text_noc = re.sub('&lt;!--.*?--&gt;','', xml_text,flags=re.DOTALL)\n    RE15 = '&lt;/([^ \\n\\r\\t&gt;]+)[ \\n\\r\\t]*&gt;(?!.*&lt;/[^&gt;]+&gt;)'  # with group(1)   # &lt;\n    m  = re.search(RE15, xml_text_noc,re.DOTALL)\n    print \"***  eyquem 15: \" + repr(m.group(1).rstrip() if m else \"FAIL\")\n\n    xml_text_noc = re.sub('&lt;!--.*?--&gt;','', xml_text,flags=re.DOTALL)\n    RE16 = '&lt;/[^ \\n\\r\\t&gt;]+[ \\n\\r\\t]*&gt;(?!.*&lt;/[^&gt;]+&gt;)' # without group(1)   # &lt;\n    m  = re.search(RE16, xml_text_noc,re.DOTALL)\n    print \"***  eyquem 16: \" + repr(m.group()[2:-1].rstrip() if m else \"FAIL\")\n\n\n\n    print\n    filelike_obj = StringIO(xml_text)\n    tree = et.parse(filelike_obj)\n    print \"***      parse:  \" + tree.getroot().tag\n\n    filelike_obj = StringIO(xml_text)\n    for event, elem in et.iterparse(filelike_obj, ('start', 'end')):\n        print \"***  iterparse:  \" + elem.tag\n        break\n\n\n    print '\\n============================================='\n</code>\n</pre>\n", "senID": 14}, {"text": ["Result"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n &lt;?xml version=\"1.0\" ?&gt; \\n\n&lt;!--  this is a comment --&gt; \\n\n&lt;root\\t\\n\n\\r\\t\\r \\r\\n\n&gt;&lt;foo\\n\n\\n\n&gt;bar&lt;/foo\\t \\r&gt;&lt;/root\\n\n&gt;\\n\n\n-----------------------------\n***  eyquem 11: 'root'\n***  eyquem 12: 'root'\n***  eyquem 13: 'root'\n***  eyquem 14: 'root'\n***  eyquem 15: 'root'\n***  eyquem 16: 'root'\n\n***      parse:  root\n***  iterparse:  root\n\n=============================================\n&lt;?xml version=\"1.0\" ?&gt; \\n\n&lt;!--  this is a comment --&gt; \\n\n&lt;root\\n\n&gt;&lt;foo\\n\n&gt;bar&lt;/foo\\n\n\\t   \\t&gt;&lt;/root \\t\\n\n\\r&gt;\\n\n&lt;!--  \\r   \\t\\n\nThat's all, folks!\\n\n\\n\n\\t--&gt;\\n\n\n-----------------------------\n***  eyquem 11: 'root'\n***  eyquem 12: 'root'\n***  eyquem 13: 'root'\n***  eyquem 14: 'root'\n***  eyquem 15: 'root'\n***  eyquem 16: 'root'\n\n***      parse:  root\n***  iterparse:  root\n\n=============================================\n&lt;?xml version=\"1.0\" ?&gt;\\n\n&lt;!-- &lt;mole1&gt; --&gt;  \\n\n&lt;root&gt;&lt;foo\\n\n\\n\n\\t\\t\\r\\r\\t/&gt;&lt;/root  \\t\\n\n&gt;  \\n\n&lt;!-- &lt;/mole2&gt;\\t\\n\n--&gt;\\n\n&lt;!----&gt;\\n\n\n-----------------------------\n***  eyquem 11: 'root'\n***  eyquem 12: 'root'\n***  eyquem 13: 'root'\n***  eyquem 14: 'root'\n***  eyquem 15: 'root'\n***  eyquem 16: 'root'\n\n***      parse:  root\n***  iterparse:  root\n\n=============================================\n&lt;?xml version=\"1.0\" ?&gt;&lt;!-- \\r&lt;mole1&gt; --&gt;&lt;root&gt;  \\t\\t&lt;foo \\t\\r\\r/&gt;&lt;/root&gt;\\t&lt;!-- &lt;/mole2&gt; --&gt;\n-----------------------------\n***  eyquem 11: 'root'\n***  eyquem 12: 'root'\n***  eyquem 13: 'root'\n***  eyquem 14: 'root'\n***  eyquem 15: 'root'\n***  eyquem 16: 'root'\n\n***      parse:  root\n***  iterparse:  root\n\n=============================================\n&lt;?xml version=\"1.0\"?&gt;\\r\\n\n&lt;stylesheet\\r\\n\n  xmlns=\"http://www.w3.org/XSL/Transform/1.0\"\\r\\n\n  xmlns:fo=\"http://www.w3.org/XSL/Format/1.0\"\\r\\n\n  result-ns=\"fo\"&gt;\\r\\n\n\\r\\n\n  &lt;template match=\"/\"&gt;\\r\\n\n    &lt;fo:root xmlns:fo=\"http://www.w3.org/XSL/Format/1.0\"&gt;\\r\\n\n\\r\\n\n      &lt;fo:layout-master-set&gt;\\r\\n\n        &lt;fo:simple-page-master page-master-name=\"only\"&gt;\\r\\n\n          &lt;fo:region-body/&gt;\\r\\n\n        &lt;/fo:simple-page-master&gt;\\r\\n\n      &lt;/fo:layout-master-set&gt;\\r\\n\n\\r\\n\n      &lt;fo:page-sequence&gt;\\r\\n\n\\r\\n\n       &lt;fo:sequence-specification&gt;\\r\\n\n        &lt;fo:sequence-specifier-single page-master-name=\"only\"/&gt;\\r\\n\n       &lt;/fo:sequence-specification&gt;\\r\\n\n        \\r\\n\n        &lt;fo:flow&gt;\\r\\n\n          &lt;apply-templates select=\"//ATOM\"/&gt;\\r\\n\n        &lt;/fo:flow&gt;\\r\\n\n        \\r\\n\n      &lt;/fo:page-sequence&gt;\\r\\n\n\\r\\n\n    &lt;/fo:root&gt;\\r\\n\n  &lt;/template&gt;\\r\\n\n\\r\\n\n  &lt;template match=\"ATOM\"&gt;\\r\\n\n    &lt;fo:block font-size=\"20pt\" font-family=\"serif\"&gt;\\r\\n\n      &lt;value-of select=\"NAME\"/&gt;\\r\\n\n    &lt;/fo:block&gt;\\r\\n\n  &lt;/template&gt;\\r\\n\n\\r\\n\n&lt;/stylesheet&gt;\\r\\n\n\n-----------------------------\n***  eyquem 11: 'stylesheet'\n***  eyquem 12: 'stylesheet'\n***  eyquem 13: 'stylesheet'\n***  eyquem 14: 'stylesheet'\n***  eyquem 15: 'stylesheet'\n***  eyquem 16: 'stylesheet'\n\n***      parse:  {http://www.w3.org/XSL/Transform/1.0}stylesheet\n***  iterparse:  {http://www.w3.org/XSL/Transform/1.0}stylesheet\n\n=============================================\n</code>\n</pre>\n", "senID": 16}, {"text": ["This code now measures the execution's times:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n # coding: ascii\nimport xml.etree.cElementTree as et\n# import xml.etree.ElementTree as et\n# import lxml.etree as et\nfrom cStringIO import StringIO\nimport re\nimport urllib\nfrom time import clock\n\nsock = urllib.urlopen('http://www.cafeconleche.org/books/bible/examples/18/18-4.xsl')\nch = sock.read()\nsock.close()\n\n# the following lines are intended to insert additional lines\n# into the XML text before its recording in a file, in order to\n# obtain a real file to use, containing an XML text \n# long enough to observe easily the timing's differences\n\nli = ch.splitlines(True)[0:6] + 30*ch.splitlines(True)[6:-2] + ch.splitlines(True)[-2:]\n\nwith open('xml_example.xml','w') as f:\n    f.write(''.join(li))\n\nprint 'length of XML text in a file : ',len(''.join(li)),'\\n'\n\n\n\n# timings\n\nP,I,A,B,C,D,E,F = [],[],[],[],[],[],[],[],\n\n\nn = 50\n\nfor cnt in xrange(50):\n\n    te = clock()\n    for i in xrange (n):\n        with open('xml_example.xml') as filelike_obj:\n            tree = et.parse(filelike_obj)\n            res_parse = tree.getroot().tag\n    P.append( clock()-te)\n\n    te = clock()\n    for i in xrange (n):\n        with open('xml_example.xml') as filelike_obj:\n            for event, elem in et.iterparse(filelike_obj, ('start', 'end')):\n                res_iterparse = elem.tag\n                break\n    I.append(  clock()-te)\n\n\n    RE11 = '(?&lt;=&lt;/)[^ &gt;]+(?= *&gt;)(?!.*&lt;/[^&gt;]+&gt;)' # with assertions   # ^\n    te = clock()\n    for i in xrange (n):\n        with open('xml_example.xml') as f:\n            f.seek(-200,2)\n            xml_text = f.read()\n            xml_text_noc = re.sub('(&lt;!--.*?--&gt;|[\\n\\r\\t])','', xml_text,flags=re.DOTALL)\n            m  = re.search(RE11, xml_text_noc,re.DOTALL)\n            res_eyq11 = m.group() if m else \"FAIL\"\n    A.append(  clock()-te)\n\n\n    RE12 = '&lt;/([^ &gt;]+) *&gt;(?!.*&lt;/[^&gt;]+&gt;)'  # with group(1)   # ^\n    te = clock()\n    for i in xrange (n):\n        with open('xml_example.xml') as f:\n            f.seek(-200,2)\n            xml_text = f.read()\n            xml_text_noc = re.sub('(&lt;!--.*?--&gt;|[\\n\\r\\t])','', xml_text,flags=re.DOTALL)\n            m  = re.search(RE12, xml_text_noc,re.DOTALL)\n            res_eyq12 = m.group(1) if m else \"FAIL\"\n    B.append(  clock()-te)\n\n\n    RE13 = '&lt;/[^ &gt;]+ *&gt;(?!.*&lt;/[^&gt;]+&gt;)' # without group(1)   # ^\n    te = clock()\n    for i in xrange (n):\n        with open('xml_example.xml') as f:\n            f.seek(-200,2)\n            xml_text = f.read()\n            xml_text_noc = re.sub('(&lt;!--.*?--&gt;|[\\n\\r\\t])','', xml_text,flags=re.DOTALL)\n            m  = re.search(RE13, xml_text_noc,re.DOTALL)\n            res_eyq13 = m.group()[2:-1] if m else \"FAIL\"\n    C.append(  clock()-te)\n\n\n\n    RE14 = '(?&lt;=&lt;/)[^ \\n\\r\\t&gt;]+(?=[ \\n\\r\\t]*&gt;)(?!.*&lt;/[^&gt;]+&gt;)' # with assertions  # ^\n    te = clock()\n    for i in xrange (n):\n        with open('xml_example.xml') as f:\n            f.seek(-200,2)\n            xml_text = f.read()\n            xml_text_noc = re.sub('&lt;!--.*?--&gt;','', xml_text,flags=re.DOTALL)\n            m  = re.search(RE14, xml_text_noc,re.DOTALL)\n            res_eyq14 = m.group() if m else \"FAIL\"\n    D.append(  clock()-te)\n\n\n    RE15 = '&lt;/([^ \\n\\r\\t&gt;]+)[ \\n\\r\\t]*&gt;(?!.*&lt;/[^&gt;]+&gt;)'  # with group(1)   # &lt;\n    te = clock()\n    for i in xrange (n):\n        with open('xml_example.xml') as f:\n            f.seek(-200,2)\n            xml_text = f.read()\n            xml_text_noc = re.sub('&lt;!--.*?--&gt;','', xml_text,flags=re.DOTALL)\n            m  = re.search(RE15, xml_text_noc,re.DOTALL)\n            res_eyq15 = m.group(1) if m else \"FAIL\"\n    E.append(  clock()-te)\n\n\n    RE16 = '&lt;/[^ \\n\\r\\t&gt;]+[ \\n\\r\\t]*&gt;(?!.*&lt;/[^&gt;]+&gt;)' # without group(1)   # &lt;\n    te = clock()\n    for i in xrange (n):\n        with open('xml_example.xml') as f:\n            f.seek(-200,2)\n            xml_text = f.read()\n            xml_text_noc = re.sub('&lt;!--.*?--&gt;','', xml_text,flags=re.DOTALL)\n            m  = re.search(RE16, xml_text_noc,re.DOTALL)\n            res_eyq16 = m.group()[2:-1].rstrip() if m else \"FAIL\"\n    F.append(  clock()-te)\n\n\nprint \"***      parse:  \" + res_parse, '  parse'\nprint \"***  iterparse:  \" + res_iterparse, '  iterparse'\nprint\nprint \"***  eyquem 11:  \" + repr(res_eyq11)\nprint \"***  eyquem 12:  \" + repr(res_eyq12)\nprint \"***  eyquem 13:  \" + repr(res_eyq13)\nprint \"***  eyquem 14:  \" + repr(res_eyq14)\nprint \"***  eyquem 15:  \" + repr(res_eyq15)\nprint \"***  eyquem 16:  \" + repr(res_eyq16)\n\nprint\nprint str(min(P))\nprint str(min(I))\nprint\nprint '\\n'.join(str(u) for u in map(min,(A,B,C)))\nprint\nprint '\\n'.join(str(u) for u in map(min,(D,E,F)))\n</code>\n</pre>\n", "senID": 18}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n length of XML text in a file :  22548 \n\n***      parse:  {http://www.w3.org/XSL/Transform/1.0}stylesheet   parse\n***  iterparse:  {http://www.w3.org/XSL/Transform/1.0}stylesheet   iterparse\n\n***  eyquem 11:  'stylesheet'\n***  eyquem 12:  'stylesheet'\n***  eyquem 13:  'stylesheet'\n***  eyquem 14:  'stylesheet'\n***  eyquem 15:  'stylesheet'\n***  eyquem 16:  'stylesheet'\n\n0.220554691169\n0.172240771802\n\n0.0273236743636\n0.0266525536625\n0.0265308269626\n\n0.0246300539733\n0.0241203758299\n0.0238024015203\n</code>\n</pre>\n", "senID": 20}, {"text": [], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"text": ["Considering your unsophisticated need, Aereal, I think that you don't care to have an end-tag of the root with possible characters \\r \\n \\t in it, instead of its name alone; So the best solution for you is, in my opinion:"], "childNum": 3, "tag": "p", "senID": 23, "childList": [{"text": "\\r", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\t", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def get_root_tag_from_xml_file(xml_file_path):\n    with open(xml_file_path) as f:\n        try:      f.seek(-200,2)\n        except:   f.seek(0,0)\n        finally:  xml_text_noc = re.sub('&lt;!--.*?--&gt;','', f.read(), flags= re.DOTALL)\n        try:\n            return re.search('&lt;/[^&gt;]+&gt;(?!.*&lt;/[^&gt;]+&gt;)' , xml_text_noc, re.DOTALL).group()\n        except :\n            return 'FAIL'\n</code>\n</pre>\n", "senID": 24}, {"text": ["Thanks to the expertise of John Machin, this solution do a more reliable job than my previous one; and in addition it answers exactly to the demand, as it was expressed: no parsing, hence a faster method, as it was implicitly aimed at."], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"text": ["John Machin, will you find a new tricky feature of XML format that will invalidate this solution ?"], "childNum": 0, "tag": "p", "senID": 27, "childList": []}]]