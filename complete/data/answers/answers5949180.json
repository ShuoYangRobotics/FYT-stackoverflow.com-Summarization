[[{"text": ["You could use a pair of conditional expressions \u2014 and no parenthesis are necessary at all; just like Python knows that 1 + 2 + 3 should be done reasonably from left-to-right, so conditional expressions can be written with one clause after another without any fear of the interpreter getting confused.", "Line breaks and indentation are important for readability, however, so I generally do something like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "1 + 2 + 3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n atype = ('Gregorian' if 'greg' in result\n         else 'Ethiopian' if 'eth' in result\n         else 'unknown')\n</code>\n</pre>\n", "senID": 1}, {"text": ["This form of indentation is not only the one that most editors will produce in any case if you press \"enter\" before each else, but it makes a great deal of visual sense to me when I come back later and read my own, or someone else's, code \u00ad\u2014 which is, after all, a big reason we use Python, right?", ":)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "else", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: Of course I realize that this is a one-liner only in the sense that Python sees the continued line as a single line of code; so I guess my answer is that your program would seem a bit dense to me as one physical line of Python, but works quite nicely to my eyes if written as one logical line of Python!"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "physical", "childNum": 0, "tag": "em", "childList": []}, {"text": "logical", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Edit: One further note: of course, I recognize that my code snippet violates PEP-8, which says to end continued lines with operators \u2014 so PEP-8 would have me move the else words up to the ends of the previous lines.", "I can only say that this is one of the rules of PEP-8 that I disagree with, which I regularly break, and that therefore I produce more readable code as a result.", "I think my difference with PEP-8 on this point comes from having a math typesetting background, and, as Donald Knuth emphasizes in the TeXBook, \u201cdisplayed formulas always break before binary operations and relations\u201d (p.195)."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "else", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "before", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}], [{"text": ["Not sure if this is meaningful and readable..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n atype = 'Gregorian' if 'greg' in result else ('Ethiopian' if 'eth' in result else 'unknown')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Personally, on a forum, I propose"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def detect(dt,result):\n    \"\"\" prints the type of date \"\"\"\n    style = 'Gregorian' if 'greg' in result else\\\n            'Ethiopian' if 'eth'  in result else\\\n            'unknown'\n    print '%s is in %s format.' % (dt,style)\n</code>\n</pre>\n", "senID": 1}, {"text": ["and in the secret of my codes where nobody will come to see if I respect the Zen of Python, I would do in fact:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def detect(dt,result):\n    \"\"\" prints the type of date \"\"\"\n    print dt + ' is in %s format.'\\\n          % \\\n          'Gregorian' if 'greg' in result else\\\n          'Ethiopian' if 'eth'  in result else\\\n          'unknown'\n</code>\n</pre>\n", "senID": 3}, {"text": ["I measured execution's times: the second runs in 89 % of the time of the first "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["EDIT 1"], "childNum": 0, "tag": "h2", "senID": 6, "childList": []}, {"text": ["The test I conducted didn't satisfy me, in the end, because it isn't fair to compare a program in which an assignement is done (style = etc) to a program in which there is no equivalent assignement."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["So I tested again, with modified codes.To accentuate the influence of differences between the codes, I added some lines of conditions. "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["I ran the following programs separately (to avoid possible persistence of objects that would be reassigned without having to be re-created; I don't precisely know what happens in the memory and the object model of Python, and if it may happen in fact; but I sometimes observe strange phenomenons when I measure execution's time.", "So I take no risk, I separate the codes)"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["first program"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n from time import clock\n\nA=[]\n\nfor repeat in xrange(5000):\n    def detect(dt,result):\n        if 'greg' in result:\n            h = '%s is in %s format.' % (dt,'Gregorian')\n        elif 'eth' in result:\n            h = '%s is in %s format.' % (dt,'Ethiopian')\n        elif 'ame' in result:\n            h = '%s is in %s format.' % (dt,'American')\n        elif 'rus' in result:\n            h = '%s is in %s format.' % (dt,'Russian')\n        elif 'egyp' in result:\n            h = '%s is in %s format.' % (dt,'Egyptian')\n        else:\n            h = '%s is in unknown format.' % dt\n\n    te = clock()\n    for i in xrange(10000):\n        detect('zozo',' he is egyptolog')\n    A.append(clock() - te)\n\nprint min(A)\n</code>\n</pre>\n", "senID": 11}, {"text": ["second program"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n from time import clock\n\nB=[]\n\nfor repeat in xrange(5000):\n\n\ndef detect(dt,result):\n    x  = '%s is in %s format.' % (dt,'Gregorian' if 'greg' in result else\\\n                                  'Ethiopian' if 'eth'  in result else\\\n                                  'American' if 'ame'  in result else\\\n                                  'Russian' if 'rus'  in result else\\\n                                  'Egyptian' if 'egyp'  in result else\\\n                                  'unknown')\n\nte = clock()\nfor i in xrange(10000):\n    detect('zozo',' he is egyptolog')\nB.append(clock() - te)\n\nprint min(B)\n</code>\n</pre>\n", "senID": 13}, {"text": ["third program"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n from time import clock\n\nC = []\n\nfor repeat in xrange(1000):\n    def detect(dt,result):\n        y = dt + ' is in %s format.'\\\n            % \\\n            'Gregorian' if 'greg' in result else\\\n            'Ethiopian' if 'eth'  in result else\\\n            'American' if 'ame'  in result else\\\n            'Russian' if 'rus'  in result else\\\n            'Egyptian' if 'egyp'  in result else\\\n            'unknown'\n\n    te = clock()\n    for i in xrange(10000):\n        detect('zozo',' he is egyptolog')\n    C.append(clock() - te)\n\nprint min(C)\n</code>\n</pre>\n", "senID": 15}, {"text": [], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["I obtained"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["Conclusions:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["there is no difference between the way of writing the code with if-elif-else conditions or with if-else-else-else successive conditions. "], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["this time, my code runs in 64 % the time of the two other execution's times.", "The more there are conditions to examine, the faster is my code"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"text": ["EDIT 2"], "childNum": 0, "tag": "h2", "senID": 22, "childList": []}, {"text": ["@eat,"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["Suppose that a list of one million elements, like this one"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"code": "<pre>\n<code>\n li = [('greg','Gregorian'),('eth','Ethiopian')]\n</code>\n</pre>\n", "senID": 25}, {"text": ["has been recorded in serialized format with cPickle.", "Then the code will be:"], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"code": "<pre>\n<code>\n import cPickle  \n\nwith open('trynewline.txt','r') as f:\n    li = cPickle.load(f)\n\ndef detect(dt,result):\n    for a,b in li:\n        if a in result:\n            return '%s is in %s format.' % (dt,b)\n        else:\n            return '%s is in unknown format.' % dt\n</code>\n</pre>\n", "senID": 27}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"code": "<pre>\n<code>\n import cPickle  \n\nwith open('trynewline.txt','r') as f:\n    li = cPickle.load(f)\n\ndef detect(dt,result):\n    ha = [ b for a,b in li if a in result]\n    y = dt + ' is in %s format.'\\\n        % (ha[0] if ha else 'unknown')\n</code>\n</pre>\n", "senID": 29}, {"text": ["That's all.", "Anyway, the data contained in li must come from somewhere.", "It can be  automatically produced; or it is manually produced.", "If it is manually produced and nobody created before me, I will be obliged to write manually the one million conditions myself.", "And if it is you that will have to write the code, you will do that also.", "I don't see how you could avoid it with your dictionary.  "], "childNum": 1, "tag": "p", "senID": 30, "childList": [{"text": "li", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"text": ["Yep, Python's variable's scope is a bit different than in other programming languages.", "So, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if 'greg' in result:\n    atype = 'Gregorian' \n\nprint(atype)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Will do just fine.", "Also "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if 'greg' in result: atype = 'Gregorian'\nprint(atype)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Will work, unless it's a Python shell (you have to execute the whole script)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["But anyway, it's a bad practice to make very long, condition-dependent variable initializations. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["actually strange but..it's just a different way to do it..I think it is easier to extend, but i guess there is a better way ;)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator as op\nimport functools as fc\n\natype = {'greg':'Gregorian', 'eth':'Ethiopian'}.get(filter(fc.partial(op.contains, ('greg', 'eth')), res)[0], 'unknown')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Although there's a separate line to set up a dictionary, here's an a one-liner (spread over two for readability):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n typemap = {'greg': 'Gregorian', 'eth': 'Ethiopian'}\n\natype = ([typemap[frag] for frag in typemap if frag in result][0]\n         if any(frag in result for frag in typemap) else 'unknown')\n</code>\n</pre>\n", "senID": 1}]]