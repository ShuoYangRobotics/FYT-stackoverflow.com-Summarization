[[{"text": ["OK, thanks to SO \"related\" feature.", "I found this question and adopted the answer by ianalis and the comment by lazyr"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "this question", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2652368/how-to-detect-a-sign-change-for-elements-in-a-numpy-array"}, {"href": "http://stackoverflow.com/users/100217/ianalis", "text": "ianalis", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://stackoverflow.com/users/566644/lazyr", "text": "lazyr", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def is_alternating_signs(a):\n    return numpy.all(numpy.abs(numpy.diff(numpy.sign(a))) == 2)\n\n\n\nprint is_alternating_signs([1, -1, 1, -1, 1]) \nprint is_alternating_signs([-1, 1, -1, 1, -1]) \nprint is_alternating_signs([1, -1, 1, -1, -1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["The output is "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n True\nTrue\nFalse\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You could check every even member is negative and every odd member is positive by taking a slice of every second item, starting at either the beginning or from position one.", "Also test the reverse to cover both possibilities."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["so:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def is_alternating_signs(l):\n    return ( (all(x&lt;0 for x in l[::2]) and all(x&gt;=0 for x in l[1::2])) or\n             (all(x&gt;=0 for x in l[::2]) and all(x&lt;0 for x in l[1::2])))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Using decimal module and is_signed method:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "decimal", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/decimal.html"}, {"href": "http://docs.python.org/library/decimal.html#decimal.Decimal.is_signed", "text": "is_signed", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from decimal import Decimal\n\na = [1, -1, 1, -1, 1]\nb = [-1, 1, -1, 1, -1]\nc = [1, -1, 1, -1, -1]\n\ndef is_alternating_signs(values):\n    lVals = [Decimal(val).is_signed() for val in values]\n    prevVal = lVals.pop(0)\n    for val in lVals:\n        if prevVal == val:\n            return False\n        prevVal = val\n    return True\n\nis_alternating_signs(a)\nis_alternating_signs(b)\nis_alternating_signs(c)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One more solution with slicing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_alternating_signs(l):\n    return all((i &gt; 0 and ii &lt; 0) or\n               (i &lt; 0 and ii &gt; 0) \n               for i in l[::2] for ii in l[1::2])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I like pairwise:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip, tee\n\ndef pairwise(iterable):\n    a, b = tee(iterable)\n    next(b)\n    return izip(a, b)\n\ndef is_alternating_signs(iterable):\n    return all(x &lt; 0 &lt; y or x &gt; 0 &gt; y for x, y in pairwise(iterable))\n</code>\n</pre>\n", "senID": 1}, {"text": ["If there are no zeros in iterable this also works:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "iterable", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def is_alternating_signs(iterable):\n    return all((x &lt; 0) == (0 &lt; y) for x, y in pairwise(iterable))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["how about something like..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_alternating_signs(aList):\n    return all( (aList[i]^aList[i-1])&lt;0 for i in range(1,len(aList)) )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What about just the straight-forward solution by looping through it once and testing?", "Quite possibly the fastest, too, because many of the other solutions loop through the list multiple times."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def signs_are_alternating(numbers):\n    \"\"\"Return True if numbers in given list have alternating signs, False\n    otherwise. If given list has less than 2 elements, return False.\n\n    &gt;&gt;&gt; signs_are_alternating([1, -1, 1, -1, 1])\n    True\n    &gt;&gt;&gt; signs_are_alternating([-1, 1, -1, 1, -1])\n    True\n    &gt;&gt;&gt; signs_are_alternating([1, -1, 1, -1, -1])\n    False\n\n    \"\"\"\n    if len(numbers) &lt; 2:\n        return False\n    previous_positive = (numbers[0] &lt; 0)  # Pretend it starts alternating\n    for number in numbers:\n        this_positive = (number &gt;= 0)\n        if previous_positive == this_positive:\n            return False\n        previous_positive = this_positive\n    return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that I wasn't quite sure what the intended behaviour is if the input list has less than 2 elements."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's my one-liner, which is probably less efficient than some of the other suggestions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_alternating_signs(lst):\n    return all(x * y &lt; 0 for x, y in zip(lst, lst[1:]))\n</code>\n</pre>\n", "senID": 1}]]