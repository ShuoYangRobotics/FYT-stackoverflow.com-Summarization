[[{"text": ["Personally, I don't really like this sort of behavior -- it interferes with duck typing.", "One could argue that it doesn't obey the \"Explicit is better than implicit\" mantra.", "Why not use the varargs syntax:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def func( *files ):\n    for f in files:\n        doSomethingWithFile( f )\n\nfunc( 'file1', 'file2', 'file3' )\nfunc( 'file1' )\nfunc( *listOfFiles )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Well, there's nothing unpythonic about checking type.", "Having said that, if you're willing to put a small burden on the caller:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def func( *files ):\n    for f in files:\n         doSomethingWithFile( f )\n\nfunc( *['file1','file2','file3'] ) #Is treated like func('file1','file2','file3')\nfunc( 'file1' )\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'd argue this is more pythonic in that \"explicit is better than implicit\".", "Here there is at least a recognition on the part of the caller when the input is already in list form."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n isinstance(your_var, basestring)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I would say the most Python'y way is to make the user always pass a list, even if there is only one item in it.", "It makes it really obvious func() can take a list of files"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "func()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def func(files):\n    for cur_file in files:\n        blah(cur_file)\n\nfunc(['file1'])\n</code>\n</pre>\n", "senID": 1}, {"text": ["As Dave suggested, you could use the func(*files) syntax, but I never liked this feature, and it seems more explicit (\"explicit is better than implicit\") to simply require a list.", "It's also turning your special-case (calling func with a single file) into the default case, because now you have to use extra syntax to call func with a list.."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "func(*files)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "func", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "func", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you do want to make a special-case for an argument being a string, use the isinstance()builtin, and compare to basestring (which both str() and unicode() are derived from) for example:"], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "isinstance()builtin", "tag": "a", "pos": 0, "childList": [{"text": "isinstance()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#isinstance"}, {"text": "isinstance()", "childNum": 0, "tag": "code", "childList": []}, {"text": "basestring", "childNum": 0, "tag": "code", "childList": []}, {"text": "str()", "childNum": 0, "tag": "code", "childList": []}, {"text": "unicode()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def func(files):\n    if isinstance(files, basestring):\n        doSomethingWithASingleFile(files)\n    else:\n        for f in files:\n            doSomethingWithFile(f)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Really, I suggest simply requiring a list, even with only one file (after all, it only requires two extra characters!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["if hasattr(f, 'lower'):\n    print \"I'm string like\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n def func(files):\n    for f in files if not isinstance(files, basestring) else [files]:\n        doSomethingWithFile(f)\n\nfunc(['file1', 'file2', 'file3'])\n\nfunc('file1')\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Varargs was confusing for me, so I tested it out in Python to clear it up for myself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First of all the PEP for varargs is here."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3102/"}]}, {"text": ["Here is sample program, based on the two answers from Dave and David Berger, followed by the output, just for clarification."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def func( *files ):\n    print files\n    for f in files:\n        print( f )\n\nif __name__ == '__main__':\n    func( *['file1','file2','file3'] ) #Is treated like func('file1','file2','file3')\n    func( 'onestring' )\n    func( 'thing1','thing2','thing3' )\n    func( ['stuff1','stuff2','stuff3'] )\n</code>\n</pre>\n", "senID": 3}, {"text": ["And the resulting output;"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n ('file1', 'file2', 'file3')\nfile1\nfile2\nfile3\n('onestring',)\nonestring\n('thing1', 'thing2', 'thing3')\nthing1\nthing2\nthing3\n(['stuff1', 'stuff2', 'stuff3'],)\n['stuff1', 'stuff2', 'stuff3']\n</code>\n</pre>\n", "senID": 5}, {"text": ["Hope this is helpful to somebody else."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]