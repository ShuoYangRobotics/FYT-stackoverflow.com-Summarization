[[{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"\\b\\d+\\b\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["That'll match only those digits that are not part of another word."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Add a space before the \\d+."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \"This must not b3 delet3d, but the number at the end yes 134411\"\n&gt;&gt;&gt; s = re.sub(\" \\d+\", \" \", s)\n&gt;&gt;&gt; s\n'This must not b3 delet3d, but the number at the end yes '\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit:  After looking at the comments, I decided to form a more complete answer.", "I think this accounts for all the cases."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n s = re.sub(\"^\\d+\\s|\\s\\d+\\s|\\s\\d+$\", \" \", s)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If your number is allways at the end of your strings try :\nre.sub(\"\\d+$\", \"\", s)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["otherwise, you may try\nre.sub(\"(\\s)\\d+(\\s)\", \"\\1\\2\", s)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can adjust the back-references to keep only one or two of the spaces (\\s match any white separator)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Using \\s isn't very good, since it doesn't handle tabs, et al.", "A first cut at a better solution is:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\\s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n re.sub(r\"\\b\\d+\\b\", \"\", s)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that the pattern is a raw string because \\b is normally the backspace escape for strings, and we want the special word boundary regex escape instead.", "A slightly fancier version is:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\\b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n re.sub(r\"$\\d+\\W+|\\b\\d+\\b|\\W+\\d+$\", \"\", s)\n</code>\n</pre>\n", "senID": 3}, {"text": ["That tries to remove leading/trailing whitespace when there are digits at the beginning/end of the string.", "I say \"tries\" because if there are multiple numbers at the end then you still have some spaces."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I don't know what your real situation looks like, but most of the answers look like they won't handle negative numbers or decimals,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["re.sub(r\"(\\b|\\s+\\-?|^\\-?", ")(\\d+|\\d*\\.\\d+)\\b\",\"\")"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "re.sub(r\"(\\b|\\s+\\-?|^\\-?)(\\d+|\\d*\\.\\d+)\\b\",\"\")", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The above should also handle things like,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["\"This must not b3 delet3d, but the number at the end yes -134.411\""], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["But this is still incomplete - you probably need a more complete definition of what you can expect to find in the files you need to parse."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit: it's also worth noting that '\\b' changes depending on the locale/character set you are using so you need to be a little careful with that."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["To handle digit strings at the beginning of a line as well:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = re.sub(r\"(^|\\W)\\d+\", \"\", s)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Non-regex solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \"This must not b3 delet3d, but the number at the end yes 134411\"\n&gt;&gt;&gt; \" \".join([x for x in s.split(\" \") if not x.isdigit()])\n'This must not b3 delet3d, but the number at the end yes'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Splits by \" \", and checks if the chunk is a number by doing str().isdigit(), then joins them back together.", "More verbosely (not using a list comprehension):"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "\" \"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "str().isdigit()", "tag": "a", "pos": -1, "childList": [{"text": "str().isdigit()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#str.isdigit"}, {"text": "str().isdigit()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n words = s.split(\" \")\nnon_digits = []\nfor word in words:\n    if not word.isdigit():\n        non_digits.append(word)\n\n\" \".join(non_digits)\n</code>\n</pre>\n", "senID": 3}]]