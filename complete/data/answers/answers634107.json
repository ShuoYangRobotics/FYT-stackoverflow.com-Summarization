[[{"text": ["asyncore is basically \"1\" - It uses select internally, and you just have one thread handling all requests.", "According to the docs it can also use poll.", "(EDIT: Removed Twisted reference, I thought it used asyncore, but I was wrong)."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "asyncore", "tag": "a", "pos": 0, "childList": [{"text": "asyncore", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/asyncore.html"}, {"text": "asyncore", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "select", "childNum": 0, "tag": "code", "childList": []}, {"text": "poll", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["\"2\" might be implemented with python-epoll (Just googled it - never seen it before).", "EDIT: (from the comments) In python 2.6 the select module has epoll, kqueue and kevent build-in (on supported platforms).", "So you don't need any external libraries to do edge-triggered serving."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "python-epoll", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/pyepoll"}, {"text": "select module", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/select.html"}]}, {"text": ["Don't rule out \"4\", as the GIL will be dropped when a thread is actually doing or waiting for IO-operations (most of the time probably).", "It doesn't make sense if you've got huge numbers of connections of course.", "If you've got lots of processing to do, then python may not make sense with any of these schemes."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For flexibility maybe look at Twisted?"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Twisted", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/trac/"}]}, {"text": ["In practice your problem boils down to how much processing you are going to do for requests.", "If you've got a lot of processing, and need to take advantage of multi-core parallel operation, then you'll probably need multiple processes.", "On the other hand if you just need to listen on lots of connections, then select or epoll, with a small number of threads should work."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["How about \"fork\"?", "(I assume that is what the ForkingMixIn does)  If the requests are handled in a \"shared nothing\" (other than DB or file system) architecture, fork() starts pretty quickly on most *nixes, and you don't have to worry about all the silly bugs and complications from threading."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Threads are a design illness forced on us by OSes with too-heavy-weight processes, IMHO.", "Cloning a page table with copy-on-write attributes seems a small price, especially if you are running an interpreter anyway."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Sorry I can't be more specific, but I'm more of a Perl-transitioning-to-Ruby programmer (when I'm not slaving over masses of Java at work)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Update:  I finally did some timings on thread vs fork in my \"spare time\".", "Check it out:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["http://roboprogs.com/devel/2009.04.html"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://roboprogs.com/devel/2009.04.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://roboprogs.com/devel/2009.04.html"}]}, {"text": ["Expanded:\nhttp://roboprogs.com/devel/2009.12.html"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://roboprogs.com/devel/2009.12.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://roboprogs.com/devel/2009.12.html"}]}], [{"text": ["Can I suggest additional links?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["cogen is a crossplatform library for network oriented, coroutine based programming using the enhanced generators from python 2.5.", "On the main page of cogen project there're links to several projects with similar purpose."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "cogen", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/cogen/"}]}], [{"text": ["One sollution is gevent.", "Gevent maries a libevent based event polling with lightweight cooperative task switching implemented by greenlet."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Gevent", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.gevent.org/"}]}, {"text": ["What you get is all the performance and scalability of an event system with the elegance and straightforward model of blocking IO programing."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(I don't know what the SO convention about answering to realy old questions is, but decided I'd still add my 2 cents)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["http://docs.python.org/library/socketserver.html#asynchronous-mixins"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/socketserver.html#asynchronous-mixins", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/socketserver.html#asynchronous-mixins"}]}, {"text": ["As for multi-processor (multi-core) machines.", "With CPython due to GIL you'll need at least one process per core, to scale.", "As you say that you need CPython, you might try to benchmark that with ForkingMixIn.", "With Linux 2.6 might give some interesting results."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "GIL", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/glossary.html#term-global-interpreter-lock"}, {"text": "ForkingMixIn", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Other way is to use Stackless Python.", "That's how EVE solved it.", "But I understand that it's not always possible. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Stackless Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.stackless.com/"}, {"text": "how EVE solved it", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.slideshare.net/Arbow/stackless-python-in-eve"}]}], [{"text": ["I like Douglas' answer, but as an aside..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could use a centralized dispatch thread/process that listens for readiness notifications using select and delegates to a pool of worker threads/processes to help accomplish your parallelism goals."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "select", "tag": "a", "pos": 0, "childList": [{"text": "select", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/select.html?highlight=select#module-select"}, {"text": "select", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/multiprocessing.html#module-multiprocessing", "text": "processes", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["As Douglas mentioned, however, the GIL won't be held during most lengthy I/O operations (since no Python-API things are happening), so if it's response latency you're concerned about you can try moving the critical portions of your code to CPython API."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]