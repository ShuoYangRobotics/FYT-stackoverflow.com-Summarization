[[{"text": ["It is considered an anti-pattern to have multiple asserts in a single unit test.", "A single unit test is expected to test only one thing.", "Perhaps you are testing too much.", "Consider splitting this test up into multiple tests.", "This way you can name each test properly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Sometimes however, it is okay to check multiple things at the same time.", "Fo5r instance when you are asserting properties of the same object.", "In that case you are in fact asserting whether that object is correct.", "A way to do this is to write a custom helper method that knows how to assert on that object.", "You can write that method in such a way that it shows all failing properties or for instance shows the complete state of the expected object and the complete state of the actual object when an assert fails."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Do each assert in a separate method."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MathTest(unittest.TestCase):\n  def test_addition1(self):\n    self.assertEqual(1 + 0, 1)\n\n  def test_addition2(self):\n    self.assertEqual(1 + 1, 3)\n\n  def test_addition3(self):\n    self.assertEqual(1 + (-1), 0)\n\n  def test_addition4(self):\n    self.assertEqaul(-1 + (-1), -1)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What you'll probably want to do is derive unittest.TestCase since that's the class that throws when an assertion fails.", "You will have to re-architect your TestCase to not throw (maybe keep a list of failures instead).", "Re-architecting stuff can cause other issues that you would have to resolve.", "For example you may end up needing to derive TestSuite to make changes in support of the changes made to your TestCase."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "unittest.TestCase", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "TestCase", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "TestSuite", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "TestCase", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Another way to have non-fatal assertions is to capture the assertion exception and store the exceptions in a list.", "Then assert that that list is empty as part of the tearDown."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import unittest\n\nclass Car(object):\n  def __init__(self, make, model):\n    self.make = make\n    self.model = make  # Copy and paste error: should be model.\n    self.has_seats = True\n    self.wheel_count = 3  # Typo: should be 4.\n\nclass CarTest(unittest.TestCase):\n  def setUp(self):\n    self.verificationErrors = []\n\n  def tearDown(self):\n    self.assertEqual([], self.verificationErrors)\n\n  def test_init(self):\n    make = \"Ford\"\n    model = \"Model T\"\n    car = Car(make=make, model=model)\n    try: self.assertEqual(car.make, make)\n    except AssertionError, e: self.verificationErrors.append(str(e))\n    try: self.assertEqual(car.model, model)  # Failure!\n    except AssertionError, e: self.verificationErrors.append(str(e))\n    try: self.assertTrue(car.has_seats)\n    except AssertionError, e: self.verificationErrors.append(str(e))\n    try: self.assertEqual(car.wheel_count, 4)  # Failure!\n    except AssertionError, e: self.verificationErrors.append(str(e))\n\nif __name__ == \"__main__\":\n    unittest.main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't think there is a way to do this with PyUnit and wouldn't want to see PyUnit extended in this way."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I prefer to stick to one assertion per test function (or more specifically asserting one concept per test) and would rewrite test_addition() as four separate test functions.", "This would give more useful information on failure, viz:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "or more specifically asserting one concept per test", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2878717/multiple-asserts-in-a-unit-test/2878912#2878912"}, {"text": "test_addition()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "viz", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n .FF.\n======================================================================\nFAIL: test_addition_with_two_negatives (__main__.MathTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"test_addition.py\", line 10, in test_addition_with_two_negatives\n    self.assertEqual(-1 + (-1), -1)\nAssertionError: -2 != -1\n\n======================================================================\nFAIL: test_addition_with_two_positives (__main__.MathTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"test_addition.py\", line 6, in test_addition_with_two_positives\n    self.assertEqual(1 + 1, 3)  # Failure!\nAssertionError: 2 != 3\n\n----------------------------------------------------------------------\nRan 4 tests in 0.000s\n\nFAILED (failures=2)\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you decide that this approach isn't for you, you may find this answer helpful."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "this answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/q/1307367/78845"}]}, {"text": ["Update"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"text": ["It looks like you are testing two concepts with your updated question and I would split these into two unit tests.", "The first being that the parameters are being stored on the creation of a new object.", "This would have two assertions, one for make and one for model.", "If the first fails, the that clearly needs to be fixed, whether the second passes or fails is irrelevant at this juncture."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "make", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "model", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The second concept is more questionable... You're testing whether some default values are initialised.", "Why?", "It would be more useful to test these values at the point that they are actually used (and if they are not used, then why are they there?", "). "], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Why", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Both of these tests fail, and both should.", "When I am unit-testing, I am far more interested in failure than I am in success as that is where I need to concentrate."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n FF\n======================================================================\nFAIL: test_creation_defaults (__main__.CarTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"test_car.py\", line 25, in test_creation_defaults\n    self.assertEqual(self.car.wheel_count, 4)  # Failure!\nAssertionError: 3 != 4\n\n======================================================================\nFAIL: test_creation_parameters (__main__.CarTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"test_car.py\", line 20, in test_creation_parameters\n    self.assertEqual(self.car.model, self.model)  # Failure!\nAssertionError: 'Ford' != 'Model T'\n\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nFAILED (failures=2)\n</code>\n</pre>\n", "senID": 8}], [{"text": ["One option is assert on all the values at once as a tuple."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class CarTest(unittest.TestCase):\n  def test_init(self):\n    make = \"Ford\"\n    model = \"Model T\"\n    car = Car(make=make, model=model)\n    self.assertEqual(\n            (car.make, car.model, car.has_seats, car.wheel_count),\n            (make, model, True, 4))\n</code>\n</pre>\n", "senID": 2}, {"text": ["The output from this tests would be:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n ======================================================================\nFAIL: test_init (test.CarTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"C:\\temp\\py_mult_assert\\test.py\", line 17, in test_init\n    (make, model, True, 4))\nAssertionError: Tuples differ: ('Ford', 'Ford', True, 3) != ('Ford', 'Model T', True, 4)\n\nFirst differing element 1:\nFord\nModel T\n\n- ('Ford', 'Ford', True, 3)\n?           ^ -          ^\n\n+ ('Ford', 'Model T', True, 4)\n?           ^  ++++         ^\n</code>\n</pre>\n", "senID": 4}, {"text": ["This shows that both the model and the wheel count are incorrect."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]