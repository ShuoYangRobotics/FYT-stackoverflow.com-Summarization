[[{"text": ["You haven't said very much about your specific use case or needs.", "In particular, it would be helpful to know what you need to do with the change information (how long do you need to store it?).", "If you only need to store it for transient purposes, @S.Lott's session solution may be best.", "If you want a full audit trail of all changes to your objects stored in the DB, try this AuditTrail solution."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "AuditTrail solution", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/wiki/AuditTrail"}]}, {"text": ["UPDATE: The AuditTrail code I linked to above is the closest I've seen to a full solution that would work for your case, though it has some limitations (doesn't work at all for ManyToMany fields).", "It will store all previous versions of your objects in the DB, so the admin could roll back to any previous version.", "You'd have to work with it a bit if you want the change to not take effect until approved."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "UPDATE", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You could also build a custom solution based on something like @Armin Ronacher's DiffingMixin.", "You'd store the diff dictionary (maybe pickled?", ") in a table for the admin to review later and apply if desired (you'd need to write the code to take the diff dictionary and apply it to an instance)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Django is currently sending all columns to the database, even if you just changed one.", "To change this, some changes in the database system would be necessary.", "This could be easily implemented on the existing code by adding a set of dirty fields to the model and adding column names to it, each time you __set__ a column value."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__set__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If you need that feature, I would suggest you look at the Django ORM, implement it and put a patch into the Django trac.", "It should be very easy to add that and it would help other users too.", "When you do that, add a hook that is called each time a column is set."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you don't want to hack on Django itself, you could copy the dict on object creation and diff it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Maybe with a mixin like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class DiffingMixin(object):\n\n    def __init__(self, *args, **kwargs):\n        super(DiffingMixin, self).__init__(*args, **kwargs)\n        self._original_state = dict(self.__dict__)\n\n    def get_changed_columns(self):\n        missing = object()\n        result = {}\n        for key, value in self._original_state.iteritems():\n            if key != self.__dict__.get(key, missing):\n                result[key] = value\n        return result\n\n class MyModel(DiffingMixin, models.Model):\n     pass\n</code>\n</pre>\n", "senID": 4}, {"text": ["This code is untested but should work.", "When you call model.get_changed_columns() you get a dict of all changed values.", "This of course won't work for mutable objects in columns because the original state is a flat copy of the dict."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "model.get_changed_columns()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I've found Armin's idea very useful.", "Here is my variation;"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class DirtyFieldsMixin(object):\n    def __init__(self, *args, **kwargs):\n        super(DirtyFieldsMixin, self).__init__(*args, **kwargs)\n        self._original_state = self._as_dict()\n\n    def _as_dict(self):\n        return dict([(f.name, getattr(self, f.name)) for f in self._meta.local_fields if not f.rel])\n\n    def get_dirty_fields(self):\n        new_state = self._as_dict()\n        return dict([(key, value) for key, value in self._original_state.iteritems() if value != new_state[key]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: I've tested this BTW."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Sorry about the long lines.", "The difference is (aside from the names) it only caches local non-relation fields.", "In other words it doesn't cache a parent model's fields if present."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["And there's one more thing; you need to reset _original_state dict after saving.", "But I didn't want to overwrite save() method since most of the times we discard model instances after saving."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def save(self, *args, **kwargs):\n    super(Klass, self).save(*args, **kwargs)\n    self._original_state = self._as_dict()\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Continuing on Muhuk's suggestion &amp; adding Django's signals and a unique dispatch_uid you could reset the state on save without overriding save():"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from django.db.models.signals import post_save\n\nclass DirtyFieldsMixin(object):\n    def __init__(self, *args, **kwargs):\n        super(DirtyFieldsMixin, self).__init__(*args, **kwargs)\n        post_save.connect(self._reset_state, sender=self.__class__, \n                            dispatch_uid='%s-DirtyFieldsMixin-sweeper' % self.__class__.__name__)\n        self._reset_state()\n\n    def _reset_state(self, *args, **kwargs):\n        self._original_state = self._as_dict()\n\n    def _as_dict(self):\n        return dict([(f.name, getattr(self, f.name)) for f in self._meta.local_fields if not f.rel])\n\n    def get_dirty_fields(self):\n        new_state = self._as_dict()\n        return dict([(key, value) for key, value in self._original_state.iteritems() if value != new_state[key]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which would clean the original state once saved without having to override save().", "The code works but not sure what the performance penalty is of connecting signals at __init__"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I extended muhuk and smn's solutions to include difference checking on the primary keys for foreign key and one-to-one fields:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from django.db.models.signals import post_save\n\nclass DirtyFieldsMixin(object):\n    def __init__(self, *args, **kwargs):\n        super(DirtyFieldsMixin, self).__init__(*args, **kwargs)\n        post_save.connect(self._reset_state, sender=self.__class__,\n                            dispatch_uid='%s-DirtyFieldsMixin-sweeper' % self.__class__.__name__)\n        self._reset_state()\n\n    def _reset_state(self, *args, **kwargs):\n        self._original_state = self._as_dict()\n\n    def _as_dict(self):\n        return dict([(f.attname, getattr(self, f.attname)) for f in self._meta.local_fields])\n\n    def get_dirty_fields(self):\n        new_state = self._as_dict()\n        return dict([(key, value) for key, value in self._original_state.iteritems() if value != new_state[key]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["The only difference is in as_dirty I changed the last line from"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "as_dirty", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n return dict([\n    (f.name, getattr(self, f.name)) for f in self._meta.local_fields\n    if not f.rel\n])\n</code>\n</pre>\n", "senID": 3}, {"text": ["to"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n return dict([\n    (f.attname, getattr(self, f.attname)) for f in self._meta.local_fields\n])\n</code>\n</pre>\n", "senID": 5}, {"text": ["This mixin, like the ones above, can be used like so:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class MyModel(DirtyFieldsMixin, models.Model):\n    ....\n</code>\n</pre>\n", "senID": 7}], [{"text": ["If you're using your own transactions (not the default admin application), you can save the before and after versions of your object.", "You can save the before version in the session, or you can put it in \"hidden\" fields in the form.", "Hidden fields is a security nightmare.", "Therefore, use the session to retain history of what's happening with this user."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Additionally, of course, you do have to fetch the previous object so you can make changes to it.", "So you have several ways to monitor the differences."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def updateSomething( request, object_id ):\n    object= Model.objects.get( id=object_id )\n    if request.method == \"GET\":\n        request.session['before']= object\n        form= SomethingForm( instance=object )\n    else request.method == \"POST\"\n        form= SomethingForm( request.POST )\n        if form.is_valid():\n            # You have before in the session\n            # You have the old object\n            # You have after in the form.cleaned_data\n            # Log the changes\n            # Apply the changes to the object\n            object.save()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["for everyone's information, muhuk's solution fails under python2.6 as it raises an exception stating 'object.__ init __()' accepts no argument..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["edit: ho!", "apparently it might've been me misusing the the mixin...", "I didnt pay attention and  declared it as the last parent and because of that the call to  init ended up in the object parent rather than the next parent as it noramlly would with diamond diagram inheritance!", "so please disregard my comment :)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "init", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}]]