[[{"text": ["Your code isn't exploded in the same order.", "The compact version goes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n A &gt; B &gt; C &gt; D &gt; E\n</code>\n</pre>\n", "senID": 1}, {"text": ["while your exploded version goes "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n B &gt; C &gt; A &gt; D &gt; E\n</code>\n</pre>\n", "senID": 3}, {"text": ["The effect is that strip() is being deferred 2 steps down, which may affect performance depending on what the input is."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Frankly speaking, the first version, where everything is in one line, is a pain to read.", "The second one is maybe a little too verbose (something in the middle would be appreciated) but it is definitely better."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["I would not care too much about micro optimizations because of Python internals, and focus only on readable code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["By the way: the two (initial) versions are not doing the same thing.", "In the former, you first strip, then split, while in the latter you first split and then strip (furthermore, only the first element).", "Again, I think you overlooked this because the former version is quite difficult to focus on.", "Then, analyzing the two (updated) versions with dis (python disassembler) showed no real difference between the two codes, only the order how the function names are being looked up.", "It is possible that this may have an impact on performance.  "], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "dis", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "python disassembler", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/dis.html"}]}, {"text": ["While we are on this, you could get some performance improvement just by binding eval to a local variable, before the loop.", "I would expect that after that change, there should be no difference in time between the two versions.", "For example:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n eval_ = eval\nfor line in lines:\n    a = line.strip()\n    b = a.split()\n    c = b[0]\n    d = eval_(c)\n    numbers.append(d)\n</code>\n</pre>\n", "senID": 4}, {"text": ["We are mostly talking about micro-optimizations, but this aliasing is actually a technique that may be very useful in several circumstances."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["The method calls are also not in the same order:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for line in lines:\n    numbers.append(eval(line.strip().split()[0]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["should be:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for line in lines:\n    numbers.append(eval(line.split()[0].strip()))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I agree with Roberto Liffredo; don't worry about that small of a performance improvement; code that is easier to understand, debug, and change is its own reward."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As for what's going on: the terse code and the expanded code don't do quite the same things.", "line.strip().split() first strips the line and then splits it; your expanded code splits the line first, and then calls strip() on the first word from the line.", "Now, the strip() isn't needed here; it's stripping white space from the end of the line, and words returned by split() never have any.", "Thus, in your expanded version, strip() has absolutely no work to do."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "line.strip().split()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "strip()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "strip()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "split()", "childNum": 0, "tag": "code", "childList": []}, {"text": "strip()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Without benchmarking, I can't be certain, but I think that strip() having no work to do is the key.", "In the one-line version, strip() sometimes has work to do; so it will strip the whitespace, building a new string object, and then return that string object.", "Then, that new string object will be split and discarded.", "The extra work of creating and discarding string objects is likely what is making the one-line solution slower.", "Compare that with the expanded version, where strip() simply looks at the string, decides it has no work to do, and returns the string unmodified."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "strip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "strip()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "strip()", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["In summary, I predict that a one-liner equivalent to your expanded code will be slightly faster than your expanded code.", "Try benchmarking this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for line in lines:\n  numbers.append(eval(line.split()[0].strip()))\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you want to be completely thorough, you could benchmark both versions with the strip() removed completely.", "You just don't need it.", "Or, you could pre-process your input file, making sure that there is no leading or trailing white space on any input line, and thus never any work for strip() to do, and you will probably see the benchmarks work as you would expect."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "strip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "strip()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If you really want to make a hobby out of optimizing for speed here, you could call split with a \"maxsplit\" argument; you don't need to process the whole string as you are throwing away everything after the first split.", "Thus you could call split(None, 1).", "You can get rid of the strip(), of course.", "And you would then have:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "split(None, 1)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "strip()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n for line in lines:\n  numbers.append(eval(line.split(None, 1)[0]))\n</code>\n</pre>\n", "senID": 7}, {"text": ["If you knew the numbers were always integers, you could call int() instead of eval(), for a speed improvement and security improvement."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "int()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "eval()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Also, sometimes it's tricky to run benchmarks.", "Did you re-run the benchmarks multiple times and take the best of several runs?", "Is there any chance that caching effects give a performance advantage to the second Python program you run?", "Have you tried making your input file ten times bigger, so your program will take about ten times longer to run?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I haven't benchmarked it, but one factor in the time differences is that you have to do several variable lookups in the second function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["From Python Patterns - An Optimization Anecdote:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "From Python Patterns - An Optimization Anecdote", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/essays/list2str.html"}]}, {"text": ["So, local variable lookups do have a cost associated.", "Let's take a look at the disassembled functions:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["First, making sure I have the same defined functions as you:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def a(lines):\n    for line in lines:\n    \tnumbers.append(eval(line.strip().split()[0]))\n\n&gt;&gt;&gt; def b(lines):\n    for line in lines:\n    \ta = line.strip()\n    \tb = a.split()\n    \tc = b[0]\n    \td = eval(c)\n    \tnumbers.append(d)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now, let's compare their disassembled values:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(a)\n  2           0 SETUP_LOOP              49 (to 52)\n              3 LOAD_FAST                0 (lines)\n              6 GET_ITER            \n        &gt;&gt;    7 FOR_ITER                41 (to 51)\n             10 STORE_FAST               1 (line)\n\n  3          13 LOAD_GLOBAL              0 (numbers)\n             16 LOAD_ATTR                1 (append)\n             19 LOAD_GLOBAL              2 (eval)\n             22 LOAD_FAST                1 (line)\n             25 LOAD_ATTR                3 (strip)\n             28 CALL_FUNCTION            0\n             31 LOAD_ATTR                4 (split)\n             34 CALL_FUNCTION            0\n             37 LOAD_CONST               1 (0)\n             40 BINARY_SUBSCR       \n             41 CALL_FUNCTION            1\n             44 CALL_FUNCTION            1\n             47 POP_TOP             \n             48 JUMP_ABSOLUTE            7\n        &gt;&gt;   51 POP_BLOCK           \n        &gt;&gt;   52 LOAD_CONST               0 (None)\n             55 RETURN_VALUE        \n&gt;&gt;&gt; dis.dis(b)\n  2           0 SETUP_LOOP              73 (to 76)\n              3 LOAD_FAST                0 (lines)\n              6 GET_ITER            \n        &gt;&gt;    7 FOR_ITER                65 (to 75)\n             10 STORE_FAST               1 (line)\n\n  3          13 LOAD_FAST                1 (line)\n             16 LOAD_ATTR                0 (strip)\n             19 CALL_FUNCTION            0\n             22 STORE_FAST               2 (a)\n\n  4          25 LOAD_FAST                2 (a)\n             28 LOAD_ATTR                1 (split)\n             31 CALL_FUNCTION            0\n             34 STORE_FAST               3 (b)\n\n  5          37 LOAD_FAST                3 (b)\n             40 LOAD_CONST               1 (0)\n             43 BINARY_SUBSCR       \n             44 STORE_FAST               4 (c)\n\n  6          47 LOAD_GLOBAL              2 (eval)\n             50 LOAD_FAST                4 (c)\n             53 CALL_FUNCTION            1\n             56 STORE_FAST               5 (d)\n\n  7          59 LOAD_GLOBAL              3 (numbers)\n             62 LOAD_ATTR                4 (append)\n             65 LOAD_FAST                5 (d)\n             68 CALL_FUNCTION            1\n             71 POP_TOP             \n             72 JUMP_ABSOLUTE            7\n        &gt;&gt;   75 POP_BLOCK           \n        &gt;&gt;   76 LOAD_CONST               0 (None)\n             79 RETURN_VALUE\n</code>\n</pre>\n", "senID": 6}, {"text": ["It's a lot of information, but we can see the second method is riddled with STORE_FAST, LOAD_FAST pairs due to the local variables being used.", "That might be enough to cause your small timing differences, (perhaps) in addition to the different operation order as others have mentioned."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "STORE_FAST", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "LOAD_FAST", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "might", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Okay, enough theorizing.", "I created a file with one million lines, with random amounts of white space (0 to 4 spaces, usually 0) at beginning and end of each line.", "And I ran your one-liner, your expanded version, and my own list comprehension version (as fast as I know how to make it)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My results?", "(Each one is the best of three trials):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n one-line: 13.208s\nexpanded: 26.321s\nlistcomp: 13.024s\n</code>\n</pre>\n", "senID": 2}, {"text": ["I tested under Ubuntu 9.04, 32-bit, with Python 2.6.2 (CPython, of course)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["So I am completely unable to explain why you saw the expanded one running faster, given that it ran half as fast on my computer."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "half", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Here's the Python program I used to generate my test data:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import random\n\nf = open(\"/tmp/junk.txt\", \"w\")\n\nr = random.Random()\n\ndef randws():\n    n = r.randint(0, 10) - 4\n    if n &lt; 0 or n &gt; 4:\n        n = 0\n    return \" \" * n\n\nfor i in xrange(1000000):\n    s0 = randws()\n    n = r.randint(0, 256)\n    s1 = randws()\n    f.write(\"%s%d%s\\n\" % (s0, n, s1))\n</code>\n</pre>\n", "senID": 6}, {"text": ["Here's my list comprehension program:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n lines = open(\"/tmp/junk.txt\")\n\nnumbers = [eval(line.split(None, 1)[0]) for line in lines]\n</code>\n</pre>\n", "senID": 8}, {"text": ["P.S.", "Here is a nice, fast version that can handle both int and float values."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n lines = open(\"/tmp/junk.txt\")\n\ndef val(x):\n    try:\n        return int(x)\n    except ValueError:\n        pass\n\n    try:\n        return float(x)\n    except StandardError:\n        return 0\n\nnumbers = [val(line.split(None, 1)[0]) for line in lines]\n</code>\n</pre>\n", "senID": 10}, {"text": ["Its best-of-three time was: 2.161s"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["A one liner doesn't mean smaller or faster code.", "And I would expect that the eval() line would throw off performance measurements quite a bit. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Do you see similar performance differences without eval ?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]