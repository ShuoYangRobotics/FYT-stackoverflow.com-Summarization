[[{"text": ["The 3rd party shove module is also worth taking a look at.", "It's very similar to shelve in that it is a simple dict-like object, however it can store to various backends (such as file, SVN, and S3), provides optional compression, and is even threadsafe.", "It's a very handy module"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "shove", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/shove"}]}, {"code": "<pre>\n<code>\n from shove import Shove\n\nmem_store = Shove()\nfile_store = Shove('file://mystore')\n\nfile_store['key'] = value\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Hash-on-disk is generally addressed with Berkeley DB or something similar - several options are listed in the Python Data Persistence documentation.", "You can front it with an in-memory cache, but I'd test against native performance first; with operating system caching in place it might come out about the same."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python Data Persistence documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/persistence.html"}]}], [{"text": ["Last time I was facing a problem like this, I rewrote to use SQLite rather than a dict, and had a massive performance increase.", "That performance increase was at least partially on account of the database's indexing capabilities; depending on your algorithms, YMMV."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A thin wrapper that does SQLite queries in __getitem__ and __setitem__ isn't much code to write."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__getitem__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__setitem__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["With a little bit of thought it seems like you could get the shelve module to do what you want."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "shelve module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.doughellmann.com/2007/08/pymotw-shelve.html"}]}], [{"text": ["The shelve module may do it; at any rate, it should be simple to test.", "Instead of:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "shelve", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/shelve.html"}]}, {"code": "<pre>\n<code>\n self.lengths = {}\n</code>\n</pre>\n", "senID": 1}, {"text": ["do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import shelve\nself.lengths = shelve.open('lengths.shelf')\n</code>\n</pre>\n", "senID": 3}, {"text": ["The only catch is that keys to shelves must be strings, so you'll have to replace"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n self.lengths[indx]\n</code>\n</pre>\n", "senID": 5}, {"text": ["with"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n self.lengths[str(indx)]\n</code>\n</pre>\n", "senID": 7}, {"text": ["(I'm assuming your keys are just integers, as per your comment to Charles Duffy's post)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["There's no built-in caching in memory, but your operating system may do that for you anyway."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["[actually, that's not quite true: you can pass the argument 'writeback=True' on creation.", "The intent of this is to make sure storing lists and other mutable things in the shelf works correctly.", "But a side-effect is that the whole dictionary is cached in memory.", "Since this caused problems for you, it's probably not a good idea :-) ]"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["You should bring more than one item at a time if there's some heuristic to know which are the most likely items to be retrieved next, and don't forget the indexes like Charles mentions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I did not try it yet but Hamster DB is promising and has a Python interface."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Hamster DB", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://hamsterdb.com/"}]}], [{"text": ["read answer for this question from GvR ;)\nSorting a million 32-bit integers in 2MB of RAM using Python"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sorting a million 32-bit integers in 2MB of RAM using Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://neopythonic.blogspot.com/2008/10/sorting-million-32-bit-integers-in-2mb.html"}]}], [{"text": ["I've read you think shelve is too slow and you tried to hack your own dict using sqlite."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another did this too :"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://sebsauvage.net/python/snyppets/index.html#dbdict"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://sebsauvage.net/python/snyppets/index.html#dbdict", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sebsauvage.net/python/snyppets/index.html#dbdict"}]}, {"text": ["It seems pretty efficient (and sebsauvage is a pretty good coder).", "Maybe you could give it a try ?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]