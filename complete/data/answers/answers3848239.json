[[{"text": ["I've managed O(n log n)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is a (somewhat intense) C++ implementation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;boost/pending/disjoint_sets.hpp&gt;\n#include &lt;boost/property_map/property_map.hpp&gt;\n\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;iostream&gt;\n\n\ntypedef std::map&lt;int, int&gt; rank_t;\ntypedef std::map&lt;int, int&gt; parent_t;\n\ntypedef boost::associative_property_map&lt; rank_t &gt; rank_pmap_t;\ntypedef boost::associative_property_map&lt; parent_t &gt; parent_pmap_t;\n\ntypedef boost::disjoint_sets&lt; rank_pmap_t, parent_pmap_t &gt; group_sets_t;\n\ntypedef std::set&lt;int&gt; key_set;\ntypedef std::map&lt;int, std::set&lt;int&gt; &gt; output;\n</code>\n</pre>\n", "senID": 2}, {"text": ["With some typedefs out of the way, here's the real meat.", "I'm using boost::disjoint_sets, which is just happens to be an exceptionally good representation for the problem.", "This first function checks to see if either of the keys given have been seen before, and adds them to the collections if needed.", "the important part is really the union_set(a, b) which links the two sets together.", "If one or the other of the sets are already in the groups collection, they get linked too."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "boost::disjoint_sets", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.boost.org/doc/libs/1_44_0/libs/disjoint_sets/disjoint_sets.html"}, {"text": "union_set(a, b)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "groups", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"code": "<pre>\n<code>\n void add_data(int a, int b, group_sets_t &amp; groups, key_set &amp; keys)\n{\n  if (keys.count(a) &lt; 1) groups.make_set(a);\n  if (keys.count(b) &lt; 1) groups.make_set(b);\n  groups.union_set(a, b);\n  keys.insert(a);\n  keys.insert(b);\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["This isn't too exciting, it just iterates through all of the keys we've seen and gets the representative key for that key, then adds the pair (representative, key) to a map.", "Once that's done, print out the map."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n void build_output(group_sets_t &amp; groups, key_set &amp; keys)\n{\n  output out;\n  for (key_set::iterator i(keys.begin()); i != keys.end(); i++)\n    out[groups.find_set(*i)].insert(*i);\n\n  for (output::iterator i(out.begin()); i != out.end(); i++)\n  {\n    std::cout &lt;&lt; i-&gt;first &lt;&lt; \": \";\n    for (output::mapped_type::iterator j(i-&gt;second.begin()); j != i-&gt;second.end(); j++)\n      std::cout &lt;&lt; *j &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n  }\n}\n\nint main()\n{\n\n  rank_t rank;\n  parent_t parent;\n  rank_pmap_t rank_index(rank);\n  parent_pmap_t parent_index(parent);\n\n\n  group_sets_t groups( rank_index, parent_index );\n  key_set keys;\n\n  int a, b;\n  while (std::cin &gt;&gt; a)\n  {\n    std::cin &gt;&gt; b;\n    add_data(a, b, groups, keys);\n  }  \n\n\n  build_output(groups, keys);\n  //std::cout &lt;&lt; \"number of sets: \" &lt;&lt; \n  //  groups.count_sets(keys.begin()), keys.end()) &lt;&lt; std::endl;\n\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["I stayed up many hours learning how to use boost::disjoint_sets on this problem.", "There doesn't seem to be much of any documentation on it.  "], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "boost::disjoint_sets", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["About the performance.", "The disjoint_sets structure is O(&alpha;(n) ) for its key operations (make_set, find_set and union_set) which is pretty close to constant, and so if it were just a matter of building the structure, the whole algorithm would be O(n &alpha;(n) ) (which is effectively O(n) ) but we have to print it out.", "That means we have to build up some associative containers, which cannot perform better than O(n log n).", "It might be possible to get a constant factor speedup by choosing a different associative containers (say, hash_set etc), since once you populate the initial list, you can reserve an optimal amount of space."], "childNum": 5, "tag": "p", "senID": 8, "childList": [{"text": "disjoint_sets", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "make_set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "find_set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "union_set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "hash_set", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["Here is a sample Perl solution that works on the original data set:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n 1 2\n3 4\n5 9\n2 6\n3 7\n\nGroup 1: 1 2 6\nGroup 2: 3 4 7\nGroup 3: 5 9\n</code>\n</pre>\n", "senID": 1}, {"text": ["On the big data set, it produces the output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Group 1: 1 27 134 137 161 171 275 309 413 464 627 684 744\nGroup 2: 2 135 398 437 548 594 717 738 783 798 912\nGroup 3: 5 74 223\nGroup 4: 7 53 65 122 237 314 701 730 755 821 875 884 898 900 930\nGroup 5: 8 115\nGroup 6: 9 207 305 342 364 493 600 676 830 941\nGroup 7: 10 164 283 380 423 468 577\nGroup 8: 11 72 132 276 306 401 515 599\nGroup 9: 12 95 126 294\nGroup 10: 13 64 172 528\nGroup 11: 14 396\nGroup 12: 15 35 66 210 226 360 588\nGroup 13: 17 263 415 474 648 986\nGroup 14: 21 543 771\nGroup 15: 22 47\nGroup 16: 23 70 203 427 590\nGroup 17: 24 286 565\nGroup 18: 25 175\nGroup 19: 26 678\nGroup 20: 29 787\n</code>\n</pre>\n", "senID": 3}, {"text": ["Whether it is efficient enough is a separate matter..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n use strict;\nuse warnings;\nmy %cache = ();\nwhile (&lt;&gt;)\n{\n    chomp;\n    my($x,$y) = split /\\s+/;\n    #print \"$x $y\\n\";\n    $cache{$x}{$y} = 1;\n    $cache{$y}{$x} = 1;\n}\n\nmy $grp = 1;\nforeach my $key (sort { $a &lt;=&gt; $b } keys %cache)\n{\n    #print \"key: $key\\n\";\n    if (defined $cache{$key})\n    {\n        my %result = ();\n        subkey_search(\\%result, $key);\n        print \"Group $grp:\";\n        $grp++;\n        foreach my $val (sort { $a &lt;=&gt; $b } keys %result)\n        {\n            print \" $val\";\n        }\n        print \"\\n\";\n    }\n}\n\nsub subkey_search\n{\n    my($resultref, $key) = @_;\n    my %hash = %{$cache{$key}};\n    delete $cache{$key};\n    $resultref-&gt;{$key} = 1;\n    foreach my $subkey (sort keys %hash)\n    {\n        #print \"subkey: $subkey\\n\";\n        subkey_search($resultref, $subkey) if (defined $cache{$subkey});\n    }\n}\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Ok so I got something working in parallel to the other solution posted by @Jonathan (first of all, many thanks for your time).", "My solution looks deceptively simple but would love some suggestions on whether this is correct (maybe I'm missing a corner case somewhere?", ") because it seems to produce the output I wanted but I'll have to parse it in a second pass to group the same group numbers which is trivial.", "The logic is that everytime it finds a new number not in the array it increments a group_id counter:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My code in PHP:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "My code in PHP:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &lt;?php\n\n//$fp = fopen(\"./resemblance.1.out\", \"r\");\n$fp = fopen(\"./wrong\", \"r\");\n\n$groups = array();\n$group[\"-1\"] = 1;\n$groups[] = $group;\n\n$map = array();\n\n//Maintain a count\n$group = 1;\n\nwhile(!feof($fp)) {\n        $source = trim(fgets($fp, 4096));\n        //echo $source.\"\\n\";\n\n        $source = explode(\" \", $source);\n\n        if(array_key_exists($source[0], $map) &amp;&amp; !array_key_exists($source[1], $map)) {\n                $map[$source[1]] = $map[$source[0]];\n        } else if(array_key_exists($source[1], $map) &amp;&amp; !array_key_exists($source[0], $map)) {\n                $map[$source[0]] = $map[$source[1]];\n        } else if(array_key_exists($source[1], $map) &amp;&amp; array_key_exists($source[0], $map) &amp;&amp; $map[$source[1]] != $map[$source[0]]) {\n                // Adjust the groups - change the groups of one of the elements to the other\n                $keys = array_keys($map, $map[$source[1]]);\n                print_r($keys);\n                foreach($keys as $key) {\n                        $map[$key] = $map[$source[0]];\n                }\n        } else {\n                $group++;\n                $map[$source[0]] = $group;\n                $map[$source[1]] = $group;\n        }\n}\n\nprint_r($map);\n?&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Output:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Array\n(\n    [1] =&gt; 2\n    [2] =&gt; 2\n    [3] =&gt; 3\n    [4] =&gt; 3\n    [5] =&gt; 4\n    [9] =&gt; 4\n    [6] =&gt; 2\n    [7] =&gt; 3\n    [] =&gt; 5\n)\n</code>\n</pre>\n", "senID": 4}, {"text": ["EDIT: Fixed the bug that was mentioned in the comment.", "Just playing around out of curiosity :) Feel free to point out any other bugs.", "I am currently testing out which solution is faster."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Here's a slightly different version in Python, which builds a graph containing the edges specified, then converts that to a list of connected subgraphs. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I might want to use this later so I wrote it as a general-purpose version that doesn't do input from a file or output with print statements, just converting data structures."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def graph_to_connected_subgraphs(graph):\n    trees = []\n    for start in graph.keys():\n        if start in graph:\n            list = [start]\n            append_tree_from(graph, start, list)\n            trees.append(list)\n    return trees\n\ndef append_tree_from(graph, node, list):\n    if node in graph:\n        for endpoint in graph[node]:\n            list.append(endpoint)\n            append_tree_from(graph, endpoint, list)\n        del graph[node]\n    return list\n\ndef add_edge(graph, f, s):\n    if s &lt; f: # ensure f &lt; s to handle cyclic graphs\n        f, s = s, f\n    if f not in graph:\n        graph[f] = [s]\n    else:\n        graph[f].append(s)\n\ngraph = {}\n\nadd_edge(graph, 1,2)\nadd_edge(graph, 2,6)\nadd_edge(graph, 3,4)\nadd_edge(graph, 5,9)\nadd_edge(graph, 3,7)\n\nprint graph_to_connected_subgraphs(graph)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [[1, 2, 6], [3, 4, 7], [5, 9]]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["This is a typical application of DFS (Depth First Search) algorithm performed on graphs.", "Try read this dfs\nComplexity of this algorithm is O(|V|+|E|), where V - number of vertices and E - number of edges"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dfs", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Depth-first_search"}]}], [{"text": ["Here's my stab at an answer.", "Python.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n groups = []\n\ninfile = open(\"so2.txt\")\n\nfor line in infile.readlines():\n  newset = set(line.split())\n  matchgroups = []\n  excludegroups = []\n  for group in groups:\n    if len(newset &amp; group):\n      newset |= group\n    else:\n      excludegroups.append(group)\n  groups = excludegroups\n  groups.append( newset)\n\nfor i, s in enumerate(groups):\n  print \"%d: %s\"%(i, \" \".join(s))\n</code>\n</pre>\n", "senID": 1}, {"text": ["The Idea here is that forming graphs is not really right.", "Each pair of numbers in the input is a set.", "The rule is to return only disjoint sets.", "So I read each line and convert them to sets, then I check all of the existing sets for intersections, and merge those into the new set.", "Nonintersecting sets are just added to the new list of sets, and once I'm done I add the new, merged set into the new list of sets.", "This way I can be sure that only disjoint sets make it into the list.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["My version in PHP actually is only a refactoring of your code.", "It fixes one issue in your code (you have one group too much) and is implemented slightly more efficient (Exec time drops from 0.0035 to 0.0020 on slow machine):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\n$group = 0;\n$map = array();\n\ndo {\n    list($a, $b) = explode(' ', fgets($file));\n    $a = (int) $a;\n    $b = (int) $b;\n\n    if (!isset($map[$a]) &amp;&amp; !isset($map[$b])) {\n        $map[$a] = $map[$b] = ++$group;\n    } elseif (!isset($map[$b])) {\n        $map[$b] = $map[$a];\n    } elseif (!isset($map[$a])) {\n        $map[$a] = $map[$b];\n    } elseif ($map[$a] != $map[$b]) {\n        // move one group to the other\n        foreach ($map as $n =&gt; $g) {\n            if ($g == $map[$b]) {\n                $map[$n] = $map[$a];\n            }\n        }\n    }\n} while (!feof($file));\n\n// print results\n$results = array();\nforeach ($map as $val =&gt; $group) {\n    $results[$group][] = $val;\n}\n\necho '&lt;pre&gt;';\n$i = 0;\nforeach ($results as $result) {\n    sort($result);\n    echo 'Group ', ++$i, ': ', implode(' ', $result), \"\\n\";\n}\n"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "$group = 0;\n$map = array();\n\ndo {\n    list($a, $b) = explode(' ', fgets($file));\n    $a = (int) $a;\n    $b = (int) $b;\n\n    if (!isset($map[$a]) &amp;&amp; !isset($map[$b])) {\n        $map[$a] = $map[$b] = ++$group;\n    } elseif (!isset($map[$b])) {\n        $map[$b] = $map[$a];\n    } elseif (!isset($map[$a])) {\n        $map[$a] = $map[$b];\n    } elseif ($map[$a] != $map[$b]) {\n        // move one group to the other\n        foreach ($map as $n =&gt; $g) {\n            if ($g == $map[$b]) {\n                $map[$n] = $map[$a];\n            }\n        }\n    }\n} while (!feof($file));\n\n// print results\n$results = array();\nforeach ($map as $val =&gt; $group) {\n    $results[$group][] = $val;\n}\n\necho '&lt;pre&gt;';\n$i = 0;\nforeach ($results as $result) {\n    sort($result);\n    echo 'Group ', ++$i, ': ', implode(' ', $result), \"\\n\";\n}", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "$group = 0;\n$map = array();\n\ndo {\n    list($a, $b) = explode(' ', fgets($file));\n    $a = (int) $a;\n    $b = (int) $b;\n\n    if (!isset($map[$a]) &amp;&amp; !isset($map[$b])) {\n        $map[$a] = $map[$b] = ++$group;\n    } elseif (!isset($map[$b])) {\n        $map[$b] = $map[$a];\n    } elseif (!isset($map[$a])) {\n        $map[$a] = $map[$b];\n    } elseif ($map[$a] != $map[$b]) {\n        // move one group to the other\n        foreach ($map as $n =&gt; $g) {\n            if ($g == $map[$b]) {\n                $map[$n] = $map[$a];\n            }\n        }\n    }\n} while (!feof($file));\n\n// print results\n$results = array();\nforeach ($map as $val =&gt; $group) {\n    $results[$group][] = $val;\n}\n\necho '&lt;pre&gt;';\n$i = 0;\nforeach ($results as $result) {\n    sort($result);\n    echo 'Group ', ++$i, ': ', implode(' ', $result), \"\\n\";\n}", "tag": "code"}]}, {"text": "$group = 0;\n$map = array();\n\ndo {\n    list($a, $b) = explode(' ', fgets($file));\n    $a = (int) $a;\n    $b = (int) $b;\n\n    if (!isset($map[$a]) &amp;&amp; !isset($map[$b])) {\n        $map[$a] = $map[$b] = ++$group;\n    } elseif (!isset($map[$b])) {\n        $map[$b] = $map[$a];\n    } elseif (!isset($map[$a])) {\n        $map[$a] = $map[$b];\n    } elseif ($map[$a] != $map[$b]) {\n        // move one group to the other\n        foreach ($map as $n =&gt; $g) {\n            if ($g == $map[$b]) {\n                $map[$n] = $map[$a];\n            }\n        }\n    }\n} while (!feof($file));\n\n// print results\n$results = array();\nforeach ($map as $val =&gt; $group) {\n    $results[$group][] = $val;\n}\n\necho '&lt;pre&gt;';\n$i = 0;\nforeach ($results as $result) {\n    sort($result);\n    echo 'Group ', ++$i, ': ', implode(' ', $result), \"\\n\";\n}", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If the input is sorted, like your huge test set, you can do it in &Theta;(input) time and &Omicron;(input) space.", "If the input is unsorted, you could modify this fairly easily and get &Omicron;(input log input) time and &Theta;(input) space."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is very quick because&nbsp;:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "it stores a hash map from a node to its \"ultimate owner\" (which is the node with the lowest ID in the connected component) which allows &Omicron;(1) \"ultimate owner\" lookup and insertion.", "tag": "none", "senID": 2}, {"text": "it stores a hash map from each \"ultimate owner\" to a result line which allows &Omicron;(1) result line lookup and insertion.", "tag": "none", "senID": 3}, {"text": "each result line is a linked list which allows &Omicron;(1) appending.", "tag": "none", "senID": 4}, {"text": "it stores a linked list of result lines which allows&nbsp;:\n", "tag": "none", "senID": 5}]}, {"code": "<pre>\n<code>\n import java.util.Scanner;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.LinkedList;\n\npublic final class Solver {\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    final Map&lt;Integer, Integer&gt;       ultimateOwners = new HashMap&lt;Integer, Integer&gt;();\n    final Map&lt;Integer, List&lt;Integer&gt;&gt; ownerToOwned   = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;();\n    final List&lt;List&lt;Integer&gt;&gt;         results        = new LinkedList&lt;List&lt;Integer&gt;&gt;();\n\n    while (in.hasNextInt()) {\n      // Get ultimate owner.\n      int owner = in.nextInt();\n      if (ultimateOwners.containsKey(owner)) owner = ultimateOwners.get(owner);\n\n      // Get owned and register its ultimate owner.\n      final int owned = in.nextInt();\n      ultimateOwners.put(owned, owner);\n\n      // Add owned to result.\n      if (ownerToOwned.containsKey(owner)) ownerToOwned.get(owner).add(owned);\n      else {\n        final List&lt;Integer&gt; resultLine = new LinkedList&lt;Integer&gt;();\n        resultLine.add(owner);\n        resultLine.add(owned);\n        ownerToOwned.put(owner, resultLine);\n        results.add(resultLine);\n      }\n    }\n\n    int lineNumber = 1;\n    for (final List&lt;Integer&gt; line : results) {\n      System.out.printf(\"%d: \", lineNumber++);\n      for (final Integer value : line) {\n        System.out.printf(\"%d \", value);\n      }\n      System.out.println();\n    }\n  }\n}\n</code>\n</pre>\n", "senID": 6}], [{"text": ["After not being completely satisfied with my first 2 attempts at this, and some research, I came across this recipe for disjoint sets in Python, with Raymond Hettinger's blessing and input.", "(Raymond Hettinger is a long-time very active Python core developer."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/387776-grouping-objects-into-disjoint-sets/"}]}, {"text": ["Here is an adaptation of that recipe that's very close to my first 2 attempts, but the recipe itself may be a better reference."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "that recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/387776-grouping-objects-into-disjoint-sets/"}]}, {"text": ["Collecting should be as efficient as possible for very large sets of data, as much of the set operations in Python are implemented in C. The input data does not have to be sorted.", "For printing, I sorted outputs solely for readability, but if this affects performance, connections can be printed without sorting."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "not", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "not", "tag": "em"}]}, {"text": "not", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n # ~~~~~\n# data, setup\n\ninput = '''\n    1 2\n    3 4\n    2 3\n    ''' # etc.\n\ndef lgen():\n    for l in input.splitlines():\n        l = l.strip()\n        if l:\n            yield tuple(int(i) for i in l.split())\n\n# ~~~~~\n# collect\n\nconnections = {} # this is a mapping of values to the connections they are in\n                 # each node will map to a shared object instance of the connection it is in\n                 # e.g. {1: set([1,2]), 2: set([1,2])}, where the 2 sets are the same object\n\nfor x, y in lgen():\n    cx = connections.setdefault(x, set([x]))      # if not found, create new connection with this single value\n\n    cy = connections.get(y)                 # defaults to None if not found\n    if not cy:                              # if we haven't come across this value yet...\n        cx.add(y)                           # ...add it to the current connection...\n        connections[y] = cx                 # ...and update the reference\n    elif cy is not cx:                      # if the cy connection is not the exact same object as the cx connection...\n        if len(cy) &gt; len(cx):               # \\\n            cx, cy = cy, cx                 #  &gt;... merge them ...\n        cx |= cy                            # /\n        connections[y] = cx                 # ...and update the reference\n\n# ~~~~~\n# print\n\nseen = set()\nfor key in sorted(connections.keys()):\n    if key not in seen:\n        c = connections[key]\n        print sorted(c)\n        seen |= c\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This actually is a very classic Union-find."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Union-find", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Union-Find"}]}, {"text": ["If M is the number of edges, N the number of nodes, the time complexity is O(M * \u03b1(M)) which is a O(M) for all practical M and the space complexity if O(N) with N the number of nodes."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "O(M * \u03b1(M))", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "O(M)", "childNum": 0, "tag": "strong", "childList": []}, {"text": "O(N)", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["The algorithm is online and does not need to know in advance all the edges (compared to other graph-traversal solutions) and hence can scale very well.", "Also there is no need to order the edges, they can be given in any order."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Also there is no need to order the edges", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["For graph with billions of nodes you'll need 64 bits / long int and a lot of RAM, but it should handle millions of nodes and billions of edges very well."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The implementation is in C++ but only use vector/map that you can find in almost any language you might want to use."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["But since you have unique id for each element we need to map these id to (contiguous) \nintegers."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["First version without mapping (suppose that all nodes between 1 and N exists):"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconst int MAX_N = 1000*1000;\nint p[MAX_N],f[MAX_N];\n\nint parent(int a) {\n  return p[a] == a ? a : p[a] = parent(p[a]);\n}\nbool join(int a, int b) {\n  p[a = parent(a)] = parent(b);\n  return p[a] != a;\n}\n\nint main()\n{\n    // First integer in the file : number of nodes in the graph\n    int N;\n    scanf(\"%d\",&amp;N);\n    // Union-find in O(M * alpha(M)) ~= O(M)\n    // M = number of lines in the file\n    for(int i = 1; i &lt;= N ; i++)\n    {\n        p[i] = i;\n        f[i] = -1;\n    }\n    int a,b;\n    while(scanf(\"%d%d\",&amp;a,&amp;b) != EOF)\n        join(a,b);\n    // Determine the number of groups : O(M)\n    int nG = 0;\n    for(int i = 1 ; i &lt;= N ; i++)\n    {\n        p[i] = parent(p[i]);\n        if(f[p[i]] == -1)\n            f[p[i]] = nG++;\n    }\n    // Build groups : O(M)\n    vector&lt; vector&lt;int&gt; &gt; Groups(N+1);\n    for(int i = 1 ; i &lt;= N ; i++)\n        Groups[ f[p[i]] ].push_back(i);\n    // Output result\n    for(int i = 0 ; i &lt; Groups.size() ; i++)\n    {\n        if(!Groups[i].size())\n            continue;\n        printf(\"%d : \",i);\n        for(int j = 0 ; j &lt; Groups[i].size() ; j++)\n            printf(\"%d \",Groups[i][j]);\n        printf(\"\\n\");\n    }\n\n}\n</code>\n</pre>\n", "senID": 7}, {"text": ["Version with mapping : for that version we need to build the mapping.", "Since I don't know anything about your data, I'm using a classical map to build it in O(M log(N)), if you can send the id of all nodes at the begin of the input file, it can be O(N log(N)) or even better if your are using a Hash Map ( O(N)) or if you can build the mapping yourself, with some knowing of the graph."], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(M log(N))", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "O(N log(N))", "childNum": 0, "tag": "strong", "childList": []}, {"text": "O(N)", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Anyway, here is the code : "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\nusing namespace std;\n\nconst int MAX_N = 1000*1000;\nint p[MAX_N],f[MAX_N];\n\nint parent(int a) {\n  return p[a] == a ? a : p[a] = parent(p[a]);\n}\nbool join(int a, int b) {\n  p[a = parent(a)] = parent(b);\n  return p[a] != a;\n}\n// Mapping\nint N = 0;\nmap&lt;int,int&gt; indMap,invMap;\nint IND(int x) {\n    if(indMap.find(x) == indMap.end())\n    {\n        N++;\n        p[N] = N;\n        f[N] = -1;\n        indMap[x] = N;\n    }\n    invMap[ indMap[x] ] = x;\n    return indMap[x];\n}\n\n\nint main()\n{\n    // Union-find in O(M * alpha(M)) ~= O(M)\n    // M = number of lines in the file\n    int a,b;\n    while(scanf(\"%d%d\",&amp;a,&amp;b) != EOF)\n        join(IND(a),IND(b));\n    // Determine the number of groups : O(M)\n    int nG = 0;\n    for(int i = 1 ; i &lt;= N ; i++)\n    {\n        p[i] = parent(p[i]);\n        if(f[p[i]] == -1)\n            f[p[i]] = nG++;\n    }\n    // Build groups : O(M)\n    vector&lt; vector&lt;int&gt; &gt; Groups(N+1);\n    for(int i = 1 ; i &lt;= N ; i++)\n        Groups[ f[p[i]] ].push_back(i);\n    // Output result\n    for(int i = 0 ; i &lt; Groups.size() ; i++)\n    {\n        if(!Groups[i].size())\n            continue;\n        printf(\"%d : \",i+1);\n        for(int j = 0 ; j &lt; Groups[i].size() ; j++)\n            printf(\"%d \", invMap[ Groups[i][j] ]);\n        printf(\"\\n\");\n    }\n\n}\n</code>\n</pre>\n", "senID": 10}]]