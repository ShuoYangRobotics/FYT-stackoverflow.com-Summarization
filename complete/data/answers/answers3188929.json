[[{"text": ["The thing is, even though Python's import statement is designed to look similar to Java's, they do completely different things under the hood.", "As you know, in Java an import statement is really little more than a hint to the compiler.", "It basically sets up an alias for a fully qualified class name.", "For example, when you write"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "import", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "look", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "import", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import java.util.Set;\n</code>\n</pre>\n", "senID": 1}, {"text": ["it tells the compiler that throughout that file, when you write Set, you mean java.util.Set.", "And if you write s.add(o) where s is an object of type Set, the compiler (or rather, linker) goes out and finds the add method in Set.class and puts in a reference to it."], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "Set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "java.util.Set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "s.add(o)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "s", "childNum": 0, "tag": "code", "childList": []}, {"text": "Set", "childNum": 0, "tag": "code", "childList": []}, {"text": "add", "childNum": 0, "tag": "code", "childList": []}, {"text": "Set.class", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["But in Python,"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import util.set\n</code>\n</pre>\n", "senID": 4}, {"text": ["(that is a made-up module, by the way) does something completely different.", "Since Python is an interpreted language with dynamic resolution, there's no compiler to go out and look up the code of any util.set module.", "What happens in Python is that the interpreter looks for a package named util with a module named set inside it and loads the package and module, and in the process, it actually creates an object named util with an attribute named set.", "(That's right, packages and modules are actual first-class objects in Python.", ") You could think of the above statement as"], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "util.set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "util", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "util", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n util = __import__('util.set')\n</code>\n</pre>\n", "senID": 6}, {"text": ["where the function __import__ produces an object which has an attribute called set.", "In fact, that's actually what happens when you import a module - see the documentation for__import__.", "So you see, when you import a Python module, what you really get is just an object corresponding to the top-level package, util, and in order to get access to set you need to go through that."], "childNum": 6, "tag": "p", "senID": 7, "childList": [{"text": "__import__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"href": "http://docs.python.org/library/functions.html", "text": "documentation for__import__", "childNum": 1, "tag": "a", "childList": [{"text": "__import__", "tag": "code"}]}, {"text": "__import__", "childNum": 0, "tag": "code", "childList": []}, {"text": "util", "childNum": 0, "tag": "code", "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As mentioned in at least one other answer, you could write"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n from util import set\n</code>\n</pre>\n", "senID": 9}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n import util.set as set\n</code>\n</pre>\n", "senID": 11}, {"text": ["This still imports the package util with the module set in it, but instead of creating a variable util in the current scope, it creates a variable set that refers to util.set.", "Behind the scenes, this works kind of like"], "childNum": 5, "tag": "p", "senID": 12, "childList": [{"text": "util", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "util", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "util.set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n _util = __import__('util', fromlist='set')\nset = _util.set\ndel _util\n</code>\n</pre>\n", "senID": 13}, {"text": ["in the former case, or"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n _util = __import__('util.set')\nset = _util.set\ndel _util\n</code>\n</pre>\n", "senID": 15}, {"text": ["in the latter (although both ways do essentially the same thing).", "This form is semantically more like what Java does; it defines an alias (set) to something that would ordinarily only be accessible by a fully qualified name (util.set)."], "childNum": 2, "tag": "p", "senID": 16, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "util.set", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can shorten it, if you would like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import foo.bar as whateveriwant\n</code>\n</pre>\n", "senID": 1}, {"text": ["Using the full name prevents two packages with the same-named submodules from clobbering each other."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You're a bit confused about how Python imports work.", "(I was too when I first started.", ") In Python, you can't simply refer to something within a module by the full name, unlike in Java; you HAVE to import the module first, regardless of how you plan on referring to the imported item.", "Try typing math.sqrt(5) in the interpreter without importing math or math.sqrt first and see what happens."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "math.sqrt(5)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "math", "childNum": 0, "tag": "code", "childList": []}, {"text": "math.sqrt", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Anyway... the reason import foo.bar has you required to use foo.bar instead of just bar is to prevent accidental namespace conflicts.", "For example, what if you do import foo.bar, and then import baz.bar?"], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "import foo.bar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo.bar", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "childList": []}, {"text": "import foo.bar", "childNum": 0, "tag": "code", "childList": []}, {"text": "import baz.bar", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You could, of course, choose to do import foo.bar as bar (i.e.", "aliasing), but if you're doing that you may as well just use from foo import bar.", "(EDIT: except when you want to import methods and variables.", "Then you have to use the from ... import ... syntax.", "This includes instances where you want to import a method or variable without aliasing, i.e.", "you can't simply do import foo.bar if bar is a method or variable."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "import foo.bar as bar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "from foo import bar", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "from ... import ...", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "import foo.bar", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["in Python, importing doesn't just indicate you might use something.", "The import actually executes code at the module level.", "You can think of the import as being the moment where the functions are 'interpreted' and created.", "Any code that is in the __init__.py level or not inside a function or class definition happens then."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 1, "tag": "strong", "pos": 3, "childList": [{"text": "init", "tag": "em"}]}, {"text": "init", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["The import also makes an inexpensive copy of the whole module's namespace and puts it inside the namespace of the file / module / whatever where it is imported.", "An IDE then has a list of the functions you might be starting to type for command completion.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["There is a module in the standard library called io:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "io", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n In [84]: import io\n\nIn [85]: io\nOut[85]: &lt;module 'io' from '/usr/lib/python2.6/io.pyc'&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["There is also a module in scipy called io:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "scipy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "io", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n In [95]: import scipy.io\n\nIn [96]: scipy.io\nOut[96]: &lt;module 'scipy.io' from '/usr/lib/python2.6/dist-packages/scipy/io/__init__.pyc'&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you wanted to use both modules in the same script, then namespaces are a convenient way to distinguish the two."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n In [97]: import this\nThe Zen of Python, by Tim Peters\n...\nNamespaces are one honking great idea -- let's do more of those!\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Part of the Python philosophy is explicit is better than implicit.", "Python could automatically import the first time you try to access something from a package, but that's not explicit."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "explicit is better than implicit", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python.org/dev/peps/pep-0020/"}]}, {"text": ["I'm also guessing that package initialization would be much more difficult if the imports were automatic, as it wouldn't be done consistently in the code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Other than in Java, in Python import foo.bar declares, that you are going to use the thing referred to by foo.bar."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "import foo.bar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo.bar", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This matches with Python's philosophy that explicit is better than implicit.", "There are more programming languages that make inter-module dependencies more explicit than Java, for example Ada."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Using the full name makes it possible to disambiguate definitions with the same name coming from different modules."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You don't have to use the full name.", "Try one of these"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from foo import bar\n\nimport foo.bar as bar\n\nimport foo.bar\nbar = foo.bar\n\nfrom foo import *\n</code>\n</pre>\n", "senID": 1}, {"text": ["A few reasons why explicit imports are good:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "They help signal to humans and tools what packages your module depends on.", "tag": "none", "senID": 3}, {"text": "They avoid the overhead of dynamically determining which packages have to be loaded (and possibly compiled) at run time.", "tag": "none", "senID": 4}, {"text": "They (along with sys.path) unambiguously distinguish symbols with conflicting names from different namespaces.", "tag": "none", "senID": 5}, {"text": "They give the programmer some control of what enters the namespace within which he is working.", "tag": "none", "senID": 6}]}]]