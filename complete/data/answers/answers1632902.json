[[{"text": ["Your tests are doing very different things.", "With S being 1000000 elements and T being 300:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["[x for x in S for y in T if x==y]= 54.875"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"text": ["This option does 300000000 equality comparisons."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["filter(lambda x:x in S,T)= 0.391000032425"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["This option does 300 linear searches through S."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["[val for val in S if val in T]= 12.6089999676"], "childNum": 0, "tag": "h2", "senID": 5, "childList": []}, {"text": ["This option does 1000000 linear searches through T."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["list(set(S) &amp; set(T))= 0.125"], "childNum": 0, "tag": "h2", "senID": 7, "childList": []}, {"text": ["This option does two set constructions and one set intersection."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "hr", "senID": 9}, {"text": ["The differences in performance between these options is much more related to the algorithms each one is using, rather than any difference between list comprehensions and lambda."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "rather", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["When I fix your code so that the list comprehension and the call to filter are actually doing the same work things change a whole lot:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import time\n\nS=[x for x in range(1000000)]\nT=[y**2 for y in range(300)]\n#\n#\ntime1 = time.time()\nN=[x for x in T if x in S]\ntime2 = time.time()\nprint 'time diff [x for x in T if x in S]=', time2-time1\n#print N\n#\n#\ntime1 = time.time()\nN=filter(lambda x:x in S,T)\ntime2 = time.time()\nprint 'time diff filter(lambda x:x in S,T)=', time2-time1\n#print N\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then the output is more like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n time diff [x for x in T if x in S]= 0.414485931396\ntime diff filter(lambda x:x in S,T)= 0.466315984726\n</code>\n</pre>\n", "senID": 3}, {"text": ["So the list comprehension has a time that's generally pretty close to and usually less than the lambda expression."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The reason lambda expressions are being phased out is that many people think they are a lot less readable than list comprehensions.", "I sort of reluctantly agree."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Q: Why is lambda etc being pushed aside?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A: List comprehensions and generator expressions are generally considered to be a nice mix of power and readability.", "The pure functional-programming style where you use map(), reduce(), and filter() with functions (often lambda functions) is considered not as clear.", "Also, Python has added built-in functions that nicely handle all the major uses for reduce()."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "map()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "reduce()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "filter()", "childNum": 0, "tag": "code", "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "childList": []}, {"text": "reduce()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Suppose you wanted to sum a list.", "Here are two ways of doing it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n lst = range(10)\nprint reduce(lambda x, y: x + y, lst)\n\nprint sum(lst)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Sign me up as a fan of sum() and not a fan of reduce() to solve this problem.", "Here's another, similar problem:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "sum()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "reduce()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n lst = range(10)\nprint reduce(lambda x, y: bool(x or y), lst)\n\nprint any(lst)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Not only is the any() solution easier to understand, but it's also much faster; it has short-circuit evaluation, such that it will stop evaluating as soon as it has found any true value.", "The reduce() has to crank through the entire list.", "This performance difference would be stark if the list was a million items long, and the first item evaluated true.", "By the way, any() was added in Python 2.5; if you don't have it, here is a version for older versions of Python:"], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "any()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "reduce()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "any()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n def any(iterable):\n    for x in iterable:\n        if x:\n            return True\n    return False\n</code>\n</pre>\n", "senID": 7}, {"text": ["Suppose you wanted to make a list of squares of even numbers from some list."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n lst = range(10)\nprint map(lambda x: x**2, filter(lambda x: x % 2 == 0, lst))\n\nprint [x**2 for x in lst if x % 2 == 0]\n</code>\n</pre>\n", "senID": 9}, {"text": ["Now suppose you wanted to sum that list of squares."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n lst = range(10)\nprint sum(map(lambda x: x**2, filter(lambda x: x % 2 == 0, lst)))\n\n# list comprehension version of the above\nprint sum([x**2 for x in lst if x % 2 == 0])\n\n# generator expression version; note the lack of '[' and ']'\nprint sum(x**2 for x in lst if x % 2 == 0)\n</code>\n</pre>\n", "senID": 11}, {"text": ["The generator expression actually just returns an iterable object.", "sum() takes the iterable and pulls values from it, one by one, summing as it goes, until all the values are consumed.", "This is the most efficient way you can solve this problem in Python.", "In contrast, the map() solution, and the equivalent solution with a list comprehension inside the call to sum(), must first build a list; this list is then passed to sum(), used once, and discarded.", "The time to build the list and then delete it again is just wasted.", "(EDIT: and note that the version with both map and filter must build two lists, one built by filter and one built by map; both lists are discarded.", ")  (EDIT: But in Python 3.0 and newer, map() and filter() are now both \"lazy\" and produce an iterator instead of a list; so this point is less true than it used to be.", "Also, in Python 2.x you were able to use itertools.imap() and itertools.ifilter() for iterator-based map and filter.", "But I continue to prefer the generator expression solutions over any map/filter solutions."], "childNum": 10, "tag": "p", "senID": 12, "childList": [{"text": "sum()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "map()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "sum()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sum()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "pos": 6, "childList": []}, {"text": "two", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "pos": 7, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": 8, "childList": []}, {"text": "both", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["By composing map(), filter(), and reduce() in combination with lambda functions, you can do many powerful things.", "But Python has idiomatic ways to solve the same problems which are simultaneously better performing and easier to read and understand."], "childNum": 4, "tag": "p", "senID": 13, "childList": [{"text": "map()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "filter()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "reduce()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["First of all, test like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import timeit\n\nS=[x for x in range(10000)]\nT=[y**2 for y in range(30)]\n\nprint \"v1\", timeit.Timer('[x for x in S for y in T if x==y]',\n    \t\t 'from __main__ import S,T').timeit(100)\nprint \"v2\", timeit.Timer('filter(lambda x:x in S,T)',\n    \t\t 'from __main__ import S,T').timeit(100)\nprint \"v3\", timeit.Timer('[val for val in T if val in S]',\n    \t\t 'from __main__ import S,T').timeit(100)\nprint \"v4\", timeit.Timer('list(set(S) &amp; set(T))',\n    \t\t 'from __main__ import S,T').timeit(100)\n</code>\n</pre>\n", "senID": 1}, {"text": ["And basically you are doing different things each time you test.", "When you would rewrite the list-comprehension for example as"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [val for val in T if val in S]\n</code>\n</pre>\n", "senID": 3}, {"text": ["performance would be on par with the 'lambda/filter' construct."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Sets are the correct solution for this.", "However try swapping S and T and see how long it takes!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n filter(lambda x:x in T,S)\n\n$ python -m timeit -s'S=[x for x in range(1000000)];T=[y**2 for y in range(300)]' 'filter(lambda x:x in S,T)'\n10 loops, best of 3: 485 msec per loop\n$ python -m timeit -r1 -n1 -s'S=[x for x in range(1000000)];T=[y**2 for y in range(300)]' 'filter(lambda x:x in T,S)'\n1 loops, best of 1: 19.6 sec per loop\n</code>\n</pre>\n", "senID": 1}, {"text": ["So you see that the order of S and T are quite important"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Changing the order of the list comprehension to match the filter gives  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n $ python -m timeit  -s'S=[x for x in range(1000000)];T=[y**2 for y in range(300)]' '[x for x in T if x in S]'\n10 loops, best of 3: 441 msec per loop\n</code>\n</pre>\n", "senID": 4}, {"text": ["So if fact the list comprehension is slightly faster than the lambda on my computer"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Your list comprehension and lambda are doing different things, the list comprehension matching the lambda would be [val for val in T if val in S]."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "[val for val in T if val in S]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Efficiency isn't the reason why list comprehension are preferred (while they actually are slightly faster in almost all cases).", "The reason why they are preferred is readability."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Try it with smaller loop body and larger loops, like make T a set, and iterate over S. In that case on my machine the list comprehension is nearly twice as fast."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Your profiling is done wrong.", "Take a look the timeit module and try again."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "timeit module", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/timeit.html#module-timeit"}]}, {"text": ["lambda defines anonymous functions.", "Their main problem is that many people don't know the whole python library and use them to re-implement functions that are already in the operator, functools etc module ( and much faster ). "], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "operator", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "functools", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["List comprehensions have nothing to do with lambda.", "They are equivalent to the standard filter and map functions from functional languages.", "LCs are preferred because they can be used as generators too, not to mention readability."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Many people have already pointed out that you're comparing apples with oranges, etc, etc.", "But I think nobody's shown how to a really simple comparison -- list comprehension vs map plus lambda with little else to get in the way -- and that might be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'L=range(1000)' 'map(lambda x: x+1, L)'\n1000 loops, best of 3: 328 usec per loop\n$ python -mtimeit -s'L=range(1000)' '[x+1 for x in L]'\n10000 loops, best of 3: 129 usec per loop\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here, you can see very sharply the cost of lambda -- about 200 microseconds, which in the case of a sufficiently simple operation such as this one swamps the operation itself."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Numbers are very similar with filter of course, since the problem is not filter or map, but rather the lambda itself:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'L=range(1000)' '[x for x in L if not x%7]'\n10000 loops, best of 3: 162 usec per loop\n$ python -mtimeit -s'L=range(1000)' 'filter(lambda x: not x%7, L)'\n1000 loops, best of 3: 334 usec per loop\n</code>\n</pre>\n", "senID": 4}, {"text": ["No doubt the fact that lambda can be less clear, or its weird connection with Sparta (Spartans had a Lambda, for \"Lakedaimon\", painted on their shields -- this suggests that lambda is pretty dictatorial and bloody;-) have at least as much to do with its slowly falling out of fashion, as its performance costs.", "But the latter are quite real."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["This is pretty fast:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def binary_search(a, x, lo=0, hi=None):\n    if hi is None:\n        hi = len(a)\n    while lo &lt; hi:\n        mid = (lo+hi)//2\n        midval = a[mid]\n        if midval &lt; x:\n            lo = mid+1\n        elif midval &gt; x: \n            hi = mid\n        else:\n            return mid\n    return -1\n\ntime1 = time.time()\nN = [x for x in T if binary_search(S, x) &gt;= 0]\ntime2 = time.time()\nprint 'time diff binary search=', time2-time1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Simply: less comparisions, less time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["List comprehensions can make a bigger difference if you have to process your filtered results.", "In your case you just build a list, but if you had to do something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n n = [f(i) for i in S if some_condition(i)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["you would gain from LC optimization over this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n n = map(f, filter(some_condition(i), S))\n</code>\n</pre>\n", "senID": 3}, {"text": ["simply because the latter has to build an intermediate list (or tuple, or string, depending on the nature of S).", "As a consequence you will also notice a different impact on the memory used by each method, the LC will keep lower."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The lambda in itself does not matter."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]