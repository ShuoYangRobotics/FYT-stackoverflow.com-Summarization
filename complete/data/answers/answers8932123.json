[[{"text": ["I'd say that the example isn't symetric, meaning that it asks the reader handle two different cases:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "int, list", "tag": "none", "senID": 1}, {"text": "str, str", "tag": "none", "senID": 2}]}, {"text": ["In my opinion, the exercise should ask to implement this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "list, list: insert_at_end([5], [1, 3, 4, 6])", "tag": "none", "senID": 4}, {"text": "str, str: insert_at_end('x', 'abc')", "tag": "none", "senID": 5}]}, {"text": ["In this case, the reader has to work only with two parameters that use the same sequence type and the hint would make much more sense."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["My best effort:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def insert_at_end(val, seq):\n    t = type(seq)\n    try:\n        return seq + t(val)\n    except TypeError:\n        return seq + t([val])\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will attempt to create the sequence of type(seq) and if val is not iterable produces a list and concatenates."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "type(seq)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "val", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["That problem is one of a long list and the hint applies to all of them.", "I think it is reasonable that, having written the encapsulate function which can be re-used for things like insert_at_front, the rest of the implementation is type agnostic."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "encapsulate", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "insert_at_front", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["However, I think a better implementation of encapsulate might be:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "encapsulate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def encapsulate(val, seq):\n    if isinstance(seq, basestring):\n        return val\n    return type(seq)([val])\n</code>\n</pre>\n", "senID": 2}, {"text": ["which handles a wider range of types with less code."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This is not a solution but rather an explanation why a truly elegant solution does not look possible."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 4, "lis": [{"text": [], "childNum": 0, "tag": "code", "senID": 1, "childList": []}, {"text": "values passed as first argument to ", "tag": "none", "senID": 2}, {"text": "to do that, you cannot simply call a sequence constructor with a scalar argument and create a one-item sequence of that type: ", "tag": "none", "senID": 3}, {"text": ["str"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}]}, {"text": ["This renders + useless in this situation, even though you can easily construct a sequence of  given type cleanly, without instanceof, just by using type()."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "instanceof", "childNum": 0, "tag": "code", "childList": []}, {"text": "type()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can't use slice assignment, too, since only lists are mutable."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["In this situation, the solution by @Hamish looks cleanest."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["The challenge with this question (in Python 2.7, I'm testing 3.2 right now to verify) is that two of the possible input types for seq are immutable, and you're expected to return the same type as was passed in.", "For strings, this is less of an issue, because you could do this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "seq", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n return seq + char\n</code>\n</pre>\n", "senID": 1}, {"text": ["As that will return a new string that's the concatenation of the input sequence and the appended character, but that doesn't work for lists or tuples.", "You can only concatenate a list to a list or a tuple to a tuple.", "If you wanted to avoid \"type\" checking, you could get there with something like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if hasattr(seq, 'append'): # List input.\n  seq.append(char)\nelif hasattr(seq, 'strip'): # String input.\n  seq = seq + char\nelse: # Tuple\n  seq = seq + (char,)\n\nreturn seq\n</code>\n</pre>\n", "senID": 3}, {"text": ["That's really not much different from actually checking types, but it does avoid using the type function directly."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This solution still requires some separate code for strings as opposed to lists/tuples, but it is more concise and doesn't do any checking for specific types."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def insert_at_end(val, seq):\n    try:\n        return seq + val\n    except TypeError:   # unsupported operand type(s) for +\n        return seq + type(seq)([val])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Maybe this is nearer the answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def genappend(x, s):\n    if isinstance(s, basestring):\n        t = s[0:0].join\n    else:\n        t = type(s)\n    lst = list(s)\n    lst.append(x)\n    return t(lst)\n\nprint genappend(5, [1,2,3,4])    \nprint genappend(5, (1,2,3,4))\nprint genappend('5', '1234')\n</code>\n</pre>\n", "senID": 1}, {"text": ["There could also be completely user-defined sequence types.", "They will also work as long as convertable to and from a list.", "This also works:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n print genappend('5', set('1234'))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I agree that the point is if item is iterable or not."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "item", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So my solution would be this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def iterate(seq, item):\n    for i in seq:\n        yield i\n    yield item\n\ndef insert_at_end(seq, item):\n    if hasattr(item, '__iter__'):\n        return seq + item\n    else:\n        return type(seq)(iterate(seq, item))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; insert_at_end('abc', 'x')\n'abcx'\n&gt;&gt;&gt; insert_at_end([1, 2, 4, 6], 5)\n[1, 2, 4, 6, 5]\n&gt;&gt;&gt; insert_at_end((1, 2, 4, 6), 5)\n(1, 2, 4, 6, 5)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Since insert_at_end can handle iterable and not, works fine even with:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "insert_at_end", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; insert_at_end('abc', 'xyz')\n'abcxyz'\n&gt;&gt;&gt; insert_at_end([1, 2, 4, 6], [5, 7])\n[1, 2, 4, 6, 5, 7]\n&gt;&gt;&gt; insert_at_end((1, 2, 4, 6), (5, 7))\n(1, 2, 4, 6, 5, 7)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["While encapsulate relies on the type, the code directly in insert_at_end does not, and relies on + meaning related things for all 3 types, and so in that sense, fits in with the hint."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]