[[{"text": ["The from collections import defaultdict and import collections should be outside the iterated timing loops, since you won't repeat doing them."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "from collections import defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "import collections", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I guess that the from syntax has to do more work that the import syntax."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "from", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "import", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Using this test code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport timeit\n\nfrom collections import defaultdict\nimport collections\n\ndef first():\n    from collections import defaultdict\n    x = defaultdict(list)\n\ndef firstwithout():\n    x = defaultdict(list)\n\ndef second():\n    import collections\n    x = collections.defaultdict(list)\n\ndef secondwithout():\n    x = collections.defaultdict(list)\n\nprint \"first with import\",timeit.timeit('first()', 'from __main__ import first');\nprint \"second with import\",timeit.timeit('second()', 'from __main__ import second');\n\nprint \"first without import\",timeit.timeit('firstwithout()', 'from __main__ import firstwithout');\nprint \"second without import\",timeit.timeit('secondwithout()', 'from __main__ import secondwithout');\n</code>\n</pre>\n", "senID": 3}, {"text": ["I get results:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n first with import 1.61359190941\nsecond with import 1.02904295921\nfirst without import 0.344709157944\nsecond without import 0.449721097946\n</code>\n</pre>\n", "senID": 5}, {"text": ["Which shows how much the repeated imports cost."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I'll get also similar ratios between first(.", ") and second(.", "), only difference is that the timings are in microsecond level."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "first(.)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "second(.)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I don't think that your timings measure anything useful.", "Try to figure out better test cases!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Update:\nFWIW, here is some tests to support David Beazley's point."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"code": "<pre>\n<code>\n import math\nfrom math import sqrt\n\ndef first(n= 1000):\n    for k in xrange(n):\n        x= math.sqrt(9)\n\ndef second(n= 1000):\n    for k in xrange(n):\n        x= sqrt(9)\n\nIn []: %timeit first()\n1000 loops, best of 3: 266 us per loop\nIn [: %timeit second()\n1000 loops, best of 3: 221 us per loop\nIn []: 266./ 221\nOut[]: 1.2036199095022624\n</code>\n</pre>\n", "senID": 3}, {"text": ["So first() is some 20% slower than second()."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "first()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "second()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["My guess, your test is biased and the second implementation gains from the first one already having loaded the module, or just from having it loaded recently. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["How many times did you try it?", "Did you switch up the order, etc.."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["first() doesn't save anything, since the module must still be accessed in order to import the name."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "first()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Also, you don't give your timing methodology but given the function names it seems that first() performs the initial import, which is always longer than subsequent imports since the module must be compiled and executed."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "first()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["There is also the question of efficiency of reading/understanding the source code.", "Here's a real live example (code from a stackoverflow question)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "stackoverflow question", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/5895832"}]}, {"text": ["Original:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import math\n\ndef midpoint(p1, p2):\n   lat1, lat2 = math.radians(p1[0]), math.radians(p2[0])\n   lon1, lon2 = math.radians(p1[1]), math.radians(p2[1])\n   dlon = lon2 - lon1\n   dx = math.cos(lat2) * math.cos(dlon)\n   dy = math.cos(lat2) * math.sin(dlon)\n   lat3 = math.atan2(math.sin(lat1) + math.sin(lat2), math.sqrt((math.cos(lat1) + dx) * (math.cos(lat1) + dx) + dy * dy))\n   lon3 = lon1 + math.atan2(dy, math.cos(lat1) + dx)\n   return(math.degrees(lat3), math.degrees(lon3))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Alternative:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from math import radians, degrees, sin, cos, atan2, sqrt\n\ndef midpoint(p1, p2):\n   lat1, lat2 = radians(p1[0]), radians(p2[0])\n   lon1, lon2 = radians(p1[1]), radians(p2[1])\n   dlon = lon2 - lon1\n   dx = cos(lat2) * cos(dlon)\n   dy = cos(lat2) * sin(dlon)\n   lat3 = atan2(sin(lat1) + sin(lat2), sqrt((cos(lat1) + dx) * (cos(lat1) + dx) + dy * dy))\n   lon3 = lon1 + atan2(dy, cos(lat1) + dx)\n   return(degrees(lat3), degrees(lon3))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Write your code as usual, importing a module and referencing its modules and constants as module.attribute.", "Then, either prefix your functions with the decorator for binding constants or bind all modules in your program by using the bind_all_modules function below:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "module.attribute", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "decorator for binding constants", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/277940-decorator-for-bindingconstants-at-compile-time/"}, {"text": "bind_all_modules", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def bind_all_modules():\n    from sys import modules\n    from types import ModuleType\n    for name, module in modules.iteritems():\n        if isinstance(module, ModuleType):\n            bind_all(module)\n\ndef bind_all(mc, builtin_only=False, stoplist=[],  verbose=False):\n    \"\"\"Recursively apply constant binding to functions in a module or class.\n\n    Use as the last line of the module (after everything is defined, but\n    before test code).  In modules that need modifiable globals, set\n    builtin_only to True.\n\n    \"\"\"\n    try:\n        d = vars(mc)\n    except TypeError:\n        return\n    for k, v in d.items():\n        if type(v) is FunctionType:\n            newv = _make_constants(v, builtin_only, stoplist,  verbose)\n            try: setattr(mc, k, newv)\n            except AttributeError: pass\n        elif type(v) in (type, ClassType):\n            bind_all(v, builtin_only, stoplist, verbose)\n</code>\n</pre>\n", "senID": 1}]]