[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; m = max(a)\n&gt;&gt;&gt; [i for i, j in enumerate(a) if j == m]\n[9, 12]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n a.index(max(a))\n</code>\n</pre>\n", "senID": 0}, {"text": ["will tell you the index of the first instance of the largest valued element of list a."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here is the max value and the indexes it appears at:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import defaultdict\n&gt;&gt;&gt; d = defaultdict(list)\n&gt;&gt;&gt; a = [32, 37, 28, 30, 37, 25, 27, 24, 35, 55, 23, 31, 55, 21, 40, 18, 50, 35, 41, 49, 37, 19, 40, 41, 31]\n&gt;&gt;&gt; for i, x in enumerate(a):\n...     d[x].append(i)\n... \n&gt;&gt;&gt; k = max(d.keys())\n&gt;&gt;&gt; print k, d[k]\n55 [9, 12]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Later: for the satisfaction of @SilentGhost"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import takewhile\n&gt;&gt;&gt; import heapq\n&gt;&gt;&gt; \n&gt;&gt;&gt; def popper(heap):\n...     while heap:\n...         yield heapq.heappop(heap)\n... \n&gt;&gt;&gt; a = [32, 37, 28, 30, 37, 25, 27, 24, 35, 55, 23, 31, 55, 21, 40, 18, 50, 35, 41, 49, 37, 19, 40, 41, 31]\n&gt;&gt;&gt; h = [(-x, i) for i, x in enumerate(a)]\n&gt;&gt;&gt; heapq.heapify(h)\n&gt;&gt;&gt; \n&gt;&gt;&gt; largest = heapq.heappop(h)\n&gt;&gt;&gt; indexes = [largest[1]] + [x[1] for x in takewhile(lambda large: large[0] == largest[0], popper(h))]\n&gt;&gt;&gt; print -largest[0], indexes\n55 [9, 12]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The chosen answer (and others) require at least two passes through the list.", "Here's a one pass solution. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Edited: To address the two deficiencies pointed out by @John Machin.", "For (2) I attempted to optimize the tests based on guesstimated probability of occurrence of each condition and inferences allowed from predecessors.", "It was a little tricky figuring out the proper initialization value formax_indices which worked for all possible cases, especially if the max happened to be the first value in the list."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Edited:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "max_indices", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n a = [32, 37, 28, 30, 37, 25, 27, 24, 35, 55, 23, 31, 55, 21, 40, 18, 50,\n             35, 41, 49, 37, 19, 40, 41, 31]\n\ndef maxelements(seq):\n    ''' Return list of position(s) of largest element '''\n    max_indices = []\n    if len(seq):\n        max_val = seq[0]\n        for i,val in ((i,val) for i,val in enumerate(seq) if val &gt;= max_val):\n            if val == max_val:\n                max_indices.append(i)\n            else:\n                max_val = val\n                max_indices = [i]\n\n    return max_indices\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I can't reproduce the @SilentGhost-beating performance quoted by @martineau.", "Here's my effort with comparisons:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["=== maxelements.py ==="], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = [32, 37, 28, 30, 37, 25, 27, 24, 35, 55, 23, 31, 55, 21, 40, 18, 50,\n             35, 41, 49, 37, 19, 40, 41, 31]\nb = range(10000)\nc = range(10000 - 1, -1, -1)\nd = b + c\n\ndef maxelements_s(seq): # @SilentGhost\n    ''' Return list of position(s) of largest element '''\n    m = max(seq)\n    return [i for i, j in enumerate(seq) if j == m]\n\ndef maxelements_m(seq): # @martineau\n    ''' Return list of position(s) of largest element '''\n    max_indices = []\n    if len(seq):\n        max_val = seq[0]\n        for i, val in ((i, val) for i, val in enumerate(seq) if val &gt;= max_val):\n            if val == max_val:\n                max_indices.append(i)\n            else:\n                max_val = val\n                max_indices = [i]\n    return max_indices\n\ndef maxelements_j(seq): # @John Machin\n    ''' Return list of position(s) of largest element '''\n    if not seq: return []\n    max_val = seq[0] if seq[0] &gt;= seq[-1] else seq[-1]\n    max_indices = []\n    for i, val in enumerate(seq):\n        if val &lt; max_val: continue\n        if val == max_val:\n            max_indices.append(i)\n        else:\n            max_val = val\n            max_indices = [i]\n    return max_indices\n</code>\n</pre>\n", "senID": 2}, {"text": ["Results from a beat-up old laptop running Python 2.7 on Windows XP SP3:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;\\python27\\python -mtimeit -s\"import maxelements as me\" \"me.maxelements_s(me.a)\"\n100000 loops, best of 3: 6.88 usec per loop\n\n&gt;\\python27\\python -mtimeit -s\"import maxelements as me\" \"me.maxelements_m(me.a)\"\n100000 loops, best of 3: 11.1 usec per loop\n\n&gt;\\python27\\python -mtimeit -s\"import maxelements as me\" \"me.maxelements_j(me.a)\"\n100000 loops, best of 3: 8.51 usec per loop\n\n&gt;\\python27\\python -mtimeit -s\"import maxelements as me;a100=me.a*100\" \"me.maxelements_s(a100)\"\n1000 loops, best of 3: 535 usec per loop\n\n&gt;\\python27\\python -mtimeit -s\"import maxelements as me;a100=me.a*100\" \"me.maxelements_m(a100)\"\n1000 loops, best of 3: 558 usec per loop\n\n&gt;\\python27\\python -mtimeit -s\"import maxelements as me;a100=me.a*100\" \"me.maxelements_j(a100)\"\n1000 loops, best of 3: 489 usec per loop\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n import operator\n\ndef max_positions(iterable, key=None, reverse=False):\n  if key is None:\n    def key(x):\n      return x\n  if reverse:\n    better = operator.lt\n  else:\n    better = operator.gt\n\n  it = enumerate(iterable)\n  for pos, item in it:\n    break\n  else:\n    raise ValueError(\"max_positions: empty iterable\")\n    # note this is the same exception type raised by max([])\n  cur_max = key(item)\n  cur_pos = [pos]\n\n  for pos, item in it:\n    k = key(item)\n    if better(k, cur_max):\n      cur_max = k\n      cur_pos = [pos]\n    elif k == cur_max:\n      cur_pos.append(pos)\n\n  return cur_max, cur_pos\n\ndef min_positions(iterable, key=None, reverse=False):\n  return max_positions(iterable, key, not reverse)\n</code>\n</pre>\n", "senID": 0}, {"tag": "b", "senID": 1}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; L = range(10) * 2\n&gt;&gt;&gt; L\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; max_positions(L)\n(9, [9, 19])\n&gt;&gt;&gt; min_positions(L)\n(0, [0, 10])\n&gt;&gt;&gt; max_positions(L, key=lambda x: x // 2, reverse=True)\n(0, [0, 1, 10, 11])\n</code>\n</pre>\n", "senID": 2}]]