[[{"text": ["You should really use the Counter class instead of reinventing your own wheel."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Counter", "tag": "a", "pos": 0, "childList": [{"text": "Counter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/dev/library/collections.html#collections.Counter"}, {"text": "Counter", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["charcount is a dictionary, and dictionaries have no implicit sort order.", "Therefore, we'll have to convert it to a list, which can be sorted.", "Each entry in that list will be a tuple of count and character."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "charcount", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#tuples-and-sequences"}]}, {"text": ["charcount.items() already gives us a list that looks like [('\\n', 1219), ('!", "', 6079)].", "Unfortunately, if we would sort this list, it would sort by character first and then (if characters were ever equal) by count instead of the other way round.", "Therefore, we need a key function to tell sort to look at count first, and then (if counts are equal) the character.", "Fortunately, our key function is really simple; it just swaps around the tuple:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "charcount.items()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[('\\n', 1219), ('!', 6079)]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "key function", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/HowTo/Sorting#Key_Functions"}]}, {"code": "<pre>\n<code>\n lambda (char,count): (count, char)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Alternatively, we could use a list comprehension to swap the values, to get something like: [('\\n', 1219), ('!", "', 6079)], then sort, and then swap the values again."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "[('\\n', 1219), ('!', 6079)]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n charcount_list = sorted(charcount.items(), key=lambda (char,count):(count, char))\n</code>\n</pre>\n", "senID": 5}, {"text": ["charcount_list will now be:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n [('a', 1), ('e', 1), ('i', 1), ('l', 1), ('q', 1), ('t', 1), ('u', 1), ('y', 1),\n ('\\n', 1219), ('^', 6030), ('*', 6034), ('&amp;', 6043), ('$', 6046), ('{', 6046),\n ('+', 6066), ('!', 6079), ('%', 6104), ('}', 6105), ('[', 6108), ('_', 6112),\n ('#', 6115), (']', 6152), (' (', 6154), ('@', 6157), (')', 6186)]\n</code>\n</pre>\n", "senID": 7}, {"text": ["If you want the reverse order, simply specify the reverse=True argument to sorted."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "reverse=True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/functions.html#sorted", "text": "sorted", "childNum": 0, "tag": "a", "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; from operator import itemgetter\n&gt;&gt;&gt; sorted(charcount.items(), key=itemgetter(1))\n[('a', 1), ('e', 1), ('i', 1), ('l', 1), ('q', 1), ('u', 1), ('t', 1), ('y', 1), ('\\n', 1219), ('^', 6030), ('*', 6034), ('&amp;', 6043), ('$', 6046), ('{', 6046), ('+', 6066), ('!', 6079), ('%', 6104), ('}', 6105), ('[', 6108), ('_', 6112), ('#', 6115), (']', 6152), (' (', 6154), ('@', 6157), (')', 6186)]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n sorted(charcount.items(), key=lambda item: item[1])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["charcount is a dict (dictionary).", "Iterating a dictionary iterates over it's keys, that's why sorted() results in a sorted list of keys."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "charcount", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sorted()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You need to get list of items then sort it by the second value:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n sorted(charcount.items(), key=lambda t: t[1])\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Dictionary is iterated by key, so you get a sorted list of keys when you pass the dictionary to sorted.", "Sort the dictionary's item tuples by value to get a list of sorted tuples. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sorted", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n sorted_charcount = sorted(charcount.items(), key=lambda item: item[1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you're using Python 2.7+, then you can use the list of tuples to initialize an OrderedDict, which will maintain the sorted order of item tuples."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "OrderedDict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Dictionaries ( what {} means) are unordered collections.", "Which means you can't sort them in any kind of meaningful way.", "I suggest storing the information as a list of tuples [(), ...] and then sorting them based on that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "unordered", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n foo = [('a', 123), ('b', 345)]\n\ndef key_function(x):\n    return x[1]\n\nsorted_list = sorted(foo, key_function)\nprint sorted_list\n</code>\n</pre>\n", "senID": 1}, {"text": ["As you can see, sorted takes an optional second parameter.", "The purpose of that parameter is to provide a function that tells sorted how to sort something.", "All you're doing is breaking down the information in each tuple in the list to provide a value that can be ordered, since you can't really order a list of tuples in any meaningful way."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "how", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Make sense? "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It can also be written like: print sorted(foo, key=lambda (x,y): y)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "print sorted(foo, key=lambda (x,y): y)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["lambda just means an inline function with no name, and it allows you to break down the tuple in a different way."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["You can see how this works by doing print [y for (x,y) in sorted_list]"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "print [y for (x,y) in sorted_list]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You can even redefine the key function from before like this:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def key_function(x):\n    x,y = x\n    return y\n</code>\n</pre>\n", "senID": 8}, {"text": ["BTW, I only put in the parentheses before for clarity.", "If you're not defining a function then the comma is the tuple constructor."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]