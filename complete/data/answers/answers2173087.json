[[{"text": ["In case a matrix is actually what you are looking for, consider the numpy package."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html#numpy.zeros"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html#numpy.zeros", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html#numpy.zeros"}]}, {"text": ["This will give you a 3x3x3 array of zeros:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n numpy.zeros((3,3,3))\n</code>\n</pre>\n", "senID": 3}, {"text": ["You also benefit from the convenience features of a module built for scientific computing."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["NumPy addresses this problem"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.scipy.org/Tentative_NumPy_Tutorial#head-d3f8e5fe9b903f3c3b2a5c0dfceb60d71602cf93"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.scipy.org/Tentative_NumPy_Tutorial#head-d3f8e5fe9b903f3c3b2a5c0dfceb60d71602cf93", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scipy.org/Tentative_NumPy_Tutorial#head-d3f8e5fe9b903f3c3b2a5c0dfceb60d71602cf93"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = array( [2,3,4] )\n&gt;&gt;&gt; a\narray([2, 3, 4])\n&gt;&gt;&gt; type(a)\n&lt;type 'numpy.ndarray'&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["But if you want to use the Python native lists as a matrix the following helper methods can become handy:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import copy\n\ndef Create(dimensions, item):\n    for dimension in dimensions:\n        item = map(copy.copy, [item] * dimension)\n    return item\ndef Get(matrix, position):\n    for index in position:\n        matrix = matrix[index]\n    return matrix\ndef Set(matrix, position, value):\n    for index in position[:-1]:\n        matrix = matrix[index]\n    matrix[position[-1]] = value\n</code>\n</pre>\n", "senID": 4}], [{"text": ["List comprehensions are just syntactic sugar for adding expressiveness to list initialization; in your case, I would not use them at all, and go for a simple nested loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On a completely different level: do you think then-dimensional arrayof NumPy could be a better approach?", "Although you can use lists to implement multi-dimensional matrices, I think they are not the best tool for that goal."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "do you think then-dimensional arrayof NumPy could be a better approach?", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "n-dimensional array", "tag": "a"}]}, {"text": "n-dimensional array", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#arrays-ndarray"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["Or use the nest function defined here, combined with repeat(0) from the itertools module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/577061-nest-a-flat-list/"}]}, {"code": "<pre>\n<code>\n nest(itertools.repeat(0),[3,3,3])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just nest the multiplication syntax:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [[[0] * 3] * 3] * 3\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's therefore simple to express this operation using folds"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "folds", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29"}]}, {"code": "<pre>\n<code>\n def zeros(dimensions):\n    return reduce(lambda x, d: [x] * d, [0] + dimensions)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or if you want to avoid reference replication, so altering one item won't affect any other you should instead use copies:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import copy\ndef zeros(dimensions):\n    item = 0\n    for dimension in dimensions:\n        item = map(copy.copy, [item] * dimension)\n   return item\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Do you mean like this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [[[0]*3]*3]*3\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This seems to be what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def three_dimension_list(x,y,z):\nreturn [[[0]*x]*y]*z\n</code>\n</pre>\n", "senID": 1}]]