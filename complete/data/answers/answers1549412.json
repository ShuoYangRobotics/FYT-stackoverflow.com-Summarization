[[{"text": ["One way to do it (no promises on speed):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Break your list of tuples into two lists:\n[1,2,2,3,4] and ['a','b','a','d','c']"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "[1,2,2,3,4]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "['a','b','a','d','c']", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Since the first list is sorted, you can just keep iterating over it until you get to an element out of the range.", "Then, you know the indexes of the start and end elements so you can just slice the strings out of second array.", "Continue until you've got all the intervals."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I'm not sure how efficient that'll be with tradition Python lists, but if your dataset is large enough, you could try using a NumPy array, which will slice really quickly."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Your code is O(n2).", "Here's an O(n) solution:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def split_series(points, interval):\n    series = []\n    current_group = []\n    marker = points[0][0]\n    for value, data in points:\n        if value &gt;= marker + interval:\n            series.append(current_group)\n            current_group = []\n            marker += interval\n        current_group.append(data)\n\n    if current_group:\n        series.append(current_group)\n\n    return series\n\npoints = [(1, 'a'), (2, 'b'), (2, 'a'), (3, 'd'), (4, 'c')]\nprint split_series(points, 3)  # Prints [['a', 'b', 'a', 'd'], ['c']]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For completeness, here's a solution with itertools.groupby, but the dictionary solution will probably be faster (not to mention a lot easier to read)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.groupby", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\nimport operator\n\ndef split_series(points, interval):\n    start = points[0][0]\n\n    return [[v for k, v in grouper] for group, grouper in\n            itertools.groupby((((n - start) // interval, val)\n                               for n, val in points), operator.itemgetter(0))]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that the above assumes you've got at least one item in each group, otherwise it'll give different results from your script, i.e."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; split_series([(1, 'a'), (2, 'b'), (6, 'a'), (6, 'd'), (11, 'c')], 3)\n[['a', 'b'], ['a', 'd'], ['c']]\n</code>\n</pre>\n", "senID": 3}, {"text": ["instead of"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n [['a', 'b'], ['a', 'd'], [], ['c']]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Here's a fixed-up dictionary solution.", "At some point the dictionary lookup time will begin to dominate, but maybe it's fast enough for you like this."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\ndef split_series(points, interval):\n    offset = points[0][0]\n    maxval = (points[-1][0] - offset) // interval\n    vals = defaultdict(list)\n    for key, value in points:\n        vals[(key - offset) // interval].append(value)\n    return [vals[i] for i in xrange(maxval + 1)]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["From your code, I'm assuming my prior comment is correct.", "The problem here appears to be that the performance is O(n^2) - you repeat the list comprehension (which iterates all items) multiple times."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I say, use a simple for loop.", "If the current item belongs in the same group as the previous one, add it to the existing inner list [[\"a\"], [\"b\"]] -> [[\"a\"], [\"b\", \"c\"]].", "If it doesn't, add it to a new inner list, perhaps adding empty padding lists first."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Expanding on Am's answer, use a defaultdict, and floor-divide the key by the interval to break them up correctly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\ndef split_series(points, interval):\n    vals = defaultdict(list)\n    for key, value in points:\n        vals[(key-1)//interval].append(value)\n    return vals.values()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a lazy approach that uses the step behavior of xrange:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def split_series(points, interval):\n    end_of_chunk = interval\n    chunk = []\n    for marker, item in points:\n        if marker &gt; end_of_chunk:\n            for end_of_chunk in xrange(end_of_chunk, marker, interval):\n                yield chunk\n                chunk = []\n            end_of_chunk += interval\n        chunk.append(item)\n    yield chunk\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about using iterators for lazy evaluation?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This should be the equivalent of your initial solution:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from itertools import groupby\n\ndef split_series(points, interval):\n    \"\"\"\n    &gt;&gt;&gt; points = [(1, 'a'), (2, 'b'), (2, 'a'), (3, 'd'), (4, 'c')]\n    &gt;&gt;&gt; print list(split_series(points, 3))\n    [['a', 'b', 'a', 'd'], ['c']]\n    \"\"\"\n\n    def interval_key(t):\n        return (t[0] - points[0][0]) // interval\n\n    groups = groupby(points, interval_key)\n\n    for group in groups:\n        yield [v for _, v in group[1]]\n</code>\n</pre>\n", "senID": 2}]]