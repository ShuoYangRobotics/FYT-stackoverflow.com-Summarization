[[{"text": ["The existing solutions all offer either one or the other of:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Faster than O(n*m) performance.", "tag": "none", "senID": 1}, {"text": "Preserve order of input list.", "tag": "none", "senID": 2}]}, {"text": ["But so far no solution has both.", "If you want both, try this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n s = set(temp2)\ntemp3 = [x for x in temp1 if x not in s]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Performance test"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Performance test", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import timeit\ninit = 'temp1 = list(range(100)); temp2 = [i * 2 for i in range(50)]'\nprint timeit.timeit('list(set(temp1) - set(temp2))', init, number = 100000)\nprint timeit.timeit('s = set(temp2);[x for x in temp1 if x not in s]', init, number = 100000)\nprint timeit.timeit('[item for item in temp1 if item not in temp2]', init, number = 100000)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n 4.34620224079 # ars' answer\n4.2770634955  # This answer\n30.7715615392 # matt b's answer\n</code>\n</pre>\n", "senID": 8}, {"text": ["The method I presented as well as preserving order is also (slightly) faster than the set subtraction because it doesn't require construction of an unnecessary set.", "The performance difference would be more noticable if the first list is considerably longer than the second and if hashing is expensive.", "Here's a second test demonstrating this:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n init = '''\ntemp1 = [str(i) for i in range(100000)]\ntemp2 = [str(i * 2) for i in range(50)]\n'''\n</code>\n</pre>\n", "senID": 10}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n 11.3836875916 # ars' answer\n3.63890368748 # this answer (3 times faster!)\n37.7445402279 # matt b's answer\n</code>\n</pre>\n", "senID": 12}], [{"code": "<pre>\n<code>\n In [5]: list(set(temp1) - set(temp2))\nOut[5]: ['Four', 'Three']\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n temp3 = [item for item in temp1 if item not in temp2]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["i'll toss in since none of the present solutions yield a tuple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n temp3 = tuple(set(temp1) - set(temp2))\n</code>\n</pre>\n", "senID": 1}, {"text": ["alternatively:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #edited using @Mark Byers idea. If you accept this one as answer, just accept his instead.\ntemp3 = tuple(x for x in temp1 if x not in set(temp2))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Like the other non-tuple yielding answers in this direction, it preserves order"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n temp3 = set(temp1) - set(temp2)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["this could be even faster than Mark's list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n filterfalse(set(temp2).__contains__, temp1)\n</code>\n</pre>\n", "senID": 1}]]