[[{"code": "<pre>\n<code>\n def pairs(lst):\n    i = iter(lst)\n    first = prev = i.next()\n    for item in i:\n        yield prev, item\n        prev = item\n    yield item, first\n</code>\n</pre>\n", "senID": 0}, {"text": ["Work on any non-empty sequence, no indexing required."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This might be satisfactory:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def pairs(lst):\n    for i in range(1, len(lst)):\n        yield lst[i-1], lst[i]\n    yield lst[-1], lst[0]\n\n&gt;&gt;&gt; a = list(range(5))\n&gt;&gt;&gt; for a1, a2 in pairs(a):\n...     print a1, a2\n...\n0 1\n1 2\n2 3\n3 4\n4 0\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you like this kind of stuff, look at python articles on wordaligned.org.", "The author has a special love of generators in python."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "wordaligned.org", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wordaligned.org/"}]}], [{"text": ["I've coded myself the tuple general versions, I like the first one for it's ellegant simplicity, the more I look at it, the more Pythonic it feels to me... after all, what is more Pythonic than a one liner with zip, asterisk argument expansion, list comprehensions, list slicing, list concatenation and \"range\"?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def ntuples(lst, n):\n    return zip(*[lst[i:]+lst[:i] for i in range(n)])\n</code>\n</pre>\n", "senID": 1}, {"text": ["The itertools version should be efficient enough even for large lists..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import *\ndef ntuples(lst, n):\n    return izip(*[chain(islice(lst,i,None), islice(lst,None,i)) for i in range(n)])\n</code>\n</pre>\n", "senID": 3}, {"text": ["And a version for non-indexable sequences:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from itertools import *\ndef ntuples(seq, n):\n    iseq = iter(seq)\n    curr = head = tuple(islice(iseq, n))\n    for x in chain(iseq, head):\n        yield curr\n        curr = curr[1:] + (x,)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Anyway, thanks everybody for your suggestions!", ":-)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I'd do it like this (mostly because I can read this):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Pairs(object):\n    def __init__(self, start):\n        self.i = start\n    def next(self):\n        p, p1 = self.i, self.i + 1\n        self.i = p1\n        return p, p1\n    def __iter__(self):\n        return self\n\nif __name__ == \"__main__\":\n    x = Pairs(0)\n    y = 1\n    while y &lt; 20:\n        print x.next()\n        y += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (0, 1)\n(1, 2)\n(2, 3)\n(3, 4)\n(4, 5)\n(5, 6)\n(6, 7)\n(7, 8)\n(8, 9)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["To answer your question about solving for the general case:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef pair(series, n):\n    s = list(itertools.tee(series, n))\n    try:\n        [ s[i].next() for i in range(1, n) for j in range(i)]\n    except StopIteration:\n        pass\n    while True:\n        result = []\n        try:\n            for j, ss in enumerate(s):\n                result.append(ss.next())\n        except StopIteration:\n            if j == 0:\n                break\n            else:\n                s[j] = iter(series)\n                for ss in s[j:]:\n                    result.append(ss.next())\n        yield result\n</code>\n</pre>\n", "senID": 1}, {"text": ["The output is like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for a in pair(range(10), 2):\n...     print a\n...\n[0, 1]\n[1, 2]\n[2, 3]\n[3, 4]\n[4, 5]\n[5, 6]\n[6, 7]\n[7, 8]\n[8, 9]\n[9, 0]\n&gt;&gt;&gt; for a in pair(range(10), 3):\n...     print a\n...\n[0, 1, 2]\n[1, 2, 3]\n[2, 3, 4]\n[3, 4, 5]\n[4, 5, 6]\n[5, 6, 7]\n[6, 7, 8]\n[7, 8, 9]\n[8, 9, 0]\n[9, 0, 1]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This infinitely cycles, for good or ill, but is algorithmically very clear.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import tee, cycle\n\ndef nextn(iterable,n=2):\n    ''' generator that yields a tuple of the next n items in iterable.\n    This generator cycles infinitely '''\n    cycled = cycle(iterable)\n    gens = tee(cycled,n)\n\n    # advance the iterators, this is O(n^2)\n    for (ii,g) in zip(xrange(n),gens):\n        for jj in xrange(ii):\n            gens[ii].next()\n\n    while True:\n        yield tuple([x.next() for x in gens])\n\n\ndef test():\n    data = ((range(10),2),\n        (range(5),3),\n        (list(\"abcdef\"),4),)\n    for (iterable, n) in data:\n        gen = nextn(iterable,n)\n        for j in range(len(iterable)+n):\n            print gen.next()            \n\n\ntest()\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (0, 1)\n(1, 2)\n(2, 3)\n(3, 4)\n(4, 5)\n(5, 6)\n(6, 7)\n(7, 8)\n(8, 9)\n(9, 0)\n(0, 1)\n(1, 2)\n(0, 1, 2)\n(1, 2, 3)\n(2, 3, 4)\n(3, 4, 0)\n(4, 0, 1)\n(0, 1, 2)\n(1, 2, 3)\n(2, 3, 4)\n('a', 'b', 'c', 'd')\n('b', 'c', 'd', 'e')\n('c', 'd', 'e', 'f')\n('d', 'e', 'f', 'a')\n('e', 'f', 'a', 'b')\n('f', 'a', 'b', 'c')\n('a', 'b', 'c', 'd')\n('b', 'c', 'd', 'e')\n('c', 'd', 'e', 'f')\n('d', 'e', 'f', 'a')\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Even shorter version of Fortran's zip * range solution (with lambda this time;):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n group = lambda t, n: zip(*[t[i::n] for i in range(n)])\n\ngroup([1, 2, 3, 3], 2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [(1, 2), (3, 4)]\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n i=(range(10))\n\nfor x in len(i):\n    print i[:2]\n    i=i[1:]+[i[1]]\n</code>\n</pre>\n", "senID": 0}, {"text": ["more pythonic than this is impossible"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here's a version that supports an optional start index (for example to return (4, 0) as the first pair, use start = -1:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef iterrot(lst, start = 0):\n\n    if start == 0:\n        i = iter(lst)\n    elif start &gt; 0:\n        i1 = itertools.islice(lst, start, None)\n        i2 = itertools.islice(lst, None, start)\n        i = itertools.chain(i1, i2)\n    else:\n        # islice doesn't support negative slice indices so...\n        lenl = len(lst)\n        i1 = itertools.islice(lst, lenl + start, None)\n        i2 = itertools.islice(lst, None, lenl + start)\n        i = itertools.chain(i1, i2)\n    return i\n\n\ndef iterpairs(lst, start = 0):\n\n    i = iterrot(lst, start)     \n\n    first = prev = i.next()\n    for item in i:\n        yield prev, item\n        prev = item\n    yield prev, first\n\n\ndef itertrios(lst, start = 0):\n\n    i = iterrot(lst, start)     \n\n    first = prevprev = i.next()\n    second = prev = i.next()\n    for item in i:\n        yield prevprev, prev, item\n        prevprev, prev = prev, item\n\n    yield prevprev, prev, first\n    yield prev, first, second\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n [(i,(i+1)%len(range(10))) for i in range(10)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["replace range(10) with the list you want."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In general \"circular indexing\" is quite easy in python; just use:  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a[i%len(a)]\n</code>\n</pre>\n", "senID": 3}]]