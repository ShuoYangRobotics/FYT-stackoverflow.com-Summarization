[[{"text": ["Assuming all your values are ints, you could use a defaultdict to make this easier:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "defaultdict", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\nmyDict = defaultdict(int)\n\nfor item in myTupleList:\n    myDict[item[1]] += item[2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["defaultdict is like a dictionary, except if you try to get a key that isn't there it fills in the value returned by the callable - in this case, int, which returns 0 when called with no arguments."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["UPDATE: Thanks to @gnibbler for reminding me, but tuples can be unpacked in a for loop:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "@gnibbler", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2210581/map-list-of-tuples-into-a-dictionary-python/2210697#2210697"}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\nmyDict = defaultdict(int)\n\nfor _, key, val in myTupleList:\n    myDict[key] += val\n</code>\n</pre>\n", "senID": 4}, {"text": ["Here, the 3-item tuple gets unpacked into the variables _, key, and val.", "_ is a common placeholder name in Python, used to indicate that the value isn't really important.", "Using this, we can avoid the hairy item[1] and item[2] indexing.", "We can't rely on this if the tuples in myTupleList aren't all the same size, but I bet they are."], "childNum": 7, "tag": "p", "senID": 5, "childList": [{"text": "_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "key", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "val", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "_", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "item[1]", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "item[2]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "myTupleList", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["(We also avoid the situation of someone looking at the code and thinking it's broken because the writer thought arrays were 1-indexed, which is what I thought when I first read the code.", "I wasn't alleviated of this until I read the question.", "In the above loop, however, it's obvious that myTupleList is a tuple of three elements, and we just don't need the first one."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "myTupleList", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"code": "<pre>\n<code>\n from collections import defaultdict\n\nmyDict = defaultdict(int)\n\nfor _, key, value in myTupleList:\n    myDict[key] += value\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here's my (tongue in cheek) answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n myDict = reduce(lambda d, t: (d.__setitem__(t[1], d.get(t[1], 0) + t[2]), d)[1], myTupleList, {})\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is ugly and bad, but here is how it works."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The first argument to reduce (because it isn't clear there) is lambda d, t: (d.__setitem__(t[1], d.get(t[1], 0) + t[2]), d)[1].", "I will talk about this later, but for now, I'll just call it joe (no offense to any people named Joe intended).", "The reduce function basically works like this:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "lambda d, t: (d.__setitem__(t[1], d.get(t[1], 0) + t[2]), d)[1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "joe", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n joe(joe(joe({}, myTupleList[0]), myTupleList[1]), myTupleList[2])\n</code>\n</pre>\n", "senID": 4}, {"text": ["And that's for a three element list.", "As you can see, it basically uses its first argument to sort of accumulate each result into the final answer.", "In this case, the final answer is the dictionary you wanted."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Now for joe itself.", "Here is joe as a def:"], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "joe", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "joe", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def joe(myDict, tupleItem):\n   myDict[tupleItem[1]] = myDict.get(tupleItem[1], 0) + tupleItem[2]\n   return myDict\n</code>\n</pre>\n", "senID": 7}, {"text": ["Unfortunately, no form of = or return is allowed in a Python lambda so that has to be gotten around.", "I get around the lack of = by calling the dicts __setitem__ function directly.", "I get around the lack of return in by creating a tuple with the return value of __setitem__ and the dictionary and then return the tuple element containing the dictionary.", "I will slowly alter joe so you can see how I accomplished this."], "childNum": 8, "tag": "p", "senID": 8, "childList": [{"text": "=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "=", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__setitem__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__setitem__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "joe", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["First, remove the =:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def joe(myDict, tupleItem):\n   # Using __setitem__ to avoid using '='\n   myDict.__setitem__(tupleItem[1], myDict.get(tupleItem[1], 0) + tupleItem[2])\n   return myDict\n</code>\n</pre>\n", "senID": 10}, {"text": ["Next, make the entire expression evaluate to the value we want to return:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def joe(myDict, tupleItem):\n   return (myDict.__setitem__(tupleItem[1], myDict.get(tupleItem[1], 0) + tupleItem[2]),\n           myDict)[1]\n</code>\n</pre>\n", "senID": 12}, {"text": ["I have run across this use-case for reduce and dict many times in my Python programming.", "In my opinion, dict could use a member function reduceto(keyfunc, reduce_func, iterable, default_val=None).", "keyfunc would take the current value from the iterable and return the key.", "reduce_func would take the existing value in the dictionary and the value from the iterable and return the new value for the dictionary.", "default_val would be what was passed into reduce_func if the dictionary was missing a key.", "The return value should be the dictionary itself so you could do things like:"], "childNum": 8, "tag": "p", "senID": 13, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "reduceto(keyfunc, reduce_func, iterable, default_val=None)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "keyfunc", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "reduce_func", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "default_val", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "reduce_func", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n myDict = dict().reduceto(lambda t: t[1], lambda o, t: o + t, myTupleList, 0)\n</code>\n</pre>\n", "senID": 14}], [{"text": ["Maybe not exactly readable but it should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fks = dict([ (v[1], True) for v in myTupleList ]).keys()\nmyDict = dict([ (fk, sum([ v[2] for v in myTupleList if v[1] == fk ])) for fk in fks ])\n</code>\n</pre>\n", "senID": 1}, {"text": ["The first line finds all unique foreign keys.", "The second line builds your dictionary by first constructing a list of (fk, sum(all values for this fk))-pairs and turning that into a dictionary."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Look at SQLAlchemy and see if that does all the mapping you need and perhaps more"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "SQLAlchemy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sqlalchemy.org/"}]}], [{"text": ["If at all possible, it's usually more efficient to move this into the database, and run an SQL query such as:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n SELECT SUM(value) FROM table GROUP BY foreignkey\n</code>\n</pre>\n", "senID": 1}]]