[[{"text": ["(This answer deals with simple optimisations and Python style; it works with the existing algorithm, teaching some points of optimisation, rather than replacing it with a more efficient one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here are some points to start with to make the code easier to read and understand:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["Iterate over sList, not over range(len(sList)).", "for i in range(len(sList)) becomes for i in sList and sList[i] becomes i."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "for i in range(len(sList))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "for i in sList", "childNum": 0, "tag": "code", "childList": []}, {"text": "sList[i]", "childNum": 0, "tag": "code", "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["No need for that tmpRad; put it inline."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Instead of if a: if b: if c: use if a and b and c."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "if a: if b: if c:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "if a and b and c", "childNum": 0, "tag": "code", "childList": []}]}]}, {"text": ["Now we're at this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n filteredList = []\nfor i in sList:\n    minx = i['x'] - i['radius']\n    maxx = i['x'] + i['radius']\n    miny = i['y'] - i['radius']\n    maxy = i['y'] + i['radius']\n    minz = i['z'] - i['radius']\n    maxz = i['z'] + i['radius']\n\n    for j in nList:\n        if minx &lt;= j['x'] &lt;= maxx and miny &lt;= j['y'] &lt;= maxy and minz &lt;= j['z'] &lt;= maxz and findRadius(i,j) &lt;= i['radius']:\n            filteredList.append(int(j['num']))\n</code>\n</pre>\n", "senID": 6}, {"text": ["(PEP 8 would recommend splitting that long line to lines of no more than 80 characters; PEP 8 would also recommend filtered_list and s_list and n_list rather than filteredList, sList and nList."], "childNum": 6, "tag": "p", "senID": 7, "childList": [{"text": "filtered_list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "s_list", "childNum": 0, "tag": "code", "childList": []}, {"text": "n_list", "childNum": 0, "tag": "code", "childList": []}, {"text": "filteredList", "childNum": 0, "tag": "code", "childList": []}, {"text": "sList", "childNum": 0, "tag": "code", "childList": []}, {"text": "nList", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I've put the findRadius(i, j) &lt;= i['radius'] first for style and because it looks like it might be more likely to evaluate to false, speeding up calculations.", "Then I've also inlined the minx etc.", "variables:"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "findRadius(i, j) &lt;= i['radius']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "minx", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n filteredList = []\nfor i in sList:\n    for j in nList:\n        if findRadius(i, j) &lt;= i['radius'] \\\n        and i['x'] - i['radius'] &lt;= j['x'] &lt;= i['x'] + i['radius'] \\\n        and i['y'] - i['radius'] &lt;= j['y'] &lt;= i['y'] + i['radius'] \\\n        and i['z'] - i['radius'] &lt;= j['z'] &lt;= i['z'] + i['radius']:\n            filteredList.append(int(j['num']))\n</code>\n</pre>\n", "senID": 9}, {"text": ["One thing to think about is that i['x'] - i['radius'] &lt;= j['x'] &lt;= i['x'] + i['radius'] could be simplified; try things like subtracting i['x'] from all three parts."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "i['x'] - i['radius'] &lt;= j['x'] &lt;= i['x'] + i['radius']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i['x']", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can shorten this even more with a list comprehension."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n filteredList = [int(j['num']) for j in nList for i in sList\n        if findRadius(i, j) &lt;= i['radius']\n        and i['x'] - i['radius'] &lt;= j['x'] &lt;= i['x'] + i['radius']\n        and i['y'] - i['radius'] &lt;= j['y'] &lt;= i['y'] + i['radius']\n        and i['z'] - i['radius'] &lt;= j['z'] &lt;= i['z'] + i['radius']]\n</code>\n</pre>\n", "senID": 12}, {"text": ["And finally, named tuples (this has the side-effect of making them immutable, too, which is probably desired?", "Also note it's Python 2.6 only, read the page for how you could do it with older versions of Python):"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "named tuples", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#collections.namedtuple"}]}, {"code": "<pre>\n<code>\n from collections import namedtuple\n\nnode = namedtuple('node', 'x y z num')\nsphere = namedtuple('sphere', 'x y z radius')\n\nnList = [\n        node(x=0.0, y=0.0, z=0.0, num=1.0),\n        node(x=1.0, y=0.0, z=0.0, num=2.0),\n        node(x=2.0, y=0.0, z=0.0, num=3.0),\n        node(x=3.0, y=0.0, z=0.0, num=4.0),\n        node(x=4.0, y=0.0, z=0.0, num=5.0),\n        node(x=5.0, y=0.0, z=0.0, num=6.0),\n        node(x=6.0, y=0.0, z=0.0, num=7.0),\n        node(x=7.0, y=0.0, z=0.0, num=8.0),\n        node(x=8.0, y=0.0, z=0.0, num=9.0),\n        node(x=9.0, y=0.0, z=0.0, num=10.0)]\n\nsList = [\n        sphere(x=25.0, y=18.0, z=26.0, radius=0.0056470000000000001),\n        sphere(x=23.0, y=29.0, z=45.0, radius=0.0066280000000000002),\n        sphere(x=29.0, y=46.0, z=13.0, radius=0.014350999999999999),\n        sphere(x=20.0, y=0.0, z=25.0, radius=0.014866000000000001),\n        sphere(x=31.0, y=27.0, z=18.0, radius=0.018311999999999998),\n        sphere(x=36.0, y=10.0, z=46.0, radius=0.024702000000000002),\n        sphere(x=13.0, y=27.0, z=48.0, radius=0.027300999999999999),\n        sphere(x=1.0, y=14.0, z=13.0, radius=0.033889000000000002),\n        sphere(x=20.0, y=31.0, z=11.0, radius=0.034118999999999997),\n        sphere(x=28.0, y=23.0, z=8.0, radius=0.036683)]\n</code>\n</pre>\n", "senID": 14}, {"text": ["Then, instead of sphere['radius'] you can do sphere.radius.", "This makes the code neater:"], "childNum": 2, "tag": "p", "senID": 15, "childList": [{"text": "sphere['radius']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sphere.radius", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n filteredList = [int(j.num) for j in nList for i in sList\n        if findRadius(i, j) &lt;= i.radius\n        and i.x - i.radius &lt;= j.x &lt;= i.x + i.radius\n        and i.y - i.radius &lt;= j.y &lt;= i.y + i.radius\n        and i.z - i.radius &lt;= j.z &lt;= i.z + i.radius]\n</code>\n</pre>\n", "senID": 16}, {"text": ["Or, without the list comprehension,"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n filteredList = []\nfor i in sList:\n    for j in nList:\n        if findRadius(i, j) &lt;= i.radius \\\n        and i.x - i.radius &lt;= j.x &lt;= i.x + i.radius \\\n        and i.y - i.radius &lt;= j.y &lt;= i.y + i.radius \\\n        and i.z - i.radius &lt;= j.z &lt;= i.z + i.radius:\n            filteredList.append(int(j.num))\n</code>\n</pre>\n", "senID": 18}, {"text": ["Finally, choose nicer names; [style changed slightly as per comments, putting findRadius at the end as it's more likely to be computationally expensive - you're the best judge of that, though]"], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "findRadius", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n filteredList = [int(n.num) for n in nodes for s in spheres\n        if s.x - s.radius &lt;= n.x &lt;= s.x + s.radius and\n            s.y - s.radius &lt;= n.y &lt;= s.y + s.radius and\n            s.z - s.radius &lt;= n.z &lt;= s.z + s.radius and\n            findRadius(s, n) &lt;= s.radius]\n</code>\n</pre>\n", "senID": 20}, {"text": ["Or,"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"code": "<pre>\n<code>\n filteredList = []\nfor s in spheres:\n    for n in nodes:\n        if (s.x - s.radius &lt;= n.x &lt;= s.x + s.radius and\n            s.y - s.radius &lt;= n.y &lt;= s.y + s.radius and\n            s.z - s.radius &lt;= n.z &lt;= s.z + s.radius and\n            findRadius(s, n) &lt;= s.radius):\n            filteredList.append(int(n.num))\n</code>\n</pre>\n", "senID": 22}, {"text": ["(You could put srad = s.radius in the outer loop for a probable slight performance gain if desired."], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "srad = s.radius", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["one we can remove from the sample"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["unless you need to iterate over a list by index, one shouldn't, also avoid using range, and merge ifs together"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n filteredList = []\nfor a in sList:\n\n        minx = (a['x']) - (a['radius'])\n        maxx = (a['x']) + (a['radius'])\n        miny = (a['y']) - (a['radius'])\n        maxy = (a['y']) + (a['radius'])\n        minz = (a['z']) - (a['radius'])\n        maxz = (a['z']) + (a['radius'])\n\n        for b in nList:\n                if minx &lt;= b['x'] &lt;= maxx and miny &lt;= b['y'] &lt;= maxy and minz &lt;= b['z'] &lt;= maxz:\n                    tmpRad = findRadius(a,b)\n                    if tmpRad &lt;= a['radius']:\n                        filteredList.append(int(b['num']))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["First off, Python isn't built for that kind of iteration.", "Using indices to get at each element of a list is backwards, a kind of brain-damage that's taught by low-level languages where it's faster.", "In Python it's actually slower.", "range(len(whatever)) actually creates a new list of numbers, and then you work with the numbers that are handed to you from that list.", "What you really want to do is just work with objects that are handed to you fromwhatever."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "range(len(whatever))", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "just work with objects that are handed to you fromwhatever", "childNum": 1, "tag": "em", "pos": 4, "childList": [{"text": "whatever", "tag": "code"}]}, {"text": "whatever", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["While we're at it, we can pull out the common s['radius'] bit that is checked several times, and put all the if-checks for the bounding box on one line.", "Oh, and we don't need a separate 'tmpRad', and I assume the 'num's are already ints and don't need to be converted (if they do, why?", "Why not just have them converted ahead of time?"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "s['radius']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["None of this will make a huge difference, but it at least makes it easier to read, and definitely doesn't hurt."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "huge", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n filteredList = []\nfor s in sList:\n  radius = s['radius']\n  minx = s['x'] - radius\n  maxx = s['x'] + radius\n  miny = s['y'] - radius\n  maxy = s['y'] + radius\n  minz = s['z'] - radius\n  maxz = s['z'] + radius\n\n  for n in nList:\n    if (minx &lt;= n['x'] &lt;= maxx) and (miny &lt;= n['y'] &lt;= maxy) and \\\n       (minz &lt;= n['z'] &lt;= maxz) and (findRadius(s, n) &lt;= radius): \n      filteredList.append(n['num'])\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now it's at least clear what's going on."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["However, for the scale of the problem we're working with, it sounds like we're going to need algorithmic improvements.", "What you probably want to do here is use some kind of BSP (binary space partitioning) technique.", "The way this works is:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["First, we rearrange the nList into a tree.", "We cut it up into 8 smaller lists, based on whether x > 0, whether y > 0 and whether z > 0 for each point (8 combinations of the 3 boolean results).", "Then each of those gets cut into 8 again, using the same sort of criteria - e.g.", "if the possible range for x/y/z is -10..10, then we cut the \"x > 0, y > 0, z > 0\" list up according to whether x > 5, y > 5, z > 5, etc.", "You get the idea."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["For each point in the sList, we check whether minx > 0, etc.", "The beautiful part: if minx > 0, we don't have to check any of the 'x &lt; 0' lists, and if maxx &lt; 0, we don't have to check any of the 'x > 0' lists.", "And so forth.", "We figure out which of the 8 \"octants\" of the space the bounding box intersects with; and for each of those, we recursively check the appropriate octants of those octants, etc.", "until we get to the leaves of the tree, and then we do the normal point-in-bounding-box, then point-in-sphere tests."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]}], [{"text": ["Actually, you could save all that by:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n filteredList = [int(node['num']) for sphere in sList \\\n    for node in nList if findRadius(sphere,node)&lt;=sphere['radius']]\n</code>\n</pre>\n", "senID": 1}, {"text": ["If the distance from a point to a sphere's globe is less than the sphere's radius, then I guess we can say it is in the sphere, right?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I assume findRadius is defined like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def findRadius(sphere,node):\n    return ((node['x']-sphere['x'])**2 + \\\n            (node['y']-sphere['y'])**2 + \\\n            (node['z']-sphere['z'])**2)**.5\n</code>\n</pre>\n", "senID": 4}], [{"text": ["(AFAICT, the following solution is algorithmically faster than any other answer posted so far: approximately O(N log N) vs O(N&sup2;).", "Caveat: this assumes that you don't have massive amounts of overlap between bounding boxes."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "N", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "N", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["If you are allowed to pre-compute an index structure:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Taking in all this advice, I managed to come up with a solution that was about 50x faster than the original."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I realized that the bottleneck was in the datatype (list of dicts) I was using.", "Looping over multiple lists was incredibly slow in my cast and using sets was much more efficient."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["First thing I did was to implement named tuples.", "I knew how my list of nodes was numbered which provided the hash I needed for efficiency."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def findNodesInSpheres(sList,nList,nx,ny,nz):\n    print \"Running findNodesInSpheres\"\n    filteredList = []\n    for a in sList:\n            rad = a.radius\n            minx = (a.x) - (rad) if (a.x - rad &gt; 0) else 0\n            maxx = (a.x) + (rad) if (a.x + rad &lt; nx ) else nx\n            miny = (a.y) - (rad) if (a.y - rad &gt; 0) else 0\n            maxy = (a.y) + (rad) if (a.y + rad &lt; ny ) else ny\n            minz = (a.z) - (rad) if (a.z - rad &gt; 0) else 0\n            maxz = (a.z) + (rad) if (a.z + rad &lt; nz ) else nz\n            boundingBox = set([ (i + j * (nx + 1) + k * (nx + 1) * (ny + 1)) for i in range (int(minx),int(maxx)+1)\n                            for j in range (int(miny),int(maxy)+1) for k in range(int(minz),int(maxz)+1) ])\n\n            for b in sorted(boundingBox):\n                    if findRadius(a,nList[b]) &lt;= rad:\n                            filteredList.append(nList[b].num)\n    return filteredList\n</code>\n</pre>\n", "senID": 3}, {"text": ["Using set() instead of list provided massive speedups.", "The larger the data set (nx, ny, nz), the more the speedup. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["It could still be improved using tree implementation and domain decomposition as has been suggested, but for the moment it works."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Thanks to everyone for the advice!"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]