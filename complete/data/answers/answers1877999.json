[[{"text": ["This doesn't use python, but python's the wrong tool for the job if this is the only task you want.", "You can use the standard *nix utility head, and run"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "head", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n head -n-1 filename &gt; newfile\n</code>\n</pre>\n", "senID": 1}, {"text": ["which will copy all but the last line of filename to newfile."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could use the above code and then:-"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lines = file.readlines()\nlines = lines[:-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This would give you an array of lines containing all lines but the last one."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Assuming you have to do this in Python and that you have a large enough file that list slicing isn't sufficient, you can do it in a single pass over the file:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n last_line = None\nfor line in file:\n    if last_line:\n        print last_line # or write to a file, call a function, etc.\n    last_line = line\n</code>\n</pre>\n", "senID": 1}, {"text": ["Not the most elegant code in the world but it gets the job done."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Basically it buffers each line in a file through the last_line variable, each iteration outputs the previous iterations line."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["On systems where file.truncate() works, you could do something like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "file.truncate()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#file.truncate"}]}, {"code": "<pre>\n<code>\n file = open('file.txt', 'rb')\npos = next = 0\nfor line in file:\n  pos = next # position of beginning of this line\n  next += len(line) # compute position of beginning of next line\nfile = open('file.txt', 'ab')\nfile.truncate(pos)\n</code>\n</pre>\n", "senID": 1}, {"text": ["According to my tests, file.tell() doesn't work when reading by line, presumably due to buffering confusing it.", "That's why this adds up the lengths of the lines to figure out positions.", "Note that this only works on systems where the line delimiter ends with '\\n'."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Though I have not tested it (please, no hate for that) I believe that there's a faster way of going it.", "It's more of a C solution, but quite possible in Python.", "It's not Pythonic, either.", "It's a theory, I'd say."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, you need to know the encoding of the file.", "Set a variable to the number of  bytes a character in that encoding uses (1 byte in ASCII).", "CHARsize (why not).", "Probably going to be 1 byte with an ASCII file. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "CHARsize", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["Then grab the size of the file, set FILEsize to it. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "FILEsize", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Assume you have the address of the file (in memory) in FILEadd. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "FILEadd", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Add FILEsize to FILEadd. "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "FILEsize", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "FILEadd", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Move backwords (increment by -1*CHARsize), testing each CHARsize bytes for a \\n (or whatever newline your system uses).", "When you reach the first \\n, you now have the position of the beginning of the first line of the file.", "Replace \\n with \\x1a (26, the ASCII for EOF, or whatever that is one your system/with the encoding). "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "CHARsize", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Clean up however you need to (change the filesize, touch the file). "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["If this works as I suspect it would, you're going to save a lot of time, as you don't need to read through the whole file from the beginning, you read from the end. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["here's another way, without slurping the whole file into memory"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n p=\"\"\nf=open(\"file\")\nfor line in f:\n    line=line.strip()\n    print p\n    p=line\nf.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a more general memory-efficient solution allowing the last 'n' lines to be skipped (like the head command):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "head", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import collections, fileinput\ndef head(filename, lines_to_delete=1):\n    queue = collections.deque()\n    lines_to_delete = max(0, lines_to_delete) \n    for line in fileinput.input(filename, inplace=True, backup='.bak'):\n        queue.append(line)\n        if lines_to_delete == 0:\n            print queue.popleft(),\n        else:\n            lines_to_delete -= 1\n    queue.clear()\n</code>\n</pre>\n", "senID": 1}]]