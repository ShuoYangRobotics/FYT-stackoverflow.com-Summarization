[[{"text": ["The best way would be to rework your logic to do the selection in the database instead of in your python program."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Instead of doing Item.select(), you should rework it to do Item.select(\"\"\"name LIKE ...."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you do this, and make sure you have the name and skim columns indexed, it will return very quickly.", "90000 entries is not a large database."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["30 seconds to fetch 90,000 rows might not be all that bad."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Have you benchmarked the time required to do the following?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for item in Item.select():\n        pass\n</code>\n</pre>\n", "senID": 2}, {"text": ["Just to see if the time is DB time, network time or application time?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If your SQLite DB is physically very large, you could be looking at -- simply -- a lot of physical I/O to read all that database stuff in. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you really need to use a regular expression, there's not really anything you can do to speed that up tremendously.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The best thing would be to write an sqlite function that performs the comparison for you in the db engine, instead of Python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You could also switch to a db server like postgresql that has support for SIMILAR.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://www.postgresql.org/docs/8.3/static/functions-matching.html"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://www.postgresql.org/docs/8.3/static/functions-matching.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.postgresql.org/docs/8.3/static/functions-matching.html"}]}], [{"text": ["Given your example and expanding on Reed's answer your code could look a bit like the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nimport sqlalchemy.sql.expression as expr\n\n...\n\ndef search1():\n    searchStr = ur'foo'\n    whereClause = expr.or_(itemsTable.c.nameColumn.contains(searchStr), itemsTable.c.skimColumn.contains(searchStr))\n    for item in Items.select().where(whereClause):\n        print item.name\n</code>\n</pre>\n", "senID": 1}, {"text": ["which translates to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n SELECT * FROM items WHERE name LIKE '%foo%' or skim LIKE '%foo%'\n</code>\n</pre>\n", "senID": 3}, {"text": ["This will have the database do all the filtering work for you instead of fetching all 90000 records and doing possibly two regex operations on each record."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You can find some info here on the .contains() method here."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "You can find some info here on the .contains() method here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sqlalchemy.org/docs/05/reference/sqlalchemy/schema.html?highlight=contains#sqlalchemy.schema.Column.contains"}]}, {"text": ["As well as the SQLAlchemy SQL Expression Language Tutorial here."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "SQLAlchemy SQL Expression Language Tutorial here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sqlalchemy.org/docs/05/sqlexpression.html"}]}, {"text": ["Of course the example above assumes variable names for your itemsTable and the column it has (nameColumn and skimColumn)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I would definitely take a suggestion of Reed to pass the filter to the SQL (forget the index part though)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I do not think that selecting only specified fields or all fields make a difference (unless you do have a lot of large fields).", "I would bet that SQLObject creates/instanciates 80K objects and puts them into a Session/UnitOfWork for tracking.", "This could definitely take some time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also if you do not need objects in your session, there must be a way to select just what the fields you need using custom-query creation so that no Item objects are created, but only tuples."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Item", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Initially doing regex via Python was considered for y_serial, but that \nwas dropped in favor of SQLite's GLOB (which is far faster).", "GLOB is similar to LIKE except that it's syntax is more \nconventional: * instead of %, ?", "instead of _ ."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["See the Endnotes at http://yserial.sourceforge.net/ for more details. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://yserial.sourceforge.net/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://yserial.sourceforge.net/"}]}]]