[[{"text": ["Something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; values = [\"12\", \"a\", \"bcd\", \"2.2\"]\n&gt;&gt;&gt; types = [int, int, str, float]\n&gt;&gt;&gt; defaults = {int: 0, float: 0.0}\n&gt;&gt;&gt; res = []\n&gt;&gt;&gt; for v, f in itertools.izip(values, types): #Just use zip for Python 3+.\n    try:\n        res.append(f(v))\n    except ValueError:\n        res.append(defaults[f])\n&gt;&gt;&gt; print(res)\n[12, 0, 'bcd', 2.2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This doesn't handle datetime values.", "My solution for that is use str for that, and convert to datetime after the loop, like:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n res[0] = datetime.strptime(res[0], \"...\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["Both getting and setting the list item has O(1) complexity, so it shouldn't be a problem."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["If your datetime value is always consistant why not let the type casting handle the invalid data that you're trying to manage in error_data.", "This is not as sexy as some solutions but makes managing type conversion based on position of data in list a little easier to maintain and expand upon. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def convert(position, val):\n    if position == 0:\n        try:\n            return datetime.strptime(val, '%Y-%m-%d %H:%M:%S') # assuming date is in a constant format\n        except ValueError:\n            return val\n    elif position in (1, 15, 16): # assuming that you have other int values in other \"columns\"\n        try:\n            return int(val)\n        except ValueError:\n            return 0\n    else: # string type\n       return val\n\nresult = [convert(i,j) for i, j in enumerate(tlist)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Since you know the types you want to convert to, you probably won't get a performance boost from trying to optimize your conversions.", "The poor performance probably comes from repeatedly iterating over error_data.", "If it is possible, reconstruct your error_data list as a set to exploit nature of that type:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "error_data", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "error_data", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n error_set = set((err, None) for err in error_data)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then proceed as you have been.", "Further improvements would require profiling your code to actually determine where time is being spent."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There's an incongruity in your code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["if all elements in a list are strings, you can't write datetime(x) with x being a string"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "datetime(x)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["It depicts nothing since it is incongruous.", "The complexity of what is not in you code doesn't justify the weirdness that is in your code.", "As long as you won't explain how you can pass a string as argument to the function datetime.datetime(), nobody will be able to help you, IMO."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "datetime.datetime()", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["Edit"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["I think that it's better to create directly your list at the moment the file is read."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I wrote an example:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["First, I created a CSV file with the following code:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import csv\nfrom random import randint,choice\nfrom time import gmtime\n\n\nxx = ['Whose', 'all', 'birth', 'just', 'infant', 'William',\n      'dearest', 'rooms', 'find', 'Deserts', 'saucy', 'His',\n      'how', 'considerate', 'only', 'other', 'Houses', 'has',\n      'Fanny', 'them', 'his', 'very', 'dispense', 'early',\n      'words', 'not', 'thus', 'now', 'pettish', 'Worth']\n\ndef gen(n):\n    for i in xrange(n):\n        yield ['AAAA','%d/%02d/%02d %02d:%02d:%02d' % gmtime(randint(0,80000000))[0:6],'@@@']\n        yield ['BBBB',randint(100,999),'^^^^^^']\n        yield ['CCCC',choice(xx),'-----------------']\n\nwith open('zzz.txt','wb') as f:\n    writ = csv.writer(f, delimiter='#')\n    writ.writerows(x for x in gen(60))\n</code>\n</pre>\n", "senID": 8}, {"text": ["The structure of the CSV file is so:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n AAAA#1972/02/11 08:53:53#@@@\nBBBB#557#^^^^^^\nCCCC#dearest#-----------------\nAAAA#1971/10/15 06:55:20#@@@\nBBBB#668#^^^^^^\nCCCC#?#-----------------\nAAAA#1972/07/13 11:10:05#@@@\nBBBB#190#^^^^^^\nCCCC#infant#-----------------\nAAAA#1971/11/22 19:31:42#@@@\nBBBB#202#^^^^^^\nCCCC##-----------------\nAAAA#1971/06/12 05:48:39#@@@\nBBBB#81#^^^^^^\nCCCC#find#-----------------\nAAAA#1970/12/09 06:26:29#@@@\nBBBB#72#^^^^^^\nCCCC#find#-----------------\nAAAA#1972/07/05 10:45:32#@@@\nBBBB#270#^^^^^^\nCCCC#rooms#-----------------\nAAAA#1972/06/23 05:52:20#@@@\nBBBB#202#^^^^^^\nCCCC##-----------------\nAAAA#1972/03/21 23:06:47#@@@\nBBBB#883#^^^^^^\nCCCC#William#-----------------\n...... etc\n</code>\n</pre>\n", "senID": 10}, {"text": [], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["The following code extracts the data in a similar way to what you want.   "], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["There is no need of a dictionary, a tuple is sufficient.", "Given the structure of the CSV file created, I defined  funcs = 60 * (to_dt, int, lambda x: x) but you'll use the succession of functions that is your dictionary's values (sorted)"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "funcs = 60 * (to_dt, int, lambda x: x)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import re\nimport csv\nfrom datetime import datetime\nfrom itertools import izip\n\nreg = re.compile('(\\d{4})/(\\d\\d)/(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d)')\n\ndef to_dt(x, error_data = ('', ' ', '?')):\n    if x in error_data:\n        return x\n    else:\n        return datetime(*map(int,reg.match(x).groups()))\n\ndef teger(x,  error_data = ('', ' ', '?')):\n    if x in error_data:\n        return 0\n    else:\n        return int(x)\n\nfuncs = 60 * (to_dt, int, lambda y: y)\n\nwith open('zzz.txt','rb') as f:\n    rid = csv.reader(f, delimiter='#')\n    li = [fct(x[1]) for fct,x in izip(funcs,rid)]\n\n\n\n# display\nit = (str(el) for el in li).next\nprint '\\n'.join('%-21s %4s  %10s' % (it(),it(),it()) for i in xrange(60))\n</code>\n</pre>\n", "senID": 14}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n 1972-02-11 08:53:53    557     dearest\n1971-10-15 06:55:20    668           ?\n1972-07-13 11:10:05    190      infant\n1971-11-22 19:31:42    202            \n1971-06-12 05:48:39     81        find\n1970-12-09 06:26:29     72        find\n1972-07-05 10:45:32    270       rooms\n1972-06-23 05:52:20    202            \n1972-03-21 23:06:47    883     William\n1970-02-08 23:47:26    617            \n1970-10-08 09:09:33    387     William\n1971-04-30 11:05:07    721           ?\n1970-02-12 11:57:48    827     Deserts\n1972-03-27 21:30:39    363        just\n1971-06-02 00:23:52    977            \n1970-04-20 04:38:38    113     William\n1971-01-20 23:10:26     75       Whose\n1971-07-01 12:46:13    352     dearest\n1971-01-31 17:01:34    220     William\n1970-06-09 20:38:52    148       rooms\n1971-08-08 07:42:10    146            \n1970-01-28 15:17:41    903        find\n...............etc\n</code>\n</pre>\n", "senID": 16}], [{"text": ["I don't know if this would be much faster, but to me it's clearer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n tlist =  [ 'some datetime value', '12', 'string', .... ]\n\n#convert it to: [ datetime object, 12, 'string', ....]\n\nerror_data = set(['', ' ', '?', ...])\n\ndef s(x):\n    return x\n\ndef d(x):\n    return datetime(x) if x not in error_data else x\n\ndef i(x):\n    return int(x) if x not in error_data else 0\n\ntypes = [ d, i, s, s, s, i, i, d, i, ... ]\n\nresult = [ t(x) for t, x in zip(types, tlist) ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["As others have mentioned, I'm using a set for the error values, which will be faster than the list you had."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As a variant on utdemir's answer, if error values are fairly infrequent, then you could optimize the common case:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; values = [\"12\", \"a\", \"bcd\", \"2.2\"]\n&gt;&gt;&gt; types = [int, int, str, float]\n&gt;&gt;&gt; defaults = {int: 0, float: 0.0}\n&gt;&gt;&gt; try: res = [f(v) for v,f in zip(values,types)]\n... except: \n...     res = []\n...     for v, f in zip(values, types):\n...        try:\n...             res.append(f(v))\n...         except ValueError:\n...             res.append(defaults[f])\n</code>\n</pre>\n", "senID": 1}, {"text": ["I.e., first try converting the whole line assuming that nothing will go wrong.", "If anything does go wrong, then go back and convert values one at a time, fixing any error values."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Thank you guys for all those approaches.", "Yeah, I tried pretty much all the approaches mentioned, but none did perform well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I tried the following approach and it worked pretty well for my performance needs.", "This is what I did."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["My Observations:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]