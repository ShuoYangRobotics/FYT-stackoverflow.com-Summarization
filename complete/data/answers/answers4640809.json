[[{"text": ["It's nothing to do with static vs. dynamic."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Rather, it's about becoming independent from the underlying hardware platform (\"build once, run everywhere\" - in theory...)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Actually, it's nothing to do with the language, either.", "One could write a C compiler that generates bytecode for the JVM.", "One could write a Java compiler that generates x86 machine code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Let's forget about VMs for a sec (we'll get back to those below, I promise), and start with this important fact:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["C doesn't have garbage collection."], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"text": ["For a language to provide garbage collection, there has to be some sort of \"runtime\"/runtime-environment/thing that will perform it."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\"runtime\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["That's why Python, Java, and Haskell require a \"runtime\", and C, which does not, can just straight-forwardly compile to native code."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "\"runtime\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Note that psyco was a Python optimizer that compiled Python code to machine code, however, a lot of that machine code consisted of calls to C-Python's runtime's functions, such as PyImport_AddModule, PyImport_GetModuleDict, etc."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "psyco", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://psyco.sourceforge.net/"}, {"text": "PyImport_AddModule", "childNum": 0, "tag": "code", "childList": []}, {"text": "PyImport_GetModuleDict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Haskell/GHC is in a similar boat to psyco-compiled Python.", "Ints are added as simple machine instructions, but more complicated stuff which allocate objects etc, invoke the runtime."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["What else?"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["C doesn't have \"exceptions\""], "childNum": 0, "tag": "h2", "senID": 7, "childList": []}, {"text": ["If we were to add exceptions to C, our generated machine code would need to do some stuff for every function and for every function call."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["If we then add \"closures\" as well, there would be more stuff added."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Now, instead of having this boilerplate machine code repeated in every function, we could make it instead call a subprocedure to do the necessary stuff, something like PyErr_Occurred."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "PyErr_Occurred", "tag": "a", "pos": 0, "childList": [{"text": "PyErr_Occurred", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/c-api/exceptions.html"}, {"text": "PyErr_Occurred", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So now, basically every original source line maps to some calls to some functions and a smaller unique part."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["But as long as we're doing so much stuff per original source code line, why even bother with machine code?"], "childNum": 0, "tag": "h2", "senID": 12, "childList": []}, {"text": ["Here's an idea (btw let's call this idea a \"Virtual Machine\")."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Let's represent your Python code, which is for example:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n def has_no_letters(text):\n  return text.upper() == text.lower()\n</code>\n</pre>\n", "senID": 15}, {"text": ["As an in-memory data-structure, for example:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n { 'func_name': 'has_no_letters',\n  'num_args': 1,\n  'kwargs': [],\n  'codez': [\n    ('get_attr', 'tmp_a', 'arg_0', 'upper'),  # tmp_a = arg_0.upper\n    ('func_call', 'tmp_b', 'tmp_a', []),  # tmp_b = tmp_a() # tmp_b = arg_0.upper()\n    ('get_attr', 'tmp_c', 'arg_0', 'lower'),\n    ('func_call', 'tmp_d', 'tmp_c', []),\n    ('get_global', 'tmp_e', '=='),\n    ('func_call', 'tmp_f', 'tmp_e', ['tmp_b', 'tmp_d']),\n    ('return', 'tmp_f'),\n  ]\n}\n</code>\n</pre>\n", "senID": 17}, {"text": ["Now, let's write an interpreter that executes this in-memory data structure."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["Let's discuss the benefits of this over direct-from-text-interpreters, and then the benefits over compiling to machine code."], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "The VM system gives you all the syntax errors before executing the code.", "tag": "none", "senID": 20}, {"text": "When evaluating a loop, a VM system doesn't parse the source code each time it runs.\n", "tag": "none", "senID": 21}]}, {"tag": "ul", "num": 2, "lis": [{"text": "The in-memory data structure describing the program, or the \"VM code\", will probably be much more compact than boilerplate-full machine code which does the same stuff again and again for every original line of code. This will make the VM system run faster because less \"instructions\" will need to be fetched from memory.", "tag": "none", "senID": 22}, {"text": ["Creating a VM is much simpler than creating a compiler to machine code."], "childNum": 0, "tag": "strong", "senID": 23, "childList": []}]}], [{"text": ["A VM (Virtual Machine) is actually a tool for a language designer to avoid some complexity in writing the implementation of a language. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Basically is a specification of a virtual computer and how each piece of said computer will interact with the other.", "You can code some assumptions in this specification that can be used by the actual language or not."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In this specification usually you define how the processor/processors work, how the memory works, what read/write barrier are possible etc, and a simpler assembly language to interact with it. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The final language is usually translated (compiled) from the text files you are writing into a representation written for that machine. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This has some advantages: "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "you decouple the language from a\nspecific hardware architecture", "tag": "none", "senID": 5}, {"text": "usually allows you to control what\nhappens", "tag": "none", "senID": 6}, {"text": "different people can port to a different architecture", "tag": "none", "senID": 7}, {"text": "you have more information to let optimize the code", "tag": "none", "senID": 8}, {"text": "etc.", "tag": "none", "senID": 9}]}, {"text": ["There is also the coolness factor: Look Ma i made a virtual machine :). "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["From the wikipedia entry on Virtual Machines:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Virtual Machines", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Virtual_machine"}]}, {"text": ["\"A virtual machine (VM) is a software implementation of a machine (i.e.", "a computer) that executes programs like a physical machine."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The greatest asset of Virtual Machines is, in theory, code portability - \"write once, run anywhere\""], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\"write once, run anywhere\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Probably the best known example of a Virtual Machine is the JVM, originally designed to run Java code, but now also increasingly used for langauges such as Clojure and Scala."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "JVM", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Java_Virtual_Machine"}]}, {"text": ["There's nothing specific to dynamic languages that means they need a VM.", "They do however need an interpreter, which could be built on a VM."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "interpreter", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Interpreter_%28computing%29"}, {"text": "could", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["There's no \"need\", any of these languages provide compilers that directly emit the machine code to implement the semantics of their language in a given architecture."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The idea of a virtual machine is to abstract away the architectural differences between all the different hardware and software manufacturers so that developers have a single machine to write to."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Java and python can be compiled in a way that maintains platform independance.", "This holds even for C#.", "Advantages are that VMs are able to convert this mostly strongly typed bytecode into very good platform specific code with relativ low overhead.", "Since Java is intended to \"build once - run anywhere\", the JVM has been created."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["A virtual machine is basically an interpreter that interprets a language closer to machine code.", "When real machine interprets real machine code, Virtual Machine interprets a made-up machine code.", "Some VM-s interpret machine code of an actual computer - these are called emulators."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "A virtual machine is basically an interpreter", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["It's easier to write an interpreter for a simple assembly-like language, then for the full high-level language.", "Besides, a lot of high-level code-constructs are often just syntactic sugar over some basic principles.", "So it's easier to just write a compiler that translates all those complex concepts to simple VM-language, so we don't have to write a complex interpreter but can get away with simple one (a VM).", "And then you have more time for optimizing the VM."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["That's basically how most languages these days (that don't compile down to real machine code) are implemented."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The interpreter (VM) and compiler can either be separate programs (like java and javac), or they can be just one program (like with Ruby or Python)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "java", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "javac", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Imagine you created a programming language: you figured out the language semantics and developed a nice syntax."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, a textual representation isn't enough: Having to parse text again and again when executing a program is inefficient, so it's natural to add an in-memory binary representation.", "Couple that with a custom memory manager, and you've basically got a VM."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now, for extra points, either develop a bytecode format for serialization of your in-memory representation and a runtime loader, or, if you want to go the way of scripting languages, an eval() function."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "eval()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For the grand finale, add a JIT."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]