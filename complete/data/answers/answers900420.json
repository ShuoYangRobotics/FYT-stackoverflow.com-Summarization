[[{"text": ["Convert both sequences to lists, and use builtin list comparison.", "It should be sufficient, unless your sequences are really large."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list(a) == list(b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Testing done by schickb shows that using tuples is slightly faster:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n tuple(a) == tuple(b)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You can determine the equality of any two iterables (strings, tuples, lists, even custom sequences) without creating and storing duplicate lists by using the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n all(x == y for x, y in itertools.izip_longest(a, b))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that if the two iterables are not the same length, the shorter one will be padded with Nones.", "In other words, it will consider [1, 2, None] to be equal to (1, 2)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[1, 2, None]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(1, 2)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: As Kamil points out in the comments, izip_longest is only available in Python 2.6.", "However, the docs for the function also provide an alternate implementation which should work all the way back to 2.3."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "izip_longest", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "the docs for the function", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.izip%5Flongest"}]}, {"text": ["Edit 2: After testing on a few different machines, it looks like this is only faster than list(a) == list(b) in certain circumstances, which I can't isolate.", "Most of the time, it takes about seven times as long.", "However, I also found tuple(a) == tuple(b) to be consistently at least twice as fast as the list version."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "Edit 2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "list(a) == list(b)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "tuple(a) == tuple(b)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["It looks like tuple(a) == tuple(b) is the best overall choice.", "Or perhaps tuple comparison with a preceding len check if they'll often be different lengths.", "This does create extra lists, but hopefully not an issue except for really huge lists.", "Here is my comparison of the various alternatives suggested:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import timeit\n\ntests = (\n'''\na=b=[5]*100\n''',\n\n'''\na=[5]*100\nb=[5]*3\n''',\n\n'''\na=b=(5,)*100\n''',\n\n'''\na=b=\"This on is a string\" * 5\n''',\n\n'''\nimport array\na=b=array.array('B', \"This on is a string\" * 5)\n'''\n)\n\ncommon = '''import itertools\ndef comp1(a, b):\n    if len(a) != len(b):\n        return False\n    for i, v in enumerate(a):\n        if v != b[i]:\n            return False\n    return True'''\n\nfor i, setup in enumerate(tests):\n    t1 = timeit.Timer(\"comp1(a, b)\", setup + common)\n    t2 = timeit.Timer(\"all(x == y for x, y in itertools.izip_longest(a, b))\", setup + common)\n    t3 = timeit.Timer(\"all([x == y for x, y in itertools.izip_longest(a, b)])\", setup + common)\n    t4 = timeit.Timer(\"list(a) == list(b)\", setup + common)\n    t5 = timeit.Timer(\"tuple(a) == tuple(b)\", setup + common)\n\n    print '==test %d==' % i\n    print '   comp1: %g' % t1.timeit()\n    print ' all gen: %g' % t2.timeit()\n    print 'all list: %g' % t3.timeit()\n    print '    list: %g' % t4.timeit()\n    print '   tuple: %g\\n' % t5.timeit()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here are the results:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ==test 0==\n   comp1: 27.8089\n all gen: 31.1406\nall list: 29.4887\n    list: 3.58438\n   tuple: 3.25859\n\n==test 1==\n   comp1: 0.833313\n all gen: 3.8026\nall list: 33.5288\n    list: 1.90453\n   tuple: 1.74985\n\n==test 2==\n   comp1: 30.606\n all gen: 31.4755\nall list: 29.5637\n    list: 3.56635\n   tuple: 1.60032\n\n==test 3==\n   comp1: 33.3725\n all gen: 35.3699\nall list: 34.2619\n    list: 10.2443\n   tuple: 10.1124\n\n==test 4==\n   comp1: 31.7014\n all gen: 32.0051\nall list: 31.0664\n    list: 8.35031\n   tuple: 8.16301\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: Added a few more tests.", "This was run on an AMD 939 3800+ with 2GB of ram.", "Linux 32bit, Python 2.6.2"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Since you put the word \"equality\" in quotes, I assume that you would like to know how the lists are the same and how the are different.", "Check out difflib which has a SequenceMatcher class:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "difflib", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n sm = difflib.SequenceMatcher(None, a, b)\n    for opcode in sm.get_opcodes():\n        print \"    (%s %d:%d %d:%d)\" % opcode\n</code>\n</pre>\n", "senID": 1}, {"text": ["You will get back a sequences of descriptions of the differences.", "It's fairly simple to turn that into diff-like output."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "diff", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Apart from the extra memory used by creating temporary lists/tuples, those answers will lose out to short circuiting generator solutions for large sequences when the inequality occurs early in the sequences"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import starmap, izip\nfrom operator import eq\nall(starmap(eq, izip(x,y)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["or more concisely"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import imap\nfrom operator import eq\nall(imap(eq, x, y))\n</code>\n</pre>\n", "senID": 3}, {"text": ["some benchmarks from ipython"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n x=range(1000)\ny=range(1000);y[10]=0\n\ntimeit tuple(x)==tuple(y)\n100000 loops, best of 3: 16.9 us per loop\n\ntimeit all(imap(eq,x,y))\n100000 loops, best of 3: 2.86 us per loop\n</code>\n</pre>\n", "senID": 5}], [{"text": ["There's always:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list(a) == list(b)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's probably not as efficient, but it looks funky:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def cmpLists(a, b):\n    return len(a) == len(b) and (False not in [a[i] == b[i] for i in range(0,len(a)])\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't know the \"all\" function that Ben mentioned, but perhaps you could use that instead of \"False not in\""], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Ben mentioned", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/900420/elegant-way-to-compare-sequences/900444#900444"}]}], [{"text": ["This \"functional\" code should be fast and generic enough for all purposes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # python 2.6 \u2264 x &lt; 3.0\nimport operator, itertools as it\n\ndef seq_cmp(seqa, seqb):\n    return all(it.starmap(operator.eq, it.izip_longest(seqa, seqb)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["If on Python 2.5, use the definition for izip_longest from there."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "there", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.izip%5Flongest"}]}]]