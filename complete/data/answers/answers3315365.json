[[{"text": ["It looks like you want this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sum([[1],[2]], [])\n[1, 2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["You're right that it's trying to add 0 to [1] and getting an error.", "The solution is to give sum an extra parameter giving the start value, which for you would be the empty list."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Edit: As gnibbler says, though, sum is not a good way to concatenate things.", "And if you just want to aggregate a sequence of things, you should probably use reduce rather than make your own __radd__ function just to use sum.", "Here's an example (with the same poor behavior as sum):"], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "reduce", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__radd__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; reduce(lambda x, y: x+y, [[1],[2]])\n[1, 2]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["It's a bad idea to use sum() on anything other than numbers, as it has quadradic performance for sequences/strings/etc. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sum()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Better to use a list comprehension to sum your lists"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [j for i in [[1],[2]] for j in i]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["It is more efficient to concatenate using itertools.chain."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.chain", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; m = [[i] for i in range(200)]\n&gt;&gt;&gt; m\n[[0], [1], [2], [3], [4], [5], [6], [7], [8], ...]\n&gt;&gt;&gt; from itertools import *\n&gt;&gt;&gt; list(chain(*m))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, ...]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Personally, I prefer this over list comprehension as it's hard to remember which for loop comes first.", "There is even a more efficient variant, list(chain.from_iterable(m))."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "list(chain.from_iterable(m))", "tag": "a", "pos": 1, "childList": [{"text": "list(chain.from_iterable(m))", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.itertools.chain.from_iterable"}, {"text": "list(chain.from_iterable(m))", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Microbenchmark results (with Python 3 using the timeit module.", "A list size of p x q means m = [list(range(q)) for _ in range(p)]):"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "p", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "q", "childNum": 0, "tag": "em", "childList": []}, {"text": "m = [list(range(q)) for _ in range(p)]", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n list size | chain(*m)  | sum(m,[])     | list comp  | flatten    |\n----------+------------+---------------+------------+------------+\n    2 x 1 |   1.78 \u00b5s  |      0.646 \u00b5s |   0.905 \u00b5s |    1.49 \u00b5s |\n   20 x 1 |   4.37 \u00b5s  |      7.49  \u00b5s |   5.19  \u00b5s |    3.59 \u00b5s |\n  200 x 1 |  26.9  \u00b5s  |    134     \u00b5s |  40     \u00b5s |   24.4  \u00b5s |\n 2000 x 1 | 233    \u00b5s  | 12.2       ms | 360     \u00b5s | 203     \u00b5s |\n----------+------------+---------------+------------+------------+\n 2 x    1 |   1.78 \u00b5s  |      0.646 \u00b5s |   0.905 \u00b5s |    1.49 \u00b5s |\n 2 x   10 |   2.55 \u00b5s  |      0.899 \u00b5s |   3.14  \u00b5s |    2.2  \u00b5s |\n 2 x  100 |   9.07 \u00b5s  |      2.03  \u00b5s |  17.2   \u00b5s |    8.55 \u00b5s |\n 2 x 1000 |  51.3  \u00b5s  |     21.9   \u00b5s | 139     \u00b5s |   49.5  \u00b5s |\n----------+------------+---------------+------------+------------+\n\nchain(*m) -&gt; list(chain(*m))\nsum(m,[]) -&gt; sum(m, [])\nlist comp -&gt; [j for i in m for j in i]\nflatten   -&gt; icfi = chain.from_iterable; list(icfi(m))\n</code>\n</pre>\n", "senID": 4}, {"text": ["It shows that sum is efficient only when the outer list size is very short.", "But then you have an even more efficient variant: m[0]+m[1]. "], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "only", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "very short", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "m[0]+m[1]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["As the docs say,"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html?highlight=sum#sum"}]}, {"text": ["What this means is that the tedious process of actually forbidding anything but numbers (except for forbidding summing strings, a particularly heinous and common error) was eschewed -- if you're summing anything but numbers, you'll probably destroy your program's performance for no good purpose, but, hey, Python's not really about stopping programmers from doing every kind of terrible mistake."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "but", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "every", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["If you do insist on doing things the wrong way, as other answers have mentioned, using sum's third parameter (as the starting value, instead of the default, 0) is the right way to do the wrong thing;-).", "So, the literal answer to your question:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["(once the very erroneous suggestion is removed, that integers behave any differently than any other kind of numbers here, by rephrasing it as \"non-numbers\" -- summing any kind of numbers is quite fine, and does not necessarily require any special precaution, though math.fsum is better for summing floats) is...: \"yes, it is possible (just like it's possible to use a hammer to bang your thumb quite painfully) -- mind you, it's absolutely not advisable (just as hammering your thumb isn't), but, it's definitely possible, if you really insist\";-)."], "childNum": 7, "tag": "p", "senID": 3, "childList": [{"text": "any", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/math.html#math.fsum", "text": "math.fsum", "childNum": 0, "tag": "a", "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "childList": []}, {"text": "is", "childNum": 0, "tag": "strong", "childList": []}, {"text": "advisable", "childNum": 0, "tag": "strong", "childList": []}, {"text": "definitely", "childNum": 0, "tag": "em", "childList": []}, {"text": "possible", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["I little misunderstood your question to be of addition and made this  solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # for me the guestion looks for me to do sum of sum of list\n# i would do like this\nlist_of_numlists=[[1,2,3],[2,3,4]]\nprint \"Input =\",list_of_numlists\nsum_of_it=sum(sum(x) for x in list_of_numlists)\nprint \"Sum = %i\" % sum_of_it\n## --&gt; Sum = 15\n# second version to understand the request is\nsum_of_items=[sum(x) for x in zip(*list_of_numlists)]\nprint \"Sum of each is\", sum_of_items\n\"\"\" Output:\nInput = [[1, 2, 3], [2, 3, 4]]\nSum = 15\nSum of each is [3, 5, 7]\n\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["\"\""], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Actually you should not talk about sum but concatenating or joining sequences."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["sum(iterable[, start])\nSums start and the items of an iterable from left to right and returns the total.", "start defaults to 0.", "The iterable\u2018s items are normally numbers, and are not allowed to be strings.", "In [26]: sum([[1],[2]], [])\nOut[26]: [1, 2]"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As in the Docs..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["By the way Gabe has given the right solution to use reduce(lambda x, y: x+y, [[1],[2]]).", "Alternatively you can use a lay man method:-"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In [69]: l = [[1],[2]]"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In [70]: a = str(l[0]).strip('[]')"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In [71]: b = str(l[1]).strip('[]')"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["In [72]: l = [int(a), int(b)]"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["In [73]: l\nOut[73]: [1, 2]"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["For case of one element sequences there is also special solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n m = [[i] for i in range(200)]\nlist_of_m = list((zip(*m))[0])\nprint list_of_m\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also if you have strings in list you can use the standard Python join to catenate"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ''.join(m)\n</code>\n</pre>\n", "senID": 3}]]