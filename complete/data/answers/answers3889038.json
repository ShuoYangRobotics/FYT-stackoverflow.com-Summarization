[[{"text": ["The best thing to do would be to turn your data into a dict mapping UID to FLAGS, then searching it will be easy.", "So the data will look something like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n {'3254': '', '3304': '', '3236': '\\\\Deleted', '3237': '-FLAGS \\\\Seen +FLAGS', '3234': 'seen \\\\Seen', '3235': '\\\\Seen', '3430': '\\\\Seen', '3431': '', '3252': '\\\\Seen', '3253':'\\\\Deleted', '3478': '', '3479': '', '3256': '\\\\Seen', '3481': '', '3480': '', '3318': '\\\\Seen', '3434': '\\\\Seen', '3243': '\\\\Seen', '3242': '\\\\Seen', '3241': '-FLAGS \\\\Seen +FLAGS', '3247': '\\\\Seen', '3245': '\\\\Seen', '3244': '\\\\Seen', '3447': '-FLAGS \\\\Seen +FLAGS'}\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can do this using a Regular Expression to match each entry in the list.", "If we get the regexp to return two groups in the match we can easily build the dict."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "using a Regular Expression", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["So we end up with something like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n items = ['1 (UID 3234 FLAGS (seen \\\\Seen))', '2 (UID 3235 FLAGS (\\\\Seen))', '3 (UID 3236 FLAGS (\\\\Deleted))', '4 (UID 3237 FLAGS (-FLAGS \\\\Seen +FLAGS))', '5 (UID 3241 FLAGS (-FLAGS \\\\Seen +FLAGS))', '6 (UID 3242 FLAGS (\\\\Seen))',  '7 (UID 3243 FLAGS (\\\\Seen))', '8 (UID 3244 FLAGS (\\\\Seen))',  '9 (UID 3245 FLAGS (\\\\Seen))', '10 (UID 3247 FLAGS (\\\\Seen))', '11 (UID 3252 FLAGS (\\\\Seen))', '12 (UID 3253 FLAGS (\\\\Deleted))', '13 (UID 3254 FLAGS ())', '14 (UID 3256 FLAGS (\\\\Seen))', '15 (UID 3304 FLAGS ())', '16 (UID 3318 FLAGS (\\\\Seen))', '17 (UID 3430 FLAGS (\\\\Seen))', '18 (UID 3431 FLAGS ())', '19 (UID 3434 FLAGS (\\\\Seen))', '20 (UID 3447 FLAGS (-FLAGS \\\\Seen +FLAGS))', '21 (UID 3478 FLAGS ())', '22 (UID 3479 FLAGS ())', '23 (UID 3480 FLAGS ())', '24 (UID 3481 FLAGS ())']\n\nimport re\npattern = re.compile(r\"\\d+ \\(UID (\\d+) FLAGS \\(([^)]*)\\)\\)\")\nvalues = dict(pattern.match(item).groups() for item in items)\n</code>\n</pre>\n", "senID": 4}, {"text": ["We can then easily query the items in values to get what you want:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "values", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print \"All UIDs:\",values.keys()\nprint \"Seen UIDs:\",[uid for uid,flags in values.iteritems() if r\"\\Seen\" in flags]\nprint \"Deleted UIDs:\",[uid for uid,flags in values.iteritems() if r\"\\Deleted\" in flags]\n</code>\n</pre>\n", "senID": 6}], [{"code": "<pre>\n<code>\n import re\n\ndata = ['1 (UID 3234 FLAGS (seen \\\\Seen))', '2 (UID 3235 FLAGS (\\\\Seen))',\n '3 (UID 3236 FLAGS (\\\\Deleted))', '4 (UID 3237 FLAGS (-FLAGS \\\\Seen +FLAGS))',\n '5 (UID 3241 FLAGS (-FLAGS \\\\Seen +FLAGS))', '6 (UID 3242 FLAGS (\\\\Seen))', \n '7 (UID 3243 FLAGS (\\\\Seen))', '8 (UID 3244 FLAGS (\\\\Seen))', \n '9 (UID 3245 FLAGS (\\\\Seen))', '10 (UID 3247 FLAGS (\\\\Seen))', \n'11 (UID 3252 FLAGS (\\\\Seen))', '12 (UID 3253 FLAGS (\\\\Deleted))', \n'13 (UID 3254 FLAGS ())', '14 (UID 3256 FLAGS (\\\\Seen))', '15 (UID 3304 FLAGS ())', \n'16 (UID 3318 FLAGS (\\\\Seen))', '17 (UID 3430 FLAGS (\\\\Seen))', \n'18 (UID 3431 FLAGS ())', '19 (UID 3434 FLAGS (\\\\Seen))', \n'20 (UID 3447 FLAGS (-FLAGS \\\\Seen +FLAGS))', '21 (UID 3478 FLAGS ())', \n'22 (UID 3479 FLAGS ())', '23 (UID 3480 FLAGS ())', '24 (UID 3481 FLAGS ())']\n\nr = re.compile('\\d+\\s\\(UID\\s(?P&lt;uid&gt;\\d+)\\sFLAGS\\s\\((?P&lt;data&gt;.*)\\)\\)')\nuid_list = []\nseen_uid_list = []\ndeleted_uid_list = []\nfor s in data:\n    m = r.match(s)\n    if m:\n        uid_list.append(m.group('uid'))\n        if m.group('data').rfind('Seen') &gt; 0: seen_uid_list.append(m.group('uid'))\n        if m.group('data').rfind('Deleted') &gt; 0: deleted_uid_list.append(m.group('uid'))\n\nprint uid_list\nprint seen_uid_list\nprint deleted_uid_list\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I'm not sure about list comprehensions since those usually map one list to another (using either filtering or mapping).", "I've not seen them being used to split lists.", "However, you could do this with a combination of a genexp and a loop in a single iteration.", "I've blown this up a little so that it's clear. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\ngrepper = re.compile(r'[0-9]+ \\(UID (?P&lt;uid&gt;[0-9]+) FLAGS (?P&lt;flags&gt;\\(.*\\))\\)')\n\nt = [..] #your list\n\nitems = (grepper.search(m).groupdict() for m in t)\n\nall = []\nseen = []\ndeleted = []\nfor i in items:\n  if \"Seen\" in i:\n    seen.append(i[\"uid\"])\n  if \"Deleted\" in i:\n    deleted.append(i[\"uid\"])\n  all.append(i[\"uid\"])\n</code>\n</pre>\n", "senID": 1}, {"text": ["You should have your 3 lists now. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n all,deleted,seen = [list(filter(None, a)) for a in \\\n    zip(*map(lambda a: (a[2], '\\Deleted' in a[-1] and a[2], '\\Seen' in  a[-1] and a[2]), map(lambda a: a.split(' '), items)))]\n</code>\n</pre>\n", "senID": 0}, {"text": ["which will be faster using re or without re - you need to check with timeit !!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This one works for your data sample...."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n uids, seen, deleted = [], [], []\nfor item in myList:\n    uids.append(int(item[7:12]))\n    if 'Se' in item[20:]:  seen.append(uids[-1])\n    elif 'De' in item[20:]: deleted.append(uids[-1])\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n all=[]\nseen=[]\ndeleted=[]\nfor item in alist:\n    s=item.split(\" \",4)\n    all.append(s[2])\n    if \"seen\" in s[-1].lower():\n        seen.append(s[2])\n    elif \"delete\" in s[-1].lower():\n        deleted.append(s[2])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["The only way I can think of of doing it in one iteration generating the three lists you ask, is by iterating manually.", "No python magic I can come up with."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can easily improve this if you know specifics about the format and how it's generated.", "I don't know why +FLAGS and -FLAGS in some items, for example, and didn't know when to expect parenthesis, so I had to use find().", "Also, I could've just split() the string in two, but then again, I don't know what the flag format means,..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def parseList(l):\n    lall = []\n    lseen = []\n    ldeleted = []\n\n    for item in l:\n        spl = item.split()\n\n        uid = int(spl[2])\n\n        lall.append(uid)\n\n        for word in spl[4:]:\n            if word.find(\"\\Seen\") != -1:\n                lseen.append(uid)\n\n            elif word.find(\"\\Deleted\") != -1:\n                ldeleted.append(uid)\n\n    return lall, lseen, ldeleted\n</code>\n</pre>\n", "senID": 2}]]