[[{"text": ["Using itertools.groupby produces a concise but tricky implementation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef ranges(i):\n    for a, b in itertools.groupby(enumerate(i), lambda (x, y): y - x):\n        b = list(b)\n        yield b[0][1], b[-1][1]\n\nprint list(ranges([0, 1, 2, 3, 4, 7, 8, 9, 11]))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Nothing built-in, or in any libraries that I know of.", "Not very helpful, I know, but I've never come across anything like what you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here are some ideas for your program atleast (in C++, but it can give you some other ideas):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Converting sets of integers into ranges"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Converting sets of integers into ranges", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2305767/converting-sets-of-integers-into-ranges"}]}], [{"text": ["Well, I can say with confidence that I don't know of such a function.", "It is a lot harder to say with confidence that something I'm not aware of doesn't exist...."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def ranges(p):\n    q = sorted(p)\n    i = 0\n    for j in xrange(1,len(q)):\n        if q[j] &gt; 1+q[j-1]:\n            yield (q[i],q[j-1])\n            i = j\n    yield (q[i], q[-1])\n\nsample = [0, 1, 2, 3, 4, 7, 8, 9, 11]\nprint list(ranges(sample))\nprint list(ranges(reversed(sample)))\nprint list(ranges([1]))\nprint list(ranges([2,3,4]))\nprint list(ranges([0,2,3,4]))\nprint list(ranges(5*[1]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Produces these results:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [(0, 4), (7, 9), (11, 11)]\n[(0, 4), (7, 9), (11, 11)]\n[(1, 1)]\n[(2, 4)]\n[(0, 0), (2, 4)]\n[(1, 1)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that runs of repeated numbers get compressed.", "I don't know if that's what you want.", "If not, change the &gt; to a !=."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "compressed", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "&gt;", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "!=", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I understand your question.", "I looked into itertools and tried to think of a solution that could be done in a couple of lines of Python, which would have qualified as \"almost a built in\", but I couldn't come up with anything."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\"almost a built in\"", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["You can use a list comprehension with a generator expression and a combination of enumerate() and itertools.groupby():"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "list comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}, {"href": "http://docs.python.org/reference/expressions.html#generator-expressions", "text": "generator expression", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://docs.python.org/library/functions.html#enumerate", "text": "enumerate()", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://docs.python.org/library/itertools.html#itertools.groupby", "text": "itertools.groupby()", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools\n&gt;&gt;&gt; l = [0, 1, 2, 3, 4, 7, 8, 9, 11]\n&gt;&gt;&gt; [[t[0][1], t[-1][1]] for t in\n... (tuple(g[1]) for g in itertools.groupby(enumerate(l), lambda (i, x): i - x))]\n[[0, 4], [7, 9], [11, 11]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["First, enumerate() will build tuples from the list items and their respective index:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "enumerate()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [t for t in enumerate(l)]\n[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 7), (6, 8), (7, 9), (8, 11)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then groupby() will group those tuples using the difference between their index and their value (which will be equal for consecutive values):"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "groupby()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [tuple(g[1]) for g in itertools.groupby(enumerate(l), lambda (i, x): i - x)]\n[((0, 0), (1, 1), (2, 2), (3, 3), (4, 4)), ((5, 7), (6, 8), (7, 9)), ((8, 11),)]\n</code>\n</pre>\n", "senID": 5}, {"text": ["From there, we only need to build lists from the values of the first and last tuples of each group (which will be the same if the group only contains one item)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["You can also use [(t[0][1], t[-1][1]) ...] to build a list of range tuples instead of nested lists, or even ((t[0][1], t[-1][1]) ...) to turn the whole expression into a iterable generator that will lazily build the range tuples on the fly."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "[(t[0][1], t[-1][1]) ...]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "((t[0][1], t[-1][1]) ...)", "childNum": 0, "tag": "code", "childList": []}, {"text": "generator", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["In the case there is no such feature in python, here is an implementation"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n p = []\nlast = -2                                                            \nstart = -1\n\nfor item in list:\n    if item != last+1:                        \n        if start != -1:\n            p.append([start, last])\n        start = item\n    last = item\n\np.append([start, last])\n</code>\n</pre>\n", "senID": 1}]]