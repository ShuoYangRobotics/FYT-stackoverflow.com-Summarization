[[{"text": ["You're not really testing Java vs. Python, you're testing java.util.HashSet using autoboxed Integers vs. Python's native set and integer handling."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "java.util.HashSet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Apparently, the Python side in this particular microbenchmark is indeed faster."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I tried replacing HashSet with TIntHashSet from GNU trove and achieved a speedup factor between 3 and 4, bringing Java slightly ahead of Python."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "TIntHashSet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://trove4j.sourceforge.net/", "text": "GNU trove", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["The real question is whether your example code is really as representative of your application code as you think.", "Have you run a profiler and determined that most of the CPU time is spent in putting a huge number of ints into a HashSet?", "If not, the example is irrelevant.", "Even if the only difference is that your production code stores other objects than ints, their creation and the computation of their hashcode could easily dominate the set insertion (and totally destroy Python's advantage in handling ints specially), making this whole question pointless."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I suspect that  is that Python uses the integer value itself as its hash and the hashtable based implementation of set uses that value directly.", "From the comments in the source:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "source", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Objects/dictobject.c?revision=72958&view=markup"}]}, {"text": ["This microbenchmark is somewhat of a best case for Python because it results in exactly zero hash collisions.", "Whereas, if Javas HashSet is rehashing the keys it has to perform the additional work and also gets much worse behavior with collisions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you store the range(iterations) in a temporary variable and do a random.shuffle on it before the loop the runtime is more than 2x slower even if the shuffle and list creation is done outside the loop."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It has generally been my experience that python programs run faster than java programs, despite the fact that java is a bit \"lower level\" language.", "Incidently, both languages are compiled into byte code (that's what those .pyc file are -- you can think of them as kind of like .class files).", "Both languages are byte-code interpreted on a virtual stack machine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You would expect python to be slower at things like, for example, a.b.", "In java, that a.b will resolve into a dereference.", "Python, on the other hand, has to do one or more hash table lookups:  check the local scope, check the module scope, check global scope, check builtins."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "a.b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a.b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["On the other hand, java is notoriously bad at certain operations such as object creation (which is probably the culprit in your example) and serialization.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In summary, there's no simple answer.", "I wouldn't expect either language to be faster for all code examples."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Correction: several people have pointed out that java isn't so bad at object creation any more.", "So, in your example, it's something else.", "Perhaps it's autoboxing that's expensive, perhaps python's default hashing algorithm is better in this case.", "In my practical experience, when I rewrite java code to python, I always see a performance increase, but that could be as much due to the language as it is due to rewritng in general leads to performance improvements."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Correction: several people have pointed out that java isn't so bad at object creation any more.  So, in your example, it's something else.  Perhaps it's autoboxing that's expensive, perhaps python's default hashing algorithm is better in this case.  In my practical experience, when I rewrite java code to python, I always see a performance increase, but that could be as much due to the language as it is due to rewritng in general leads to performance improvements.", "childNum": 0, "tag": "i", "pos": -1, "childList": []}]}], [{"text": ["Another possible explanation is that sets in Python are implemented natively in C code, while HashSet's in Java are implemented in Java itself.", "So, sets in Python should be inherently much faster."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I'd like to dispel a couple myths I saw in the answers:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Java is compiled, yes, to bytecode but ultimately to native code in most runtime environments.", "People who say C is inherently faster aren't telling the entire story, I could make a case that byte compiled languages are inherently faster because the JIT compiler can make machine-specific optimizations that are unavailable to way-ahead-of-time compilers."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["A number of things that could make the differences are:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Python's hash tables and sets are the most heavily optimized objects in Python, and Python's hash function is designed to return similar results for similar inputs: hashing an integer just returns the integer, guaranteeing that you will NEVER see a collision in a hash table of consecutive integers in Python.", "tag": "none", "senID": 3}, {"text": "A secondary effect of the above is that the Python code will have high locality of reference as you'll be accessing the hash table in sequence.  ", "tag": "none", "senID": 4}, {"text": "Java does some fancy boxing and unboxing of integers when you add them to collections.  On the bonus side, this makes arithmetic way faster in Java than Python (as long as you stay away from bignums) but on the downside it means more allocations than you're used to.", "tag": "none", "senID": 5}]}], [{"text": ["Edit: A TreeSet might be faster for the real use case, depending on allocation patterns.", "My comments below deals only with this simplified scenario.", "However, I do not believe that it would make a very significant difference.", "The real issue lays elsewhere. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Edit: A TreeSet might be faster for the real use case, depending on allocation patterns. My comments below deals only with this simplified scenario. However, I do not believe that it would make a very significant difference. The real issue lays elsewhere.", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Several people here has recommended replacing the HashSet with a TreeSet.", "This sounds like a very strange advice to me, since there's no way that a data structure with O(log n) insertion time is faster then a O(1) structure that preallocates enough buckets to store all the elements."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's some code to benchmark this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import java.util.*;\nclass SpeedTest\n{    \n    public static void main(String[] args)\n    {        \n        long startTime;\n        long totalTime;\n        int iterations = 10000000;\n        Set counts;\n\n        System.out.println(\"HashSet:\");\n        counts = new HashSet((2*iterations), 0.75f);\n        startTime = System.currentTimeMillis();\n        for(int i=0; i&lt;iterations; i++) {\n            counts.add(i);\n        }\n        totalTime = System.currentTimeMillis() - startTime;\n        System.out.println(\"TOTAL TIME = \"+( totalTime/1000f) );\n        System.out.println(counts.size());\n\n        counts.clear();\n\n        System.out.println(\"TreeSet:\");\n        counts = new TreeSet();\n        startTime = System.currentTimeMillis();\n        for(int i=0; i&lt;iterations; i++) {\n            counts.add(i);\n        }\n        totalTime = System.currentTimeMillis() - startTime;\n        System.out.println(\"TOTAL TIME = \"+( totalTime/1000f) );\n        System.out.println(counts.size());\n    }\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["And here's the result on my machine:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n $ java -Xmx1024M SpeedTest\nHashSet:\nTOTAL TIME = 4.436\n10000000\nTreeSet:\nTOTAL TIME = 8.163\n10000000\n</code>\n</pre>\n", "senID": 5}, {"text": ["Several people also argued that boxing isn't a performance issue and that object creation is inexpensive.", "While it's true that object creation is fast, it's definitely not as fast as primitives:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import java.util.*;\nclass SpeedTest2\n{    \n    public static void main(String[] args)\n    {        \n        long startTime;\n        long totalTime;\n        int iterations = 10000000;\n\n        System.out.println(\"primitives:\");\n        startTime = System.currentTimeMillis();\n        int[] primitive = new int[iterations];\n        for (int i = 0; i &lt; iterations; i++) {\n            primitive[i] = i;\n        }\n        totalTime = System.currentTimeMillis() - startTime;\n        System.out.println(\"TOTAL TIME = \"+( totalTime/1000f) );\n\n        System.out.println(\"primitives:\");\n        startTime = System.currentTimeMillis();\n        Integer[] boxed = new Integer[iterations];\n        for (int i = 0; i &lt; iterations; i++) {\n            boxed[i] = i;\n        }\n        totalTime = System.currentTimeMillis() - startTime;\n        System.out.println(\"TOTAL TIME = \"+( totalTime/1000f) );\n    }\n}\n</code>\n</pre>\n", "senID": 7}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n $ java -Xmx1024M SpeedTest2\nprimitives:\nTOTAL TIME = 0.058\nprimitives:\nTOTAL TIME = 1.402\n</code>\n</pre>\n", "senID": 9}, {"text": ["Moreover, creating a lot of objects results in additional overhead from the garbage collector.", "This becomes significant when you start keeping tens of millions of live objects in memory."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I find benchmarks like this to be meaningless.", "I don't solve problems that look like the test case.", "It's not terribly interesting."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'd much rather see a solution for a meaningful linear algebra solution using NumPy and JAMA.", "Maybe I'll try it and report back with results."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'm not too familiar with python, but I do know HashSet can't contain primitives, so when you say counts.add(i) the i there is getting autoboxed into a new Integer(i) call.", "That's probably your problem.  "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "HashSet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "counts.add(i)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "new Integer(i)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["If for some reason you really needed a 'set' of integers between 0 and some large n, its probably best declared as an 'boolean[] set = new boolean[n]'.", "Then you could go through the array and mark items that are in the set as 'true' without incurring the overhead of creating n Integer wrapper objects.", "If you wanted to go further than that you could use a byte[] of size n/8 and use the individual bits directly.", "Or perhaps BigInteger.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["EDIT"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Stop voting my answer up.", "Its wrong.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["No really, its wrong.", "I get comparable performance if I do what the question suggest, populate the set with N Integers.", "if I replace the contents of the for loop with this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Integer[] ints = new Integer[N];\n    for (int i = 0; i &lt; N; ++i) {\n        ints[i] = i;\n    }\n</code>\n</pre>\n", "senID": 6}, {"text": ["Then it only takes 2 seconds.", "If you don't store the Integer at all then it takes less than 200 millis.", "Forcing the allocation of 10000000 Integer objects does take some time, but it looks like most of the time is spent inside the HashSet put operation."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["There's a number of issues here which I'd like to bring together."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First if it's a program that you are only going to run once, does it matter it takes an extra few seconds?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Secondly, this is just one microbenchmarks.", "Microbenchmarks are pointless for comparing performance."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Startup has a number of issues."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The Java runtime is much bigger than Python so takes longer to load from disk and takes up more memory which may be important if you are swapping."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you haven't set -Xms you may be running the GC only to resize the heap.", "Might as well have the heap properly sized at the start."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "-Xms", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It is true that Java starts off interpreting and then compiles.", "Around 1,500 iterations for Sun client [C1] Hotspot and 10,000 for server [C2].", "Server Hotspot will give you better performance eventually, but take more memory.", "We may see client Hotspot use server for very frequently executed code for best of both worlds.", "However, this should not usually be a question of seconds."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Most importantly you may be creating two objects per iteration.", "For most code, you wouldn't be creating these tiny objects for such a proportion of the execution.", "TreeSet may be better on number of objects score, with 6u14 and Harmony getting even better."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Most importantly you may be creating two objects per iteration. For most code, you wouldn't be creating these tiny objects for such a proportion of the execution. TreeSet may be better on number of objects score, with 6u14 and Harmony getting even better.", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Python may possibly be winning by storing small integer objects in references instead of actually have an object.", "That is undoubtably a good optimisation."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["A problem with a lot of benchmarks is you are mixing a lot of different code up in one method.", "You wouldn't write code you cared about like that, would you?", "So why are you attempting to performance test which is unlike code you would actually like to run fast?"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Better data structure: Something like BitSet would seem to make sense (although that has ynchronisation on it, which may or may not impact performance)."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "BitSet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You need to run it multiple times to get a real idea of \"how fast\" each runs.", "The JVM startup time [for one] is adding to the single running time of the Java version."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You're also creating a HashSet with a large initial capacity, which means the backing HashMap will be created with that many available slots, unlike the Python where you create a basic Set.", "Hard to tell if that would hinder though, as when your HashSet grows it will have to reallocate the stored objects."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Are you using the -server flag with the jvm?", "You can't test for performance without it.", "(You also have to warm up the jvm before doing the test."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, you probably want to use TreeSet&lt;Integer&gt;.", "HashSet will be slower in the long run."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "TreeSet&lt;Integer&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["And which jvm are you using?", "The newest I hope."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["When I say use TreeSet, I mean in general, not for this benchmark.", "TreeSet handles the real world issue of non even hashing of objects.", "If you get too many objects in the same bin in a HashSet, you will perform about O(n)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you really want to store primitive types in a set, and do heavy work on it, roll your own set in Java.", "The generic classes are not fast enough for scientific computing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As Ants Aasma mentions, Python bypasses hashing and uses the integer directly.", "Java creates an Integer object (autoboxing), and then casts it to an Object (in your implementation).", "This object must be hashed, as well, for use in a hash set."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "autoboxing", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://java.sun.com/j2se/1.5.0/docs/guide/language/autoboxing.html"}]}, {"text": ["For a fun comparision, try this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Java"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Java", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import java.util.HashSet;\nclass SpeedTest\n{ \n  public static class Element {\n    private int m_i;\n    public Element(int i) {\n      m_i = i;\n    }\n  }\n\n  public static void main(String[] args)\n  {        \n    long startTime;\n    long totalTime;\n    int iterations = 1000000;\n    HashSet&lt;Element&gt; counts = new HashSet&lt;Element&gt;((int)(2*iterations), 0.75f);\n\n    startTime = System.currentTimeMillis();\n    for(int i=0; i&lt;iterations; ++i)\n    {\n      counts.add(new Element(i));\n    }\n    totalTime = System.currentTimeMillis() - startTime;\n    System.out.println(\"TOTAL TIME = \"+( totalTime/1000f) );\n    System.out.println(counts.size());\n  }\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n $java SpeedTest\nTOTAL TIME = 3.028\n1000000\n\n$java -Xmx1G -Xms1G SpeedTest\nTOTAL TIME = 0.578\n1000000\n</code>\n</pre>\n", "senID": 6}, {"text": ["Python"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Python", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/python\nimport time\nimport sys\n\nclass Element(object):\n  def __init__(self, i):\n    self.num = i\n\ndef main(args):    \n    iterations = 1000000\n    counts = set()\n    startTime = time.time();    \n    for i in range(0, iterations):\n        counts.add(Element(i))\n    totalTime = time.time() - startTime\n    print 'total time =',totalTime\n    print len(counts)\n\n\nif __name__ == \"__main__\":\n  main(sys.argv)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n $./speedtest.py \ntotal time = 20.6943161488\n1000000\n</code>\n</pre>\n", "senID": 10}, {"text": ["How's that for 'python is faster than java'?"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["How much memory did you start the JVM with?", "It depends?", "When I run the JVM with your program with 1 Gig of RAM:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ java -Xmx1024M -Xms1024M -classpath . SpeedTest \nTOTAL TIME = 5.682\n10000000\n$ python speedtest.py \ntotal time = 4.48310899734\n10000000\n</code>\n</pre>\n", "senID": 1}, {"text": ["If I run the JVM with less memory, it takes longer ... considerably longer:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ java -Xmx768M -Xms768M -classpath . SpeedTest \nTOTAL TIME = 6.706\n10000000\n$ java -Xmx600M -Xms600M -classpath . SpeedTest \nTOTAL TIME = 14.086\n10000000\n</code>\n</pre>\n", "senID": 3}, {"text": ["I think the HashSet is the performance bottleneck in this particular instance.", "If I replace the HashSet with a LinkedList, the program gets substantially faster."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "HashSet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "HashSet", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "LinkedList", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Finally -- note that Java programs are initially interpreted and only those methods that are called many times are compiled.", "Thus, you're probably comparing Python to Java's interpreter, not the compiler."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Just a stab in the dark here, but some optimizations that Python is making that Java probably isn't:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "The range() call in Python is creating all 10000000 integer objects at once, in optimized C code.  Java must create an Integer object each iteration, which may be slower. ", "tag": "none", "senID": 1}, {"text": "In Python, ints are immutable, so you can just store a reference to a global \"42\", for example, rather than allocating a slot for the object.  I'm not sure how Java boxed Integer objects compare.", "tag": "none", "senID": 2}, {"text": "Many of the built-in Python algorithms and data structures are rather heavily optimized for special cases.  For instance, the hash function for integers is, simply the identity function.  If Java is using a more \"clever\" hash function, this could slow things down quite a bit.  If most of your time is spent in data structure code, I wouldn't be surprised at all to see Python beat Java given the amount of effort that has been spent over the years hand-tuning the Python C implementation.", "tag": "none", "senID": 3}]}], [{"text": ["A few changes for faster Python. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\nimport time\nimport sys\n\nimport psyco                 #&lt;&lt;&lt;&lt;  \npsyco.full()\n\nclass Element(object):\n    __slots__=[\"num\"]        #&lt;&lt;&lt;&lt;\n    def __init__(self, i):\n        self.num = i\n\ndef main(args):    \n    iterations = 1000000\n    counts = set()\n    startTime = time.time();\n    for i in xrange(0, iterations):\n        counts.add(Element(i))\n    totalTime = time.time() - startTime\n    print 'total time =',totalTime\n    print len(counts)\n\nif __name__ == \"__main__\":\n  main(sys.argv)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Before"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (env)~$ python speedTest.py\ntotal time = 8.82906794548\n1000000\n</code>\n</pre>\n", "senID": 3}, {"text": ["After"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n (env)~$ python speedTest.py\ntotal time = 2.44039201736\n1000000\n</code>\n</pre>\n", "senID": 5}, {"text": ["Now some good old cheating and ..."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\nimport time\nimport sys\nimport psyco\n\npsyco.full()\n\nclass Element(object):\n    __slots__=[\"num\"]\n    def __init__(self, i):\n        self.num = i\n\ndef main(args):    \n    iterations = 1000000\n    counts = set()\n    elements = [Element(i) for i in range(0, iterations)]\n    startTime = time.time();\n    for e in elements:\n        counts.add(e)\n    totalTime = time.time() - startTime\n    print 'total time =',totalTime\n    print len(counts)\n\nif __name__ == \"__main__\":\n  main(sys.argv)\n\n(env)~$ python speedTest.py\ntotal time = 0.526521921158\n1000000\n</code>\n</pre>\n", "senID": 7}], [{"text": ["I agree with Gandalf about the startup time.", "Also, you are allocating a huge HashSet which is not at all similar to your python code.", "I imaging if you put this under a profiler, a good chunk of time would be spent there.", "Also, inserting new elements is really going to be slow with this size.", "I would look into TreeSet as suggested."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The biggest issue is probably that what the given code measures is wall time -- what your watch measures -- but what should be measured to compare code runtime is process time -- the amount of time the cpu spend executing that particular code and not other tasks."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "wall time", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Wall%5Ftime"}, {"href": "http://en.wikipedia.org/wiki/Process%5Ftime", "text": "process time", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You can make the Java microbenchamrk much faster, by adding just a simple little extra."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "adding", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n HashSet counts = new HashSet((2*iterations), 0.75f);\n</code>\n</pre>\n", "senID": 1}, {"text": ["becomes"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n HashSet counts = new HashSet((2*iterations), 0.75f) {\n        @Override public boolean add(Object element) { return false; }\n    };\n</code>\n</pre>\n", "senID": 3}, {"text": ["Simple, faster and gets the same result."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You might want to see if you can \"prime\" the JIT compiler into compiling the section of code you're interested in, by perhaps running it as a function once beforehand and sleeping briefly afterwords.", "This might allow the JVM to compile the function down to native code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Well, if you're going to tune the Java program, you might as well tune the Python program too."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import timeit\n&gt;&gt;&gt; timeit.Timer('x = set()\\nfor i in range(10000000):\\n    x.add(i)').repeat(3, 1)\n[2.1174559593200684, 2.0019571781158447, 1.9973630905151367]\n&gt;&gt;&gt; timeit.Timer('x = set()\\nfor i in xrange(10000000):\\n    x.add(i)').repeat(3, 1)\n[1.8742368221282959, 1.8714439868927002, 1.869229793548584]\n&gt;&gt;&gt; timeit.Timer('x = set(xrange(10000000))').repeat(3, 1)\n[0.74582195281982422, 0.73061800003051758, 0.73396801948547363]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Just using xrange makes it about 8% faster on my machine.", "And the expression set(xrange(10000000)) builds exactly the same set, but 2.5x faster (from 1.87 seconds to 0.74)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "xrange", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set(xrange(10000000))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "2.5x faster", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["I like how tuning a Python program makes it shorter.", ":)  But Java can do the same trick.", "As everyone knows, if you want a dense set of smallish integers in Java, you don't use a hash table.", "You use a java.util.BitSet!"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "java.util.BitSet", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n BitSet bits = new BitSet(iterations);\n\nstartTime = System.currentTimeMillis();\nbits.set(0, iterations, true);\ntotalTime = System.currentTimeMillis() - startTime;\nSystem.out.println(\"TOTAL TIME = \"+( totalTime/1000f) );\nSystem.out.println(bits.cardinality());\n</code>\n</pre>\n", "senID": 4}, {"text": ["That should be fairly quick.", "Unfortunately I don't have the time to test it right now."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]