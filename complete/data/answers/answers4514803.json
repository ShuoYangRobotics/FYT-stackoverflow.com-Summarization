[[{"text": ["It's easier to see what's happening if we eliminate the __bases__ magic and write our the classes you're creating explicitly:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__bases__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class StoryHTMLMixin(object):\n    def render(self):\n        return (\"&lt;html&gt;&lt;title&gt;%s&lt;/title&gt;\"\n            \"&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;\"\n            % (self.name, self.content))\n\nclass Story(object, StoryHTMLMixin):\n    def __init__(self, name, content):\n        self.name = name\n        self.content = content\n</code>\n</pre>\n", "senID": 1}, {"text": ["That's the end result of what you're doing--or what it would be if it succeeded.", "It results in the same error."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Notice that this isn't actually diamond inheritance.", "That involves four classes, where two base classes each inherit a common fourth class; Python's multiple inheritance deals with that."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Here you have just three classes, leading to inheritance that looks like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n StoryHTMLMixin &lt;--- Story\n            |   _____/\n            |  |\n            v  v\n           object\n</code>\n</pre>\n", "senID": 5}, {"text": ["Python doesn't know how to resolve this."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I don't know about a workaround for this.", "In principle the solution would be to remove object from the bases of Story at the same time you add StoryHTMLMixin to it, but that isn't allowed for somewhat opaque, internal reasons (TypeError: __bases__ assignment: 'StoryHTMLMixin' deallocator differs from 'object')."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "object", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Story", "childNum": 0, "tag": "code", "childList": []}, {"text": "StoryHTMLMixin", "childNum": 0, "tag": "code", "childList": []}, {"text": "TypeError: __bases__ assignment: 'StoryHTMLMixin' deallocator differs from 'object'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I've never found any practical, real-world use for modifying classes like this anyway.", "It just seems obfuscated and confusing--if you want a class that derives from those two classes, just create a class normally."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Ed:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Here's an approach that does something similar to yours, but without modifying classes in-place.", "Note how it returns a new class, deriving dynamically from the arguments of the function.", "This is much clearer--you can't inadvertently modify objects that are already instantiated, for example."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n class Story(object):\n    def __init__(self, name, content):\n        self.name = name\n        self.content = content\n\nclass StoryHTMLMixin(object):\n    def render(self):\n        return (\"&lt;html&gt;&lt;title&gt;%s&lt;/title&gt;\"\n            \"&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;\"\n            % (self.name, self.content))\n\ndef MixIn(TargetClass, MixInClass, name=None):\n    if name is None:\n        name = \"mixed_%s_with_%s\" % (TargetClass.__name__, MixInClass.__name__)\n\n    class CombinedClass(TargetClass, MixInClass):\n        pass\n\n    CombinedClass.__name__ = name\n    return CombinedClass\n\nif __name__ == \"__main__\":\n    MixedStory = MixIn(Story, StoryHTMLMixin, \"MixedStory\")\n    my_story = MixedStory(\"My Life\", \"&lt;p&gt;Is good.&lt;/p&gt;\")\n    print my_story.render()\n</code>\n</pre>\n", "senID": 11}], [{"text": ["EDIT: My bad, the bug is a separate issue (thanks @Glenn Maynard).", "The following hack still works, as long as your mixin inherits directly from object."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "object", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class Text(object): pass\nclass Story(Text):\n    ....\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, I think that mixins are not the neatest solution to your problem.", "Both other solutions provided (a class decorator and an ordinary subclass) clearly mark the Story class as renderable, while your solution conceals this fact.", "That is, the existence of the render method in the other solutions is explicit while in your solution it is hidden.", "I think this will cause confusion later, especially if you come to rely more heavily on the mixin methodology."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Story", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "render", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "explicit", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Personally I like the class decorator."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Why don't you use mixins directly instead of hacking around in the mro?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Story(object):\n    def __init__(self, name, content):  \n     self.name = name\n     self.content = content    \n\nclass StoryHTMLMixin(object):\n    def render(self):\n     return (\"&lt;html&gt;&lt;title&gt;%s&lt;/title&gt;\"\n         \"&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;\"\n         % (self.name, self.content))\n\nclass StoryHTML(Story, StoryHTMLMixin):\n    pass\n\n\nprint StoryHTML('asd','asdf').render() # works just fine\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you really, really, really want to glue extra methods on a class, that is not a big problem.", "Well, except that it's evil and bad practice.", "Anyways, you can change a class at any time: "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # first, the story\nx = Story('asd','asdf')\n\n# changes a class object\ndef stick_methods_to_class( cls, *methods):\n    for m in methods:\n        setattr(cls, m.__name__, m)\n\n# a bare method to glue on\ndef render(self):\n return (\"&lt;html&gt;&lt;title&gt;%s&lt;/title&gt;\"\n     \"&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;\"\n     % (self.name, self.content))\n\n# change the class object\nstick_methods_to_class(Story, render)\n\nprint x.render()\n</code>\n</pre>\n", "senID": 3}, {"text": ["But in the end, the question remains: Why should classes suddenly grow extra methods?", "That's the stuff horror movies are made of ;-)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You could try using a decorator to add the functionality instead:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def render(obj):\n  return (\"&lt;html&gt;&lt;title&gt;%s&lt;/title&gt;\"\n    \"&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;\"\n    % (obj.name, obj.content))\n\ndef renderable(cls):\n  cls.render = render\n  return cls\n\n@renderable\nclass Story(object):\n  ...\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Others have suggested better solutions -- such as explicit construction of the\ndesired class -- but to answer your edited question, it is possible to define\nthe mixin without resorting to old-style classes:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "possible", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Base(object): pass\n\nclass Story(Base):\n    def __init__(self, name, content):  \n     self.name = name\n     self.content = content    \n\nclass StoryHTMLMixin(Base):\n    def render(self):\n     return (\"&lt;html&gt;&lt;title&gt;%s&lt;/title&gt;\"\n         \"&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;\"\n         % (self.name, self.content))\n\ndef MixIn(TargetClass, MixInClass):\n    if MixInClass not in TargetClass.__bases__:\n        TargetClass.__bases__ = (MixInClass,)+TargetClass.__bases__\n\nif __name__ == \"__main__\":\n    my_story = Story(\"My Life\", \"&lt;p&gt;Is good.&lt;/p&gt;\")\n    # plug-in the MixIn here\n    MixIn(Story, StoryHTMLMixin)\n    # now I can render the story as HTML\n    print my_story.render()\n</code>\n</pre>\n", "senID": 1}, {"text": ["yields"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &lt;html&gt;&lt;title&gt;My Life&lt;/title&gt;&lt;body&gt;&lt;p&gt;Is good.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Aside from everything said by the previous answers (and being evil and a bad idea), your problem is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]