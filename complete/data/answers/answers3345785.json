[[{"text": ["An iterator is just an object which has a pointer to the next object to be read by some kind of buffer or stream, it's like a LinkedList where you don't know how many things you have until you iterate through them.", "Iterators are meant to be efficient because all they do is tell you what is next by references instead of using indexing (but as you saw you lose the ability to see how many entries are next)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["No, any method will require you to resolve every result.", "You can do iter_length = len(list(iterable)), but running that on an infinite iterator will of course never return.", "It also will consume the iterator and it will need to be reset if you want to use the contents."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "iter_length = len(list(iterable))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Telling us what real problem you're trying to solve might help us find you a better way to accomplish your actual goal."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: Using list() will read the whole iterable into memory at once, which may be undesirable.", "Another way is to do sum(1 for _ in iterable) as another person posted.", "That will avoid keeping it in memory."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "list()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sum(1 for _ in iterable)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["There are two ways to get the length of \"something\" on a computer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first way is to store a count - this requires anything that touches the file/data to modify it (or a class that only exposes interfaces -- but it boils down to the same thing)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The other way is to iterate over it and count how big it is."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Kinda.", "You could check the __lenght_hint__ method, but be warned that it's a undocumented implementation detail (following message in thread), that could very well vanish or summon nasal demons instead."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "could", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "__lenght_hint__", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://mail.python.org/pipermail/python-dev/2009-April/088109.html", "text": "undocumented implementation detail", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://mail.python.org/pipermail/python-dev/2009-April/088110.html", "text": "following message in thread", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Otherwise, no.", "Iterators are just an object that only expose the next() method.", "You can call it as many times as required and they may or may not eventually raise StopIteration.", "Luckily, this behaviour is most of the time transparent to the coder.", ":)"], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "next()", "tag": "a", "pos": 1, "childList": [{"text": "next()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#iterator.next"}, {"text": "next()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "StopIteration", "tag": "a", "pos": 2, "childList": [{"text": "StopIteration", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/exceptions.html#exceptions.StopIteration"}, {"text": "StopIteration", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["No.", "It's not possible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import random\n\ndef gen(n):\n    for i in xrange(n):\n        if random.randint(0, 1) == 0:\n            yield i\n\niterator = gen(10)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Length of iterator is unknown until you iterate through it."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "iterator", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Regarding your original question, the answer is still that there is no way in general to know the length of an iterator in Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Given that you question is motivated by an application of the pysam library, I can give a more specific answer: I'm a contributer to PySAM and the definitive answer is that SAM/BAM files do not provide an exact count of aligned reads.", "Nor is this information easily available from a BAM index file.", "The best one can do is to estimate the approximate number of alignments by using the location of the file pointer after reading a number of alignments and extrapolating based on the total size of the file.", "This is enough to implement a progress bar, but not a method of counting alignments in constant time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This code should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; iter = (i for i in range(50))\n&gt;&gt;&gt; sum(1 for _ in iter)\n50\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's common practice to put this type of information in the file header, and for pysam to give you access to this.", "I don't know the format, but have you checked the API?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As others have said, you can't know the length from the iterator."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]