[[{"text": ["I would have your object keep a reference to all of its parents.", "Then, when it should be destroyed, it would notify its parents.", "If you're already using an event system, this should integrate nicely with the rest of the game."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A nice way to avoid forcing your parent to explicitly notify the object whenever the reference is dropped or added is to use some sort of proxy.", "Python supports properties that will allow for code like self.weapon = Weapon() to actually hand off the duty of setting the weapon attribute to the new weapon to a user defined function."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "properties", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "self.weapon = Weapon()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here's some example code using properties:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Weapon(object):\n    def __init__(self, name):\n        self.name = name\n        self.parent = None\n    def destroy(self):\n        if self.parent:\n            self.parent.weaponDestroyed()\n\ndef WeaponRef():\n    def getWeapon(self):\n        return self._weapon\n    def setWeapon(self, newWeapon):\n        if newWeapon == None: #ensure that this is a valid weapon\n            delWeapon(self)\n            return\n        if hasattr(self, \"weapon\"): #remove old weapon's reference to us\n            self._weapon.parent = None\n        self._weapon = newWeapon\n        newWeapon.parent = self\n    def delWeapon(self):\n        if hasattr(self, \"weapon\"):\n            self._weapon.parent = None\n            del self._weapon\n    return property(getWeapon, setWeapon, delWeapon)\n\nclass Parent(object):\n    weapon = WeaponRef()\n    def __init__(self, name, weapon=None):\n        self.name = name\n        self.weapon = weapon\n    def weaponDestroyed(self):\n        print \"%s deleting reference to %s\" %(self.name, self.weapon.name)\n        del self.weapon\n\n\nw1 = Weapon(\"weapon 1\")\nw2 = Weapon(\"weapon 2\")\nw3 = Weapon(\"weapon 3\")\np1 = Parent(\"parent 1\", w1)\np2 = Parent(\"parent 2\")\n\nw1.destroy()\n\np2.weapon = w2\nw2.destroy()\n\np2.weapon = w3\nw3.destroy()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now if you're doing some sort of inventory system, where a player can have more than 1 weapon and any one of them can be destroyed at any time, then you're going to have to write your own collection class.", "For something like that, just keep in mind that x[2] calls x.__getitem__(2), x[2] = 5 calls x.__setitem__(2, 5) and del x[2] calls x.__delitem__(2)"], "childNum": 7, "tag": "p", "senID": 4, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "x[2]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x.__getitem__(2)", "childNum": 0, "tag": "code", "childList": []}, {"text": "x[2] = 5", "childNum": 0, "tag": "code", "childList": []}, {"text": "x.__setitem__(2, 5)", "childNum": 0, "tag": "code", "childList": []}, {"text": "del x[2]", "childNum": 0, "tag": "code", "childList": []}, {"text": "x.__delitem__(2)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You're conflating two meanings of the \"destroying\" idea.", "The Item should get destroyed in a \"gameplay\" sense.", "Let the garbage collector worry about when to destroy it as an object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Who has a reference to the Item?", "Perhaps the player has it in his inventory, or it is in a room in the game.", "In either case your Inventory or Room objects know about the Item.", "Tell them the Item has been destroyed (in a gameplay sense) and let them handle that.", "Perhaps they'll now keep a reference to a \"broken\" Item.", "Perhaps they'll keep track of it, but not display it to the user.", "Perhaps they'll delete all references to it, in which case the object in memory will soon be deleted."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The beauty of object-oriented programming is that you can abstract these processes away from the Item itself: pass the messages to whoever needs to know, and let them implement in their own way what it means for the Item to be destroyed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Assuming you call a method when the item is used, you could always return a boolean value indicating whether it's broken."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["How about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\n_items = defaultdict(set)\n_owner = {}\n\nclass CanHaveItems(object):\n    @property\n    def items(self):\n        return iter(_items[self])\n    def take(self, item):\n        item.change_owner(self)\n    def lose(self, item):\n        \"\"\" local cleanup \"\"\"\n\nclass _nobody(CanHaveItems):\n    def __repr__(self):\n        return '_nobody'\n_nobody = _nobody()\n\nclass Destroyed(object):\n    def __repr__(self):\n        return 'This is an ex-item!'\n\nclass Item(object):\n    def __new__(cls, *a, **k):\n        self = object.__new__(cls)\n        _owner[self] = _nobody\n        _items[_nobody].add(self)\n        self._damage = .0\n        return self\n    def destroy(self):\n        self.change_owner(_nobody)\n        self.__class__ = Destroyed\n    @property\n    def damage(self):\n        return self._damage\n    @damage.setter\n    def damage(self, value):\n        self._damage = value\n        if self._damage &gt;= 1.:\n            self.destroy()\n    def change_owner(self, new_owner):\n        old_owner = _owner[self]\n        old_owner.lose(self)\n        _items[old_owner].discard(self)\n        _owner[self] = new_owner\n        _items[new_owner].add(self)\n\n\nclass Ball(Item):\n    def __init__(self, color):\n        self.color = color\n    def __repr__(self):\n        return 'Ball(%s)' % self.color\n\nclass Player(CanHaveItems):\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return 'Player(%s)' % self.name\n\nball = Ball('red')\nball = Ball('blue')\n\njoe = Player('joe')\njim = Player('jim')\n\nprint list(joe.items), ':', list(jim.items)\njoe.take(ball)\nprint list(joe.items), ':', list(jim.items)\njim.take(ball)\nprint list(joe.items), ':', list(jim.items)\n\nprint ball, ':', _owner[ball], ':', list(jim.items)\nball.damage += 2\nprint ball, ':', _owner[ball], ':', list(jim.items)\n\nprint _items, ':', _owner\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One option would be to use a signal system"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Firstly, we have a reusable class that lets you define a signal"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Signal(object):\n    def __init__(self):\n         self._handlers = []\n\n    def connect(self, handler):\n         self._handlers.append(handler)\n\n    def fire(self, *args):\n         for handler in self._handlers:\n             handler(*args)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Your item class uses this signal to create a destroyed signal that other classes can listen for."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Item(object):\n    def __init__(self):\n        self.destroyed = Signal()\n\n    def destroy(self):\n        self.destroyed.fire(self)\n</code>\n</pre>\n", "senID": 4}, {"text": ["And inventory listens to the signals from the items and updates its internal state accordingly"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class Inventory(object):\n     def __init__(self):\n         self._items = []\n\n     def add(self, item):\n         item.destroyed.connect(self.on_destroyed)\n         self._items.add(item)\n\n     def on_destroyed(self, item):\n         self._items.remove(item)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["at first: i don't have any python experience, so think about this in a more general way"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["your item should neither know or care ... your Item should have an interface that says it is something destroyable.", "containers and other objects that care about things that can be destroyed, can make use of that interface"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["that destroyable interface could have some option for consuming objects to register a callback or event, triggered when the item gets destroyed"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]