[[{"text": ["-2 is not correct for the values you have specified, and byte order matters.", "struct uses &gt; for big-endian (most-significant byte first) and &lt; for little-endian (least-significant byte first):"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "&gt;", "childNum": 0, "tag": "code", "childList": []}, {"text": "&lt;", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import struct\n&gt;&gt;&gt; struct.pack('&gt;h',-2)\n'\\xff\\xfe'\n&gt;&gt;&gt; struct.pack('&lt;h',-2)\n'\\xfe\\xff'\n&gt;&gt;&gt; p1=chr(254) # 0xFE\n&gt;&gt;&gt; p0=chr(255) # 0xFF\n&gt;&gt;&gt; struct.unpack('&lt;h',p1+p0)[0]\n-2\n&gt;&gt;&gt; struct.unpack('&gt;h',p0+p1)[0]\n-2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Generally, when using struct, your format string should start with one of the alignment specifiers.", "The default, native one differs from machine to machine."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "alignment specifiers", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/struct.html#byte-order-size-and-alignment"}]}, {"text": ["Therefore, the correct result is"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; struct.unpack('!h',p0+p1)[0]\n-20761\n</code>\n</pre>\n", "senID": 2}, {"text": ["The representation of -2 in big endian is:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "endian", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/484764/endianness-theory-and-concept"}]}, {"code": "<pre>\n<code>\n 1111 1111 1111 1110 # binary\n  255        254    # decimal bytes\n  f   f    f    e   # hexadecimal bytes\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can easily verify that by adding two, which results in 0."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["With the first method (256*ord(p1) + ord(p0)), you could check to see if the first bit is 1 with if p1 &amp; 0x80 &gt; 0.", "If so then you'd use p1 &amp; 0x7f instead of p1 and then negate the end result."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "256*ord(p1) + ord(p0)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "if p1 &amp; 0x80 &gt; 0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "p1 &amp; 0x7f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "p1", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Your original equation will work fine if you use masking to take off the extra 1 bits in a negative number:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 256*(ord(p0) &amp; 0xff) + (ord(p1) &amp; 0xff)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: I think I might have misunderstood your question.", "You're trying to convert two positive byte values into a negative integer?", "This should work:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = 256*ord(p0) + ord(p1)\nif a &gt; 32767: # 0x7fff\n    a -= 65536 # 0x10000\n</code>\n</pre>\n", "senID": 3}], [{"text": ["For the record, you can do it without struct.", "Your original equation can be used, but if the result is greater than 32767, subtract 65536.", "(Or if the high-order byte is greater than 127, which is the same thing.", ") Look up two's complement, which is how all modern computers represent negative integers."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n p1 = chr(231)\np0 = chr(174)\n\na = 256 * ord(p1) + ord(p0) - (65536 if ord(p1) &gt; 127 else 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This gets you the correct answer of -6226.", "(The correct answer is not -2."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "is not -2.", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["If you are converting values from a file that is large, use the array module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "array", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/array.html"}]}, {"text": ["For a file, know that it is the endianess of the file format that matters.", "Not the endianess of the machine that either wrote it or is reading it. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Alex Martelli, of course, has the definitive answer. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "the definitive answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1400012/endianness-of-integers-in-python"}]}]]