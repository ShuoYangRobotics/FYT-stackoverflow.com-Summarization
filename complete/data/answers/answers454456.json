[[{"text": ["You can use mmap to map the file to memory.", "The file contents can then be accessed like a normal string:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re, mmap\n\nwith open('/var/log/error.log', 'r+') as f:\n  data = mmap.mmap(f.fileno(), 0)\n  mo = re.search('error: (.*)', data)\n  if mo:\n    print \"found error\", mo.group(1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This also works for big files, the file content is internally loaded from disk as needed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This depends on the file and the regex.", "The best thing you could do would be to read the file in line by line but if that does not work for your situation then might get stuck with pulling the whole file into memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Lets say for example that this is your file:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Lorem ipsum dolor sit amet, consectetur\nadipiscing elit. Ut fringilla pede blandit\neros sagittis viverra. Curabitur facilisis\nurna ABC elementum lacus molestie aliquet.\nVestibulum lobortis semper risus. Etiam\nsollicitudin. Vivamus posuere mauris eu\nnulla. Nunc nisi. Curabitur fringilla fringilla\nelit. Nullam feugiat, metus et suscipit\nfermentum, mauris ipsum blandit purus,\nnon vehicula purus felis sit amet tortor.\nVestibulum odio. Mauris dapibus ultricies\nmetus. Cras XYZ eu lectus. Cras elit turpis,\nultrices nec, commodo eu, sodales non, erat.\nQuisque accumsan, nunc nec porttitor vulputate,\nerat dolor suscipit quam, a tristique justo\nturpis at erat.\n</code>\n</pre>\n", "senID": 2}, {"text": ["And this was your regex:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n consectetur(?=\\sadipiscing)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now this regex uses positive lookahead and will only match a string of \"consectetur\" if it is immediately followed by any whitepace character and then a string of \"adipiscing\"."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "positive lookahead", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/lookaround.html"}]}, {"text": ["So in this example you would have to read the whole file into memory because your regex is depending on the entire file being parsed as a single string.", "This is one of many examples that would require you to have your entire string in memory for a particular regex to work."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I guess the unfortunate answer is that it all depends on your situation."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Open the file and iterate over the lines."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fd = open('myfile')\nfor line in fd:\n    if re.match(...,line)\n        print line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If this is a big deal and worth some effort, you can convert the regular expression into a finite state machine which reads the file.", "The FSM can be of O(n) complexity which means it will be a lot faster as the file size gets big."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You will be able to efficiently match patterns that span lines in files too large to fit in memory."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here are two places that describe the algorithm for converting a regular expression to a FSM:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["http://swtch.com/~rsc/regexp/regexp1.html"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["http://www.math.grin.edu/~rebelsky/Courses/CS362/98F/Outlines/outline.07.html"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}]}], [{"text": ["For single line patterns you can iterate over the lines of the file, but for multi-line patterns, You will have to read all (or part, but that'll be hard to keep track of) of the file into memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This is one way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nREGEX = '\\d+'\n\nwith open('/tmp/workfile', 'r') as f:\n      for line in f:\n          print re.match(REGEX,line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Another approach which comes to my mind is to use read(size) and file.seek(offset) method, which will read a portion of the file size at a time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nREGEX = '\\d+'\n\nwith open('/tmp/workfile', 'r') as f:\n      filesize = f.size()\n      part = filesize / 10 # a suitable size that you can determine ahead or in the prog.\n      position = 0 \n      while position &lt;= filesize: \n          content = f.read(part)\n          print re.match(REGEX,content)\n          position = position + part\n          f.seek(position)\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can also combine these two there you can create generator that would return contents a certain bytes at the time and iterate through that content to check your regex.", "This IMO would be a good approach."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]