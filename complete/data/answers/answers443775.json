[[{"text": ["Python doesn't have variables, it has objects and names.", "When you do "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "objects and names", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/python-objects.htm"}]}, {"code": "<pre>\n<code>\n c = Class()\n</code>\n</pre>\n", "senID": 1}, {"text": ["you're doing two things:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The object you created doesn't have any concept of a \"variable name\" -- If later you do"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n a = c\n</code>\n</pre>\n", "senID": 4}, {"text": ["then the same object is accessible in exactly the same way using the names a and c. You can delete the name a, and the object would still exist."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the objects you create need to have a name, the best way is to pass it to them explicitly, "], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "explicitly", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0020/"}]}, {"code": "<pre>\n<code>\n class Class(object):\n    def __init__(self, name):\n        self.name = name\n\nvar = Class('var')\n</code>\n</pre>\n", "senID": 7}], [{"text": ["You can't do this.", "The reason for this is that the object of the class is created first, and only afterwards is this object bound to the name of the instance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can't (short of incredible hacks like examining the stack frame and inspecting the bytecode).", "There may not even be a name, or there could be multiple such names.", "What should be given for the following code fragments for instance:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "be", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n l = [Class(), Class()]\na=b=c=d=Class()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't think this would be possible because the assignment to the variable of your new instance occours after the object is fully constructed and initialized and so you don't know the variable name it will be assigned to within init method"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "init", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["I am unaware of a way to access a variable's name programmatically without using deep reflection and a debugger.", "I do not think the information is available at runtime."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to give instances a (unique?", ") name, you should probably make the initializer accept an extra argument."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def __init__(self, name):\n    self.name = name\n</code>\n</pre>\n", "senID": 2}, {"text": ["And the caller should pass in the appropriate name:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n c = Class(\"c\")\n</code>\n</pre>\n", "senID": 4}], [{"text": ["This is a scope issue, you can't do what you're asking.", "Because c would be declared outside  your class' scope, your instance is unaware of what its been named in code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Perhaps if you can provide a broader explanation of what you're trying to accomplish a better solution can be suggested."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["To persist data objects you need to use the database record's unique ID."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["pesudo code because I don't know what database module you're using"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "pesudo code because I don't know what database module you're using", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import db # assume this is your db module\n\nclass Class(object):\n    def __init__(self):\n        self.id = None\n        self.name = None\n\n    def get_by_id(self, id):\n        records = db.execute('select * from table where id=%s' % str(id))\n        if records:\n            self.id = records[0]['id']\n            self.name = records[0]['name']\n\n    def save(self):\n        db.execute('update table set name=%s where id=%s' % (self.name, str(self.id)))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Again, this is pseudo code, the string injection technique I'm using is NOT advised as its fairly insecure, its just there to illustrate how to persist using classes with a db."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["That isn't possible.", "You seem to be confusing variables and objects."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In any case there may well not be a variable:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["e.g."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n foo(Class())\n\nClass().arbitraryMethod()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or multiple:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a = b = Class()\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I have the same thought several years ago.", "This is somekind of neat feature, but the language creator doesn't provide it.", "And I thought they are all fool to not discover this great feature."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But then come to think about that.", "I think the logic is impossible.", "say:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Class(object):\n    def __init__(self):\n        self.instance_name.move() # self.instance_name refer to var\n    def move(self):\n        print \"move\"\n\nvar = Class()\n</code>\n</pre>\n", "senID": 2}, {"text": ["now if the var is an array is that possible too ?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n var[0] = Class() # i think it will get confused a bit\n</code>\n</pre>\n", "senID": 4}, {"text": ["that's what i think of, i don't think that assigning the instance into itself is possible.", "and in some language I just sent the instance string into the object then using eval to execute the function"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]