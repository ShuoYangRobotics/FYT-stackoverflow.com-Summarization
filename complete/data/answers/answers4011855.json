[[{"text": ["No need for regular expressions here.", "Some background:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import socket\n&gt;&gt;&gt; socket.inet_aton('255.255.255.255')\n'\\xff\\xff\\xff\\xff'\n&gt;&gt;&gt; socket.inet_aton('255.255.255.256')\nTraceback (most recent call last):\n  File \"&lt;input&gt;\", line 1, in &lt;module&gt;\nerror: illegal IP address string passed to inet_aton\n&gt;&gt;&gt; socket.inet_aton('my name is nobody')\nTraceback (most recent call last):\n  File \"&lt;input&gt;\", line 1, in &lt;module&gt;\nerror: illegal IP address string passed to inet_aton\n</code>\n</pre>\n", "senID": 1}, {"text": ["So:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import socket\n\ndef ip_address_is_valid(address):\n    try: socket.inet_aton(address)\n    except socket.error: return False\n    else: return True\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that addresses like '127.1' could be acceptable on your machine (there are systems, including MS Windows and Linux, where missing octets are interpreted as zero, so '127.1' is equivalent to '127.0.0.1', and '10.1.4' is equivalent to '10.1.0.4').", "Should you require that there are always 4 octets, change the last line from:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n else: return True\n</code>\n</pre>\n", "senID": 5}, {"text": ["into:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n else: return address.count('.') == 3\n</code>\n</pre>\n", "senID": 7}], [{"text": ["You can check a 4-octet IP address easily without regexes at all.", "Here's a tested working method:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "tested working", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def valid_ip(ip):\n...    parts = ip.split('.')\n...    return (\n...        len(parts) == 4\n...        and all(part.isdigit() for part in parts)\n...        and all(0 &lt;= int(part) &lt;= 255 for part in parts)\n...        )\n...\n&gt;&gt;&gt; valid_ip('1.2.3.4')\nTrue\n&gt;&gt;&gt; valid_ip('1.2.3.4.5')\nFalse\n&gt;&gt;&gt; valid_ip('1.2.   3   .4.5')\nFalse\n&gt;&gt;&gt; valid_ip('1.256.3.4.5')\nFalse\n&gt;&gt;&gt; valid_ip('1.B.3.4')\nFalse\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You need to check the allowed numbers in each position.", "For the first optional digit, acceptable values are 0-2.", "For the second, 0-5 (if the first digit for that part is present, otherwise 0-9), and 0-9 for the third."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["I found this annotated example at http://www.regular-expressions.info/regexbuddy/ipaccurate.html :"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.regular-expressions.info/regexbuddy/ipaccurate.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/regexbuddy/ipaccurate.html"}]}, {"code": "<pre>\n<code>\n \\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Regex is for pattern matching, but to check for a valid IP, you need to check for the range (i.e.", "0 &lt;= n &lt;= 255)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You may use regex to check for range, but that'll be a bit overkill.", "I think you're better off checking for basic patter and then check for the range for each number."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For example, use the following pattern to match an IP:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then check whether each number is within range."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["IP addresses can also be checked with split as follows,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n all(map((lambda x: 0&lt;=x&lt;=255),map(int,ip.split('.')))) and len(ip.split(\".\"))==4\n</code>\n</pre>\n", "senID": 1}, {"text": ["For me thats a little bit more readable than regex."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I think people are taking this too far I suggest you first do this:\nips = re.findall('(?:[\\d]{1,3}).(?:[\\d]{1,3}).(?:[\\d]{1,3}).(?", ":[\\d]{1,3})', page)\nthen split the 4 numbers where there is a '.", "' and check and see if they are smaller than 256"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]