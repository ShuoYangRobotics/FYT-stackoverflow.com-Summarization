[[{"text": ["You could extend the list class and override it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class myList(list):\n  def __str__(self):\n    # do something\n    return \"something\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: removed an incorrect part of the answer which suggested dynamically replacing __str__ on the list object, which is not allowed in the implementation of Python lists."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__str__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This solution works without a wrapper.", "And works if you join two lists by add.", "Any operation that modify the list itself will work as expected.", "Only functions that return a copy of the list like: sorted, reveresed will return the native python list which is fine.", "sort and reverse on the other hand operate on the list itself and will keep the type."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class myList(list):\n    def __new__(cls, data=None):\n        obj = super(myList, cls).__new__(cls, data)\n        return obj\n\n    def __str__(self):\n        return 'myList(%s)' % list(self)\n\n    def __add__(self, other):\n        return myList(list(self) + list(other))\n\n&gt;&gt;&gt; l = myList(range(5))\n&gt;&gt;&gt; print l\nmyList([0, 1, 2, 3, 4])\n&gt;&gt;&gt; print l + [1, 2]\nmyList([0, 1, 2, 3, 4, 1, 2])\n&gt;&gt;&gt; l.sort()\n&gt;&gt;&gt; print l\nmyList([0, 1, 2, 3, 4])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you would like to override __str__ for other containers (e.g., tuple), you can take advantage of multiple inheritance:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__str__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class PrettyStr(object):\n    def __str__(self):\n        ret = ''\n\n        if isinstance(self, (list, tuple)):\n            ret = ''.join(str(elem) for elem in self)\n        else:\n            pass  # handle other types here\n\n        return ret\n\n\nclass MyList(PrettyStr, list):\n    pass\n\n\nclass MyTuple(PrettyStr, tuple):\n    pass\n\n\nif __name__ == \"__main__\":\n    print MyList([1, 2, 3, 4])\n    print MyTuple((1, 2, 3, 4))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm a Java programmer but I think that is what you want (tested with python 2.6): "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class myList(list):\n...   def __str__(self):\n...     return \"aaa\"\n...\n&gt;&gt;&gt; def myListWrapper(list):\n...   return myList(list)\n...\n&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; type(a)\n&lt;type 'list'&gt;\n&gt;&gt;&gt; b = myListWrapper(a)\n&gt;&gt;&gt; type(b)\n&lt;class '__main__.myList'&gt;\n&gt;&gt;&gt; print(a)\n[1, 2, 3]\n&gt;&gt;&gt; print(b)\naaa\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n class MyList(list):\n     def __str__(self):\n             return \"foo\"\n\nstr(MyList([1, 2, 3]))\n</code>\n</pre>\n", "senID": 0}, {"text": ["'foo'"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n str(MyList(list([1, 2, 3])))\n</code>\n</pre>\n", "senID": 2}, {"text": ["'foo'"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["My earlier comments as an answer.", "As you can see MyList accepts any sequence in its constructor."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Which raises the question: why do you want to override the __str__ method?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Wouldnt it be better to create a class to encapsulate your object?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class MyContainer(object):\n    def __init__(self, list):\n        self.containedList = list\n\n    def __str__(self):\n        print('All hail Python')\n</code>\n</pre>\n", "senID": 2}, {"text": ["This way you don't have to worry about converting your object, or copying the attributes, or whatsoever.", "(by the way, how expensive is MyList(longlist)?", "Is it an intelligent copy, or a dumb \"let's recreate a list object from an iterable?", "\")"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If, at some point, it looks complicated to do what you're trying to do, it might mean that you're doing it wrong :p"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["How about wrapping the list?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class StrList(object):\n    def __init__(self, data=None):\n    \tself._data = data or []\n    def __str__(self):\n    \treturn \"StrList!\"\n    def __getattr__(self, attr):\n    \tif attr == \"_data\":\n    \t\treturn self.__dict__[attr]\n    \treturn getattr(self._data, attr)\n    def __setattr__(self, key, val):\n    \tif key == \"_data\":\n    \t\tself.__dict__[key] = val\n    \telse:\n    \t\tsetattr(self._data, key, val)\n    def __getitem__(self, index):\n    \treturn self._data[index]\n    def __setitem__(self, index, value):\n    \tself._data[index] = value\n\n\n&gt;&gt;&gt; l = StrList(range(3))\n&gt;&gt;&gt; print l\nStrList!\n&gt;&gt;&gt; l[0]\n0\n&gt;&gt;&gt; for x in l:\n    print x\n\n\n0\n1\n2\n&gt;&gt;&gt; l[0] = \"spam\"\n&gt;&gt;&gt; l.append(\"egg\")\n&gt;&gt;&gt; print list(l)\n['spam', 1, 2, 'egg']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}]]