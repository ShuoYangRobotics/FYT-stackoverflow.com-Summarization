[[{"text": ["The question you reference asks which languages promote both OO and functional programming.", "Python does not promote functional programming even though it works fairly well."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "promote", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "works", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["The best argument against functional programming in Python is that imperative/OO use cases are carefully considered by Guido, while functional programming use cases are not.", "When I write imperative Python, it's one of the prettiest languages I know.", "When I write functional Python, it becomes as ugly and unpleasant as your average language that doesn't have a BDFL."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "against", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Which is not to say that it's bad, just that you have to work harder than you would if you switched to a language that promotes functional programming or switched to writing OO Python."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here are the functional things I miss in Python:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 8, "lis": [{"text": ["Pattern matching"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}, {"text": ["Tail recursion"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}, {"text": ["Large library of list functions"], "childNum": 0, "tag": "a", "senID": 6, "childList": []}, {"text": ["Functional dictionary class"], "childNum": 0, "tag": "a", "senID": 7, "childList": []}, {"text": ["Automatic currying"], "childNum": 0, "tag": "a", "senID": 8, "childList": []}, {"text": ["Concise way to compose functions"], "childNum": 0, "tag": "a", "senID": 9, "childList": []}, {"text": "Lazy lists", "tag": "none", "senID": 10}, {"text": "Simple, powerful expression syntax (Python's simple block syntax prevents Guido from adding it)", "tag": "none", "senID": 11}]}, {"tag": "ul", "num": 5, "lis": [{"text": "No pattern matching and no tail recursion mean your basic algorithms have to be written imperatively. Recursion is ugly and slow in Python.", "tag": "none", "senID": 12}, {"text": "A small list library and no functional dictionaries mean that you have to write a lot of stuff yourself. ", "tag": "none", "senID": 13}, {"text": "No syntax for currying or composition means that point-free style is about as full of punctuation as explicitly passing arguments.", "tag": "none", "senID": 14}, {"text": "Iterators instead of lazy lists means that you have to know whether you want efficiency or persistence, and to scatter calls to ", "tag": "none", "senID": 15}, {"text": "Python's simple imperative syntax, along with its simple LL1 parser, mean that a better syntax for if-expressions and lambda-expressions is basically impossible. Guido likes it this way, and I think he's right.", "tag": "none", "senID": 16}]}], [{"text": ["Guido has a good explanation of this here.", "Here's the most relevant part:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python-history.blogspot.com/2009/04/origins-of-pythons-functional-features.html"}]}, {"text": ["I pull two things out of this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Scheme doesn't have algebraic data types or pattern matching but it's certainly a functional language.", "Annoying things about Python from a functional programming perspective:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On the other hand, python has lexical closures, Lambdas, and list comprehensions (which are really a \"functional\" concept whether or not Guido admits it).", "I do plenty of \"functional-style\" programming in Python, but I'd hardly say it's ideal."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I would never call Python \u201cfunctional\u201d but whenever I program in Python the code invariably ends up being almost purely functional."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Admittedly, that's mainly due to the extremely nice list comprehension.", "So I wouldn't necessarily suggest Python as a functional programming language but I would suggest functional programming for anyone using Python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Python is almost a functional language.", "It's \"functional lite\".  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It has extra features, so it isn't pure enough for some.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It also lacks some features, so it isn't complete enough for some.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The missing features are relatively easy to write.", "Check out posts like this on FP in Python."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "this", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://blog.sigfpe.com/2008/02/purely-functional-recursive-types-in.html"}]}, {"text": ["Check the answers to this question on functional programming languages.", "The comments are more informative than my lame answer."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/779800/a-gentler-introduction-to-functional-programming"}]}], [{"text": ["Let me demonstrate with a piece of code taken from an answer to a \"functional\" Python question on SO"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1016997/generate-from-generators/1017105#1017105"}]}, {"text": ["Python:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def grandKids(generation, kidsFunc, val):\n  layer = [val]\n  for i in xrange(generation):\n    layer = concat(itertools.imap(kidsFunc, layer))\n  return layer\n\ndef concat(xs):\n  for x in xs:\n    for val in x:\n      yield val\n</code>\n</pre>\n", "senID": 2}, {"text": ["Haskell:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n grandKids generation kidsFunc val =\n  iterate (concatMap kidsFunc) [val] !! generation\n</code>\n</pre>\n", "senID": 4}, {"text": ["The main difference here is that Haskell's standard library has useful functions for functional programming: in this case iterate, concat, and (!!"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "iterate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "concat", "childNum": 0, "tag": "code", "childList": []}, {"text": "(!!)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Maybe this article will help clear it up."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Maybe this article will help clear it up", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/library/l-prog.html"}]}]]