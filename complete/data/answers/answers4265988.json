[[{"text": ["scipy.stats.rv_discrete might be what you want.", "You can supply your probabilities via the values parameter.", "You can then use the rvs() method of the distribution object to generate random numbers."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "scipy.stats.rv_discrete", "tag": "a", "pos": 0, "childList": [{"text": "scipy.stats.rv_discrete", "tag": "code"}], "childNum": 1, "href": "http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.html"}, {"text": "scipy.stats.rv_discrete", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "values", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "rvs()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["(OK, I know you are asking for shrink-wrap, but maybe those home-grown solutions just weren't succinct enough for your liking.", ":-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum(p for j,p in pdf if j &lt; i)) for i,_ in pdf]\nR = max(i for r in [random.random()] for i,c in cdf if c &lt;= r)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I pseudo-confirmed that this works by eyeballing the output of this expression:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n sorted(max(i for r in [random.random()] for i,c in cdf if c &lt;= r)\n       for _ in range(1000))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["you might want to have a look at NumPy Random sampling distributions"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Random sampling distributions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/reference/routines.random.html"}]}], [{"text": ["Make a list of items, based on their weights:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "weights", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n items = [1, 2, 3, 4, 5, 6]\nprobabilities= [0.1, 0.05, 0.05, 0.2, 0.4, 0.2]\n# if the list of probs is normalized (sum(probs) == 1), omit this part\nprob = sum(probabilities) # find sum of probs, to normalize them\nc = (1.0)/prob # a multiplier to make a list of normalized probs\nprobabilities = map(lambda x: c*x, probabilities)\nprint probabilities\n\nml = max(probabilities, key=lambda x: len(str(x)) - str(x).find('.'))\nml = len(str(ml)) - str(ml).find('.') -1\namounts = [ int(x*(10**ml)) for x in probabilities]\nitemsList = list()\nfor i in range(0, len(items)): # iterate through original items\n  itemsList += items[i:i+1]*amounts[i]\n\n# choose from itemsList randomly\nprint itemsList\n</code>\n</pre>\n", "senID": 1}, {"text": ["An optimization may be to normalize amounts by the greatest common divisor, to make the target list smaller."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also, this might be interesting."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2570690/python-algorithm-to-randomly-select-a-key-based-on-proportionality-weight"}]}], [{"text": ["Another answer, probably faster :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n distribution = [(1, 0.2), (2, 0.3), (3, 0.5)]  \n# init distribution  \ndlist = []  \nsumchance = 0  \nfor value, chance in distribution:  \n    sumchance += chance  \n    dlist.append((value, sumchance))  \nassert sumchance == 1.0 # not good assert because of float equality  \n\n# get random value  \nr = random.random()  \n# for small distributions use lineair search  \nif len(distribution) &lt; 64: # don't know exact speed limit  \n    for value, sumchance in dlist:  \n        if r &lt; sumchance:  \n            return value  \nelse:  \n    # else (not implemented) binary search algorithm\n</code>\n</pre>\n", "senID": 1}], [{"text": ["An advantage to generating the list using CDF is that you can use binary search.", "While you need O(n) time and space for preprocessing, you can get k numbers in O(k log n).", "Since normal Python lists are inefficient, you can use array module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "array", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If you insist on constant space, you can do the following; O(n) time, O(1) space."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def random_distr(l):\n    r = random.uniform(0, 1)\n    s = 0\n    for item, prob in l:\n        s += prob\n        if s &gt;= r:\n            return item\n    return l[-1]  # Might occur because of floating point inaccuracies\n</code>\n</pre>\n", "senID": 2}]]