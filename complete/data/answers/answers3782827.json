[[{"text": ["The crucial distinction between Python's __init__ and those other languages constructors is that __init__ is not a constructor: it's an initializer (the actual constructor (if any, but, see later;-) is __new__ and works completely differently again).", "While constructing all superclasses (and, no doubt, doing so \"before\" you continue constructing downwards) is obviously part of saying you're constructing a subclass's instance, that is clearly not the case for initializing, since there are many use cases in which superclasses' initialization needs to be skipped, altered, controlled -- happening, if at all, \"in the middle\" of the subclass initialization, and so forth."], "childNum": 10, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "constructors", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "initializer", "childNum": 0, "tag": "strong", "childList": []}, {"text": "constructor", "childNum": 0, "tag": "strong", "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "childList": []}, {"text": "constructing", "childNum": 0, "tag": "strong", "childList": []}, {"text": "constructing", "childNum": 0, "tag": "strong", "childList": []}, {"text": "initializing", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Basically, super-class delegation of the initializer is not automatic in Python for exactly the same reasons such delegation is also not automatic for any other methods -- and note that those \"other languages\" don't do automatic super-class delegation for any other method either... just for the constructor (and if applicable, destructor), which, as I mentioned, is not what Python's __init__ is.", "(Behavior of __new__ is also quite peculiar, though really not directly related to your question, since __new__ is such a peculiar constructor that it doesn't actually necessarily need to construct anything -- could perfectly well return an existing instance, or even a non-instance... clearly Python offers you a lot more control of the mechanics than the \"other languages\" you have in mind, which also includes having no automatic delegation in __new__ itself!-)."], "childNum": 9, "tag": "p", "senID": 1, "childList": [{"text": "any", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "just", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "childList": []}, {"text": "lot", "childNum": 0, "tag": "strong", "childList": []}, {"text": "also", "childNum": 0, "tag": "em", "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["\"Explicit is better than implicit.", "\" It's the same reasoning that indicates we should explicitly write 'self'."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think in in the end it is a benefit-- can you recite all of the rules Java has regarding calling superclasses' constructors?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'm somewhat embarrassed when people parrot the \"Zen of Python\", as if it's a justification for anything.", "It's a design philosophy; particular design decisions can always be explained in more specific terms--and they must be, or else the \"Zen of Python\" becomes an excuse for doing anything."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "always", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["The reason is simple: you don't necessarily construct a derived class in a way similar at all to how you construct the base class.", "You may have more parameters, fewer, they may be in a different order or not related at all."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class myFile(object):\n    def __init__(self, filename, mode):\n        self.f = open(filename, mode)\nclass readFile(myFile):\n    def __init__(self, filename):\n        super(readFile, self).__init__(filename, \"r\")\nclass tempFile(myFile):\n    def __init__(self, mode):\n        super(tempFile, self).__init__(\"/tmp/file\", mode)\nclass wordsFile(myFile):\n    def __init__(self, language):\n        super(wordsFile, self).__init__(\"/usr/share/dict/%s\" % language, \"r\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["This applies to all derived methods, not just __init__."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Right now, we have a rather long page describing the method resolution order in case of multiple inheritance: http://www.python.org/download/releases/2.3/mro/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.python.org/download/releases/2.3/mro/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/download/releases/2.3/mro/"}]}, {"text": ["If constructors were called automatically, you'd need another page of at least the same length explaining the order of that happening.", "That would be hell..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Maybe __init__ is the method that the subclass needs to override.", "Sometimes subclasses need the parent's function to run before they add class-specific code, and other times they need to set up instance variables before calling the parent's function.", "Since there's no way Python could possibly know when it would be most appropriate to call those functions, it shouldn't guess."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If those don't sway you, consider that __init__ is Just Another Function.", "If the function in question were dostuff instead, would you still want Python to automatically call the corresponding function in the parent class?"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dostuff", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Often the subclass has extra parameters which can't be passed to the superclass."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["i believe the one very important consideration here is that with an automatic call to super.__init__(), you proscribe, by design, when that initialization method is called, and with what arguments.", "eschewing automatically calling it, and requiring the programmer to explicitly do that call, entails a lot of flexibility. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "super.__init__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["after all, just because class B is derived from class A does not mean A.__init__() can or should be called with the same arguments as B.__init__().", "making the call explicit means a programmer can have e.g.", "define B.__init__() with completely different parameters, do some computation with that data, call A.__init__() with arguments as appropriate for that method, and then do some postprocessing.", "this kind of flexibility would be awkward to attain if A.__init__() would be called from B.__init__() implicitly, either before B.__init__() executes or right after it. "], "childNum": 7, "tag": "p", "senID": 1, "childList": [{"text": "A.__init__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "B.__init__()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "B.__init__()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "A.__init__()", "childNum": 0, "tag": "code", "childList": []}, {"text": "A.__init__()", "childNum": 0, "tag": "code", "childList": []}, {"text": "B.__init__()", "childNum": 0, "tag": "code", "childList": []}, {"text": "B.__init__()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Java and C++ require that a base class constructor is called because of memory layout."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "require", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If you have a class BaseClass with a member field1, and you create a new class SubClass that adds a member field2, then an instance of SubClass contains space for field1 and field2.", "You need a constructor of BaseClass to fill in field1, unless you require all inheriting classes to repeat BaseClass's initialization in their own constructors.", "And if field1 is private, then inheriting classes can't initialise field1."], "childNum": 13, "tag": "p", "senID": 1, "childList": [{"text": "BaseClass", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "field1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "SubClass", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "field2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "SubClass", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "field1", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "field2", "childNum": 0, "tag": "code", "childList": []}, {"text": "BaseClass", "childNum": 0, "tag": "code", "childList": []}, {"text": "field1", "childNum": 0, "tag": "code", "childList": []}, {"text": "BaseClass", "childNum": 0, "tag": "code", "childList": []}, {"text": "field1", "childNum": 0, "tag": "code", "childList": []}, {"text": "can't", "childNum": 0, "tag": "strong", "childList": []}, {"text": "field1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Python is not Java or C++.", "All instances of all user-defined classes have the same 'shape'.", "They're basically just dictionaries in which attributes can be inserted.", "Before any initialisation has been done, all instances of all user-defined classes are almost exactly the same; they're just places to store attributes that aren't storing any yet."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "exactly the same", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["So it makes perfect sense for a Python subclass not to call its base class constructor.", "It could just add the attributes itself if it wanted to.", "There's no space reserved for a given number of fields for each class in the hierarchy, and there's no difference between an attribute added by code from a BaseClass method and an attribute added by code from a SubClass method."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "BaseClass", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "SubClass", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If, as is common, SubClass actually does want to have all of BaseClass's invariants set up before it goes on to do its own customisation, then yes you can just call BaseClass.__init__() (or use super, but that's complicated and has its own problems sometimes).", "But you don't have to.", "And you can do it before, or after, or with different arguments.", "Hell, if you wanted you could call the BaseClass.__init__ from another method entirely than __init__; maybe you have some bizarre lazy initialization thing going."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "SubClass", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "BaseClass", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "BaseClass.__init__()", "childNum": 0, "tag": "code", "childList": []}, {"text": "super", "childNum": 0, "tag": "code", "childList": []}, {"text": "BaseClass.__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Python achieves this flexibility by keeping things simple.", "You initialise objects by writing an __init__ method that sets attributes on self.", "That's it.", "It behaves exactly like a method, because it is exactly a method.", "There are no other strange and unintuitive rules about things having to be done first, or things that will automatically happen if you don't do other things.", "The only purpose it needs to serve is to be a hook to execute during object initialisation to set initial attribute values, and it does just that.", "If you want it to do something else, you explicitly write that in your code."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]