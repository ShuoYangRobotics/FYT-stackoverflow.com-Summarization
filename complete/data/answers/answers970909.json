[[{"text": ["Assuming we're talking about the classic (CPython) implementation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In other words, Python threads are really much less rich than Java's -- not to mention that only one thread per process can in fact run Python code (others may be running C code or waiting)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For anything fancy, i.e.", "anything beyond Python's limited threading capabilities, it's recommended you use the multiprocessing module from the standard library -- or switch to implementations of Python that let you use richer threading approaches, such as Jython for the JVM or IronPython for .NET."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "multiprocessing", "tag": "a", "pos": 1, "childList": [{"text": "multiprocessing", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/multiprocessing.html"}, {"text": "multiprocessing", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Regular java thread priorities can't be counted on.", "You may find a lower priority thread running when a higher priority thread is ready and waiting. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is something called \"realtime java\" (see http://www.rtsj.org) which does enforce thread priority, at least for the RealtimeThread class.", "Regular java.lang.Thread may still not enforce true priority ordering."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.rtsj.org", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.rtsj.org"}]}], [{"text": ["I felt the need to debunk the common myths perpetuated here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Not in the OS sense.", "But you can use cooperative multitasking and your own custom scheduler to ensure that certain threads use more time.", "You can also set the timeslices between a thread with this: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://docs.python.org/library/sys.html#sys.setcheckinterval"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://docs.python.org/library/sys.html#sys.setcheckinterval", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/sys.html#sys.setcheckinterval"}]}, {"text": ["Note that you can do it.", "Its just difficult, and people will wax philosophical about how it is evil.", "But this is true in any language.", "You can either use the following API function:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "can", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["http://docs.python.org/c-api/init.html#PyThreadState_SetAsyncExc"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://docs.python.org/c-api/init.html#PyThreadState_SetAsyncExc", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/c-api/init.html#PyThreadState_SetAsyncExc"}]}, {"text": ["Or you can use your underlying OS like TerminateThread in windows off the TID.", "Just be sure to acquire the global lock."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I don't believe so.", "They are for controlling groups of threads."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Read the thread and threading module."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["here's an example of how I allow my threads to be halted (only works for threads within loops really, unless you wanted to place an if \"self.alive\" before every line):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import threading, Queue\n\nclass HaltableThread(object.Thread):\n    def __init__(self):\n    \tself.stringQueue = Queue.Queue()\n    \tself.alive = True\n    def run(self):\n    \twhile self.alive:\n    \t\ttry:\n    \t\t\tdata = self.stringQueue.read(0.01) #100ms block until data\n    \t\texcept Queue.Empty:\n    \t\t\tpass\n    \t\telse:\n    \t\t\tprint data\n    def stop(self):\n    \tself.alive = False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just a sidestep about point 1 here, because Java Thread priorities might not work as one would expect."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["From the SCJP guide:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Unfortunately the standard Python package has something called the GIL, or global interpreter lock.", "This means only one of your threads will ever be running at a time.", "That being said, simple multithreaded applications are possible and pretty easy to write.", "The threading module contains basic synchronization primitives like mutexes, sempahores, etc.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is also an awesome with statement that automates most aspects of lock usages.", "For an example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import threading\nmyLock = threading.Lock()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then to use the lock:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n with myLock:\n    #lock has now been acquired\n    print \"I have the lock and can now to fun stuff\"\nprint \"The lock has been released\"\n</code>\n</pre>\n", "senID": 4}]]