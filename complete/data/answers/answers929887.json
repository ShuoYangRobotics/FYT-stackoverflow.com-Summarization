[[{"text": ["lines are just data delimited by the newline char '\\n'."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "'\\n'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["1) Since lines are variable length, you have to read the entire file to know where the newline chars are, so you can count how many lines:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n count = 0\nfor line in open('myfile'):\n    count += 1\nprint count, line # it will be the last line\n</code>\n</pre>\n", "senID": 2}, {"text": ["2) reading a chunk from the end of the file is the fastest method to find the last newline char."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def seek_newline_backwards(file_obj, eol_char='\\n', buffer_size=200):\n    if not file_obj.tell(): return # already in beginning of file\n    # All lines end with \\n, including the last one, so assuming we are just \n    # after one end of line char\n    file_obj.seek(-1, os.SEEK_CUR)\n    while file_obj.tell():\n        ammount = min(buffer_size, file_obj.tell())\n        file_obj.seek(-ammount, os.SEEK_CUR)\n        data = file_obj.read(ammount)\n        eol_pos = data.rfind(eol_char)\n        if eol_pos != -1:\n            file_obj.seek(eol_pos - len(data) + 1, os.SEEK_CUR)\n            break\n        file_obj.seek(-len(data), os.SEEK_CUR)\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can use that like this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n f = open('some_file.txt')\nf.seek(0, os.SEEK_END)\nseek_newline_backwards(f)\nprint f.tell(), repr(f.readline())\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Let's not forget"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open(\"myfile.txt\")\nlines = f.readlines()\n\nnumlines = len(lines)\nlastline = lines[-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["NOTE: this reads the whole file in memory as a list.", "Keep that in mind in the case that the file is very large."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The easiest way is simply to read the file into memory.", "eg:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "easiest", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n f = open('filename.txt')\nlines = f.readlines()\nnum_lines = len(lines)\nlast_line = lines[-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["However for big files, this may use up a lot of memory, as the whole file is loaded into RAM.", "An alternative is to iterate through the file line by line.", "eg:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f = open('filename.txt')\nnum_lines = sum(1 for line in f)\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is more efficient, since it won't load the entire file into memory, but only look at a line at a time.", "If you want the last line as well, you can keep track of the lines as you iterate and get both answers by:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n f = open('filename.txt')\ncount=0\nlast_line = None\nfor line in f:\n    num_lines += 1\n    last_line = line\nprint \"There were %d lines.  The last was: %s\" % (num_lines, last_line)\n</code>\n</pre>\n", "senID": 5}, {"text": ["One final possible improvement if you need only the last line, is to start at the end of the file, and seek backwards until you find a newline character.", "Here's a question which has some code doing this.", "If you need both the linecount as well though, theres no alternative except to iterate through all lines in the file however."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Here's", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/136168/tail-a-file-with-python"}]}], [{"text": ["For small files that fit memory,\nhow about using str.count() for getting the number of lines of a file:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "str.count()", "tag": "a", "pos": 0, "childList": [{"text": "str.count()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/string.html#string.count"}, {"text": "str.count()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n line_count = open(\"myfile.txt\").read().count('\\n')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'd like too add to the other solutions that some of them (those who look for \\n) will not work with files with OS 9-style line endings (\\r only), and that they may contain an extra blank line at the end because lots of text editors append it for some curious reasons, so you might or might not want to add a check for it."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "\\n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\r", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The only way to count lines [that I know of] is to read all lines, like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n count = 0\nfor line in open(\"file.txt\"): count = count + 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["After the loop, count will have the number of lines read."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "count", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Answer to the first question (beware of poor performance on large files when using this method):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open(\"myfile.txt\").readlines()\nprint len(f) - 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Answer to the second question:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f = open(\"myfile.txt\").read()\nprint f.rfind(\"\\n\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["P.S.", "Yes I do understand that this only suits for small files and simple programs.", "I think I will not delete this answer however useless for real use-cases it may seem."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["For the first question there're already a few good ones, I'll suggest @Brian's one as the best (most pythonic, line ending character proof and memory efficient):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open('filename.txt')\nnum_lines = sum(1 for line in f)\n</code>\n</pre>\n", "senID": 1}, {"text": ["For the second one, I like @nosklo's one, but modified to be more general should be:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import os\nf = open('myfile')\nto = f.seek(0, os.SEEK_END)\nfound = -1\nwhile found == -1 and to &gt; 0:\n  fro = max(0, to-1024)\n  f.seek(fro)\n  chunk = f.read(to-fro)\n  found = chunk.rfind(\"\\n\")\n  to -= 1024\n\nif found != -1:\n  found += fro\n</code>\n</pre>\n", "senID": 3}, {"text": ["It seachs in chunks of 1Kb from the end of the file, until it finds a newline character or the file ends.", "At the end of the code, found is the index of the last newline character."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]