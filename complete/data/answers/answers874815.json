[[{"text": ["Update with code that appears not to work (on windows anyway)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ThreadWorker(threading.Thread):\n    def __init__(self, callable, *args, **kwargs):\n        super(ThreadWorker, self).__init__()\n        self.callable = callable\n        self.args = args\n        self.kwargs = kwargs\n        self.setDaemon(True)\n\n    def run(self):\n        try:\n            self.callable(*self.args, **self.kwargs)\n        except wx.PyDeadObjectError:\n            pass\n        except Exception, e:\n            print e\n\n\n\nif __name__ == \"__main__\":\n    import os\n    from subprocess import Popen, PIPE\n\n    def worker(pipe):\n        while True:\n            line = pipe.readline()\n            if line == '': break\n            else: print line\n\n    proc = Popen(\"python subprocess_test.py\", shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)\n\n    stdout_worker = ThreadWorker(worker, proc.stdout)\n    stderr_worker = ThreadWorker(worker, proc.stderr)\n    stdout_worker.start()\n    stderr_worker.start()\n    while True: pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["stdout will be buffered - so you won't get anything till that buffer is filled, or the subprocess exits."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can try flushing stdout from the sub-process, or using stderr, or changing stdout on non-buffered mode."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "stdout", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It sounds like the issue might be the use of buffered output by the subprocess - if a relatively small amount of output is created, it could be buffered until the subprocess exits.", "Some background can be found here:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.pixelbeat.org/programming/stdio%5Fbuffering/"}]}], [{"text": ["Here's what worked for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n cmd = [\"./tester_script.bash\"]\np = subprocess.Popen( cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE )\nwhile p.poll() is None:\n    out = p.stdout.readline()\n    do_something_with( out, err )\n</code>\n</pre>\n", "senID": 1}, {"text": ["In your case you could try to pass a reference to the sub-process to your Worker Thread, and do the polling inside the thread.", "I don't know how it will behave when two threads poll (and interact with) the same subprocess, but it may work."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also note thate the while p.poll() is None: is intended as is.", "Do not replace it with while not p.poll() as in python 0 (the returncode for successful termination) is also considered False."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "while p.poll() is None:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "while not p.poll()", "childNum": 0, "tag": "code", "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You might try this StackOverflow thread.", "If that's not it, then try this StackOverflow search."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "StackOverflow thread", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/803265/getting-realtime-output-using-subprocess"}, {"text": "StackOverflow search", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/search?q=python%2Bstdout%2Breadline"}]}], [{"text": ["I've been running into this problem as well.", "The problem occurs because you are trying to read stderr as well.", "If there are no errors, then trying to read from stderr would block. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On Windows, there is no easy way to poll() file descriptors (only Winsock sockets)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So a solution is not to try and read from stderr."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I've used the pexpect module for this, it seems to work ok. http://sourceforge.net/projects/pexpect/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://sourceforge.net/projects/pexpect/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/pexpect/"}]}], [{"text": ["Using pexpect [http://www.noah.org/wiki/Pexpect] with non-blocking readlines will resolve this problem.", "It stems from the fact that pipes are buffered, and so your app's output is getting buffered by the pipe, therefore you can't get to that output until the buffer fills or the process dies."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]