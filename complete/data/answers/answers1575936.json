[[{"text": ["In Perl"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while(&lt;&gt;) {\n    my @F=split/\\t/;\n    die \"Invalid line: $_\" if @F!=8 or $F[3]!~/^-?\\d+$/;\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def isfileok(filename):\n  f = open(filename)\n  for line in f:\n    pieces = line.split('\\t')\n    if len(pieces) != 8:\n      return False\n    if not pieces[3].isdigit():\n      return False\n  return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["I assume that by \"column no.", "4\" you mean the 4th one, hence the [3] since Python (like most computer languages) indices from 0."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[3]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Here I'm just returning a boolean result, but I split up the code so it's easy to give good diagnostics about what line is wrong, and how, if you so desire."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["It's very easy work for Perl:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n perl -F\\\\t -ane'die\"Invalid!\"if@F!=8||$F[3]!~/^-?\\d+$/' CHECKME\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Perl:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while (&lt;&gt;) {\n  if (! /^[^\\t]+\\t[^\\t]+\\t[^\\t]+\\t\\d+\\t[^\\t]+\\t[^\\t]+\\t[^\\t]+\\t[^\\t]+$/) {\n    die \"Line $. is bad: $_\";\n  }\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Checks to see that the line starts with one or more non-tabs, followed by a tab, followed by one or more non-tabs, followed by a tab, followed by  one or more non-tabs, followed by a tab, followed by one or more digits, etc.", "until the eighth set of non-tab(s), which must be at the end of the line."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Thats the quick and dirty solution, but in the long run, it'd probably be better to use a \"split /\\t/\" and count the number of fields it gets and then check to make sure field 3 (zero origin) is just digits.", "That way when (not if) the requirements change and you now need 9 fields, with the 9th field being a prime number, it's easy to make the change."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Read files given on the command-line or stdin.", "Print invalid lines.", "Return code is zero if there are no errors or one otherwise."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import fileinput, sys\n\ndef error(msg, line):\n    print &gt;&gt; sys.stderr, \"%s:%d:%s\\terror: %s\" % (\n        fileinput.filename(), fileinput.filelineno(), line, msg)\n    error.count += 1\nerror.count = 0\n\nncol, icol = 8, 3\nfor row in (line.split('\\t') for line in fileinput.input()):\n    if len(row) == ncol:\n        try: int(row[icol])\n        except ValueError:\n            error(\"%dth field '%s' is not integer\" % (\n                (icol + 1), row[icol]), '\\t'.join(row))\n    else:\n        error('wrong number of columns (want: %d, got: %d)' % (\n            ncol, len(row)), '\\t'.join(row))\n\nsys.exit(error.count != 0)\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n$ echo 1 2 3 | python validate-input.py *.txt -\nnot_integer.txt:2:a b\tc\t1.1\te\tf\tg\th\n    error: 4th field '1.1' is not integer\nwrong_cols.txt:3:a  b\t\n    error: wrong number of columns (want: 8, got: 3)\n&lt;stdin>:1:1 2 3\n    error: wrong number of columns (want: 8, got: 1)\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n for n,line in enumerate(open(\"filename\")):\n    line=line.split()\n    if len(line)!=8: \n        print \"line %d error\" % n+1        \n    if not line[3].isdigit(): \n        print \"line %d error\" % n+1\n</code>\n</pre>\n", "senID": 0}]]