[[{"text": ["The collections module has grown a namedtuple function in 2.6:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "collections module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html"}, {"text": "namedtuple", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n import collections\nopt=collections.namedtuple('options','VERBOSE IGNORE_WARNINGS')\nmyoptions=opt(True, False)\n\n&gt;&gt;&gt; myoptions\noptions(VERBOSE=True, IGNORE_WARNINGS=False)\n&gt;&gt;&gt; myoptions.VERBOSE\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["A namedtuple is immutable, so you can only assign field values when you create it."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "namedtuple", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["In earlier Python versions, you can create an empty class:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Python", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class options(object):\n    pass\n\nmyoptions=options()\nmyoptions.VERBOSE=True\nmyoptions.IGNORE_WARNINGS=False\n&gt;&gt;&gt; myoptions.IGNORE_WARNINGS,myoptions.VERBOSE\n(False, True)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Why not just use optparse:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "optparse", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/optparse.html#module-optparse"}]}, {"code": "<pre>\n<code>\n from optparse import OptionParser\n[...]\nparser = OptionParser()\nparser.add_option(\"-f\", \"--file\", dest=\"filename\",\n              help=\"write report to FILE\", metavar=\"FILE\")\nparser.add_option(\"-q\", \"--quiet\",\n              action=\"store_false\", dest=\"verbose\", default=True,\n              help=\"don't print status messages to stdout\")\n\n(options, args) = parser.parse_args()\n\nfile = options.filename\nif options.quiet == True:\n    [...]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you insist on not having to define a class, you can abuse some existing classes.", "Most objects belong to \"new-style\" classes which don't have a dict, but functions can have arbitrary attributes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = lambda: 0   # any function will do\n&gt;&gt;&gt; x.foo = 'bar'\n&gt;&gt;&gt; x.bar = 0\n&gt;&gt;&gt; x.xyzzy = x\n&gt;&gt;&gt; x.foo\n'bar'\n&gt;&gt;&gt; x.bar\n0\n&gt;&gt;&gt; x.xyzzy\n&lt;function &lt;lambda&gt; at 0x6cf30&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["One problem is that functions already have some attributes, so dir(x) is a little messy:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dir(x)\n['__call__', '__class__', '__delattr__', '__dict__', '__doc__',\n'__get__', '__getattribute__', '__hash__', '__init__',\n'__module__', '__name__', '__new__', '__reduce__',\n'__reduce_ex__', '__repr__', '__setattr__', '__str__', 'foo',\n'func_closure', 'func_code', 'func_defaults', 'func_dict',\n'func_doc', 'func_globals', 'func_name', 'xyzzy']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Given your requirements, I'd say the custom class is your best bet:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class options(object):\n    VERBOSE = True\n    IGNORE_WARNINGS = True\n\nif options.VERBOSE:\n    # ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["To be complete, another approach would be using a separate module, i.e.", "options.py to encapsulate your option defaults."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "options.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["options.py:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "options.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n VERBOSE = True\nIGNORE_WARNINGS = True\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then, in main.py:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "main.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import options\n\nif options.VERBOSE:\n    # ...\n</code>\n</pre>\n", "senID": 6}, {"text": ["This has the feature of removing some clutter from your script.", "The default values are easy to find and change, as they are cordoned off in their own module.", "If later your application has grown, you can easily access the options from other modules."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["This is a pattern that I frequently use, and would heartily recommend if you don't mind your application growing larger than a single module.", "Or, start with a custom class, and expand to a module later if your app grows to multiple modules."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I use attrdict:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "attrdict", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/361668/"}]}, {"code": "<pre>\n<code>\n class attrdict(dict):\n    def __init__(self, *args, **kwargs):\n        dict.__init__(self, *args, **kwargs)\n        self.__dict__ = self\n</code>\n</pre>\n", "senID": 1}, {"text": ["Depending on your point of view, you probably think it's either a big kludge or quite clever.", "But whatever you think, it does make for nice looking code, and is compatible with a dict:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ad = attrdict({'foo': 100, 'bar': 200})\n&gt;&gt;&gt; ad.foo\n100\n&gt;&gt;&gt; ad.bar\n200\n&gt;&gt;&gt; ad.baz = 'hello'\n&gt;&gt;&gt; ad.baz\n'hello'\n&gt;&gt;&gt; ad\n{'baz': 'hello', 'foo': 100, 'bar': 200}\n&gt;&gt;&gt; isinstance(ad, dict)\nTrue\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As best practices go, you're really better off with one of the options in David Eyk's answer. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "David Eyk's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/211695/what-is-an-easy-way-to-create-a-trivial-one-off-python-object#212299"}]}, {"text": ["However, to answer your question, you can create a one-off class using the type function:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n options = type('Options', (object,), { 'VERBOSE': True })()\noptions.IGNORE_WARNINGS = False\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note that you can provide an initial dictionary, or just leave it empty   ."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Options = type('Options', (object,), {})\noptions = Options()\noptions.VERBOSE = True\noptions.IGNORE_WARNINGS = False\n</code>\n</pre>\n", "senID": 4}, {"text": ["Not very pythonic."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Just make a module called Options.py, and import it.", "Put your default options values in there as global variables."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Simplifying davraamides's suggestion, one could use the following:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "davraamides's suggestion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/211695/what-is-an-easy-way-to-create-a-trivial-one-off-python-object#211918"}]}, {"code": "<pre>\n<code>\n class attrdict2(object):\n    def __init__(self, *args, **kwargs):\n        self.__dict__.update(*args, **kwargs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["which"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["By the way, it is even easier to initialize instances of attrdict or attrdict2:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "attrdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "attrdict2", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ad = attrdict2(foo = 100, bar = 200)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Granted, attrdict2 is not compatible with a dict."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "attrdict2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you don't need the magic initialization behavior, you can even use"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class attrdict3(object):\n    pass\n\nad = attrdict3()\nad.foo = 100\nad.bar = 200\n</code>\n</pre>\n", "senID": 7}, {"text": ["But I was still hoping for a solution that doesn't require an auxiliary class."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["One can use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class options(object):\n    VERBOSE = True\n    IGNORE_WARNINGS = False\n\noptions.VERBOSE = False\n\nif options.VERBOSE:\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": [", using the class object itself (not an instance of the class!", ") as the place to store individual options.", "This is terse and satisfies all of the requirements, but it seems like a misuse of the class concept.", "It would also lead to confusion if a user instantiated the options class."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "options", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["(If multiple instances of the options-holding objects were needed, this would be a very nice solution--the class definition supplies default values, which can be overridden in individual instances."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The absolutely simplest class to do the job is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Struct:\n    def __init__(self, **entries): \n        self.__dict__.update(entries)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It can be later used as:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n john = Struct(name='john doe', salary=34000)\nprint john.salary\n</code>\n</pre>\n", "senID": 3}, {"text": ["namedtuple (as another commented suggested) is a more advanced class that gives you more functionality.", "If you're still using Python 2.5, the implementation 2.6's namedtuple is based on can be found at http://code.activestate.com/recipes/500261/"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "namedtuple", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "namedtuple", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://code.activestate.com/recipes/500261/", "text": "http://code.activestate.com/recipes/500261/", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["simple object and named tuples are the way to go"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]