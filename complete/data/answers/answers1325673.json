[[{"text": ["A bit late, but I've discovered that it is in fact possible to add a property to a class dynamically.", "You just have to add it to the CLASS, not the object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Foo(object):\n...     def add_property(self, name, func):\n...         setattr(self.__class__, name, property(func))\n... \n&gt;&gt;&gt; foo = Foo()\n&gt;&gt;&gt; foo.a = 3\n&gt;&gt;&gt; foo.add_property('b', lambda self: self.a + 1)\n&gt;&gt;&gt; foo.b\n4\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It seems you could solve this problem much more simply with a namedtuple, since you know the entire list of fields ahead of time."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "namedtuple", "tag": "a", "pos": 0, "childList": [{"text": "namedtuple", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/collections.html#collections.namedtuple"}, {"text": "namedtuple", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from collections import namedtuple\n\nFoo = namedtuple('Foo', ['bar', 'quux'])\n\nfoo = Foo(bar=13, quux=74)\nprint foo.bar, foo.quux\n\nfoo2 = Foo()  # error\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you absolutely need to write your own setter, you'll have to do the metaprogramming at the class level; property() doesn't work on instances."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "property()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You don't need to use a property for that.", "Just override __setattr__ to make them read only."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__setattr__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class C(object):\n    def __init__(self, keys, values):\n        for (key, value) in zip(keys, values):\n            self.__dict__[key] = value\n\n    def __setattr__(self, name, value):\n        raise \"It's read only!\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Tada."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; c = C('abc', [1,2,3])\n&gt;&gt;&gt; c.a\n1\n&gt;&gt;&gt; c.b\n2\n&gt;&gt;&gt; c.c\n3\n&gt;&gt;&gt; c.d\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'C' object has no attribute 'd'\n&gt;&gt;&gt; c.d = 42\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 6, in __setattr__\nException: It's read only!\n&gt;&gt;&gt; c.a = 'blah'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 6, in __setattr__\nException: It's read only!\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Not sure if I completely understand the question, but you can modify instance properties at runtime with the built-in __dict__ of your class:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class C(object):\n    def __init__(self, ks, vs):\n        self.__dict__ = dict(zip(ks, vs))\n\n\nif __name__ == \"__main__\":\n    ks = ['ab', 'cd']\n    vs = [12, 34]\n    c = C(ks, vs)\n    print(c.ab) # 12\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You cannot add a new property() to an instance at runtime, because properties are data descriptors.", "Instead you must dynamically create a new class, or over getattribute in order to process data descriptors on instances."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "getattribute", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"text": ["Only way to dynamically attach a property is to create a new class and its instance with your new property.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Holder: p = property(lambda x: vs[i], self.fn_readonly)\nsetattr(self, k, Holder().p)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The best way to achieve is by defining __slots__.", "That way your instances can't have new attributes."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ks = ['ab', 'cd']\nvs = [12, 34]\n\nclass C(dict):\n    __slots__ = []\n    def __init__(self, ks, vs): self.update(zip(ks, vs))\n    def __getattr__(self, key): return self[key]\n\nif __name__ == \"__main__\":\n    c = C(ks, vs)\n    print c.ab\n</code>\n</pre>\n", "senID": 1}, {"text": ["That prints 12"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "12", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n c.ab = 33\n</code>\n</pre>\n", "senID": 3}, {"text": ["That gives: AttributeError: 'C' object has no attribute 'ab'"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "AttributeError: 'C' object has no attribute 'ab'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["So what you want is a dictionary where you can spell a['b'] as a.b?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That's easy:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class atdict(dict):\n    __getattr__= dict.__getitem__\n    __setattr__= dict.__setitem__\n    __delattr__= dict.__delitem__\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This seems to work(but see below):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class data(dict,object):\n    def __init__(self,*args,**argd):\n        dict.__init__(self,*args,**argd)\n        self.__dict__.update(self)\n    def __setattr__(self,name,value):\n        raise AttributeError,\"Attribute '%s' of '%s' object cannot be set\"%(name,self.__class__.__name__)\n    def __delattr__(self,name):\n        raise AttributeError,\"Attribute '%s' of '%s' object cannot be deleted\"%(name,self.__class__.__name__)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you need more complex behavior, feel free to edit your answer."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["edit"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["The following would probably be more memory-efficient for large datasets:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class data(dict,object):\n    def __init__(self,*args,**argd):\n        dict.__init__(self,*args,**argd)\n    def __getattr__(self,name):\n        return self[name]\n    def __setattr__(self,name,value):\n        raise AttributeError,\"Attribute '%s' of '%s' object cannot be set\"%(name,self.__class__.__name__)\n    def __delattr__(self,name):\n        raise AttributeError,\"Attribute '%s' of '%s' object cannot be deleted\"%(name,self.__class__.__name__)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I asked a similary question on this Stack Overflow post to create a class factory which created simple types.", "The outcome was this answer which had a working version of the class factory.", "Here is a snippet of the answer:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "on this Stack Overflow post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1264833/python-class-factory-to-produce-simple-struct-like-classes"}, {"text": "this answer", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1264833/python-class-factory-to-produce-simple-struct-like-classes/1275088#1275088"}]}, {"code": "<pre>\n<code>\n def Struct(*args, **kwargs):\n    def init(self, *iargs, **ikwargs):\n        for k,v in kwargs.items():\n            setattr(self, k, v)\n        for i in range(len(iargs)):\n            setattr(self, args[i], iargs[i])\n        for k,v in ikwargs.items():\n            setattr(self, k, v)\n\n    name = kwargs.pop(\"name\", \"MyStruct\")\n    kwargs.update(dict((k, None) for k in args))\n    return type(name, (object,), {'__init__': init, '__slots__': kwargs.keys()})\n\n&gt;&gt;&gt; Person = Struct('fname', 'age')\n&gt;&gt;&gt; person1 = Person('Kevin', 25)\n&gt;&gt;&gt; person2 = Person(age=42, fname='Terry')\n&gt;&gt;&gt; person1.age += 10\n&gt;&gt;&gt; person2.age -= 10\n&gt;&gt;&gt; person1.fname, person1.age, person2.fname, person2.age\n('Kevin', 35, 'Terry', 32)\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could use some variation of this to create default values which is your goal (there is also an answer in that question which deals with this)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]