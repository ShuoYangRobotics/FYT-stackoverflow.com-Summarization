[[{"text": ["You probably want something like the next:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; re.findall(r'url=(\\w+)',st)\n['these', 'are', 'test', 'questions']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You've used square brackets [] which select characters.", "You've got [^\\(url=\\)] which matches any character except (, u, r, l, = and )."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "[]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[^\\(url=\\)]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Instead, you want url=([^,]+) which matches 'url=' then proceeds to match until it finds a  non-comma character."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "url=([^,]+)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It's because your regex is splitting based on the letters 'url'."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This works for me:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n re.findall(r'url=([^,]+)',st)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This is not a regex answer, but maybe you want to take it into account:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [14]: st = \"url=these,url=are,url=test,url=questions\"\nIn [15]: [item.strip(',') for item in st.split('url=') if item]\nOut[15]: ['these', 'are', 'test', 'questions']\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n re.findall(r'url=([^,]+)', st)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Your regex is weird... How about this pattern "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [19]: pat = r'url\\=([^,]*)'\n\nIn [20]: re.findall(pat,st)\nOut[20]: ['these', 'are', 'test', 'questions']\n</code>\n</pre>\n", "senID": 1}]]