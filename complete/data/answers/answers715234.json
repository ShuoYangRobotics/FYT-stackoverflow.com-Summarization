[[{"text": ["No, but you can subclass dict to provide notification on change.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ObservableDict( dict ):\n    def __init__( self, *args, **kw ):\n        self.observers= []\n        super( ObservableDict, self ).__init__( *args, **kw )\n    def observe( self, observer ):\n        self.observers.append( observer )\n    def __setitem__( self, key, value ):\n        for o in self.observers:\n            o.notify( self, key, self[key], value )\n        super( ObservableDict, self ).__setitem__( key, value )\n    def update( self, anotherDict ):\n        for k in anotherDict:\n            self[k]= anotherDict[k]\n\nclass Watcher( object ):\n    def notify( self, observable, key, old, new ):\n        print \"Change to \", observable, \"at\", key\n\nw= Watcher()\na= ObservableDict( {'a':'hamburger', 'b':'fries', 'c':'coke'} )\na.observe( w )\nb = {'b':'fries', 'c':'pepsi'}\na.update( b )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that the superclass Watcher defined here doesn't check to see if there was a \"real\" change or not; it simply notes that there was a change."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["one year later"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I like the following solution:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def dictdiff(d1, d2):                                              \n        return dict(set(d2.iteritems()) - set(d1.iteritems()))\n... \n&gt;&gt;&gt; a = {'a':'hamburger', 'b':'fries', 'c':'coke'}\n&gt;&gt;&gt; b = {'b':'fries', 'c':'pepsi', 'd':'ice cream'}\n&gt;&gt;&gt; dictdiff(a, b)\n{'c': 'pepsi', 'd': 'ice cream'}\n</code>\n</pre>\n", "senID": 2}], [{"text": ["No, it doesn't.", "But it's not hard to write a dictionary diff function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def diff(a, b):\n  diff = {}\n  for key in b.keys():\n    if (not a.has_key(key)) or (a.has_key(key) and a[key] != b[key]):\n      diff[key] = b[key]\n  return diff\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def diff_update(dict_to_update, updater):\n    changes=dict((k,updater[k]) for k in filter(lambda k:(k not in dict_to_update or updater[k] != dict_to_update[k]), updater.iterkeys()))\n    dict_to_update.update(updater)\n    return changes\n\na = {'a':'hamburger', 'b':'fries', 'c':'coke'}\nb = {'b':'fries', 'c':'pepsi'}\n&gt;&gt;&gt; print diff_update(a, b)\n{'c': 'pepsi'}\n&gt;&gt;&gt; print a\n{'a': 'hamburger', 'c': 'pepsi', 'b': 'fries'}\n</code>\n</pre>\n", "senID": 0}], [{"text": ["A simple diffing function is easy to write.", "Depending on how often you need it, it may be faster than the more elegant ObservableDict by S.Lott."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def dict_diff(a, b):\n    \"\"\"Return differences from dictionaries a to b.\n\n    Return a tuple of three dicts: (removed, added, changed).\n    'removed' has all keys and values removed from a. 'added' has\n    all keys and values that were added to b. 'changed' has all\n    keys and their values in b that are different from the corresponding\n    key in a.\n\n    \"\"\"\n\n    removed = dict()\n    added = dict()\n    changed = dict()\n\n    for key, value in a.iteritems():\n        if key not in b:\n            removed[key] = value\n        elif b[key] != value:\n            changed[key] = b[key]\n    for key, value in b.iteritems():\n        if key not in a:\n            added[key] = value\n    return removed, added, changed\n\nif __name__ == \"__main__\":\n    print dict_diff({'foo': 1, 'bar': 2, 'yo': 4 }, \n                    {'foo': 0, 'foobar': 3, 'yo': 4 })\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Not built in, but you could iterate on the keys of the dict and do comparisons.", "Could be slow though."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Better solution is probably to build a more complex datastructure and use a dictionary as the underlying representation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]