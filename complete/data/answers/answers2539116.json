[[{"text": ["if statements will skip everything in an else bracket if it evaluates to true.", "It should be noted that worrying about this sort of problem, unless it's done millions of times per program execution, is called \"premature optimization\" and should be avoided.", "If your code is clearer with three if (a and b and c) statements, they should be left in."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "else", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "if (a and b and c)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I would say the single test is as fast as the separate tests.", "Python also makes use of so called short-circuit evaluation."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "short-circuit evaluation", "tag": "a", "pos": 1, "childList": [{"text": "short-circuit evaluation", "tag": "strong"}], "childNum": 1, "href": "http://en.wikipedia.org/wiki/Short-circuit_evaluation"}, {"text": "short-circuit evaluation", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["That means for (a and b and c), that b or c would not be tested anymore if a is false."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "(a and b and c)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "false", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Similar, if you have an OR expression (a or b) and a is true, b is never evaluated."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "OR", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(a or b)", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "true", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So to sum up, the clauses don't fail faster with separation."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "fail faster", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import dis\n\ndef foo():\n  if ( a and b and c):\n    pass\n  else:\n    pass\n\ndef bar():\n  if a:\n    if b:\n      if c:\n        pass\n\nprint 'foo():'\ndis.dis(foo)\nprint 'bar():'\ndis.dis(bar)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n foo():\n  4           0 LOAD_GLOBAL              0 (a)\n              3 JUMP_IF_FALSE           18 (to 24)\n              6 POP_TOP             \n              7 LOAD_GLOBAL              1 (b)\n             10 JUMP_IF_FALSE           11 (to 24)\n             13 POP_TOP             \n             14 LOAD_GLOBAL              2 (c)\n             17 JUMP_IF_FALSE            4 (to 24)\n             20 POP_TOP             \n\n  5          21 JUMP_FORWARD             1 (to 25)\n        &gt;&gt;   24 POP_TOP             \n\n  7     &gt;&gt;   25 LOAD_CONST               0 (None)\n             28 RETURN_VALUE        \nbar():\n 10           0 LOAD_GLOBAL              0 (a)\n              3 JUMP_IF_FALSE           26 (to 32)\n              6 POP_TOP             \n\n 11           7 LOAD_GLOBAL              1 (b)\n             10 JUMP_IF_FALSE           15 (to 28)\n             13 POP_TOP             \n\n 12          14 LOAD_GLOBAL              2 (c)\n             17 JUMP_IF_FALSE            4 (to 24)\n             20 POP_TOP             \n\n 13          21 JUMP_ABSOLUTE           29\n        &gt;&gt;   24 POP_TOP             \n             25 JUMP_ABSOLUTE           33\n        &gt;&gt;   28 POP_TOP             \n        &gt;&gt;   29 JUMP_FORWARD             1 (to 33)\n        &gt;&gt;   32 POP_TOP             \n        &gt;&gt;   33 LOAD_CONST               0 (None)\n             36 RETURN_VALUE\n</code>\n</pre>\n", "senID": 3}, {"text": ["So, although the setup is the same, the cleanup for the combined expression is faster since it leaves only a single value on the stack."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["At least in python, efficiency is second to readability and \"Flat is better than nested\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["See The Zen of Python"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "The Zen of Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0020/"}]}], [{"text": ["If you are worried about b or c being functions that are called instead of just variables that are evaluated, then this code shows that short-circuiting is your friend:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = False\ndef b():\n    print \"b was called\"\n    return True\n\nif a and b():\n    print \"this shouldn't happen\"\nelse:\n    print \"if b was not called, then short-circuiting works\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if b was not called, then short-circuiting works\n</code>\n</pre>\n", "senID": 3}, {"text": ["But if you have code that does this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a = call_to_expensive_function_A()\nb = call_to_expensive_function_B()\nc = call_to_expensive_function_C()\n\nif a and b and c:\n    do something...\n</code>\n</pre>\n", "senID": 5}, {"text": ["then your code is still calling all 3 expensive functions.", "Better to let Python be Python:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n if (call_to_expensive_function_A() and\n    call_to_expensive_function_B() and\n    call_to_expensive_function_C())\n    do something...\n</code>\n</pre>\n", "senID": 7}, {"text": ["which will only call as many expensive functions as necessary to determine the overall condition."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Edit"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You can generalize this using the all built-in:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "all", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # note, this is a list of the functions themselves\n# the functions are *not* called when creating this list\nfuncs = [function_A, function_B, function_C]\n\nif all(fn() for fn in funcs):\n    do something\n</code>\n</pre>\n", "senID": 11}, {"text": ["Now if you have to add other functions, or want to reorder them (maybe function_A is very time-consuming, and you would benefit by filtering cases that fail function_B or function_C first), you just update the funcs list.", "all does short-circuiting just as if you had spelled out the if as if a and b and c.  (If functions are 'or'ed together, use any builtin instead."], "childNum": 7, "tag": "p", "senID": 12, "childList": [{"text": "function_A", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "function_B", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "function_C", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "funcs", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "all", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "if a and b and c", "childNum": 0, "tag": "code", "childList": []}, {"text": "any", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I doubt you'd see a measurable difference so I'd recommend doing whatever makes the code most readable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["if (a and b and c) will fail if a is falsy, and not bother checking b or c."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "if (a and b and c)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["That said, I personally feel that nested conditionals are easier to read than 2^n combinations of conditionals."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In general, if you want to determine which way of doing something is fastest, you can write a simple benchmark using timeit."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "timeit", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/performance_tuning/timeit.html"}]}], [{"text": ["if (a and b and c) is faster and better, for the sake of the \"Real Programmer's code optimization\" and code readability."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if (a and b and c)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]