[[{"text": ["I would use this regular expression in multiline mode:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ^\\s*([a-zA-Z_][a-zA-Z_0-9]*)\\s*=\\s*((?:[^\\\\#]|\\\\.)+)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This allows any character to be escaped (\\\\.).", "If you just want to allow the #, use \\\\# instead."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "\\\\.", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "#", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\\\\#", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I've left a comment about the purpose of this question, but supposing this question is purely about regular expressions, I'll still give the answer a shot."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Assuming you're dealing with input one line at a time, I would go about this as a two-pass phase.", "This means you'll have 2 regular expressions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The reason your regular expression isn't matching as you want is because of the greedy matching behaviour of regular expressions: each part will match the longest substring such that the rest of the string can still be matched with the remainder of the regular expression"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What this means in the case of one of your lines with an escaped # is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "The ", "tag": "none", "senID": 2}, {"text": "The ", "tag": "none", "senID": 3}, {"text": "The final ", "tag": "none", "senID": 4}]}, {"text": ["A simple example to emphasise this potentially unintuitive behaviour: in the regular expression (a*)(ab)?", "(b*), the (ab)?", "will never match anything"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "(a*)(ab)?(b*)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(ab)?", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I believe this regular expression (based on the original one) should work: ^\\s*(\\S+\\s*=([^\\\\#]|\\\\#?)*)?(#.", "*)?$"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "^\\s*(\\S+\\s*=([^\\\\#]|\\\\#?)*)?(#.*)?$", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Of the 5 solutions presented thus far, only Gumbo's actually works.", "Here is my solution, which also works and is heavily commented:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n import re\n\ndef fn(line):\n    match = re.search(\n        r\"\"\"^          # Anchor to start of line\n        (\\s*)          # $1: Zero or more leading ws chars\n        (?:            # Begin group for optional var=value.\n          (\\S+)        # $2: Variable name. One or more non-spaces.\n          (\\s*=\\s*)    # $3: Assignment operator, optional ws\n          (            # $4: Everything up to comment or EOL.\n            [^#\\\\]*    # Unrolling the loop 1st normal*.\n            (?:        # Begin (special normal*)* construct.\n              \\\\.      # special is backslash-anything.\n              [^#\\\\]*  # More normal*.\n            )*         # End (special normal*)* construct.\n          )            # End $4: Value.\n        )?             # End group for optional var=value.\n        ((?:\\#.*)?)    # $5: Optional comment.\n        $              # Anchor to end of line\"\"\", \n        line, re.MULTILINE | re.VERBOSE)\n    return match.groups()\n\nprint (fn(r\" # just a comment\"))\nprint (fn(r\" option1 = value\"))\nprint (fn(r\" option2 = value # no escape == IS a comment\"))\nprint (fn(r\" option3 = value \\# 1 escape == NOT a comment\"))\nprint (fn(r\" option4 = value \\\\# 2 escapes == IS a comment\"))\nprint (fn(r\" option5 = value \\\\\\# 3 escapes == NOT a comment\"))\nprint (fn(r\" option6 = value \\\\\\\\# 4 escapes == IS a comment\"))\n</code>\n</pre>\n", "senID": 1}, {"text": ["The above script produces the following (correct) output: (tested with Python 3.0.1)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n (' ', None, None, None, '# just a comment')\n(' ', 'option1', ' = ', 'value', '')\n(' ', 'option2', ' = ', 'value ', '# no escape == IS a comment')\n(' ', 'option3', ' = ', 'value \\\\# 1 escape == NOT a comment', '')\n(' ', 'option4', ' = ', 'value \\\\\\\\', '# 2 escapes == IS a comment')\n(' ', 'option5', ' = ', 'value \\\\\\\\\\\\# 3 escapes == NOT a comment', '')\n(' ', 'option6', ' = ', 'value \\\\\\\\\\\\\\\\', '# 4 escapes == IS a comment')\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that this solution uses Jeffrey Friedl's \"Unrolling the loop efficiency technique (which eliminates slow alternation).", "It also uses no lookaround at all and is very fast.", "Mastering Regular Expressions (3rd edition) is a must read for anyone claiming to \"know\" regular expressions.", "(And when I say \"know\", I mean in the Neo \"I know Kung-Fu!", "\" sense :)"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Mastering Regular Expressions (3rd edition)", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/0596528124"}, {"text": "must read", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "I know Kung-Fu!", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}], [{"text": ["I wouldn't use a regex for this at all, for the same reason I wouldn't try kill a fly with a thermo-nuclear warhead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Assuming you're reading a line in at a time, just:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "if the first character is a ", "tag": "none", "senID": 2}, {"text": "otherwise, find the first occurrence of ", "tag": "none", "senID": 3}, {"text": "replace all occurrences of ", "tag": "none", "senID": 4}]}, {"text": ["That's it, you now have a proper line and a comment section.", "Use regexes to split up the new line section by all means."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef fn(line):\n    # Split line into non-comment and comment.\n\n    comment = \"\"\n    if line[0] == \"#\":\n        comment = line\n        line = \"\"\n    else:\n        idx = re.search (r\"[^\\\\]#\", line)\n        if idx != None:\n            comment = line[idx.start()+1:]\n            line = line[:idx.start()+1]\n\n    # Split non-comment into key and value.\n\n    idx = re.search (r\"=\", line)\n    if idx == None:\n        key = line\n        val = \"\"\n    else:\n        key = line[:idx.start()]\n        val = line[idx.start()+1:]\n    val = val.replace (\"\\\\#\", \"#\")\n\n    return (key.strip(),val.strip(),comment.strip())\n\nprint fn(r\"someoption1 = some value # some comment\")\nprint fn(r\"# this line is only a comment\")\nprint fn(r\"someoption2 = some value with an escaped \\# hash\")\nprint fn(r\"someoption3 = some value with a \\# hash # some comment\")\n</code>\n</pre>\n", "senID": 7}, {"text": ["produces:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n ('someoption1', 'some value', '# some comment')\n('', '', '# this line is only a comment')\n('someoption2', 'some value with an escaped # hash', '')\n('someoption3', 'some value with a # hash', '# some comment')\n</code>\n</pre>\n", "senID": 9}, {"text": ["If you must use a regex (against my advice), your specific problem lies here:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "must", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [^\\#]\n</code>\n</pre>\n", "senID": 11}, {"text": ["This (assuming you meant the properly escaped r\"[^\\\\#]\") will attempt to match any character other than either \\ or #, not the sequence \\# as you desire.", "You can use negative look-behinds to do it but I always say that, once a regular expression becomes unreadable to a moron in a hurry, it's better to revert to procedural code :-)"], "childNum": 4, "tag": "p", "senID": 12, "childList": [{"text": "r\"[^\\\\#]\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "#", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\\#", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["On reflection, a better way to do it is with a multi-level split (so the regex doesn't have to get too hideous by handling missing fields), as follows:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n def fn(line):\n    line = line.strip()                            # remove spaces\n    first = re.split (r\"\\s*(?&lt;!\\\\)#\\s*\", line, 1)  # get non-comment/comment\n    if len(first) == 1: first.append (\"\")          # ensure we have a comment\n    first[0] = first[0].replace(\"\\\\#\",\"#\")         # unescape non-comment\n\n    second = re.split (r\"\\s*=\\s*\", first[0], 1)    # get key and value\n    if len(second) == 1: second.append (\"\")        # ensure we have a value\n    second.append (first[1])                       # create 3-tuple\n    return second                                  # and return it\n</code>\n</pre>\n", "senID": 14}, {"text": ["This uses the negative look-ahead to correctly match the comment separator then separates the non-comment bit into key and value.", "Spaces are handled correctly in this one as well, yielding:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n ['someoption1', 'some value', 'some comment']\n['', '', 'this line is only a comment']\n['someoption2', 'some value with an escaped # hash', '']\n['someoption3', 'some value with a # hash', 'some comment']\n</code>\n</pre>\n", "senID": 16}], [{"text": ["Try breaking it down into 2 steps:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["BIG HINT: use re.VERBOSE with comments"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]