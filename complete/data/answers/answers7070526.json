[[{"text": ["Simple approach using enumerate:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "enumerate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for n in newlist:\n    for i, t in enumerate(tlist):\n        if t &gt; n:\n            # found upper boundry, previous must be equal or lower\n            upper, lower = t, tlist[i-1]\n            break\n    print lower, n, upper\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Somewhat plain and assuming tlist is sorted"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "tlist", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def find_interval(tlist, item):\n    for lower, upper in zip(tlist[:-1], tlist[1:]):\n        if lower &lt;= item &lt; upper:\n            return (lower, upper)\n    return None # Or raise some \"IntervalNotFoudException\"\n\nprint((find_interval(tlist, item) for item in newlist))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit : Made it shorter using zip"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; tlist = [0.0, 0.07, 0.13, 0.15, 0.2, 0.22]\n&gt;&gt;&gt; newlist = [0.0, 0.04, 0.08, 0.12, 0.16, 0.2]\n&gt;&gt;&gt; def getrange(x):\n...     for i in range(len(tlist)):\n...         if tlist[i] &gt; x:\n...             return tlist[max(0, i-1)], tlist[i]\n&gt;&gt;&gt; [getrange(x) for x in newlist]\n8: [(0.0, 0.07),\n (0.0, 0.07),\n (0.07, 0.13),\n (0.07, 0.13),\n (0.15, 0.2),\n (0.2, 0.22)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Does this help?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You can use the bisect module for this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bisect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/bisect.html"}]}, {"code": "<pre>\n<code>\n import bisect\ndef bisect_range(sortedlist, tofind):\n    for t in tofind:\n        loc = bisect.bisect_right(sortedlist, t)\n        yield (sortedlist[loc-1], sortedlist[loc])\n\ntlist = [0.0, 0.07, 0.13, 0.15, 0.2, 0.22]\nnewlist = [0.0, 0.04, 0.08, 0.12, 0.16, 0.2]\nprint list(bisect_range(sorted(tlist), newlist))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is O(N * log(M)) where M is the length of the sorted list and N is the length of the items being searched, because the bisect_right function is O(log(M)) and we are calling it once for each item in the search list of length N. Sorting the initial list (if it's not already sorted) is O(M * log(M))."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "O(N * log(M))", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "bisect_right", "childNum": 0, "tag": "code", "childList": []}, {"text": "O(log(M))", "childNum": 0, "tag": "em", "childList": []}, {"text": "O(M * log(M))", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Using the code you posted from your question Unexpected output from Newton&#39;s method, here a time function which correctly matches the boundary:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Unexpected output from Newton&#39;s method", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/7078244/unexpected-output-from-newtons-method"}, {"text": "time", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def time() :\n    t_u = 0\n    i = 0\n    while i &lt; len(tlist) - 1:\n        # if the number is in the range\n        # do the calculations and move to the next number\n        if t_u &gt; tlist[i] and t_u &lt; tlist[i + 1] :\n            print \"\\n The t_u value:\", t_u, 'is between',\n            print \"start:\", tlist[i], \" and end: \", tlist[i+1]\n            poly = poly_coeff(tlist[i], tlist[i + 1], t_u)\n            Newton(poly)\n            t_u = t_u + 0.04 # regular time interval\n        # if the number is at the boundary of the range\n        # go to the next number without doing the calculation\n        elif t_u == tlist[i] or t_u == tlist[i + 1] :\n            print \"\\n The t_u value:\", t_u, 'is on the boundary of',\n            print \"start:\", tlist[i], \" and end: \", tlist[i+1]\n            t_u = t_u + 0.04 # regular time interval\n        # if the number isn't in the range, move to the next range\n        else :\n            i += 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If your First Array is Sorted, this should be pretty simple.", "for every number in the array 2 (call it 'z'), iterate once through array one and find the value with highest index which is smaller than z.", "This is your x. then find the smallest index of the value in array 1 which is greater or equal to 'z'.", "This is your y. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Hope that helps.Let me know if you need more explanation.", "Coding this should not be a big deal.", "If you get stuck while coding post the code and I can help you with it. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Thanks\nShaunak "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n tlist = [0.0, 0.07, 0.13, 0.15, 0.2, 0.22]\nnewlist = [0.0, 0.04, 0.08, 0.12, 0.16, 0.2]\n\nfor n in newlist:\n    print n\n    for i in xrange(len(tlist) - 1):\n        if tlist[i] &lt;= n &lt; tlist[i + 1]:\n            print tlist[i], tlist[i + 1]\n            break\n    else:\n        print \"Not found\"\n    print \"\"\n</code>\n</pre>\n", "senID": 0}, {"text": ["This prints out the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n 0.0\n0.0 0.07\n\n0.04\n0.0 0.07\n\n0.08\n0.07 0.13\n\n0.12\n0.07 0.13\n\n0.16\n0.15 0.2\n\n0.2\n0.2 0.22\n</code>\n</pre>\n", "senID": 2}, {"text": ["Assumptions: I assume you want inclusive on the lower bound, and not on the upper bound, and I assume your tlist is sorted."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Many solutions... here's one using iterators:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n tlist = [0.0, 0.07, 0.13, 0.15, 0.2, 0.22]\nnewlist = [0.0, 0.04, 0.08, 0.12, 0.16, 0.2]\n\ndef range_finder(a,b):\n  iter_a = iter(a)\n  lower_a, upper_a = iter_a.next(), iter_a.next()\n  for item in b:\n    while True:\n      if lower_a &lt;= item &lt; upper_a:\n        print \"%s is %s to %s\" % (item,lower_a,upper_a)\n        break\n      else:\n        lower_a = upper_a\n        upper_a = iter_a.next()\n\nrange_finder(tlist,newlist)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Producing:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n0.0 is 0.0 to 0.07\n0.04 is 0.0 to 0.07\n0.08 is 0.07 to 0.13\n0.12 is 0.07 to 0.13\n0.16 is 0.15 to 0.2\n0.2 is 0.2 to 0.22\n</pre>\n", "senID": 3}]]