[[{"text": ["One idea is to sort the data.", "Assume inputdata is your list from above:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "inputdata", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import groupby\nfrom operator import itemgetter\n\ninputdata.sort(key=itemgetter(*inputdata[0])) # ensures order\nprint [k for k, g in groupby(inputdata) if len(list(g)) &gt; 1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [{'line': u'line 666', 'file': u'/file.txt', 'rule': u'A DUPLICATE RULE'}]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I always prefer to work with objects instead of dicts, if the fields are the same for every item."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So, I define a class:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class rule(object):\n    def __init__(self, file, line, rule):\n    \tself.file = file\n    \tself.line = line\n    \tself.rule = rule\n\n    #Not a \"magic\" method, just a helper for all the methods below :)\n    def _tuple_(self):\n    \treturn (self.file, self.line, self.rule)\n\n    def __eq__(self, other):\n    \treturn cmp(self, other) == 0\n\n    def __cmp__(self, other):\n    \treturn cmp(self._tuple_(), rule._tuple_(other))\n\n    def __hash__(self):\n    \treturn hash(self._tuple_())\n\n    def __repr__(self):\n    \treturn repr(self._tuple_())\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now, create a list of these objects, and sort it.", "ruledict_list can be the example data in your question."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "ruledict_list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n rules = [rule(**r) for r in ruledict_list]\nrules.sort()\n</code>\n</pre>\n", "senID": 4}, {"text": ["Loop through the (sorted) list, removing unique objects as we go.", "Finally, create a set, to remove duplicates.", "The loop will also remove one of each duplicate object, but that doesn't really matter."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n pos = 0\nwhile(pos &lt; len(rules)):\n    while pos &lt; len(rules)-1 and rules[pos] == rules[pos+1]:\n    \tprint \"Skipping rule %s\" % rules[pos]\n    \tpos+=1\n    rules.pop(pos)\nrule_set = set(rules)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I'd make another dictionary, using the existing dictionaries as keys and the count of occurrences as values.", "(Python doesn't allow dictionaries to be used as dictionary keys out of the box, but there are a couple of ways of doing that mentioned in this answer.", ") Then it's just a matter of iterating over it and selecting the keys where the value is greater than 1."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this answer", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1151658/python-hashable-dicts"}]}, {"text": ["Of course, using dictionaries as keys relies on their contents not changing over time - at least over the time that you need to use the resulting dictionary.", "(This is why Python doesn't support it natively."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Another way is to make a counter for each dict data, based on a frozenset of items:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from operator import itemgetter\nfrom collections import defaultdict\n\ncounter = defaultdict(int)\nfor d in inputdata:\n    counter[frozenset(d.iteritems())] += 1\n\nresult = [dict(item) for item, count in counter.iteritems() if count &gt; 1]\nprint result\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think that is the best answer so far, because it is very simple to understand and will work linearly."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools\n&gt;&gt;&gt; list(a[0] for a in itertools.groupby(sorted(data)) if len(list(a[1])) &gt; 1)\n[{'file': u'/file.txt', 'line': u'line 666', 'rule': u'A DUPLICATE RULE'}]\n</code>\n</pre>\n", "senID": 0}, {"text": ["There's probably a more optimal way to check this than len(list(a[1]))."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: I added a call to sorted."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Another option is to create your own data structure instead of using a dict.", "If you do this, then you can override __cmp__, __eq__ and __hash__.", "This will give you the ability to then use the 'set' data type in all its glory."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__cmp__", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#object.%5F%5Fcmp%5F%5F"}, {"text": "__eq__", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#object.%5F%5Feq%5F%5F"}, {"text": "__hash__", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#object.%5F%5Fhash%5F%5F"}]}, {"text": ["Here's one possible implementation, though I make no promises about the quality of the hash routine I've provided:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Thing(object):\n    def __init__(self, file, line, rule):\n        self.file = file\n        self.line = line\n        self.rule = rule\n\n    def __cmp__(self, other):\n        result = cmp(self.file, other.file)\n        if result == 0:\n            result = cmp(self.line, other.line)\n        if result == 0:\n            result = cmp(self.rule, other.rule)\n        return result\n\n    def __eq__(self, other):\n        return cmp(self, other) == 0\n\n    def __hash__(self):\n        return hash(self.file) * hash(self.line) * hash(self.rule)\n\n    def __str__(self):\n        return ', '.join([self.file, self.line, self.rule])\n\nthings = [ Thing(u'/file.txt', u'line 666', u'A DUPLICATE RULE'),\n  Thing(u'/file.txt', u'line 666', u'A DUPLICATE RULE'),\n  Thing(u'/uniquefile.txt', u'line 999', u'A UNIQUE RULE')]\n\nduplicate_things = set()\nunique_things = set()\nfor t in things:\n    if t in unique_things:\n        duplicate_things.add(t)\n    else:\n        unique_things.add(t)\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you need to get back to a list, just construct one from the resulting set:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n unique_things = list(unique_things)\nduplicate_things = list(duplicate_things)\n</code>\n</pre>\n", "senID": 4}, {"text": ["It's a bit more code to create your own class like this, but may give you other options down the road if your program grows in complexity."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Edit"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["OK, my hands are faster than my eyes tonight, but I think this edit solves the problem pointed out by @nosklo"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I'm pretty sure this works..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dupe = [i for n,i in enumerate(x) if x.index(i) == n and x.count(i) &gt; 1]\n&gt;&gt;[{'line': u'line 666', 'rule': u'A DUPLICATE RULE', 'file': u'/file.txt'}]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This answer is based on Steven Huwig's answer.", "It's similar to his, but I use sorted() on the list so that groupby() works correctly."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sorted()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "groupby()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also, since he said \"There's probably a more optimal way to check this than len(list(a[1])).", "\", I decided to use some other way to check for non-unique items.", "Instead of forcing the whole list, I try to call the .next() method on the iterator, twice.", "If it works twice, there are at least two items in the iterator, and we are done with it; if we get a StopIteration exception on the first or second call to .next() there was zero or one items in the iterator.", "(Actually, since we got this iterator from itertools.groupby we know it will have at least one item in it."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": ".next()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "StopIteration", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": ".next()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools.groupby", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["Also, instead of using explicit tuple indexing like a[0] and a[1], I used tuple unpacking, since that's what the cool kids seem to be doing these days."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "a[0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a[1]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Finally, instead of using a generator expression to compute the list, and using list() to force it to expand out into a list, I simply used a list comprehension."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "list()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n data = [\n    {\n    \t'file': u'/file.txt',\n    \t'line': u'line 666',\n    \t'rule': u'A DUPLICATE RULE'\n    },\n\n    {   'file': u'/uniquefile.txt',\n    \t'line': u'line 999',\n    \t'rule': u'A UNIQUE RULE'\n    },\n\n    {   'file': u'/file.txt',\n    \t'line': u'line 666',\n    \t'rule': u'A DUPLICATE RULE'\n    },\n\n]\n\nfrom itertools import groupby\n\ndef notunique(itr):\n    try:\n    \titr.next()\n    \titr.next()\n    \treturn True\n    except StopIteration:\n    \treturn False\n\ndef unique_list(lst):\n    return [key for key, itr in groupby(sorted(lst)) if notunique(itr)]\n\nprint(unique_list(data))\n</code>\n</pre>\n", "senID": 4}]]