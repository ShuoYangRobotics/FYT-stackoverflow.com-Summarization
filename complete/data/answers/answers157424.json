[[{"text": ["You can't sort dictionaries.", "You have to sort the list of items."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Previous versions were wrong.", "When you have a numeric value, it's easy to sort in reverse order.", "These will do that.", "But this isn't general.", "This only works because the value is numeric."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = { 'key':1, 'another':2, 'key2':1 }\n\nb= a.items()\nb.sort( key=lambda a:(-a[1],a[0]) )\nprint b\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here's an alternative, using an explicit function instead of a lambda and the cmp instead of the key option."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def valueKeyCmp( a, b ):\n    return cmp( (-a[1], a[0]), (-b[1], b[0] ) )\n\nb.sort( cmp= valueKeyCmp )\nprint b\n</code>\n</pre>\n", "senID": 4}, {"text": ["The more general solution is actually two separate sorts"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n b.sort( key=lambda a:a[1], reverse=True )\nb.sort( key=lambda a:a[0] )\nprint b\n</code>\n</pre>\n", "senID": 6}], [{"code": "<pre>\n<code>\n data = { 'keyC':1, 'keyB':2, 'keyA':1 }\n\nfor key, value in sorted(data.items(), key=lambda x: (-1*x[1], x[0])):\n    print key, value\n</code>\n</pre>\n", "senID": 0}], [{"text": ["The most pythonic way to do it would be to know a little more about the actual data -- specifically, the maximum value you can have -- and then do it like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def sortkey((k, v)): \n    return (maxval - v, k)\n\nitems = thedict.items()\nitems.sort(key=sortkey)\n</code>\n</pre>\n", "senID": 1}, {"text": ["but unless you already know the maximum value, searching for the maximum value means looping through the dict an extra time (with max(thedict.itervalues())), which may be expensive.", "Alternatively, a keyfunc version of S.Lott's solution:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "max(thedict.itervalues())", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def sortkey((k, v)): \n    return (-v, k)\n\nitems = thedict.items()\nitems.sort(key=sortkey)\n</code>\n</pre>\n", "senID": 3}, {"text": ["An alternative that doesn't care about the types would be a comparison function:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def sortcmp((ak, av), (bk, bv)):\n    # compare values 'in reverse'  \n    r = cmp(bv, av)\n    if not r:\n        # and then keys normally\n        r = cmp(ak, bk)\n    return r\n\nitems = thedict.items()\nitems.sort(cmp=sortcmp)\n</code>\n</pre>\n", "senID": 5}, {"text": ["and this solution actually works for any type of key and value that you want to mix ascending and descending sorting with in the same key.", "If you value brevity you can write sortcmp as:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def sortcmp((ak, av), (bk, bv)):\n    return cmp((bk, av), (ak, bv))\n</code>\n</pre>\n", "senID": 7}], [{"text": ["You can use something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dic = {'aaa':1, 'aab':3, 'aaf':3, 'aac':2, 'aad':2, 'aae':4}\n\ndef sort_compare(a, b):\n\tc = cmp(dic[b], dic[a])\n\tif c != 0:\n\t\treturn c\n\treturn cmp(a, b)\n\nfor k in sorted(dic.keys(), cmp=sort_compare):\n\tprint k, dic[k]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Don't know how pythonic it is however :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Building on Thomas Wouters and Ricardo Reyes solutions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def combine(*cmps):\n    \"\"\"Sequence comparisons.\"\"\"\n    def comparator(a, b):\n        for cmp in cmps:\n            result = cmp(a, b):\n            if result:\n                return result\n        return 0\n    return comparator\n\ndef reverse(cmp):\n    \"\"\"Invert a comparison.\"\"\"\n    def comparator(a, b):\n        return cmp(b, a)\n    return comparator\n\ndef compare_nth(cmp, n):\n    \"\"\"Compare the n'th item from two sequences.\"\"\"\n    def comparator(a, b):\n        return cmp(a[n], b[n])\n    return comparator\n\nrev_val_key_cmp = combine(\n        # compare values, decreasing\n        reverse(compare_nth(1, cmp)),\n\n        # compare keys, increasing\n        compare_nth(0, cmp)\n    )\n\ndata = { 'keyC':1, 'keyB':2, 'keyA':1 }\n\nfor key, value in sorted(data.items(), cmp=rev_val_key_cmp):\n    print key, value\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; keys = sorted(a, key=lambda k: (-a[k], k))\n</code>\n</pre>\n", "senID": 0}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; keys = sorted(a)\n&gt;&gt;&gt; keys.sort(key=a.get, reverse=True)\n</code>\n</pre>\n", "senID": 2}, {"text": ["then"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n print [(key, a[key]) for key in keys]\n[('keyB', 2), ('keyA', 1), ('keyC', 1)]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["See my answer to a related question here."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1143671/python-sorting-list-of-dictionaries-by-multiple-keys/1144405"}]}]]