[[{"text": ["This could be simplified, but:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = [[1, 2, 4, 8], [1, 2, 4, 5, 6], [1, 2, 3], [2, 3, 21], [1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]]\nl2 = l[:]\n\nfor m in l:\n    for n in l:\n        if set(m).issubset(set(n)) and m != n:\n            l2.remove(m)\n            break\n\nprint l2\n[[1, 2, 4, 8], [2, 3, 21], [1, 2, 3, 4, 5, 6, 7]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This code should be rather memory efficient.", "Beyond storing your initial list of lists, this code uses negligible extra memory (no temporary sets or copies of lists are created)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_subset(needle,haystack):\n   \"\"\" Check if needle is ordered subset of haystack in O(n)  \"\"\"\n\n   if len(haystack) &lt; len(needle): return False\n\n   index = 0\n   for element in needle:\n      try:\n         index = haystack.index(element, index) + 1\n      except ValueError:\n         return False\n   else:\n      return True\n\ndef filter_subsets(lists):\n   \"\"\" Given list of lists, return new list of lists without subsets  \"\"\"\n\n   for needle in lists:\n      if not any(is_subset(needle, haystack) for haystack in lists\n         if needle is not haystack):\n         yield needle\n\nmy_lists = [[1, 2, 4, 8], [1, 2, 4, 5, 6], [1, 2, 3], \n            [2, 3, 21], [1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]]    \nprint list(filter_subsets(my_lists))\n\n&gt;&gt;&gt; [[1, 2, 4, 8], [2, 3, 21], [1, 2, 3, 4, 5, 6, 7]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["And, just for fun, a one-liner:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def filter_list(L):\n    return [x for x in L if not any(set(x)&lt;=set(y) for y in L if x is not y)]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["A list is a superlist if it is not a subset of any other list.", "It's a subset of another list if every element of the list can be found, in order, in another list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's my code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def is_sublist_of_any_list(cand, lists):\n    # Compare candidate to a single list\n    def is_sublist_of_list(cand, target):\n        try:\n            i = 0\n            for c in cand:\n                i = 1 + target.index(c, i)\n            return True\n        except ValueError:\n            return False\n    # See if candidate matches any other list\n    return any(is_sublist_of_list(cand, target) for target in lists if len(cand) &lt;= len(target))\n\n# Compare candidates to all other lists\ndef super_lists(lists):\n    return [cand for i, cand in enumerate(lists) if not is_sublist_of_any_list(cand, lists[:i] + lists[i+1:])]\n\nif __name__ == '__main__':\n    lists = [[1, 2, 4, 8], [1, 2, 4, 5, 6], [1, 2, 3], [2, 3, 21], [1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]]\n    superlists = super_lists(lists)\n    print superlists\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here are the results:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [[1, 2, 4, 8], [2, 3, 21], [1, 2, 3, 4, 5, 6, 7]]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Edit: Results for your later data set."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lists = [[2, 16, 17], [1, 2, 3, 4, 5, 6, 7], [1], [1, 2, 3, 4], [1, 2], [17,\n 18, 19, 22, 41, 48], [2, 3], [1, 2, 3], [50, 69], [1, 2, 3], [2, 3, 21], [1, 2,\n 3], [1, 2, 4, 8], [1, 2, 4, 5, 6]]\n&gt;&gt;&gt; superlists = super_lists(lists)\n&gt;&gt;&gt; expected = [[2, 16, 17], [1, 2, 3, 4, 5, 6, 7], [17, 18, 19, 22, 41, 48], [5\n0, 69],  [2, 3, 21], [1, 2, 4, 8]]\n&gt;&gt;&gt; assert(superlists == expected)\n&gt;&gt;&gt; print superlists\n[[2, 16, 17], [1, 2, 3, 4, 5, 6, 7], [17, 18, 19, 22, 41, 48], [50, 69], [2, 3,\n21], [1, 2, 4, 8]]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Edit: I really need to improve my reading comprehension.", "Here's the answer to what was actually asked.", "It exploits the fact that \"A is super of B\" implies \"len(A) &gt; len(B) or A == B\". "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "A is super of B", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "len(A) &gt; len(B) or A == B", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def advance_to(it, value):\n    \"\"\"Advances an iterator until it matches the given value. Returns False\n    if not found.\"\"\"\n    for item in it:\n        if item == value:\n            return True\n    return False\n\ndef has_supersequence(seq, super_sequences):\n    \"\"\"Checks if the given sequence has a supersequence in the list of\n    supersequences.\"\"\" \n    candidates = map(iter, super_sequences)\n    for next_item in seq:\n        candidates = [seq for seq in candidates if advance_to(seq, next_item)]\n    return len(candidates) &gt; 0\n\ndef find_supersequences(sequences):\n    \"\"\"Finds the supersequences in the given list of sequences.\n\n    Sequence A is a supersequence of sequence B if B can be created by removing\n    items from A.\"\"\"\n    super_seqs = []\n    for candidate in sorted(sequences, key=len, reverse=True):\n        if not has_supersequence(candidate, super_seqs):\n            super_seqs.append(candidate)\n    return super_seqs\n\nprint(find_supersequences([[1, 2, 4, 8], [1, 2, 4, 5, 6], [1, 2, 3],\n    [2, 3, 21], [1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]]))\n#Output: [[1, 2, 3, 4, 5, 6, 7], [1, 2, 4, 8], [2, 3, 21]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you need to also preserve the original order of the sequences, then the find_supersequences() function needs to keep track of the positions of the sequences and sort the output afterwards."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "find_supersequences()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n list0=[[1, 2, 4, 8], [1, 2, 4, 5, 6], [1, 2, 3], [2, 3, 21], [1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]]\n\nfor list1 in list0[:]:\n    for list2 in list0:\n        if list2!=list1:\n            len1=len(list1)\n            c=0\n            for n in list2:\n                if n==list1[c]:\n                    c+=1\n                if c==len1:\n                    list0.remove(list1)\n                    break\n</code>\n</pre>\n", "senID": 0}, {"text": ["This filters list0 in place using a copy of it.", "This is good if the result is expected to be about the same size as the original, there is only a few \"subset\" to remove."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If the result is expected to be small and the original is large, you might prefer this one who is more memory freindly as it doesn't copy the original list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n list0=[[1, 2, 4, 8], [1, 2, 4, 5, 6], [1, 2, 3], [2, 3, 21], [1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]]\nresult=[]\n\nfor list1 in list0:\n    subset=False\n    for list2 in list0:\n        if list2!=list1:\n            len1=len(list1)\n            c=0\n            for n in list2:\n                if n==list1[c]:\n                    c+=1\n                if c==len1:\n                    subset=True\n                    break\n            if subset:\n                break\n    if not subset:\n        result.append(list1)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This seems to work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n original=[[1, 2, 4, 8], [1, 2, 4, 5, 6], [1, 2, 3], [2, 3, 21], [1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]]\n\ntarget=[[1, 2, 4, 8], [2, 3, 21], [1, 2, 3, 4, 5, 6, 7]]\n\nclass SetAndList:\n    def __init__(self,aList):\n        self.list=aList\n        self.set=set(aList)\n        self.isUnique=True\n    def compare(self,aList):\n        s=set(aList)\n        if self.set.issubset(s):\n            #print self.list,'superceded by',aList\n            self.isUnique=False\n\ndef listReduce(lists):\n    temp=[]\n    for l in lists:\n        for t in temp:\n            t.compare(l)\n        temp.append( SetAndList(l) )\n\n    return [t.list for t in temp if t.isUnique]\n\nprint listReduce(original)\nprint target\n</code>\n</pre>\n", "senID": 1}, {"text": ["This prints the calculated list and the target for visual comparison."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Uncomment the print line in the compare method to see how various lists get superceded."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Tested with python 2.6.2"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I implemented a different issubseq because yours doesn't say that [1, 2, 4, 5, 6] is a subsequence of [1, 2, 3, 4, 5, 6, 7], for example (besides being painfully slow).", "The solution I came up with looks like this:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "issubseq", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[1, 2, 4, 5, 6]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "[1, 2, 3, 4, 5, 6, 7]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def is_subseq(a, b):\n    if len(a) &gt; len(b): return False\n    start = 0\n    for el in a:\n    \twhile start &lt; len(b):\n    \t\tif el == b[start]:\n    \t\t\tbreak\n    \t\tstart = start + 1\n    \telse:\n    \t\treturn False\n    return True\n\ndef filter_partial_matches(sets):\n     return [s for s in sets if all([not(is_subseq(s, ss)) for ss in sets if s != ss])]\n</code>\n</pre>\n", "senID": 1}, {"text": ["A simple test case, given your inputs and outputs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; test = [[1, 2, 4, 8], [1, 2, 4, 5, 6], [1, 2, 3], [2, 3, 21], [1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]]\n&gt;&gt;&gt; another_test = [[1, 2, 3, 4], [2, 4, 3], [3, 4, 5]]\n&gt;&gt;&gt; filter_partial_matches(test)\n[[1, 2, 4, 8], [2, 3, 21], [1, 2, 3, 4, 5, 6, 7]]\n&gt;&gt;&gt; filter_partial_matches(another_test)\n[[1, 2, 3, 4], [2, 4, 3], [3, 4, 5]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Hope it helps!"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Refined answer after new test case:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n original= [[2, 16, 17], [1, 2, 3, 4, 5, 6, 7], [1], [1, 2, 3, 4], [1, 2], [17, 18, 19, 22, 41, 48], [2, 3], [1, 2, 3], [50, 69], [1, 2, 3], [2, 3, 21], [1, 2, 3], [1, 2, 4, 8], [1, 2, 4, 5, 6]]\n\nclass SetAndList:\n    def __init__(self,aList):\n        self.list=aList\n        self.set=set(aList)\n        self.isUnique=True\n    def compare(self,other):\n        if self.set.issubset(other.set):\n            #print self.list,'superceded by',other.list\n            self.isUnique=False\n\ndef listReduce(lists):\n    temp=[]\n    for l in lists:\n        s=SetAndList(l)\n        for t in temp:\n            t.compare(s)\n            s.compare(t)\n        temp.append( s )\n        temp=[t for t in temp if t.isUnique]\n\n    return [t.list for t in temp if t.isUnique]\n\nprint listReduce(original)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You didn't give the required output, but I'm guessing this is right, as [1,2,3] does not appear in the output."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[1,2,3]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Thanks to all who suggested solutions and coping with my sometimes erroneous data sets.", "Using @hughdbrown solution I modified it to what I wanted:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@hughdbrown", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["The modification was to use a sliding window over the target to ensure the subset sequence was found.", "I think I should have used a more appropriate word than 'Set' to describe my problem."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def is_sublist_of_any_list(cand, lists):\n    # Compare candidate to a single list\n    def is_sublist_of_list(cand, target):\n        try:\n            i = 0            \n            try:\n                start = target.index(cand[0])\n            except:\n                return False\n\n            while start &lt; (len(target) + len(cand)) - start:\n                if cand == target[start:len(cand)]:\n                    return True\n                else:\n                    start = target.index(cand[0], start + 1)\n        except ValueError:\n            return False\n\n    # See if candidate matches any other list\n    return any(is_sublist_of_list(cand, target) for target in lists if len(cand) &lt;= len(target))\n\n# Compare candidates to all other lists\ndef super_lists(lists):\n    a = [cand for i, cand in enumerate(lists) if not is_sublist_of_any_list(cand, lists[:i] + lists[i+1:])]\n    return a\n\nlists = [[2, 16, 17], [1, 2, 3, 4, 5, 6, 7], [1], [1, 2, 3, 4], [1, 2], [17, 18, 19, 22, 41, 48], [2, 3], [1, 2, 3], [50, 69], [1, 2, 3], [2, 3, 21], [1, 2, 3], [1, 2, 4, 8], [1, 2, 4, 5, 6]]\nexpect = [[2, 16, 17], [1, 2, 3, 4, 5, 6, 7], [17, 18, 19, 22, 41, 48], [50, 69],  [2, 3, 21], [1, 2, 4, 8], [1, 2, 4, 5, 6]]\n\ndef test():\n    out = super_lists(list(lists))\n\n    print \"In  : \", lists\n    print \"Out : \", out\n\n    assert (out == expect)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n In  :  [[2, 16, 17], [1, 2, 3, 4, 5, 6, 7], [1], [1, 2, 3, 4], [1, 2], [17, 18, 19, 22, 41, 48], [2, 3], [1, 2, 3], [50, 69], [1, 2, 3], [2, 3, 21], [1, 2, 3], [1, 2, 4, 8], [1, 2, 4, 5, 6]]\nOut :  [[2, 16, 17], [1, 2, 3, 4, 5, 6, 7], [17, 18, 19, 22, 41, 48], [50, 69], [2, 3, 21], [1, 2, 4, 8], [1, 2, 4, 5, 6]]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["So what you really wanted was to know if a list was a substring, so to speak, of another, with all the matching elements consecutive.", "Here is code that converts the candidate and the target list to comma-separated strings and does a substring comparison to see if the candidate appears within the target list"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_sublist_of_any_list(cand, lists):\n    def comma_list(l):\n        return \",\" + \",\".join(str(x) for x in l) + \",\"\n    cand = comma_list(cand)\n    return any(cand in comma_list(target) for target in lists if len(cand) &lt;= len(target))\n\n\ndef super_lists(lists):\n    return [cand for i, cand in enumerate(lists) if not is_sublist_of_any_list(cand, lists[:i] + lists[i+1:])]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The function comma_list() puts leading and trailing commas on the list to ensure that integers are fully delimited.", "Otherwise, [1] would be a subset of [100], for example."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]