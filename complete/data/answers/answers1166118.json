[[{"text": ["In the general case, you can't, because"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @with_connection\ndef spam(connection):\n    # Do something\n</code>\n</pre>\n", "senID": 1}, {"text": ["is equivalent to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def spam(connection):\n    # Do something\n\nspam = with_connection(spam)\n</code>\n</pre>\n", "senID": 3}, {"text": ["which means that the \"original\" spam might not even exist anymore.", "A (not too pretty) hack would be this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def with_connection(f):\n    def decorated(*args, **kwargs):\n        f(get_connection(...), *args, **kwargs)\n    decorated._original = f\n    return decorated\n\n@with_connection\ndef spam(connection):\n    # Do something\n\nspam._original(testcon) # calls the undecorated function\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Behold, FuglyHackThatWillWorkForYourExampleButICantPromiseAnythingElse:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n orig_spam = spam.func_closure[0].cell_contents\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: For functions/methods decorated more than once and with more complicated decorators you can try using the following code.", "It relies on the fact, that decorated functions are __name__d differently than the original function."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def search_for_orig(decorated, orig_name):\n    for obj in (c.cell_contents for c in decorated.__closure__):\n    \tif hasattr(obj, \"__name__\") and obj.__name__ == orig_name:\n    \t\treturn obj\n    \tif hasattr(obj, \"__closure__\") and obj.__closure__:\n    \t\tfound = search_for_orig(obj, orig_name)\n    \t\tif found:\n    \t\t\treturn found\n    return None\n\n &gt;&gt;&gt; search_for_orig(spam, \"spam\")\n &lt;function spam at 0x027ACD70&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["It's not fool proof though.", "It will fail if the name of the function returned from a decorator is the same as the decorated one.", "The order of hasattr() checks is also a heuristic,  there are decoration chains that return wrong results in any case."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["balpha's solution can be made more generalizable with this meta-decorator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def include_original(dec):\n    def meta_decorator(f):\n        decorator = dec(f)\n        decorator._original = f\n        return decorator\n    return meta_decorator\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can decorate your decorators with @include_original, and every one will have a testable (undecorated) version tucked away inside it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The usual approach to testing such functions is to make any dependencies, such as get_connection, configurable.", "Then you can override it with a mock while testing.", "Basically the same as dependency injection in the Java world but a lot simpler thanks to Pythons dynamic nature."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Code for it might look something like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # decorator definition\ndef with_connection(f):\n    def decorated(*args, **kwargs):\n        f(with_connection.connection_getter(), *args, **kwargs)\n    return decorated\n\n# normal configuration\nwith_connection.connection_getter = lambda: get_connection(...)\n\n# inside testsuite setup override it\nwith_connection.connection_getter = lambda: \"a mock connection\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["Depending on your code you could find a better object than the decorator to stick the factory function on.", "The issue with having it on the decorator is that you'd have to remember to restore it to the old value in the teardown method."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Instead of doing.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def with_connection(f):\n    def decorated(*args, **kwargs):\n        f(get_connection(...), *args, **kwargs)\n    return decorated\n\n@with_connection\ndef spam(connection):\n    # Do something\n\norig_spam = magic_hack_of_a_function(spam)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could just do.."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def with_connection(f):\n    ....\n\ndef spam_f(connection):\n    ...\n\nspam = with_connection(spam_f)\n</code>\n</pre>\n", "senID": 3}, {"text": ["..which is all the @decorator syntax does - you can then obviously access the original spam_f normally"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "@decorator", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "spam_f", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Add a do-nothing decorator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def do_nothing(f):\n    return f\n</code>\n</pre>\n", "senID": 1}, {"text": ["After defining or importing with_connection but before you get to the methods that use it as a decorator, add:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if TESTING:\n    with_connection = do_nothing\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then if you set the global TESTING to True, you will have replaced with_connection with a do-nothing decorator."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]