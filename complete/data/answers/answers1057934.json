[[{"text": ["It's easier than you think:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Instrument(Object):\n    def __init__(self):\n        self.flag = True\n    def direct_method(self,arg1):\n        self.external_method(arg1, arg2)\n\nimport to_import_from\n\nInstrument.external_method = to_import_from.external_method\n</code>\n</pre>\n", "senID": 1}, {"text": ["Done!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Although having the machine generated code generate a class definition and subclassing from it would be a neater solution."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I don't think what you want is directly possible in Python. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could, however, try one of the following."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In other words, in to_import_from.py:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "to_import_from.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class InstrumentBase(object):\n    def external_method(self, arg1, arg2):\n        if self.flag:\n            ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["and then in main_module.py:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "main_module.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import to_import_from\n\nclass Instrument(to_import_from.InstrumentBase):\n    def __init__(self):\n        ...\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I'm sorry that this is kind of a \"You shouldn't be putting nails in the wall\" answer, but you're missing the point of python class definitions.", "You should rather put the class with all its methods in its own python file, and in your main_module.py do"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "\"You shouldn't be putting nails in the wall\" answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://stackoverflow.fogbugz.com/default.asp?W29025"}, {"text": "main_module.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from instrument import Instrument\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you plan on using the methods for several classes, you should consider subclassing.", "In your case, the machine generated file could contain the base class that Instrument inherits from."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Instrument", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Finally, give your class a good docstring that explains the API to its user, so there is no need for a \"header file\" used as an overview of your class."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["you can do this with the __getattr__ method"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["external.py"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def external_function(arg):\n    print(\"external\", arg)\n</code>\n</pre>\n", "senID": 2}, {"text": ["main.py:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import external\n\nclass Instrument(object):\n    def __getattr__(self, name):\n        if hasattr(external, name):\n            return getattr(external, name)\n        else:\n            return Object.__getattr__(self, name)\n\n    def direct_method(self, arg):\n        print(\"internal\", arg)\n\n\ni = Instrument() \ni.direct_method(\"foo\")\ni.external_function(\"foo\")\n</code>\n</pre>\n", "senID": 4}], [{"text": ["What you're doing is extending a base class with some \"machine-generated\" code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Choice 1.", "Extend a base class with machine-generated code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["machine_generated.py"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # Start of boilerplate #\nimport main_module\nclass Instrument_Implementation( main_module.Instrument_Abstraction ):\n    def direct_method(self,arg1): \n       # End of boilerplate #\n       ...the real code...\n</code>\n</pre>\n", "senID": 3}, {"text": ["Your application can then import machine_generated and use machine_generated.Instrument_Implementation."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "import machine_generated", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "machine_generated.Instrument_Implementation", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Choice 2.", "Simply use first-class functions."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["machine_generated.py"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def external_method(self, arg1, arg2):\n    ...the real code...\n</code>\n</pre>\n", "senID": 7}, {"text": ["main_module.py"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n import machine_generated\n\nclass Instrument( object ):\n    def direct_method(self,arg1): \n        return machine_generator.external_method( arg1, ... )\n</code>\n</pre>\n", "senID": 9}, {"text": ["Your application can import main_module and use main_module.Instrument."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "import main_module", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "main_module.Instrument", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["People seem to be overthinking this.", "Methods are just function valued local variables in class construction scope.", "So the following works fine:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Instrument(Object):\n    # load external methods\n    from to_import_from import *\n\n    def __init__(self):\n        self.flag = True\n    def direct_method(self,arg1):\n        self.external_method(arg1, arg2)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's my try.", "I think a nicer approach could be made with metaclasses..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["to_import_from.py :"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def external_method(self, arg1, arg2):\n    if self.flag:\n        print \"flag is set\"\n    else :\n        print \"flag is not set\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["instrument.py :"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import imp\nimport os\nimport inspect\nimport new\n\nimport pdb\n\nclass MethodImporter(object) :\n    def __init__(self, path_to_module) :\n        self.load_module(path_to_module)\n\n    def load_module(self, path_to_module) :\n        name = os.path.basename(path_to_module)\n        module_file = file(path_to_module,\"r\")\n        self.module = imp.load_module(name, module_file , path_to_module, ('','r',imp.PY_SOURCE))\n        print \"Module %s imported\" % self.module\n        for method_name, method_object in inspect.getmembers(self.module, inspect.isfunction) :\n            print \"adding method %s to %s\" % (method_name, self)\n            setattr(self, method_name, new.instancemethod(method_object, self, self.__class__))\n\n\nclass Instrument(MethodImporter):\n    def __init__(self):\n        super(Instrument,self).__init__(\"./to_import_from.py\")\n        self.flag = True\n    def direct_method(self,arg1):\n        self.external_method(arg1, arg2)\n</code>\n</pre>\n", "senID": 4}, {"text": ["when you run this code"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n arg1, arg2 = 1, 2\ninstr = Instrument()\ninstr.direct_method(arg1)\ninstr.external_method(arg1, arg2)\n</code>\n</pre>\n", "senID": 6}, {"text": ["here's the output :"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n Module &lt;module 'to_import_from.py' from './to_import_from.pyc'&gt; imported\nadding method external_method to &lt;__main__.Instrument object at 0x2ddeb0&gt;\nflag is set\nflag is set\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Technically, yes this is possible, but solving it this way is not really idiomatic python, and there are likely better solutions.", "Here's an example of how to do so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import to_import_from\n\nclass Instrument(object):\n    locals().update(dict((k,v) for (k,v) in \n                    to_import_from.__dict__.iteritems() if callable(v)))\n\n    def __init__(self):\n        self.flag = True\n    def direct_method(self,arg1):\n        self.external_method(arg1, arg2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["That will import all callable functions defined in to_import_from as methods of the Instrument class, as well as adding some more methods.", "Note: if you also want to copy global variables as instance variables, you'll need to refine the check.", "Also note that it adds all callable objects it finds in to_import_from's namespace, including imports from other modules (ie from module import some_func style imports)"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "to_import_from", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Instrument", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "all", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "from module import some_func", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["However, this isn't a terribly nice way to do it.", "Better would be to instead tweak your code generation to produce a class, and have your class inherit from it.", "This avoids the unneccessary copying of methods into Instrument's namespace, and instead uses normal inheritcance.", "ie:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "produce", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class Instrument(to_import_from.BaseClass):\n    # Add new methods here.\n</code>\n</pre>\n", "senID": 4}]]