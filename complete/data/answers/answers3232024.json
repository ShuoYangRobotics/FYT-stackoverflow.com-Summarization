[[{"text": ["If you can change the way you call the decorators from "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n    @many\n    @decorators\n    @here\n    def bar(self):\n        pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n    @register(many,decos,here)\n    def bar(self):\n        pass\n</code>\n</pre>\n", "senID": 3}, {"text": ["then you could register the decorators this way:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def register(*decorators):\n    def register_wrapper(func):\n        for deco in decorators[::-1]:\n            func=deco(func)\n        func._decorators=decorators        \n        return func\n    return register_wrapper\n</code>\n</pre>\n", "senID": 5}, {"text": ["For example:    "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def many(f):\n    def wrapper(*args,**kwds):\n        return f(*args,**kwds)\n    return wrapper\n\ndecos = here = many\n\nclass Foo(object):\n    @register(many,decos,here)\n    def bar(self):\n        pass\n\nfoo=Foo()\n</code>\n</pre>\n", "senID": 7}, {"text": ["Here we access the tuple of decorators:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n print(foo.bar._decorators)\n# (&lt;function many at 0xb76d9d14&gt;, &lt;function decos at 0xb76d9d4c&gt;, &lt;function here at 0xb76d9d84&gt;)\n</code>\n</pre>\n", "senID": 9}, {"text": ["Here we print just the names of the decorators:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n print([d.func_name for d in foo.bar._decorators])\n# ['many', 'decos', 'here']\n</code>\n</pre>\n", "senID": 11}], [{"text": ["You can't but even worse is there exists libraries to help hide the fact that you have decorated a function to begin with.", "See Functools or the decorator library (@decorator if I could find it) for more information."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Functools", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functools.html"}, {"text": "@decorator", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["That's not possible in my opinion.", "A decorator is not some kind of attribute or meta data of a method.", "A decorator is a convenient syntax for replacing a function with the result of a function call.", "See http://docs.python.org/whatsnew/2.4.html?highlight=decorators#pep-318-decorators-for-functions-and-methods for more details."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/whatsnew/2.4.html?highlight=decorators#pep-318-decorators-for-functions-and-methods", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://docs.python.org/whatsnew/2.4.html?highlight=decorators#pep-318-decorators-for-functions-and-methods"}]}], [{"text": ["That's because decorators are \"syntactic sugar\".", "Say you have the following decorator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def MyDecorator(func):\n    def transformed(*args):\n        print \"Calling func \" + func.__name__\n        func()\n    return transformed\n</code>\n</pre>\n", "senID": 1}, {"text": ["And you apply it to a function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @MyDecorator\ndef thisFunction():\n    print \"Hello!\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is equivalent to:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n thisFunction = MyDecorator(thisFunction)\n</code>\n</pre>\n", "senID": 5}, {"text": ["You could embed a \"history\" into the function object, perhaps, if you're in control of the decorators.", "I bet there's some other clever way to do this (perhaps by overriding assignment), but I'm not that well-versed in Python unfortunately.", ":("], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["It is impossible to do in a general way, because"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @foo\ndef bar ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["is exactly the same as"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def bar ...\nbar = foo (bar)\n</code>\n</pre>\n", "senID": 3}, {"text": ["You may do it in certain special cases, like probably @staticmethod by analyzing function objects, but not better than that."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "@staticmethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["As Faisal notes, you could have the decorators themselves attach metadata to the function, but to my knowledge it isn't automatically done."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You cannot, by definition.", "Decorator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @dec\ndef foo():\n    return 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["is just shortcut for:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def foo_internal()\n    return 1\nfoo = dec(foo_internal)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Notice that, decorator dec is simply some callable returning something (function, maybe some other callable object).", "You don't even know if foo has anything to do with decorated definition, e.g:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "dec", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def dec(f):\n    def not_foo():\n        return 0\n    return not_foo\n</code>\n</pre>\n", "senID": 5}, {"text": ["If you need to put some additional information on methods, classes etc.---like e.g.", "attributes in .NET---simply set some attributes on them."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def foo()\n    return 1\nfoo.decorated = True\n</code>\n</pre>\n", "senID": 7}, {"text": ["Or implement decorators that set those attributes, if it really helps readability."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def dec(f):\n    f.decorated = True\n    return f\n</code>\n</pre>\n", "senID": 9}, {"text": ["Well.", "Python is open-source.", "You can always extend Python interpreter to track decorators applied to object.", "Since (as shown above) object returned by decorator doesn't have to be related in any way to decorated object, this implementation would have to store information from decorated object before applying decorator, apply decorator, replace decorator info on returned object and add info about last decorator."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Can be done.", "But I am not sure if it's really useful.", "And it adds some overhead to each decorator.", "So I wouldn't expect such mechanism in mainstream Python, unless it provides some other benefits, like simplifying implementation of decorators, etc."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}]]