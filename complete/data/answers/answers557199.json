[[{"text": ["If the data is a natural fit for database tables (\"rectangular data\"), why not convert it to sqlite?", "It's portable -- just one file to move the db around, and sqlite is available anywhere you have python (2.5 and above anyway)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Generally you want your Objects to absolutely match your \"real world entities\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Since you're starting from a database, it's not always the case that the database has any real-world fidelity, either.", "Some database designs are simply awful."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If your database has reasonable models for Fruit, that's where you start.", "Get that right first."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A \"collection\" may -- or may not -- be an artificial construct that's part of the solution algorithm, not really a proper part of the problem.", "Usually collections are part of the problem, and you should design those classes, also."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "are", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Other times, however, the collection is an artifact of having used a database, and a simple Python list is all you need."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Still other times, the collection is actually a proper mapping from some unique key value to an entity, in which case, it's a Python dictionary."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["And sometimes, the collection is a proper mapping from some non-unique key value to some collection of entities, in which case it's a Python collections.defaultdict(list)."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "collections.defaultdict(list)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Start with the fundamental, real-world-like entities.", "Those get class definitions."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Collections may use built-in Python collections or may require their own classes."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["There's no \"one size fits all\" answer for this -- it'll depend a lot on the data and how it's used in the application.", "If the data and usage are simple enough you might want to store your fruit in a dict with id as key and the rest of the data as tuples.", "Or not.", "It totally depends.", "If there's a guiding principle out there then it's to extract the underlying requirements of the app and then write code against those requirements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["you could have a fruit class with id and name instance variables.", "and a function to read/write the information from a file, and maybe a class variable to keep track of the number of fruits (objects) created"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In the simple case namedtuples let get you started:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "namedtuples", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/collections.html#collections.namedtuple"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; Fruit = namedtuple(\"Fruit\", \"name weight color\")\n&gt;&gt;&gt; fruits = [Fruit(*row) for row in cursor.execute('select * from fruits')]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Fruit is equivalent to the following class:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Fruit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Fruit = namedtuple(\"Fruit\", \"name weight color\", verbose=True)\nclass Fruit(tuple):\n        'Fruit(name, weight, color)'\n\n        __slots__ = ()\n\n        _fields = ('name', 'weight', 'color')\n\n        def __new__(cls, name, weight, color):\n            return tuple.__new__(cls, (name, weight, color))\n\n        @classmethod\n        def _make(cls, iterable, new=tuple.__new__, len=len):\n            'Make a new Fruit object from a sequence or iterable'\n            result = new(cls, iterable)\n            if len(result) != 3:\n                raise TypeError('Expected 3 arguments, got %d' % len(result))\n            return result\n\n        def __repr__(self):\n            return 'Fruit(name=%r, weight=%r, color=%r)' % self\n\n        def _asdict(t):\n            'Return a new dict which maps field names to their values'\n            return {'name': t[0], 'weight': t[1], 'color': t[2]}\n\n        def _replace(self, **kwds):\n            'Return a new Fruit object replacing specified fields with new values'\n            result = self._make(map(kwds.pop, ('name', 'weight', 'color'), self))\n            if kwds:\n                raise ValueError('Got unexpected field names: %r' % kwds.keys())\n\n            return result\n\n        def __getnewargs__(self):\n            return tuple(self)\n\n        name = property(itemgetter(0))\n        weight = property(itemgetter(1))\n        color = property(itemgetter(2))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Another way would be to use the ZODB to directly store objects persistently.", "The only thing you have to do is to derive your classes from Peristent and everything from the root object up is then automatically stored in that database as an object.", "The root object comes from the ZODB connection.", "There are many backends available and the default is simple a file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A class could then look like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Collection(persistent.Persistent):\n\n  def __init__(self, fruit = []):\n      self.fruit = fruit\n\nclass Fruit(peristent.Persistent):\n\n  def __init__(self, name):\n      self.name = name\n</code>\n</pre>\n", "senID": 2}, {"text": ["Assuming you have the root object you can then do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n fruit = Fruit(\"apple\")\nroot.collection = Collection([fruit])\n</code>\n</pre>\n", "senID": 4}, {"text": ["and it's stored in the database automatically.", "You can find it again by simply looking accessing 'collection' from the root object:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n print root.collection.fruit\n</code>\n</pre>\n", "senID": 6}, {"text": ["You can also derive subclasses from e.g.", "Fruit as usual."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Useful links with more information:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["The new ZODB homepage"], "childNum": 0, "tag": "a", "senID": 9, "childList": []}, {"text": ["a ZODB tutorial"], "childNum": 0, "tag": "a", "senID": 10, "childList": []}]}, {"text": ["That way you still are able to use the full power of Python objects and there is no need to serialize something e.g.", "via an ORM but you still have an easy way to store your data."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Here are a couple points for you to consider.", "If your data is large reading it all into memory may be wasteful.", "If you need random access and not just sequential access to your data then you'll either have to scan the at most the entire file each time or read that table into an indexed memory structure like a dictionary.", "A list will still require some kind of scan (straight iteration or binary search if sorted).", "With that said, if you don't require some of the features of a DB then don't use one but if you just think MySQL is too heavy then +1 on the Sqlite suggestion from earlier.", "It gives you most of the features you'd want while using a database without the concurrency overhead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Abstract persistence from the object class.", "Put all of the persistence logic in an adapter class, and assign the adapter to the object class.", "Something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Fruit(Object):\n\n   @classmethod\n   def get(cls, id):\n      return cls.adapter.get(id)\n\n   def put(self):\n      cls.adapter.put(self)\n\n   def __init__(self, id, name, weight, color):\n      self.id = id\n      self.name = name\n      self.weight = weight\n      self.color = color\n\n\n class FruitAdapter(Object):\n\n    def get(id):\n       # retrieve attributes from persistent storage here\n       return Fruit(id, name, weight, color)\n\n    def put(fruit):\n       # insert/update fruit in persistent storage here\n\n Fruit.adapter = FruitAdapter()\n f = Fruit.get(1)\n f.name = \"lemon\"\n f.put()\n # and so on...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now you can build different FruitAdapter objects that interoperate with whatever persistence format you settle on (database, flat file, in-memory collection, whatever) and the basic Fruit class will be completely unaffected."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]