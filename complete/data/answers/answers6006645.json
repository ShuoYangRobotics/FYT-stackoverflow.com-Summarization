[[{"text": ["What you are looking for is anti-pythonic, because:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In your case, I would use something like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n match = re.search(r'^(/dev/[a-zA-Z0-9]+)', line)\nif match:\n    partition.identifier = match.group(0)\n</code>\n</pre>\n", "senID": 2}, {"text": ["And you have 3 lines instead of 4."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There is no better way.", "Silently ignoring error is bad practice in any language, so it's naturally not Pythonic."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Please don't ask for Python to be like PHP.", "You should always explicitly trap the most specific error you can.", "Catching and ignoring all errors like that is not good best practice.", "This is because it can hide other problems and make bugs harder to find.", "But in the case of REs, you should really check for the None value that it returns.", "For example, your code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n label = re.search(r'LABEL=\"((?:[^\"\\\\]|\\.)*)\"', line).group(1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Raises an AttributeError if there is not match, because the re.search returns None if there is no match.", "But what if there was a match but you had a typo in your code:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "re.search", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n label = re.search(r'LABEL=\"((?:[^\"\\\\]|\\.)*)\"', line).roup(1)\n</code>\n</pre>\n", "senID": 3}, {"text": ["This also raises an AttributeError, even if there was a match.", "But using the catchall exception and ignoring it would mask that error from you.", "You will never match a label in that case, and you would never know it until you found it some other way, such as by eventually noticing that your code never matches a label (but hopefully you have unit tests for that case...)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["For REs, the usual pattern is this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n matchobj = re.search(r'LABEL=\"((?:[^\"\\\\]|\\.)*)\"', line)\nif matchobj:\n    label = matchobj.group(1)\n</code>\n</pre>\n", "senID": 6}, {"text": ["No need to try and catch an exception here since there would not be one.", "Except... when there was an exception caused by a similar typo."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Use data-driven design instead of repeating yourself.", "Naming the relevant group also makes it easier to avoid group indexing bugs:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n _components = dict(\n  identifier = re.compile(r'^(?P&lt;value&gt;/dev/[a-zA-Z0-9]+)'),\n  label = re.compile(r'LABEL=\"(?P&lt;value&gt;(?:[^\"\\\\]|\\\\.)*)\"'),\n  uuid = re.compile(r'UUID=\"(?P&lt;value&gt;(?:[^\"\\\\]|\\\\.)*)\"'),\n  type = re.compile(r'TYPE=\"(?P&lt;value&gt;(?:[^\"\\\\]|\\\\.)*)\"'),\n)\n\nfor line in blkid:\n    line = line.strip()\n    partition = Partition()\n\n    for name, pattern in _components:\n        match = pattern.search(line)\n        value = match.group('value') if match else None\n        setattr(partition, name, value)\n\n    partitions.add(partition)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Building upon Gabi Purcanu's answer and your desire to condense to one-liners, you could encapsulate his solution into a function and reduce your example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def cond_match(regexp, line, grp):\n    match = re.search(regexp, line)\n    if match:\n        return match.group(grp)\n    else:\n        return None\n\nfor line in blkid:\n    line = line.strip()\n    partition = Partition()\n    partition.identifier = cond_match(r'^(/dev/[a-zA-Z0-9]+)', line, 0)\n    partition.label = cond_match(r'LABEL=\"((?:[^\"\\\\]|\\\\.)*)\"', line, 1)\n    partition.uuid = cond_match(r'UUID=\"((?:[^\"\\\\]|\\\\.)*)\"', line, 1)\n    partition.type = cond_match(r'TYPE=\"((?:[^\"\\\\]|\\\\.)*)\"', line, 1)\n    partitions.add(partition)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There is warnings control in Python - http://docs.python.org/library/warnings.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/warnings.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/warnings.html"}]}, {"text": ["After edit:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You probably want to check if it is not None before trying to get the groups.", "Also use len() on the groups to see how many groups you have got.", "\"Pass\"ing the error is definitely not the way to go."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Also use len() on the groups to see how many groups you have got", "childNum": 0, "tag": "strike", "pos": 1, "childList": []}]}]]