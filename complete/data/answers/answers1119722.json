[[{"text": ["There is no standard module for this, but I have written my own functions to achieve that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef base62_encode(num, alphabet=ALPHABET):\n    \"\"\"Encode a number in Base X\n\n    `num`: The number to encode\n    `alphabet`: The alphabet to use for encoding\n    \"\"\"\n    if (num == 0):\n        return alphabet[0]\n    arr = []\n    base = len(alphabet)\n    while num:\n        rem = num % base\n        num = num // base\n        arr.append(alphabet[rem])\n    arr.reverse()\n    return ''.join(arr)\n\ndef base62_decode(string, alphabet=ALPHABET):\n    \"\"\"Decode a Base X encoded string into the number\n\n    Arguments:\n    - `string`: The encoded string\n    - `alphabet`: The alphabet to use for encoding\n    \"\"\"\n    base = len(alphabet)\n    strlen = len(string)\n    num = 0\n\n    idx = 0\n    for char in string:\n        power = (strlen - (idx + 1))\n        num += alphabet.index(char) * (base ** power)\n        idx += 1\n\n    return num\n</code>\n</pre>\n", "senID": 1}, {"text": ["Notice the fact that you can give it any Alphabet to use for encoding and decoding."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Hope this helps."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["PS - For URL shorteners, I have found that it's better to leave out a few confusing characters like 0Ol1oI etc.", "Thus I use this alphabet for my URL shortening needs - \"23456789abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\""], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "\"23456789abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Have fun."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I once wrote a script to do this aswell, I think it's quite elegant :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import string\nBASE_LIST = string.digits + string.letters + '_@'\nBASE_DICT = dict((c, i) for i, c in enumerate(BASE_LIST))\n\ndef base_decode(string, reverse_base=BASE_DICT):\n    length = len(reverse_base)\n    ret = 0\n    for i, c in enumerate(string[::-1]):\n        ret += (length ** i) * reverse_base[c]\n\n    return ret\n\ndef base_encode(integer, base=BASE_LIST):\n    length = len(base)\n    ret = ''\n    while integer != 0:\n        ret = base[integer % length] + ret\n        integer /= length\n\n    return ret\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for i in range(100):                                    \n    print i, base_decode(base_encode(i)), base_encode(i)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The following decoder-maker works with any reasonable base, has a much tidier loop, and gives an explicit error message when it meets an invalid character."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def base_n_decoder(alphabet):\n    \"\"\"Return a decoder for a base-n encoded string\n    Argument:\n    - `alphabet`: The alphabet used for encoding\n    \"\"\"\n    base = len(alphabet)\n    char_value = dict(((c, v) for v, c in enumerate(alphabet)))\n    def f(string):\n        num = 0\n        try:\n            for char in string:\n                num = num * base + char_value[char]\n        except KeyError:\n            raise ValueError('Unexpected character %r' % char)\n        return num\n    return f\n\nif __name__ == \"__main__\":\n    func = base_n_decoder('0123456789abcdef')\n    for test in ('0', 'f', '2020', 'ffff', 'abqdef'):\n        print test\n        print func(test)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You probably want base64, not base62.", "There's an URL-compatible version of it floating around, so the extra two filler characters shouldn't be a problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The process is fairly simple; consider that base64 represents 6 bits and a regular byte represents 8.", "Assign a value from 000000 to 111111 to each of the 64 characters chosen, and put the 4 values together to match a set of 3 base256 bytes.", "Repeat for each set of 3 bytes, padding at the end with your choice of padding character (0 is generally useful)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["you can download zbase62 module from pypi"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pypi", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/zbase62"}]}, {"text": ["eg "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import zbase62\n&gt;&gt;&gt; zbase62.b2a(\"abcd\")\n'1mZPsa'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I have a Python library for doing exactly that here: http://www.djangosnippets.org/snippets/1431/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.djangosnippets.org/snippets/1431/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.djangosnippets.org/snippets/1431/"}]}], [{"text": ["I have benefited greatly from others' posts here.", "I needed the python code originally for a Django project, but since then I have turned to node.js, so here's a javascript version of the code (the encoding part) that Baishampayan Ghose provided."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "javascript version", "childNum": 1, "tag": "strong", "pos": 1, "childList": [{"text": "javascript version", "tag": "em"}]}, {"text": "javascript version", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n var ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nfunction base62_encode(n, alpha) {\n  var num = n || 0;\n  var alphabet = alpha || ALPHABET;\n\n  if (num == 0) return alphabet[0];\n  var arr = [];\n  var base = alphabet.length;\n\n  while(num) {\n    rem = num % base;\n    num = (num - rem)/base;\n    arr.push(alphabet.substring(rem,rem+1));\n  }\n\n  return arr.reverse().join('');\n}\n\nconsole.log(base62_encode(2390687438976, \"123456789ABCDEFGHIJKLMNPQRSTUVWXYZ\"));\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Sorry, I can't help you with a library here.", "I would prefer using base64 and just adding to extra characters to your choice -- if possible!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Then you can use the base64 module."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If this is really, really not possible:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You can do it yourself this way (this is pseudo-code):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n base62vals = []\nmyBase = 62\nwhile num &gt; 0:\n   reminder = num % myBase\n   num = num / myBase\n   base62vals.insert(0, reminder)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Personally I like the solution from Baishampayan, mostly because of stripping the confusing characters."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For completeness, and solution with better performance, this post shows a way to use the Python base64 module."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://fi.am/entry/urlsafe-base64-encodingdecoding-in-two-lines/"}]}], [{"text": ["If all you need is to generate a short ID (since you mention URL shorteners) rather than encode/decode something, this module might help:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["https://github.com/stochastic-technologies/shortuuid/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "https://github.com/stochastic-technologies/shortuuid/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/stochastic-technologies/shortuuid/"}]}], [{"text": ["I wrote this a while back and it's worked pretty well (negatives and all included)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def code(number,base):\n    try:\n        int(number),int(base)\n    except ValueError:\n        raise ValueError('code(number,base): number and base must be in base10')\n    else:\n        number,base = int(number),int(base)\n    if base &lt; 2:\n        base = 2\n    if base &gt; 62:\n        base = 62\n    numbers = [0,1,2,3,4,5,6,7,8,9,\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\n               \"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\n               \"z\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\n               \"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\n    final = \"\"\n    loc = 0\n    if number &lt; 0:\n        final = \"-\"\n        number = abs(number)\n    while base**loc &lt;= number:\n        loc = loc + 1\n    for x in range(loc-1,-1,-1):\n        for y in range(base-1,-1,-1):\n            if y*(base**x) &lt;= number:\n                final = \"{}{}\".format(final,numbers[y])\n                number = number - y*(base**x)\n                break\n    return final\n\ndef decode(number,base):\n    try:\n        int(base)\n    except ValueError:\n        raise ValueError('decode(value,base): base must be in base10')\n    else:\n        base = int(base)\n    number = str(number)\n    if base &lt; 2:\n        base = 2\n    if base &gt; 62:\n        base = 62\n    numbers = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\n               \"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\n               \"w\",\"x\",\"y\",\"z\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\n               \"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\n    final = 0\n    if number.startswith(\"-\"):\n        neg = True\n        number = list(number)\n        del(number[0])\n        temp = number\n        number = \"\"\n        for x in temp:\n            number = \"{}{}\".format(number,x)\n    else:\n        neg = False\n    loc = len(number)-1\n    number = str(number)\n    for x in number:\n        if numbers.index(x) &gt; base:\n            raise ValueError('{} is out of base{} range'.format(x,str(base)))\n        final = final+(numbers.index(x)*(base**loc))\n        loc = loc - 1\n    if neg:\n        return -final\n    else:\n        return final\n</code>\n</pre>\n", "senID": 1}, {"text": ["sorry about the length of it all"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]