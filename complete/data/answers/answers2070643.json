[[{"text": ["I know \"for\" is not what you want, but it's simple and clear, why bother?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for x in b:\n  a.remove(x)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm not sure what the objection to a for loop is: there is no multiset in Python so you can't use a builtin container to help you out."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Seems to me anything on one line (if possible) will probably be helishly complex to understand.", "Go for readability and KISS.", "Python is not C :)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Python 2.7 and 3.2 will add the collections.Counter class which is a dictionary that maps elements to the number of occurrences of the element.", "This can be used as a multiset."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collections.Counter", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/collections.html#collections.Counter"}]}, {"text": ["According to the docs you should be able to do something like this (untested, since I do not have either version installed)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from collections import Counter\na = Counter(0,1,2,1)\nb = Counter(0,1,1)\n\nprint a - b  # ignores items in b missing in a\n\n# check every element in a is in b\n# a[key] returns 0 if key not in a, instead of raising an exception\nassert all(a[key] &gt; b[key] for key in b)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Since you are stuck with 2.5 you could try importing it and define your own version if that fails.", "That way you will be sure to get the latest version if it is available, and fall back to a working version if not.", "You will also benefit from speed improvements if if gets converted to a C implementation in the future."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["i.e."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n try:\n   from collections import Counter\nexcept ImportError:\n    class Counter(dict):\n       ...\n</code>\n</pre>\n", "senID": 6}, {"text": ["You can find the current Python source here. "], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Lib/collections.py?revision=HEAD&view=markup"}]}], [{"text": ["Python 2.7+ and 3.0 have collections.Counter (a.k.a.", "multiset).", "The documentation links to Recipe 576611: Counter class for Python 2.5:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "collections.Counter", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/collections.html#collections.Counter"}, {"text": "Recipe 576611: Counter class", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/576611/"}]}, {"code": "<pre>\n<code>\n from operator import itemgetter\nfrom heapq import nlargest\nfrom itertools import repeat, ifilter\n\nclass Counter(dict):\n    '''Dict subclass for counting hashable objects.  Sometimes called a bag\n    or multiset.  Elements are stored as dictionary keys and their counts\n    are stored as dictionary values.\n\n    &gt;&gt;&gt; Counter('zyzygy')\n    Counter({'y': 3, 'z': 2, 'g': 1})\n\n    '''\n\n    def __init__(self, iterable=None, **kwds):\n        '''Create a new, empty Counter object.  And if given, count elements\n        from an input iterable.  Or, initialize the count from another mapping\n        of elements to their counts.\n\n        &gt;&gt;&gt; c = Counter()                           # a new, empty counter\n        &gt;&gt;&gt; c = Counter('gallahad')                 # a new counter from an iterable\n        &gt;&gt;&gt; c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping\n        &gt;&gt;&gt; c = Counter(a=4, b=2)                   # a new counter from keyword args\n\n        '''        \n        self.update(iterable, **kwds)\n\n    def __missing__(self, key):\n        return 0\n\n    def most_common(self, n=None):\n        '''List the n most common elements and their counts from the most\n        common to the least.  If n is None, then list all element counts.\n\n        &gt;&gt;&gt; Counter('abracadabra').most_common(3)\n        [('a', 5), ('r', 2), ('b', 2)]\n\n        '''        \n        if n is None:\n            return sorted(self.iteritems(), key=itemgetter(1), reverse=True)\n        return nlargest(n, self.iteritems(), key=itemgetter(1))\n\n    def elements(self):\n        '''Iterator over elements repeating each as many times as its count.\n\n        &gt;&gt;&gt; c = Counter('ABCABC')\n        &gt;&gt;&gt; sorted(c.elements())\n        ['A', 'A', 'B', 'B', 'C', 'C']\n\n        If an element's count has been set to zero or is a negative number,\n        elements() will ignore it.\n\n        '''\n        for elem, count in self.iteritems():\n            for _ in repeat(None, count):\n                yield elem\n\n    # Override dict methods where the meaning changes for Counter objects.\n\n    @classmethod\n    def fromkeys(cls, iterable, v=None):\n        raise NotImplementedError(\n            'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')\n\n    def update(self, iterable=None, **kwds):\n        '''Like dict.update() but add counts instead of replacing them.\n\n        Source can be an iterable, a dictionary, or another Counter instance.\n\n        &gt;&gt;&gt; c = Counter('which')\n        &gt;&gt;&gt; c.update('witch')           # add elements from another iterable\n        &gt;&gt;&gt; d = Counter('watch')\n        &gt;&gt;&gt; c.update(d)                 # add elements from another counter\n        &gt;&gt;&gt; c['h']                      # four 'h' in which, witch, and watch\n        4\n\n        '''        \n        if iterable is not None:\n            if hasattr(iterable, 'iteritems'):\n                if self:\n                    self_get = self.get\n                    for elem, count in iterable.iteritems():\n                        self[elem] = self_get(elem, 0) + count\n                else:\n                    dict.update(self, iterable) # fast path when counter is empty\n            else:\n                self_get = self.get\n                for elem in iterable:\n                    self[elem] = self_get(elem, 0) + 1\n        if kwds:\n            self.update(kwds)\n\n    def copy(self):\n        'Like dict.copy() but returns a Counter instance instead of a dict.'\n        return Counter(self)\n\n    def __delitem__(self, elem):\n        'Like dict.__delitem__() but does not raise KeyError for missing values.'\n        if elem in self:\n            dict.__delitem__(self, elem)\n\n    def __repr__(self):\n        if not self:\n            return '%s()' % self.__class__.__name__\n        items = ', '.join(map('%r: %r'.__mod__, self.most_common()))\n        return '%s({%s})' % (self.__class__.__name__, items)\n\n    # Multiset-style mathematical operations discussed in:\n    #       Knuth TAOCP Volume II section 4.6.3 exercise 19\n    #       and at http://en.wikipedia.org/wiki/Multiset\n    #\n    # Outputs guaranteed to only include positive counts.\n    #\n    # To strip negative and zero counts, add-in an empty counter:\n    #       c += Counter()\n\n    def __add__(self, other):\n        '''Add counts from two counters.\n\n        &gt;&gt;&gt; Counter('abbb') + Counter('bcc')\n        Counter({'b': 4, 'c': 2, 'a': 1})\n\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        result = Counter()\n        for elem in set(self) | set(other):\n            newcount = self[elem] + other[elem]\n            if newcount &gt; 0:\n                result[elem] = newcount\n        return result\n\n    def __sub__(self, other):\n        ''' Subtract count, but keep only results with positive counts.\n\n        &gt;&gt;&gt; Counter('abbbc') - Counter('bccd')\n        Counter({'b': 2, 'a': 1})\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        result = Counter()\n        for elem in set(self) | set(other):\n            newcount = self[elem] - other[elem]\n            if newcount &gt; 0:\n                result[elem] = newcount\n        return result\n\n    def __or__(self, other):\n        '''Union is the maximum of value in either of the input counters.\n\n        &gt;&gt;&gt; Counter('abbb') | Counter('bcc')\n        Counter({'b': 3, 'c': 2, 'a': 1})\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        _max = max\n        result = Counter()\n        for elem in set(self) | set(other):\n            newcount = _max(self[elem], other[elem])\n            if newcount &gt; 0:\n                result[elem] = newcount\n        return result\n\n    def __and__(self, other):\n        ''' Intersection is the minimum of corresponding counts.\n\n        &gt;&gt;&gt; Counter('abbb') &amp; Counter('bcc')\n        Counter({'b': 1})\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        _min = min\n        result = Counter()\n        if len(self) &lt; len(other):\n            self, other = other, self\n        for elem in ifilter(self.__contains__, other):\n            newcount = _min(self[elem], other[elem])\n            if newcount &gt; 0:\n                result[elem] = newcount\n        return result\n\n\nif __name__ == '__main__':\n    import doctest\n    print doctest.testmod()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can write"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a = Counter([0,1,2,1,0])\n b = Counter([0, 1, 1])\n c = a - b\n print list(c.elements())  # [0, 2]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I would do it in an easier way:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "I would do it in an easier way:", "childNum": 0, "tag": "strike", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a_b = [e for e in a if not e in b ]\n</code>\n</pre>\n", "senID": 1}, {"senID": 2}, {"text": ["..as wich wrote, this is wrong - it works only if the items are unique in the lists.", "And if they are, it's better to use"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n a_b = list(set(a) - set(b))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You can try something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class mylist(list):\n\n    def __sub__(self, b):\n        result = self[:]\n        b = b[:]\n        while b:\n            try:\n                result.remove(b.pop())\n            except ValueError:\n                raise Exception(\"Not all elements found during subtraction\")\n        return result\n\n\na = mylist([0, 1, 2, 1, 0] )\nb = mylist([0, 1, 1])\n\n&gt;&gt;&gt; a - b\n[2, 0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["You have to define what [1, 2, 3] - [5, 6] should output though, I guess you want [1, 2, 3] thats why I ignore the ValueError."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit:\nNow I see you wanted an exception if a does not contain all elements, added it instead of passing the ValueError."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["to use list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [i for i in a if not i in b or b.remove(i)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["would do the trick.", "It would change b in the process though.", "But I agree with jkp and Dyno Fu that using a for loop would be better."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Perhaps someone can create a better example that uses list comprehension but still is KISS? "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["To prove jkp's point that 'anything on one line will probably be helishly complex to understand', I created a one-liner.", "Please do not mod me down because I understand this is not a solution that you should actually use.", "It is just for demonstrational purposes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The idea is to add the values in a one by one, as long as the total times you have added that value does is smaller than the total number of times this value is in a minus the number of times it is in b:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [ value for counter,value in enumerate(a) if a.count(value) &gt;= b.count(value) + a[counter:].count(value) ]\n</code>\n</pre>\n", "senID": 2}, {"text": ["The horror!", "But perhaps someone can improve on it?", "Is it even bug free?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit: Seeing Devin Jeanpierre comment about using a dictionary datastructure, I came up with this oneliner:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n sum([ [value]*count for value,count in {value:a.count(value)-b.count(value) for value in set(a)}.items() ], [])\n</code>\n</pre>\n", "senID": 5}, {"text": ["Better, but still unreadable."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I attempted to find a more elegant solution, but the best I could do was basically the same thing that Dyno Fu said:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from copy import copy\n\ndef subtract_lists(a, b):\n    \"\"\"\n    &gt;&gt;&gt; a = [0, 1, 2, 1, 0]\n    &gt;&gt;&gt; b = [0, 1, 1]\n    &gt;&gt;&gt; subtract_lists(a, b)\n    [2, 0]\n\n    &gt;&gt;&gt; import random\n    &gt;&gt;&gt; size = 10000\n    &gt;&gt;&gt; a = [random.randrange(100) for _ in range(size)]\n    &gt;&gt;&gt; b = [random.randrange(100) for _ in range(size)]\n    &gt;&gt;&gt; c = subtract_lists(a, b)\n    &gt;&gt;&gt; assert all((x in a) for x in c)\n    \"\"\"\n    a = copy(a)\n    for x in b:\n        if x in a:\n            a.remove(x)\n    return a\n</code>\n</pre>\n", "senID": 1}]]