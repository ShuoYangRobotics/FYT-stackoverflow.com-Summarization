[[{"text": ["In Python, use heapq.nlargest.", "This is the most flexible approach in case you ever want to handle more than just the top two elements."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "heapq.nlargest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here's an example."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import heapq\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; x = range(100000)\n&gt;&gt;&gt; random.shuffle(x)\n&gt;&gt;&gt; heapq.nlargest(2, x)\n[99999, 99998]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Documentation:\nhttp://docs.python.org/library/heapq.html#heapq.nlargest"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://docs.python.org/library/heapq.html#heapq.nlargest", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/heapq.html#heapq.nlargest"}]}], [{"text": ["You iterate over the list, maintaining variables that contain the value of the highest and the second highest item encountered thus far.", "Each new item that is encountered will replace whichever of the two the new item is higher than (if any)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["A really slick way is to use heapq.", "Heapify the array (O(n)), then just pop an many elements that you need (log(n)).", "(Saw this question in an interview once, good question to keep in mind."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "heapq", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Heapify the array", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/heapq.html"}]}], [{"text": ["JacobM's answer is absolutely the way to go.", "However, there are a few things to keep in mind while implementing what he described.", "Here's a little play-along-at-home tutorial to guide you through the trickier parts of solving this problem."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "JacobM's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2739051/retrieve-the-2-highest-item-from-a-list-containing-100-000-integers/2739090#2739090"}]}, {"text": ["If this code is meant for production use, please use one of the more efficient/concise answers listed.", "This answer is targetted at someone new to programming."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "If this code is meant for production use, please use one of the more efficient/concise answers listed. This answer is targetted at someone new to programming.", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["The idea is simple."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Keep two variables: ", "tag": "none", "senID": 3}, {"text": "Go through the list.\n", "tag": "none", "senID": 4}]}, {"text": ["Let's start."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def two_largest(inlist):\n    \"\"\"Return the two largest items in the sequence. The sequence must\n    contain at least two items.\"\"\"\n    for item in inlist:\n        if item &gt; largest:\n            largest = item\n        elif largest &gt; item &gt; second_largest:\n            second_largest = item\n    # Return the results as a tuple\n    return largest, second_largest\n\n# If we run this script, it will should find the two largest items and\n# print those\nif __name__ == \"__main__\":\n    inlist = [3, 2, 1]\n    print two_largest(inlist)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Okay, we now have JacobM's answer as a Python function.", "What happens when we try to run it?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n Traceback (most recent call last):\n  File \"twol.py\", line 10, in &lt;module&gt;\n    print two_largest(inlist)\n  File \"twol.py\", line 3, in two_largest\n    if item &gt; largest:\nUnboundLocalError: local variable 'largest' referenced before assignment\n</code>\n</pre>\n", "senID": 8}, {"text": ["Apparently, we need to set largest before we start the loop.", "This probably means we should set second_largest too."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "largest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "second_largest", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Let's set largest and second_largest to 0."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "largest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "second_largest", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def two_largest(inlist):\n    \"\"\"Return the two largest items in the sequence. The sequence must\n    contain at least two items.\"\"\"\n    largest = 0 # NEW!\n    second_largest = 0 # NEW!\n    for item in inlist:\n        if item &gt; largest:\n            largest = item\n        elif largest &gt; item &gt; second_largest:\n            second_largest = item\n    # Return the results as a tuple\n    return largest, second_largest\n\n# If we run this script, it will should find the two largest items and\n# print those\nif __name__ == \"__main__\":\n    inlist = [3, 2, 1]\n    print two_largest(inlist)\n</code>\n</pre>\n", "senID": 11}, {"text": ["Good.", "Let's run it."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n (3, 2)\n</code>\n</pre>\n", "senID": 13}, {"text": ["Great!", "Now let's test with inlist being [1, 2, 3]"], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "inlist", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "[1, 2, 3]", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n inlist = [1, 2, 3] # CHANGED!\n</code>\n</pre>\n", "senID": 15}, {"text": ["Let's try it."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n (3, 0)\n</code>\n</pre>\n", "senID": 17}, {"text": ["...Uh oh."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["The largest value (3) seems correct.", "The second-largest value is completely wrong though.", "What's going on?"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["Let's work through what the function is doing."], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "When we start, ", "tag": "none", "senID": 21}, {"text": "The first item in the list we look at is 1, so ", "tag": "none", "senID": 22}, {"text": "The next item is 2, so ", "tag": "none", "senID": 23}]}, {"text": ["But what about second_largest?"], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "second_largest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["When we assign a new value to largest, the largest value actually becomes second-largest.", "We need to show that in the code."], "childNum": 1, "tag": "p", "senID": 25, "childList": [{"text": "largest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def two_largest(inlist):\n    \"\"\"Return the two largest items in the sequence. The sequence must\n    contain at least two items.\"\"\"\n    largest = 0\n    second_largest = 0\n    for item in inlist:\n        if item &gt; largest:\n            second_largest = largest # NEW!\n            largest = item\n        elif largest &gt; item &gt; second_largest:\n            second_largest = item\n    # Return the results as a tuple\n    return largest, second_largest\n\n# If we run this script, it will should find the two largest items and\n# print those\nif __name__ == \"__main__\":\n    inlist = [1, 2, 3]\n    print two_largest(inlist)\n</code>\n</pre>\n", "senID": 26}, {"text": ["Let's run it."], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"code": "<pre>\n<code>\n (3, 2)\n</code>\n</pre>\n", "senID": 28}, {"text": ["Fantastic."], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"text": ["Now let's try it with a list of negative numbers."], "childNum": 0, "tag": "p", "senID": 30, "childList": []}, {"code": "<pre>\n<code>\n inlist = [-1, -2, -3] # CHANGED!\n</code>\n</pre>\n", "senID": 31}, {"text": ["Let's run it."], "childNum": 0, "tag": "p", "senID": 32, "childList": []}, {"code": "<pre>\n<code>\n (0, 0)\n</code>\n</pre>\n", "senID": 33}, {"text": ["That's not right at all.", "Where did these zeroes come from?"], "childNum": 0, "tag": "p", "senID": 34, "childList": []}, {"text": ["It turns out that the starting values for largest and second_largest were actually larger than all the items in the list.", "The first thing you might consider is setting largest and second_largest to the lowest values possible in Python.", "Unfortunately, Python doesn't have a smallest possible value.", "That means that, even if you set both of them to -1,000,000,000,000,000,000, you can have a list of values smaller than that."], "childNum": 4, "tag": "p", "senID": 35, "childList": [{"text": "largest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "second_largest", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "largest", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "second_largest", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["So what's the best thing to do?", "Let's try setting largest and second_largest to the first and second items in the list.", "Then, to avoid double-counting any items in the list, we only look at the part of the list after the second item."], "childNum": 2, "tag": "p", "senID": 36, "childList": [{"text": "largest", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "second_largest", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def two_largest(inlist):\n    \"\"\"Return the two largest items in the sequence. The sequence must\n    contain at least two items.\"\"\"\n    largest = inlist[0] # CHANGED!\n    second_largest = inlist[1] # CHANGED!\n    # Only look at the part of inlist starting with item 2\n    for item in inlist[2:]: # CHANGED!\n        if item &gt; largest:\n            second_largest = largest\n            largest = item\n        elif largest &gt; item &gt; second_largest:\n            second_largest = item\n    # Return the results as a tuple\n    return largest, second_largest\n\n# If we run this script, it will should find the two largest items and\n# print those\nif __name__ == \"__main__\":\n    inlist = [-1, -2, -3]\n    print two_largest(inlist)\n</code>\n</pre>\n", "senID": 37}, {"text": ["Let's run it."], "childNum": 0, "tag": "p", "senID": 38, "childList": []}, {"code": "<pre>\n<code>\n (-1, -2)\n</code>\n</pre>\n", "senID": 39}, {"text": ["Great!", "Let's try with another list of negative numbers."], "childNum": 0, "tag": "p", "senID": 40, "childList": []}, {"code": "<pre>\n<code>\n inlist = [-3, -2, -1] # CHANGED!\n</code>\n</pre>\n", "senID": 41}, {"text": ["Let's run it."], "childNum": 0, "tag": "p", "senID": 42, "childList": []}, {"code": "<pre>\n<code>\n (-1, -3)\n</code>\n</pre>\n", "senID": 43}, {"text": ["Wait, what?"], "childNum": 0, "tag": "p", "senID": 44, "childList": []}, {"text": ["Let's step through our logic again."], "childNum": 0, "tag": "p", "senID": 45, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["largest"], "childNum": 0, "tag": "code", "senID": 46, "childList": []}, {"text": ["second_largest"], "childNum": 0, "tag": "code", "senID": 47, "childList": []}]}, {"text": ["Wait right there.", "Already, this seems wrong.", "-2 is larger than -3.", "Is this what caused the problem?", "Let's continue."], "childNum": 0, "tag": "p", "senID": 48, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["largest"], "childNum": 0, "tag": "code", "senID": 49, "childList": []}]}, {"text": ["Yes, that looks to be the problem.", "We need to ensure that largest and second_largest are set correctly."], "childNum": 2, "tag": "p", "senID": 50, "childList": [{"text": "largest", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "second_largest", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def two_largest(inlist):\n    \"\"\"Return the two largest items in the sequence. The sequence must\n    contain at least two items.\"\"\"\n    if inlist[0] &gt; inlist[1]: # NEW\n        largest = inlist[0]\n        second_largest = inlist[1]\n    else: # NEW\n        largest = inlist[1] # NEW\n        second_largest = inlist[0] # NEW\n    # Only look at the part of inlist starting with item 2\n    for item in inlist[2:]:\n        if item &gt; largest:\n            second_largest = largest\n            largest = item\n        elif largest &gt; item &gt; second_largest:\n            second_largest = item\n    # Return the results as a tuple\n    return largest, second_largest\n\n# If we run this script, it will should find the two largest items and\n# print those\nif __name__ == \"__main__\":\n    inlist = [-3, -2, -1]\n    print two_largest(inlist)\n</code>\n</pre>\n", "senID": 51}, {"text": ["Let's run it."], "childNum": 0, "tag": "p", "senID": 52, "childList": []}, {"code": "<pre>\n<code>\n (-1, -2)\n</code>\n</pre>\n", "senID": 53}, {"text": ["Excellent."], "childNum": 0, "tag": "p", "senID": 54, "childList": []}, {"text": ["So here's the code, nicely commented and formatted.", "It's also had all the bugs I could find beaten from it.", "Enjoy."], "childNum": 0, "tag": "p", "senID": 55, "childList": []}, {"text": ["However, assuming this really is a homework question, I hope you get some useful experience from seeing an imperfect piece of code slowly improved.", "I hope some of these techniques will be useful in future programming assignments."], "childNum": 0, "tag": "p", "senID": 56, "childList": []}, {"text": ["Not very efficient.", "But for most purposes, it should be okay: on my computer (Core 2 Duo), a list of 100 000 items can be processed in 0.27 seconds (using timeit, averaged over 100 runs)."], "childNum": 1, "tag": "p", "senID": 57, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["This will work, but I don't know if you want to retain the items in the list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n max1 = max(myList)\nmyList.remove(max1)\nmax2 = max(myList)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you do, you can do this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n max1 = max(myList)\nidx1 = myList.index(max1)\nmyList.pop(idx1)\n\nmax2 = max(myList)\nmyList.insert(idx1,max1)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Iterating through the entire list is the only way to do it without sorting."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Without sorting the list the only way to really do it is to iterate through the whole list and save the highest two numbers.", "I think you'd be better off sorting the list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The second highest item is a fairly simple case, but for the kth highest item what you want is a selection algorithm.", "That page is pretty thorough so it's probably best just to read that. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "selection algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Selection_algorithm"}]}], [{"text": ["The best time you can expect is linear, since you have to at least look through all the elements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is my pseudocode to solve the problem:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n //assume list has at least 2 elements\n(max, nextMax) = if (list[0] &gt; list[1])\n                 then (list[0], list[1])\n                 else (list[1], list[0])\n\nfor (2 &lt;= i &lt; length) {\n    (max, nextMax) = if       (max &lt; list[i])     =&gt; (list[i], max)\n                     elseif   (nextMax &lt; list[i]) =&gt; (max, list[i])\n                     else     (no change)         =&gt; (max, nextMax)\n}\n\nreturn (max, nextMax)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["\"2 highest\" is impossible; only one item can be \"highest\".", "Perhaps you mean \"highest 2\".", "In any case, you need to say what to do when the list contains duplicates.", "What do you want from [8, 9, 10, 10]: (10, 9) or (10, 10)?", "If your response is (10, 10), please consider input of [8, 9, 10, 10, 10].", "What are you going to do with the \"highest two\" when you've got them?", "Please edit your question to give this guidance."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\"2 highest\" is impossible; only one item can be \"highest\".", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["In the meantime, here's an answer that takes the first approach (two unique values):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n largest = max(inlist)\nsecond_largest = max(item for item in inlist if item &lt; largest)\n</code>\n</pre>\n", "senID": 2}, {"text": ["You should add guards against fewer than 2 unique values in the list."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]