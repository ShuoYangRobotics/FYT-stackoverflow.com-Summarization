[[{"code": "<pre>\n<code>\n def find_odds(numbers):\n  if not numbers:\n    return []\n  if numbers[0] % 2 == 1:\n    return [numbers[0]] + find_odds(numbers[1:])\n  return find_odds(numbers[1:])\n</code>\n</pre>\n", "senID": 0}, {"text": ["No extra variables or parameters needed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n def only_odd(L):\n    return L[0:L[0]&amp;1]+only_odd(L[1:]) if L else L\n</code>\n</pre>\n", "senID": 0}, {"text": ["This version is much faster as it avoids making copies of L"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def only_odd_no_copy(L, i=0):\n    return L[i:i+(L[i]&amp;1)]+only_odd_no_copy(L, i+1) if i&lt;len(L) else []\n</code>\n</pre>\n", "senID": 2}, {"text": ["This one only uses O(log n) stack space"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def only_odd_logn(L):\n    x=len(L)/2+1\n    return L[:L[0]&amp;1] + only_odd2(L[1:x]) + only_odd_logn(L[x:]) if L else L\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Considering the default stack depth limit of 1000 in python, I would really not use recursion for this.", "I know there are a lot of recursive implementations above so here's a non-recursive one that is doing it the python way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print filter(lambda x: x % 2, range(0, 10))\n</code>\n</pre>\n", "senID": 1}, {"text": ["And for the sake of completeness; if you really really must use recursion here's my go at it.", "This is very similar to the version by Josh Matthews."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def rec_foo(list):\n    if not list:\n        return []\n    return ([list[0]] if list[0] % 2 else []) + rec_foo(list[1:])\n\nprint rec_foo(range(1, 10))\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n def find_odds(numbers, odds):\n    if len(numbers) == 0:\n        return\n    v = numbers.pop()\n    if v % 2 == 1:\n        odds.append(v)\n    find_odds(numbers, odds)\n\nodds = []\nnumbers = [1,2,3,4,5,6,7]\nfind_odds(numbers,odds)\n# Now odds has the odd numbers\nprint odds\n</code>\n</pre>\n", "senID": 0}, {"text": ["Here's a test output of what I get when I run this"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["[7, 5, 3, 1]"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's another way of doing it which returns the list of odd numbers rather than modifying the list passed in.", "Very similar to that provided by GWW but I thought I'd add it for completeness."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "GWW", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def find_odds(numbers, odds):\n    if len(numbers) == 0:\n        return odds\n\n    if numbers[0] % 2 == 1:\n        odds.append(numbers[0])\n\n    return find_odds(numbers[1:],odds)\n\nprint find_odds([1,2,3,4,5,6,7,8,9],[])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [1, 3, 5, 7, 9]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Since it's a party, I just thought I'd chime in with a nice, sensible, Real ProgrammerTM solution.", "It's written in emacs and inspired by gnibbler's answer.", "Like his, it uses &amp;1 instead of % 2 (adding 2 into co_consts is pure decadence if 1 is already there) and uses that nifty trick for getting the first element only if it's odd, but shaves some cycles off for a time savings of around 5% (on my machine, running 2.6.5 compiled with GCC 4.4.3 on a linux2 kernel)."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "TM", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"text": "&amp;1", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "% 2", "childNum": 0, "tag": "code", "childList": []}, {"text": "co_consts", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from opcode import opmap\nimport types\n\nopcodes = [opmap['LOAD_FAST'],      0,0,   #    L\n           opmap['JUMP_IF_FALSE'],  24,0, \n           opmap['DUP_TOP'],\n           opmap['LOAD_CONST'],     0,0,   #    0\n           opmap['BINARY_SUBSCR'],  \n           opmap['LOAD_CONST'],     1,0,   #    1\n           opmap['BINARY_AND'],\n           opmap['SLICE+2'],\n           opmap['LOAD_GLOBAL'],    0,0,   #    odds\n           opmap['LOAD_FAST'],      0,0,\n           opmap['LOAD_CONST'],     1,0,\n           opmap['SLICE+1'],\n           opmap['CALL_FUNCTION'],  1,0,\n           opmap['BINARY_ADD'],\n           opmap['RETURN_VALUE']]\n\ncode_str = ''.join(chr(byte) for byte in opcodes)\n\ncode = types.CodeType(1, 1, 4, 0x1 | 0x2 | 0x40, code_str, (0, 1),\n                      ('odds',), ('L',), '&lt;nowhere&gt;', 'odds',\n                      0, '')\n\nodds = types.FunctionType(code, globals())\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n odds = []\ndef findOdds(listOfNumbers):\n    if listOfNumbers[0] % 2 == 1:\n        odds.append(listOfNumbers[0])\n    if len(listOfNumbers) &gt; 1:\n        findOdds(listOfNumbers[1:])\n\nfindOdds(range(0,10))\nprint odds\n# returns [1,3,5,7,9]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; def fodds(alist, odds=None):\n...     if odds is None: odds = []\n...     if not alist: return odds\n...     x = alist[0] # doesn't destroy the input sequence\n...     if x % 2: odds.append(x)\n...     return fodds(alist[1:], odds)\n...\n&gt;&gt;&gt; fodds(range(10)) # only one arg needs to be supplied\n[1, 3, 5, 7, 9] # same order as input\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}, {"text": ["This one avoids the list copying overhead, at the cost of getting the answer backwards and a big increase in the ugliness factor:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def fo(aseq, pos=None, odds=None):\n...     if odds is None: odds = []\n...     if pos is None: pos = len(aseq) - 1\n...     if pos &lt; 0: return odds\n...     x = aseq[pos]\n...     if x % 2: odds.append(x)\n...     return fo(aseq, pos - 1, odds)\n...\n&gt;&gt;&gt; fo(range(10))\n[9, 7, 5, 3, 1]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n def odds(L):\n    if L == []: \n        return []\n    else:\n        if L[0]%2:\n            B = odds(L[1:])\n            B.append(L[0])\n            return B\n        else:\n            return odds(L[1:])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Well, there are a bunch of other answers but I think mine's the cleanest:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def odds(L):\n   if not L: \n      return []\n   return [L[0]] * (L[0] % 2) + odds(L[1:])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Fun exercise but just to reiterate, don't ever do this recursively in practice."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["well since we're all contributing: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def odds(aList):\n    from operator import lshift as l\n    if aList and not aList[1:]:\n        return aList if aList[-1] - l(aList[0]&gt;&gt;1, 1) else list()\n    return odds(aList[:len(aList)/3+1]) + odds(aList                                     \\\n    [len(aList)/3+1:]) if aList else []\n</code>\n</pre>\n", "senID": 1}]]