[[{"text": ["For word segmentation in Chinese, and other advanced tasks in processing natural language, consider NLTK as a good starting point if not a complete solution -- it's a rich Python-based toolkit, particularly good for learning about NL processing techniques (and not rarely good enough to offer you viable solution to some of these problems)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "NLTK", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://nltk.googlecode.com/svn/trunk/doc/book/ch03.html#word-segmentation"}]}], [{"text": ["Chinese doesn't usually have whitespace between words, and the symbols can have different meanings depending on context.", "You will have to understand the text in order to split it at a word boundary.", "In other words, what you are trying to do is not easy in general."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["the re.Uflag will treat \\s according to the Unicode character properties database."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "re.Uflag", "tag": "a", "pos": 0, "childList": [{"text": "re.U", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/re.html#re.U"}, {"text": "re.U", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\s", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The given string, however, doesn't apparently contain any white space characters according to python's unicode database:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = u'\\u7b80\\u8baf\\uff1a\\u65b0\\u83ef\\u793e\\u5831\\u9053\\uff0c\\u7f8e\\u570b\\u7e3d\\u7d71\\u5967\\u5df4\\u99ac\\u4e58\\u5750\\u7684\\u300c\\u7a7a\\u8ecd\\u4e00\\u865f\\u300d\\u5c08\\u6a5f\\u665a\\u4e0a10\\u664242\\u5206\\u9032\\u5165\\u4e0a\\u6d77\\u7a7a\\u57df\\uff0c\\u9810\\u8a08\\u7d0430\\u5206\\u9418\\u5f8c\\u62b5\\u9054\\u6d66\\u6771\\u570b\\u969b\\u6a5f\\u5834\\uff0c\\u958b\\u5c55\\u4ed6\\u4e0a\\u4efb\\u5f8c\\u9996\\u6b21\\u8a2a\\u83ef\\u4e4b\\u65c5\\u3002'\n&gt;&gt;&gt; re.compile(r'\\s+', re.U).split(x)\n[u'\\u7b80\\u8baf\\uff1a\\u65b0\\u83ef\\u793e\\u5831\\u9053\\uff0c\\u7f8e\\u570b\\u7e3d\\u7d71\\u5967\\u5df4\\u99ac\\u4e58\\u5750\\u7684\\u300c\\u7a7a\\u8ecd\\u4e00\\u865f\\u300d\\u5c08\\u6a5f\\u665a\\u4e0a10\\u664242\\u5206\\u9032\\u5165\\u4e0a\\u6d77\\u7a7a\\u57df\\uff0c\\u9810\\u8a08\\u7d0430\\u5206\\u9418\\u5f8c\\u62b5\\u9054\\u6d66\\u6771\\u570b\\u969b\\u6a5f\\u5834\\uff0c\\u958b\\u5c55\\u4ed6\\u4e0a\\u4efb\\u5f8c\\u9996\\u6b21\\u8a2a\\u83ef\\u4e4b\\u65c5\\u3002']\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This punts the word-breaking decision to the re module, but it may work well enough for you."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef shorten(tweet, footer=\"\", limit=140):\n    \"\"\"Break tweet into two pieces at roughly the last word break\n    before limit.\n    \"\"\"\n    lower_break_limit = limit / 2\n    # limit under which to assume breaking didn't work as expected\n\n    limit -= len(footer)\n\n    tweet = re.sub(r\"\\s+\", \" \", tweet.strip())\n    m = re.match(r\"^(.{,%d})\\b(?:\\W|$)\" % limit, tweet, re.UNICODE)\n    if not m or m.end(1) &lt; lower_break_limit:\n        # no suitable word break found\n        # cutting at an arbitrary location,\n        # or if len(tweet) &lt; lower_break_limit, this will be true and\n        # returning this still gives the desired result\n        return tweet[:limit] + footer\n    return m.group(1) + footer\n</code>\n</pre>\n", "senID": 1}], [{"text": ["After speaking with some native Cantonese, Mandarin, and Japanese speakers it seems that the correct thing to do is hard, but my current algorithm still makes sense to them in the context of internet posts. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Meaning, they are used to the \"split on space and add \u2026 at the end\" treatment."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So I'm going to be lazy and stick with it, until I get complaints from people that don't understand it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The only change to my original implementation would be to not force a space on the last word since it is unneeded in any language (and use the unicode character \u2026 &amp;#x2026 instead of ... three dots to save 2 characters)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "&amp;#x2026", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "three dots", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I tried out the solution with PyAPNS for push notifications and just wanted to share what worked for me.", "The issue I had is that truncating at 256 bytes in UTF-8 would result in the notification getting dropped.", "I had to make sure the notification was encoded as \"unicode_escape\" to get it to work.", "I'm assuming this is because the result is sent as JSON and not raw UTF-8.", "Anyways here is the function that worked for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def unicode_truncate(s, length, encoding='unicode_escape'):\n    encoded = s.encode(encoding)[:length]\n    return encoded.decode(encoding, 'ignore')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Basically, in CJK (Except Korean with spaces), you need dictionary look-ups to segment words properly.", "Depending on your exact definition of \"word\", Japanese can be more difficult than that, since not all inflected variants of a word (i.e.", "\"\u884c\u3053\u3046\" vs. \"\u884c\u3063\u305f\") will appear in the dictionary.", "Whether it's worth the effort depends upon your application."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Save two characters and use an elipsis (\u2026, 0x2026) instead of three dots!"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "\u2026", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://www.fileformat.info/info/unicode/char/2026/index.htm", "text": "0x2026", "childNum": 0, "tag": "a", "childList": []}]}]]