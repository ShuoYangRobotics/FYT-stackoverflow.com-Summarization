[[{"text": ["I'd vote for parsing the file, checking you've got 4 components per record, that the first two components are strings, the third is an int (checking for NaN conditions), and the fourth is a float (also checking for NaN conditions)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python would be an excellent tool for the job."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I'm not aware of any libraries in Python to deal with validation of CSV files against a spec, but it really shouldn't be too hard to write."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import csv\nimport math\n\ndataChecker = csv.reader(open('data.csv'))\nfor row in dataChecker:\n    if len(row) != 4:\n        print 'Invalid row length.'\n        return\n\n    my_int = int(row[2])\n    my_float = float(row[3])\n\n    if math.isnan(my_int):\n        print 'Bad int found'\n        return\n\n    if math.isnan(my_float):\n        print 'Bad float found'\n        return\n\nprint 'All good!'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's a small snippet I made:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import csv \n\nf = csv.reader(open(\"test.csv\"))\n\nfor value in f:\n    value[0] = str(value[0])\n    value[1] = str(value[1])\n    value[2] = int(value[2])\n    value[3] = float(value[3])\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you run that with a file that doesn't have the format your specified, you'll get an exception:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ python valid.py \nTraceback (most recent call last):\n  File \"valid.py\", line 8, in &lt;module&gt;\n    i[2] = int(i[2])\nValueError: invalid literal for int() with base 10: 'a3'\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can then make a try-except ValueError to catch it and let the users know what they did wrong."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["There can be a lot of corner-cases for parsing CSV, so you probably don't want to try doing it \"by hand\".", "At least start with a package/library built-in to the language that you're using, even if it doesn't do all the \"verification\" you can think of."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Once you get there, then examine the fields for your list of \"illegal\" chars, or examine the values in each field to determine they're valid (if you can do so).", "You also don't even need a regex for this task necessarily, but it may be more concise to do it that way."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You might also disallow embedded \\r or \\n, \\0 or \\t.", "Just loop through the fields and check them after you've loaded the data with your csv lib."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Try Cutplace.", "It verifies that tabluar data conforms to an interface control document."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Cutplace", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cutplace.sourceforge.net/"}, {"text": "interface control document", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Pyparsing will process this data, and will be tolerant of unexpected things like spaces before and after commas, commas within quotes, etc.", "(csv module is too, but regex solutions force you to add \"\\s*\" bits all over the place)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from pyparsing import *\n\ninteger = Regex(r\"-?\\d+\").setName(\"integer\")\ninteger.setParseAction(lambda tokens: int(tokens[0]))\nfloatnum = Regex(r\"-?\\d+\\.\\d*\").setName(\"float\")\nfloatnum.setParseAction(lambda tokens: float(tokens[0]))\ndblQuotedString.setParseAction(removeQuotes)\nCOMMA = Suppress(',')\nvalidLine = dblQuotedString + COMMA + dblQuotedString + COMMA + \\\n        integer + COMMA + floatnum + LineEnd()\n\ntests = \"\"\"\\\n\"good data\",\"good2\",100,3.14\n\"good data\" , \"good2\", 100, 3.14\nbad, \"good\",\"good2\",100,3.14\n\"bad\",\"good2\",100,3\n\"bad\",\"good2\",100.5,3\n\"\"\".splitlines()\n\nfor t in tests:\n    print t\n    try:\n        print validLine.parseString(t).asList()\n    except ParseException, pe:\n        print pe.markInputline('?')\n        print pe.msg\n    print\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n \"good data\",\"good2\",100,3.14\n['good data', 'good2', 100, 3.1400000000000001]\n\n\"good data\" , \"good2\", 100, 3.14\n['good data', 'good2', 100, 3.1400000000000001]\n\nbad, \"good\",\"good2\",100,3.14\n?bad, \"good\",\"good2\",100,3.14\nExpected string enclosed in double quotes\n\n\"bad\",\"good2\",100,3\n\"bad\",\"good2\",100,?3\nExpected float\n\n\"bad\",\"good2\",100.5,3\n\"bad\",\"good2\",100?.5,3\nExpected \",\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["You will probably be stripping those quotation marks off at some future time, pyparsing can do that at parse time by adding:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n dblQuotedString.setParseAction(removeQuotes)\n</code>\n</pre>\n", "senID": 5}, {"text": ["If you want to add comment support to your input file, say a '#' followed by the rest of the line, you can do this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n comment = '#' + restOfline\nvalidLine.ignore(comment)\n</code>\n</pre>\n", "senID": 7}, {"text": ["You can also add names to these fields, so that you can access them by name instead of index position (which I find gives more robust code in light of changes down the road):"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n validLine = dblQuotedString(\"key\") + COMMA + dblQuotedString(\"title\") + COMMA + \\\n        integer(\"qty\") + COMMA + floatnum(\"price\") + LineEnd()\n</code>\n</pre>\n", "senID": 9}, {"text": ["And your post-processing code can then do this:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n data = validLine.parseString(t)\nprint \"%(key)s: %(title)s, %(qty)d in stock at $%(price).2f\" % data\nprint data.qty*data.price\n</code>\n</pre>\n", "senID": 11}], [{"text": ["Ideally, you want your filtering to be as restrictive as possible - the fewer things you allow, the fewer potential avenues of attack.", "For instance, a float or int field has a very small number of characters (and very few configurations of those characters) which should actually be allowed.", "String filtering should ideally be restricted to only what characters people would have a reason to input - without knowing the larger context it's hard to tell you exactly which you should allow, but at a bare minimum the string match regex should require quoting of strings and disallow anything that would terminate the string early."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Keep in mind, however, that some names may contain things like single quotes (\"O'Neil\", for instance) or dashes, so you couldn't necessarily rule those out."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Something like..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n /\"[a-zA-Z' -]+\"/\n</code>\n</pre>\n", "senID": 3}, {"text": ["...would probably be ideal for double-quoted strings which are supposed to contain names.", "You could replace the + with a {x,y} length min/max if you wanted to enforce certain lengths as well."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "{x,y}", "childNum": 0, "tag": "code", "childList": []}]}]]