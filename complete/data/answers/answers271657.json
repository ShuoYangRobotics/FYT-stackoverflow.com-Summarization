[[{"text": ["The header value tells you this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n=?gb2312?B?uLGxvmhlbrixsb5nLnhscw==?=\n\n\"=?\"     introduces an encoded value\n\"gb2312\" denotes the character encoding of the original value\n\"B\"      denotes that B-encoding (equal to Base64) was used (the alternative \n         is \"Q\", which refers to something close to quoted-printable)\n\"?\"      functions as a separator\n\"uLG...\" is the actual value, encoded using the encoding specified before\n\"?=\"     ends the encoded value\n</pre>\n", "senID": 1}, {"text": ["So splitting on \"?", "\" actually gets you this (JSON notation)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n[\"=\", \"gb2312\", \"B\", \"uLGxvmhlbrixsb5nLnhscw==\", \"=\"]\n</pre>\n", "senID": 3}, {"text": ["In the resulting array, if \"B\" is on position 2, you face a base-64 encoded string on position 3.", "Once you decoded it, be sure to pay attention to the encoding on position 1, probably it would be best to convert the whole thing to UTF-8 using that info."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Not relevant in this case, the Content-Transfer-Encoding only applies to the body payload, not to the headers."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Content-Transfer-Encoding", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n =?gb2312?B?uLGxvmhlbrixsb5nLnhscw==?=\n</code>\n</pre>\n", "senID": 1}, {"text": ["That's an RFC2047-encoded header atom.", "The stdlib function to decode it is email.header.decode_header.", "It still needs a little post-processing to interpret the outcome of that function though:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "RFC2047", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "email.header.decode_header", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import email.header\nx= '=?gb2312?B?uLGxvmhlbrixsb5nLnhscw==?='\ntry:\n    name= u''.join([\n        unicode(b, e or 'ascii') for b, e in email.header.decode_header(x)\n    ])\nexcept email.Errors.HeaderParseError:\n    pass # leave name as it was\n</code>\n</pre>\n", "senID": 3}, {"text": ["However..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n Content-Type: application/vnd.ms-excel;\n name=\"=?gb2312?B?uLGxvmhlbrixsb5nLnhscw==?=\"\n</code>\n</pre>\n", "senID": 5}, {"text": ["This is simply wrong.", "What mailer created it?", "RFC2047 encoding can only happen in atoms, and a quoted-string is not an atom.", "RFC2047 \u00a75 explicitly denies this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The accepted way to encode parameter headers when long string or Unicode characters are present is RFC2231, which is a whole new bag of hurt.", "But you should be using a standard mail-parsing library which will cope with that for you."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "RFC2231", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["So, you could detect the '=?", "' in filename parameters if you want, and try to decode it via RFC2047.", "However, the strictly-speaking-correct thing to do is to take the mailer at its word and really call the file =?gb2312?B?uLGxvmhlbrixsb5nLnhscw==?=!"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "'=?'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "=?gb2312?B?uLGxvmhlbrixsb5nLnhscw==?=", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["@gnud, @edg - Unless I misunderstand, he's asking about the filename, not the file content\n@setori - the Content-Trasfer-Encoding is telling you how the CONTENT of the file is encoded, not the \"filename\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'm not an expert, but this part here in the filename is telling him about the characters that follow:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["=?gb2312?B?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I'm looking for the documentation in the RFCs... Ah!", "here it is: http://tools.ietf.org/html/rfc2047"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://tools.ietf.org/html/rfc2047", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://tools.ietf.org/html/rfc2047"}]}, {"text": ["The RFC says:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Generally, an \"encoded-word\" is a sequence of printable ASCII characters that begins with \"=?", "\", ends with \"?=\", and has two \"?", "\"s in between. "], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "Generally, an \"encoded-word\" is a sequence of printable ASCII characters that begins with \"=?\", ends with \"?=\", and has two \"?\"s in between.", "childNum": 1, "tag": "strong", "pos": -1, "childList": [{"text": "Generally, an \"encoded-word\" is a sequence of printable ASCII characters that begins with \"=?\", ends with \"?=\", and has two \"?\"s in between.", "tag": "em"}]}, {"text": "Generally, an \"encoded-word\" is a sequence of printable ASCII characters that begins with \"=?\", ends with \"?=\", and has two \"?\"s in between.", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Something else to look at is the code in SharpMimeTools, a MIME parser (in C#) that I use in my bug tracking app, BugTracker.NET"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "bug tracking", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ifdefined.com/bugtrackernet.html"}, {"href": "http://ifdefined.com/bugtrackernet.html", "text": "BugTracker.NET", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["There is a better way than bobince\u2019s method to handle the output of decode_header.", "I found it here: http://mail.python.org/pipermail/email-sig/2007-March/000332.html"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "decode_header", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "http://mail.python.org/pipermail/email-sig/2007-March/000332.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/email-sig/2007-March/000332.html"}]}, {"code": "<pre>\n<code>\n name = unicode(email.header.make_header(email.header.decode_header(x)))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Well, you parse the email header into a dictionary.", "And then you check if Content-Transfer-Encoding is set, and if it = \"base64\" or \"base-64\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Question: \"\"\"Also I actually need to know what type of file it is ie .xls or .doc so I do need to decode the filename in order to correctly process the attachment, but as above, seems gb2312 is not supported in jython, know any roundabouts?", "\"\"\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Data:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Content-Type: application/vnd.ms-excel;\n name=\"=?gb2312?B?uLGxvmhlbrixsb5nLnhscw==?=\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["Observations:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["(1) The first line indicates Microsoft Excel, so .xls is looking better than .doc"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": ".xls", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".doc", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["(2) "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import base64\n&gt;&gt;&gt; base64.b64decode(\"uLGxvmhlbrixsb5nLnhscw==\")\n'\\xb8\\xb1\\xb1\\xbehen\\xb8\\xb1\\xb1\\xbeg.xls'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 6}, {"text": ["(a) The extension appears to be .xls -- no need for a gb2312 codec\n(b) If you want a file-system-safe file name, you could use the \"-_\" variant of base64 OR you could percent-encode it\n(c) For what it's worth, the file name is XYhenXYg.xls where X and Y are 2 Chinese characters that together mean \"copy\" and the remainder are literal ASCII characters."], "childNum": 5, "tag": "p", "senID": 7, "childList": [{"text": ".xls", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "gb2312", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "XYhenXYg.xls", "childNum": 0, "tag": "code", "childList": []}]}]]