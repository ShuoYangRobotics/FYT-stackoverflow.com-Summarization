[[{"text": ["Did we forget why \"multiple exit points\" was considered harmful in the first place?", "Back in the day (before widespread access to good exception handling and finally constructs, or managing objects like auto_ptr that do cleanup when they leave scope), this was the problem that haunted many multi-exit functions:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "auto_ptr", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n int function blah(arg1, arg2)\n    allocate resource\n\n    if early failure detection\n        return failure_status\n\n    ... much later...\n\n    release resource // oh rats! resource didn't release\n    return success_status\n</code>\n</pre>\n", "senID": 1}, {"text": ["If the resource is memory, this creates a memory leak.", "If it's a database transaction, we are heading for bad database contention or deadlock.", "For that matter, with the advent of more exception support, we implicitly add many potential exits from a method (by virtue of an unhandled exception).", "In my C++ days, I developed the habit of never calling delete, but instead using auto_ptr, so that allocated memory was cleaned up when the auto_ptr exited its scope, even if some unexpected exception reared its head."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "many", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "never", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "auto_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "auto_ptr", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In our garbage collected Python world, we can still have this issue, even though many of our objects, such as files, or locks, have improved self-cleaning behavior.", "But in implementations other than CPython (jython and IronPython to name two), there is no guarantee just when a destructor will get called, so something more proactive needs to be built into your method.", "The first mechanism for this purpose was try/finally:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n int function blah(arg1, arg2)\n    allocate resource\n    try:\n\n        if early failure detection\n            return failure_status\n\n        ... much later...\n        return success_status\n\n    finally:\n        release resource // always releases no matter what\n</code>\n</pre>\n", "senID": 4}, {"text": ["But now Python has context managers, in conjunction with the new 'with' syntax:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n int function blah(arg1, arg2)\n    allocate resource\n    with context_manager(resource): // releases on exit from 'with'\n\n        if early failure detection\n            return failure_status\n\n        ... much later...\n        return success_status\n</code>\n</pre>\n", "senID": 6}, {"text": ["So let's be sure that we tell the whole story, that the reason we can discard this old chestnut is that newer coding practices make it unnecessary."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["In Python, it is quite common to have a return statement in the middle of the function - in particular, if it is an early exit.", "Your example often is rewritten as"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def function():\n    if some_condition():\n        return 2\n    return 3\n</code>\n</pre>\n", "senID": 1}, {"text": ["I.e.", "you drop the else case when the if ends with a return."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Don't use an accumulator unless it's absolutely unavoidable.", "It introduces unnecessary statefulness and branching into your procedures, which you then have to track manually.", "By returning early, you can reduce the state and branch count of your code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Precisely the opposite -- structured programming discourages multiple points of entry, but multiple points of exit are acceptable and even encouraged (eg \"guard clauses\")."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "entry", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Stylistics aside, let's take a look at the disassembly for the two approaches:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo():\n...     r = 0\n...     if bar():\n...             r = 2\n...     else:\n...             r = 3\n...     return r\n... \n&gt;&gt;&gt; dis.dis(foo)\n  2           0 LOAD_CONST               1 (0)\n              3 STORE_FAST               0 (r)\n\n  3           6 LOAD_GLOBAL              0 (bar)\n              9 CALL_FUNCTION            0\n             12 JUMP_IF_FALSE           10 (to 25)\n             15 POP_TOP             \n\n  4          16 LOAD_CONST               2 (2)\n             19 STORE_FAST               0 (r)\n             22 JUMP_FORWARD             7 (to 32)\n        &gt;&gt;   25 POP_TOP             \n\n  6          26 LOAD_CONST               3 (3)\n             29 STORE_FAST               0 (r)\n\n  7     &gt;&gt;   32 LOAD_FAST                0 (r)\n             35 RETURN_VALUE\n</code>\n</pre>\n", "senID": 1}, {"text": ["14 bytecode instructions in the first approach..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def quux():\n...     if bar():\n...             return 2\n...     else:\n...             return 3\n... \n&gt;&gt;&gt; dis.dis(quux)\n  2           0 LOAD_GLOBAL              0 (bar)\n              3 CALL_FUNCTION            0\n              6 JUMP_IF_FALSE            5 (to 14)\n              9 POP_TOP             \n\n  3          10 LOAD_CONST               1 (2)\n             13 RETURN_VALUE        \n        &gt;&gt;   14 POP_TOP             \n\n  5          15 LOAD_CONST               2 (3)\n             18 RETURN_VALUE        \n             19 LOAD_CONST               0 (None)\n             22 RETURN_VALUE\n</code>\n</pre>\n", "senID": 3}, {"text": ["11 in the second approach..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["And a third approach, slightly shorter than the second:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def baz():\n...     if bar():\n...             return 2\n...     return 3\n... \n&gt;&gt;&gt; dis.dis(baz)\n  2           0 LOAD_GLOBAL              0 (bar)\n              3 CALL_FUNCTION            0\n              6 JUMP_IF_FALSE            5 (to 14)\n              9 POP_TOP             \n\n  3          10 LOAD_CONST               1 (2)\n             13 RETURN_VALUE        \n        &gt;&gt;   14 POP_TOP             \n\n  4          15 LOAD_CONST               2 (3)\n             18 RETURN_VALUE\n</code>\n</pre>\n", "senID": 6}, {"text": ["Has just nine instructions.", "The differences may not seem like much, but it actually makes a bit of a difference over a million runs with timeit, with bar defined to return alternating zeros and ones:"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n$ sudo nice -n -19 python b.py\n('foo', 1.3846859931945801)\n('quux', 1.282526969909668)\n('baz', 1.2973799705505371)\n$ sudo nice -n -19 python b.py\n('foo', 1.354640007019043)\n('quux', 1.2609632015228271)\n('baz', 1.2767179012298584)\n\n$ sudo nice -n -19 python3 b.py\nfoo 1.72521305084\nquux 1.62322306633\nbaz 1.62547206879\n$ sudo nice -n -19 python3 b.py\nfoo 1.73264288902\nquux 1.67029309273\nbaz 1.62204194069\n</pre>\n", "senID": 8}, {"text": ["quux and baz tended to be close to the same time, both of which were consistently faster than foo."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "quux", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "baz", "childNum": 0, "tag": "code", "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you're still on the fence about which one is better, hopefully this illustrates another advantage of the accumulator-less approach that nobody else mentioned so far."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["It depends on the language to a large extent, however I would go with the second method returning the value directly rather than imposing another superfluous variable.", "The second method is cleaner, more precise and therefore more maintainable in my opinion."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I suppose it's more a question of style and coding conventions.", "Generally, theory tells us that multiple exit points are bad.", "In practice it can be easier to follow to simply return inside each condition.", "The code is likely to be compiled down to very similar if not identical instructions, so it has little to no functional impact."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My rule of thumb is this: If the function is longer than one page (25 lines) avoid multiple exit points.", "If you can see it all at once, do whatever seems best at the time you write it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["A further alternative in recent versions of Python (since 2.6?", ") is a ternary operator statement like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def function():\n    return (2 if some_condition() else 3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Just in case you like that better."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["For primitives, it doesn't matter.", "In a language like C++ (&amp; presumably with structs in C it's the compiler will do something similar), the compiler is able to optimize the copy constructor out if you ensure all code paths return the same variable.", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "copy constructor", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.9"}]}, {"code": "<pre>\n<code>\n Foo someFunction()\n{\n    Foo result(5);\n    if (someConditionA())  return result;\n    else if (someConditionB()) result.doSomething();\n    result.doSomethingElse();\n    return result;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["becomes more efficient than (unless your compiler is very very good):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Foo someFunction()\n{\n   if (someConditionA()) return Foo(5);\n   if (someConditionB()) { Foo result(5); result.doSomething(); result.doSomethingElse(); return result; }\n   Foo result(5);\n   result.doSomethingElse();\n   return result;\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["In all other cases, it's more style-preference &amp; readability.", "In the end, choose the format that's more readable for that particular case."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Although people advocate single exit strategy, I find it useful to return early.", "That way you don't have to keep track when you are adding code later."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In a language with function prototypes like C++ or Java, the compiler enforces that you return something of the correct type, even if execution would otherwise fall off the end of the function.", "In Python, since there are no function prototypes, falling off the end of the function will return the special value None.", "For this reason, you may want to use an accumulator variable and an explicit return ret_val at the end when coding in Python.", "Or use another style that ensures that execution cannot fall off the end without returning a value."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "something", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "return ret_val", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "cannot", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}], [{"text": ["Returning values directly is not terrible for small functions like your example.", "However, if you have a large or complex function then multiple return points can be more difficult to debug.", "If you have a coding standard I'd refer to it (here the variable is preferred according to our company coding standard)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]