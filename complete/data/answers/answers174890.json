[[{"text": ["After a bit of work, I found the answer myself.", "Looking at the ElementTree.py source code, I found there was special handling of XML comments and preprocessing instructions.", "What they do is create a factory function for the special element type that uses a special (non-string) tag value to differentiate it from regular elements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def Comment(text=None):\n    element = Element(Comment)\n    element.text = text\n    return element\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then in the _write function of ElementTree that actually outputs the XML, there's a special case handling for comments:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "_write", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if tag is Comment:\n    file.write(\"&lt;!-- %s --&gt;\" % _escape_cdata(node.text, encoding))\n</code>\n</pre>\n", "senID": 3}, {"text": ["In order to support CDATA sections, I create a factory function called CDATA, extended the ElementTree class and changed the _write function to handle the CDATA elements."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "CDATA", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "_write", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This still doesn't help if you want to parse an XML with CDATA sections and then output it again with the CDATA sections, but it at least allows you to create XMLs with CDATA sections programmatically, which is what I needed to do."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The implementation seems to work with both ElementTree and cElementTree."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import elementtree.ElementTree as etree\n#~ import cElementTree as etree\n\ndef CDATA(text=None):\n    element = etree.Element(CDATA)\n    element.text = text\n    return element\n\nclass ElementTreeCDATA(etree.ElementTree):\n    def _write(self, file, node, encoding, namespaces):\n        if node.tag is CDATA:\n            text = node.text.encode(encoding)\n            file.write(\"\\n&lt;![CDATA[%s]]&gt;\\n\" % text)\n        else:\n            etree.ElementTree._write(self, file, node, encoding, namespaces)\n\nif __name__ == \"__main__\":\n    import sys\n\n    text = \"\"\"\n    &lt;?xml version='1.0' encoding='utf-8'?&gt;\n    &lt;text&gt;\n    This is just some sample text.\n    &lt;/text&gt;\n    \"\"\"\n\n    e = etree.Element(\"data\")\n    cdata = CDATA(text)\n    e.append(cdata)\n    et = ElementTreeCDATA(e)\n    et.write(sys.stdout, \"utf-8\")\n</code>\n</pre>\n", "senID": 7}], [{"text": ["It's not possible AFAIK... which is a pity.", "Basically, ElementTree modules assume that the reader is 100% XML compliant, so it shouldn't matter if they output a section as CDATA or some other format that generates the equivalent text."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["See this thread on the Python mailing list for more info.", "Basically, they recommend some kind of DOM-based XML library instead."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this thread", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2005-June/324995.html"}]}], [{"text": ["lxml has support for CDATA and API like ElementTree."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "lxml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codespeak.net/lxml/"}, {"href": "http://codespeak.net/lxml/api.html#cdata", "text": "CDATA", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Actually this code has a bug, since you don't catch ]]> appearing in the data you are inserting as CDATA"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["as per http://stackoverflow.com/questions/223652/is-there-a-way-to-escape-a-cdata-end-token-in-xml"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/questions/223652/is-there-a-way-to-escape-a-cdata-end-token-in-xml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/223652/is-there-a-way-to-escape-a-cdata-end-token-in-xml"}]}, {"text": ["you should break it into two CDATA's in that case"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["basically data = re.sub(r\">\\]\\]\", r\">\\]>\\]\\]&lt;!\\[CDATA\\[\\]\", data) \n(I hope this is correct, not tested)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The DOM has (atleast in level 2) an interface\nDATASection, and an operation Document::createCDATASection.", "They are\nextension interfaces, supported only if an implementation supports the\n\"xml\" feature."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["from xml.dom import minidom"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["my_xmldoc=minidom.parse(xmlfile)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["my_xmldoc.createCDATASection(data)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["now u have cadata node add it wherever u want...."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here is a variant of gooli's solution that works for python 3.2:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n import xml.etree.ElementTree as etree\n\ndef CDATA(text=None):\n    element = etree.Element('![CDATA[')\n    element.text = text\n    return element\n\netree._original_serialize_xml = etree._serialize_xml\ndef _serialize_xml(write, elem, qnames, namespaces):\n    if elem.tag == '![CDATA[':\n        write(\"\\n&lt;%s%s]]&gt;\\n\" % (\n                elem.tag, elem.text))\n        return\n    return etree._original_serialize_xml(\n        write, elem, qnames, namespaces)\netree._serialize_xml = etree._serialize['xml'] = _serialize_xml\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    text = \"\"\"\n    &lt;?xml version='1.0' encoding='utf-8'?&gt;\n    &lt;text&gt;\n    This is just some sample text.\n    &lt;/text&gt;\n    \"\"\"\n\n    e = etree.Element(\"data\")\n    cdata = CDATA(text)\n    e.append(cdata)\n    et = etree.ElementTree(e)\n    et.write(sys.stdout.buffer.raw, \"utf-8\")\n</code>\n</pre>\n", "senID": 1}]]