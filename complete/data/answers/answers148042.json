[[{"code": "<pre>\n<code>\n if job in (\"mechanic\", \"tech\"):\n    print \"awesome\"\nelif job in (\"tool\", \"rock\"):\n    print \"dolt\"\n</code>\n</pre>\n", "senID": 0}, {"text": ["The values in parentheses are a tuple.", "The in operator checks to see whether the left hand side item occurs somewhere inside the right handle tuple."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Note that when Python searches a tuple or list using the in operator, it does a linear search.", "If you have a large number of items on the right hand side, this could be a performance bottleneck.", "A larger-scale way of doing this would be to use a frozenset:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "frozenset", "tag": "a", "pos": 2, "childList": [{"text": "frozenset", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/lib/types-set.html"}, {"text": "frozenset", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n AwesomeJobs = frozenset([\"mechanic\", \"tech\", ... lots of others ])\ndef func():\n    if job in AwesomeJobs:\n        print \"awesome\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["The use of frozenset over set is preferred if the list of awesome jobs does not need to be changed during the operation of your program."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "frozenset", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can use in:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if job  in [\"mechanic\", \"tech\"]:\n    print \"awesome\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["When checking very large numbers, it may also be worth storing off a set of the items to check, as this will be faster.", "Eg."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n AwesomeJobs = set([\"mechanic\", \"tech\", ... lots of others ])\n...\n\ndef func():\n    if job in AwesomeJobs:\n        print \"awesome\"\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n if job in (\"mechanic\", \"tech\"):\n    print \"awesome\"\nelif job in (\"tool\", \"rock\"):\n    print \"dolt\"\n</code>\n</pre>\n", "senID": 0}], [{"text": ["While I don't think you can do what you want directly, one alternative is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if job in [ \"mechanic\", \"tech\" ]:\n    print \"awesome\"\nelif job in [ \"tool\", \"rock\" ]:\n    print \"dolt\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Tuples with constant items are stored themselves as constants in the compiled function.", "They can be loaded with a single instruction.", "Lists and sets on the other hand, are always constructed anew on each execution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Both tuples and lists use linear search for the in-operator.", "Sets uses a hash-based look-up, so it will be faster for a larger number of options."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["In other languages I'd use a switch/select statement to get the job done.", "You can do that in python too."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "You can do that in python too", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://simonwillison.net/2004/May/7/switch/"}]}]]