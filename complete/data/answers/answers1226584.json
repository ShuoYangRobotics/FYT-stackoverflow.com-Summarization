[[{"text": ["If you are truly compute bound, using the multiprocessing module is probably the lightest weight solution (in terms of both memory consumption and implementation difficulty."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/multiprocessing.html#module-multiprocessing"}]}, {"text": ["If you are I/O bound, using the threading module will usually give you good results.", "Make sure that you use thread safe storage (like the Queue) to hand data to your threads.", "Or else hand them a single piece of data that is unique to them when they are spawned."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "threading module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/threading.html#module-threading"}]}, {"text": ["Stackless Python is also a nice idea, as is Unladen Swallow (although it is not finished yet.", ")   Stackless has portability issues as indicated above.", "Unladen Swallow has a different kind of portability problem, in that few people probably have it, and it may not work on Windows platforms yet."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["For small collections of data, simply create subprocesses with subprocess.Popen."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "subprocess.Popen", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/subprocess.html#subprocess.Popen"}]}, {"text": ["Each subprocess can simply get it's piece of data from stdin or from command-line arguments, do it's processing, and simply write the result to an output file."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["When the subprocesses have all finished (or timed out), you simply merge the output files."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Very simple."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You might consider looking into Stackless Python.", "If you have control over the function that takes a long time, you can just throw some stackless.schedule()s in there (saying yield to the next coroutine), or else you can set Stackless to preemptive multitasking."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Stackless Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.stackless.com/"}, {"text": "stackless.schedule()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://www.stackless.com/wiki/Scheduling", "text": "set Stackless to preemptive multitasking", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["In Stackless, you don't have threads, but tasklets or greenlets which are essentially very lightweight threads.", "It works great in the sense that there's a pretty good framework with very little setup to get multitasking going."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "tasklets", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "greenlets", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["However, Stackless hinders portability because you have to replace a few of the standard Python libraries -- Stackless removes reliance on the C stack.", "It's very portable if the next user also has Stackless installed, but that will rarely be the case."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Tasks runs like sequentially but you have the illusion that are run in parallel.", "Tasks are good when you use for file or connection I/O and because are lightweights."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Multiprocess with Pool may be the right solution for you because processes runs in parallel so are very good with intensive computing because each process run in one CPU (or core)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Setup multiprocess may be very easy:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from multiprocessing import Pool\n\ndef worker(input_item):\n    output = do_some_work()\n    return output\n\npool = Pool() # it make one process for each CPU (or core) of your PC. Use \"Pool(4)\" to force to use 4 processes, for example.\nlist_of_results = pool.map(worker, input_list) # Launch all automatically\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Using CPython's threading model will not give you any performance improvement, because the threads are not actually executed in parallel, due to the way garbage collection is handled.", "Multiprocess would allow parallel execution.", "Obviously in this case you have to have multiple cores available to farm out your parallel jobs to."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is much more information available in this related question."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this related question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1190206/threading-in-python"}]}], [{"text": ["If you can easily partition and separate the data you have, it sounds like you should just do that partitioning externally, and feed them to several processes of your program.", "(i.e.", "several processes instead of threads)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["IronPython has real multithreading, unlike CPython and it's GIL.", "So depending on what you're doing it may be worth looking at.", "But it sounds like your use case is better suited to the multiprocessing module."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To the guy who recommends stackless python, I'm not an expert on it, but it seems to me that he's talking about software \"multithreading\", which is actually not parallel at all (still runs in one physical thread, so cannot scale to multiple cores.", ") It's merely an alternative way to structure asynchronous (but still single-threaded, non-parallel) application."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You may want to look at Twisted.", "It is designed for asynchronous network tasks. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Twisted", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.twistedmatrix.com"}]}]]