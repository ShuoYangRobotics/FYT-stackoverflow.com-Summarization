[[{"text": ["Mark's iterative approach would be the usual way, I think."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's an alternative with string-splitting, which can often be useful for finding-related processes:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def findnth(haystack, needle, n):\n    parts= haystack.split(needle, n+1)\n    if len(parts)&lt;=n+1:\n        return -1\n    return len(haystack)-len(parts[-1])-len(needle)\n</code>\n</pre>\n", "senID": 2}, {"text": ["And here's a quick (and somewhat dirty, in that you have to choose some chaff that can't match the needle) one-liner:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 'foo bar bar bar'.replace('bar', 'XXX', 1).find('bar')\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here's a more Pythonic version of the straightforward iterative solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def find_nth(haystack, needle, n):\n    start = haystack.find(needle)\n    while start &gt;= 0 and n &gt; 1:\n        start = haystack.find(needle, start+len(needle))\n        n -= 1\n    return start\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Example:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; find_nth(\"foofoofoofoo\", \"foofoo\", 2)\n6\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you want to find the nth overlapping occurrence of needle, you can increment by 1 instead of len(needle), like this:"], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "overlapping", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "needle", "childNum": 0, "tag": "code", "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}, {"text": "len(needle)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def find_nth_overlapping(haystack, needle, n):\n    start = haystack.find(needle)\n    while start &gt;= 0 and n &gt; 1:\n        start = haystack.find(needle, start+1)\n        n -= 1\n    return start\n</code>\n</pre>\n", "senID": 5}, {"text": ["Example:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Example:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; find_nth_overlapping(\"foofoofoofoo\", \"foofoo\", 2)\n3\n</code>\n</pre>\n", "senID": 7}, {"text": ["This is easier to read than Mark's version, and it doesn't require the extra memory of the splitting version or importing regular expression module.", "It also adheres to a few of the rules in the Zen of python, unlike the various re approaches:"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "Zen of python", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0020/"}, {"text": "re", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Understanding that regex is not always the best solution, I'd probably use one here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; s = \"ababdfegtduab\"\n&gt;&gt;&gt; [m.start() for m in re.finditer(r\"ab\",s)]\n[0, 2, 11]\n&gt;&gt;&gt; [m.start() for m in re.finditer(r\"ab\",s)][2] #index 2 is third occurrence \n11\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'd probably do something like this, using the find function that takes an index parameter:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def find_nth(s, x, n):\n    i = -1\n    for _ in range(n):\n        i = s.find(x, i + len(x))\n        if i == -1:\n            break\n    return i\n\nprint find_nth('bananabanana', 'an', 3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's not particularly Pythonic I guess, but it's simple.", "You could do it using recursion instead:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def find_nth(s, x, n, i = 0):\n    i = s.find(x, i)\n    if n == 1 or i == -1:\n        return i \n    else:\n        return find_nth(s, x, n - 1, i + len(x))\n\nprint find_nth('bananabanana', 'an', 3)\n</code>\n</pre>\n", "senID": 3}, {"text": ["It's a functional way to solve it, but I don't know if that makes it more Pythonic."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here is another approach using re.finditer.", "The difference is that this only looks into the haystack as far as necessary"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from re import finditer\nfrom itertools import dropwhile\nneedle='an'\nhaystack='bananabanana'\nn=2\nnext(dropwhile(lambda x: x[0]&lt;n, enumerate(re.finditer(needle,haystack))))[1].start()\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; s=\"abcdefabcdefababcdef\"\n&gt;&gt;&gt; j=0\n&gt;&gt;&gt; for n,i in enumerate(s):\n...   if s[n:n+2] ==\"ab\":\n...     print n,i\n...     j=j+1\n...     if j==2: print \"2nd occurence at index position: \",n\n...\n0 a\n6 a\n2nd occurence at index position:  6\n12 a\n14 a\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here's another re + itertools version that should work when searching for either a str or a RegexpObject.", "I will freely admit that this is likely over-engineered, but for some reason it entertained me."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "RegexpObject", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\nimport re\n\ndef find_nth(haystack, needle, n = 1):\n    \"\"\"\n    Find the starting index of the nth occurrence of ``needle`` in \\\n    ``haystack``.\n\n    If ``needle`` is a ``str``, this will perform an exact substring\n    match; if it is a ``RegexpObject``, this will perform a regex\n    search.\n\n    If ``needle`` doesn't appear in ``haystack``, return ``-1``. If\n    ``needle`` doesn't appear in ``haystack`` ``n`` times,\n    return ``-1``.\n\n    Arguments\n    ---------\n    * ``needle`` the substring (or a ``RegexpObject``) to find\n    * ``haystack`` is a ``str``\n    * an ``int`` indicating which occurrence to find; defaults to ``1``\n\n    &gt;&gt;&gt; find_nth(\"foo\", \"o\", 1)\n    1\n    &gt;&gt;&gt; find_nth(\"foo\", \"o\", 2)\n    2\n    &gt;&gt;&gt; find_nth(\"foo\", \"o\", 3)\n    -1\n    &gt;&gt;&gt; find_nth(\"foo\", \"b\")\n    -1\n    &gt;&gt;&gt; import re\n    &gt;&gt;&gt; either_o = re.compile(\"[oO]\")\n    &gt;&gt;&gt; find_nth(\"foo\", either_o, 1)\n    1\n    &gt;&gt;&gt; find_nth(\"FOO\", either_o, 1)\n    1\n    \"\"\"\n    if (hasattr(needle, 'finditer')):\n        matches = needle.finditer(haystack)\n    else:\n        matches = re.finditer(re.escape(needle), haystack)\n    start_here = itertools.dropwhile(lambda x: x[0] &lt; n, enumerate(matches, 1))\n    try:\n        return next(start_here)[1].start()\n    except StopIteration:\n        return -1\n</code>\n</pre>\n", "senID": 1}]]