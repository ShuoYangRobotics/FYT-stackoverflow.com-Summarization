[[{"text": ["There is a OSS project that uses WebDriver to take screen shots and then compares the images to see if there are any issues (http://code.google.com/p/fighting-layout-bugs/)).", "It does it by openning the file into a stream and then comparing every bit. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.google.com/p/fighting-layout-bugs/)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/fighting-layout-bugs/"}]}, {"text": ["You may be able to do something similar with PIL."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PIL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pythonware.com/products/pil"}]}, {"text": ["EDIT:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["After more research I found"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n h1 = Image.open(\"image1\").histogram()\nh2 = Image.open(\"image2\").histogram()\n\nrms = math.sqrt(reduce(operator.add,\n    map(lambda a,b: (a-b)**2, h1, h2))/len(h1))\n</code>\n</pre>\n", "senID": 4}, {"text": ["on http://snipplr.com/view/757/compare-two-pil-images-in-python/ and http://effbot.org/zone/pil-comparing-images.htm"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "http://snipplr.com/view/757/compare-two-pil-images-in-python/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://snipplr.com/view/757/compare-two-pil-images-in-python/"}, {"href": "http://effbot.org/zone/pil-comparing-images.htm", "text": "http://effbot.org/zone/pil-comparing-images.htm", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I guess you should decode the images and do a pixel by pixel comparison to see if they're reasonably similar."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With PIL and Numpy you can do it quite easily:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import Image\nimport numpy\nimport sys\n\ndef main():\n    img1 = Image.open(sys.argv[1])\n    img2 = Image.open(sys.argv[2])\n\n    if img1.size != img2.size or img1.getbands() != img2.getbands():\n        return -1\n\n    s = 0\n    for band_index, band in enumerate(img1.getbands()):\n        m1 = numpy.array([p[band_index] for p in img1.getdata()]).reshape(*img1.size)\n        m2 = numpy.array([p[band_index] for p in img2.getdata()]).reshape(*img2.size)\n        s += numpy.sum(numpy.abs(m1-m2))\n    print s\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n</code>\n</pre>\n", "senID": 2}, {"text": ["This will give you a numeric value that should be very close to 0 if the images are quite the same."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["First, I should note they\u2019re not identical; b has been recompressed and lost quality.", "You can see this if you look carefully on a good monitor."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["To determine that they are subjectively \u201cthe same,\u201d you would have to do something like what fortran suggested, although you will have to arbitrarily establish a threshold for \u201csameness.\u201d To make s independent of image size, and to handle channels a little more sensibly, I would consider doing the RMS (root mean square) Euclidean distance in colorspace between the pixels of the two images.", "I don\u2019t have time to write out the code right now, but basically for each pixel, you compute"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n (R_2 - R_1) ** 2 + (G_2 - G_1) ** 2 + (B_2 - B_1) ** 2\n</code>\n</pre>\n", "senID": 2}, {"text": [", adding in an"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["(A_2 - A_1) ** 2"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["term if the image has an alpha channel, etc.", "The result is the square of the colorspace distance between the two images.", "Find the mean (average) across all pixels, then take the square root of the resulting scalar.", "Then decide a reasonable threshold for this value."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Or, you might just decide that copies of the same original image with different lossy compression are not truly \u201cthe same\u201d and stick with the file hash."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["the problem of knowing what makes some features of the image more important than other is a whole scientific program.", "I would suggest some alternatives depending on the solution you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["if your problem is to see if there is a flipping of bits in your JPEGs, then try to image the difference image (there was perhaps a minor edit locally?", "),"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["to see if images are globally the same, use the Kullback Leibler distance to compare your histograms,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["to see if you have some qualittative change, before applying other answers, filter your image using the functions below to raise the importance of high-level frequencies:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]}, {"text": ["code:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def FTfilter(image,FTfilter):\n    from scipy.fftpack import fft2, fftshift, ifft2, ifftshift\n    from scipy import real\n    FTimage = fftshift(fft2(image)) * FTfilter\n    return real(ifft2(ifftshift(FTimage)))\n    #return real(ifft2(fft2(image)* FTfilter))\n\n\n#### whitening\ndef olshausen_whitening_filt(size, f_0 = .78, alpha = 4., N = 0.01):\n    \"\"\"\n    Returns the whitening filter used by (Olshausen, 98)\n\n    f_0 = 200 / 512\n\n    /!\\ you will have some problems at dewhitening without a low-pass\n\n    \"\"\"\n    from scipy import mgrid, absolute\n    fx, fy = mgrid[-1:1:1j*size[0],-1:1:1j*size[1]]\n    rho = numpy.sqrt(fx**2+fy**2)\n    K_ols = (N**2 + rho**2)**.5 * low_pass(size, f_0 = f_0, alpha = alpha)\n    K_ols /= numpy.max(K_ols)\n\n    return  K_ols\n\ndef low_pass(size, f_0, alpha):\n    \"\"\"\n    Returns the low_pass filter used by (Olshausen, 98)\n\n    parameters from Atick (p.240)\n    f_0 = 22 c/deg in primates: the full image is approx 45 deg\n    alpha makes the aspect change (1=diamond on the vert and hor, 2 = anisotropic)\n\n    \"\"\"\n\n    from scipy import mgrid, absolute\n    fx, fy = mgrid[-1:1:1j*size[0],-1:1:1j*size[1]]\n    rho = numpy.sqrt(fx**2+fy**2)\n    low_pass = numpy.exp(-(rho/f_0)**alpha)\n\n    return  low_pass\n</code>\n</pre>\n", "senID": 5}, {"text": ["(shameless copy from http://www.incm.cnrs-mrs.fr/LaurentPerrinet/Publications/Perrinet08spie )"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://www.incm.cnrs-mrs.fr/LaurentPerrinet/Publications/Perrinet08spie", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.incm.cnrs-mrs.fr/LaurentPerrinet/Publications/Perrinet08spie"}]}], [{"text": ["You can either compare it using PIL (iterate through pixels / segments of the picture and compare) or if you're looking for a complete identical copy comparison, try comparing the MD5 hash of both files."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PIL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pythonware.com/products/pil/"}]}], [{"text": ["From here"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/pil-comparing-images.htm"}]}, {"text": ["The quickest way to determine if two images have exactly the same contents is to get the difference between the two images, and then calculate the bounding box of the non-zero regions in this image.", "If the images are identical, all pixels in the difference image are zero, and the bounding box function returns None."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import ImageChops\n\ndef equal(im1, im2):\n    return ImageChops.difference(im1, im2).getbbox() is None\n</code>\n</pre>\n", "senID": 2}]]