[[{"text": ["When you do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lst = anything\n</code>\n</pre>\n", "senID": 1}, {"text": ["You're pointing the name lst at an object.", "It doesn't change the old object lst used to point to in any way, though if nothing else pointed to that object its reference count will drop to zero and it will get deleted."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "name", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "lst", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "lst", "childNum": 0, "tag": "code", "childList": []}, {"text": "any way", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["When you do"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n lst[:] = whatever\n</code>\n</pre>\n", "senID": 4}, {"text": ["You're iterating over whatever and assigning each item to an index in the already existing lst object.", "That means if multiple names point to the same object, you will see the change reflected when you reference any of the names, just as if you use append or extend or any of the other in-place operations."], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "whatever", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "already existing", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "lst", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "append", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "extend", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["An example of the difference:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lst = range(1, 4)\n&gt;&gt;&gt; id(lst)\n74339392\n&gt;&gt;&gt; lst = [1, 2, 3]\n&gt;&gt;&gt; id(lst)  # different; you pointed lst at a new object\n73087936\n&gt;&gt;&gt; lst[:] = range(1, 4)\n&gt;&gt;&gt; id(lst)  # the same, you iterated over the list returned by range\n73087936\n&gt;&gt;&gt; lst = xrange(1, 4)\n&gt;&gt;&gt; lst\nxrange(1, 4)   # not a list, an xrange object\n&gt;&gt;&gt; id(lst)   # and different\n73955976\n&gt;&gt;&gt; lst = [1, 2, 3]\n&gt;&gt;&gt; id(lst)    # again different\n73105320\n&gt;&gt;&gt; lst[:] = xrange(1, 4) # remember this doesn't make a list\n&gt;&gt;&gt; id(lst)   # the same, because you iterated over the xrange\n73105320\n&gt;&gt;&gt; lst    # and still a list\n[1, 2, 3]\n</code>\n</pre>\n", "senID": 7}, {"text": ["So, when you're assigning from an iterable / iterator / generator like xrange, you don't have to store all the items in memory before assigning to lst.", "That is, when you do normal assignment of an range to a list, and the list already exists, both objects have to exist in memory at the same time -- the old one can't go away until the new one is assigned to the name lst.", "When you do it with slice assignment and an xrange, you get one item from the xrange at a time and assign it to an index in lst, so you don't have to have much additional memory."], "childNum": 10, "tag": "p", "senID": 8, "childList": [{"text": "xrange", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "don't have to store all the items in memory before assigning to", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "lst", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}, {"text": "lst", "childNum": 0, "tag": "code", "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "childList": []}, {"text": "lst", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["When it comes to speed, slice assignment is slower, though it could theoretically be faster if not using it forced you to swap pages out to disk."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["The first one redefines the built-in name list to point to some list."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The second fails with TypeError: 'type' object does not support item assignment."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "TypeError: 'type' object does not support item assignment", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["list[:] will only work if there is already an object named list that allows slice assignment."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list[:]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also, you shouldn't name variables list because there is a built-in named list which is the list type itself."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n list[:] = range(100)\n</code>\n</pre>\n", "senID": 0}, {"text": ["won't work on uninitialized variable, as it is modifying it.", "The [:] specifies the whole list/touple."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "[:]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["[:] is also useful to make a deep copy of the list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def x(l):\n    f=l[:]\n    g=l\n    l.append(8)\n    print \"l\", l\n    print \"g\", g\n    print \"f\", f\n\nl = range(3)\n\nprint l\n #[0, 1, 2]\n\nx(l)\n #l [0, 1, 2, 8]\n #g [0, 1, 2, 8]\n #f [0, 1, 2]\n\nprint l\n#[0, 1, 2, 8]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Modification to l is get reflected in g (because, both point to same list, in fact, both g and l are just names in python), not in f(because, it's a copy of l)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["But, in your case, It doesn't make any difference.", "(Though, I'm not eligible to comment on any memory usage of both methods.", ")  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n h = range(3)\nid(h) #141312204 \nh[:]=range(3)\nid(h) #141312204 \nh=range(3)\nid(h) #141312588\n</code>\n</pre>\n", "senID": 5}, {"text": ["list[:] = range(100) updates the list \nlist = range(100) creates new list. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["@agf: thanks for pointing my error "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["list[:] specifies a range within the list, in this case it defines the complete range of the list, i.e.", "the whole list and changes them.", "list=range(100), on the other hand, kind of wipes out the original contents of list and sets the new contents."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "list[:]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list=range(100)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["But try the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a=[1,2,3,4]\n\na[0:2]=[5,6]\n\na # prints [5,6,3,4]\n</code>\n</pre>\n", "senID": 2}, {"text": ["You see, we changed the first two elements with the assignment.", "This means, using this notation, you can change several elements in the list once."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]