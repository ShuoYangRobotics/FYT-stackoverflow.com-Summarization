[[{"text": ["Another solution (not that pythonic, but very fast) is to use string.translate - though note that this will not work for unicode.", "It's also worth noting that you can speed up Dana's code by moving the characters into a set (which looks up by hash, rather than performing a linear search each time).", "Here are the timings I get for various of the solutions given:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Dana's code", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/638893/what-is-the-most-efficient-way-in-python-to-convert-a-string-to-all-lowercase-str/638920#638920"}]}, {"code": "<pre>\n<code>\n import string, re, timeit\n\n# Precomputed values (for str_join_set and translate)\n\nletter_set = frozenset(string.ascii_lowercase + string.ascii_uppercase)\ntab = string.maketrans(string.ascii_lowercase + string.ascii_uppercase,\n                       string.ascii_lowercase * 2)\ndeletions = ''.join(ch for ch in map(chr,range(256)) if ch not in letter_set)\n\ns=\"A235th@#$&amp;( er Ra{}|?&gt;ndom\"\n\n# From unwind's filter approach\ndef test_filter(s):\n    return filter(lambda x: x in string.ascii_lowercase, s.lower())\n\n# using set instead (and contains)\ndef test_filter_set(s):\n    return filter(letter_set.__contains__, s).lower()\n\n# Tomalak's solution\ndef test_regex(s):\n    return re.sub('[^a-z]', '', s.lower())\n\n# Dana's\ndef test_str_join(s):\n    return ''.join(c for c in s.lower() if c in string.ascii_lowercase)\n\n# Modified to use a set.\ndef test_str_join_set(s):\n    return ''.join(c for c in s.lower() if c in letter_set)\n\n# Translate approach.\ndef test_translate(s):\n    return string.translate(s, tab, deletions)\n\n\nfor test in sorted(globals()):\n    if test.startswith(\"test_\"):\n        assert globals()[test](s)=='atherrandom'\n        print \"%30s : %s\" % (test, timeit.Timer(\"f(s)\", \n              \"from __main__ import %s as f, s\" % test).timeit(200000))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This gives me:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n test_filter : 2.57138351271\n           test_filter_set : 0.981806765698\n                test_regex : 3.10069885233\n             test_str_join : 2.87172979743\n         test_str_join_set : 2.43197956381\n            test_translate : 0.335367566218\n</code>\n</pre>\n", "senID": 3}, {"text": ["[Edit] Updated with filter solutions as well.", "(Note that using set.__contains__ makes a big difference here, as it avoids making an extra function call for the lambda."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "set.__contains__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; filter(str.isalpha, \"This is a Test\").lower()\n'thisisatest'\n&gt;&gt;&gt; filter(str.isalpha, \"A235th@#$&amp;( er Ra{}|?&gt;ndom\").lower()\n'atherrandom'\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Not especially runtime efficient, but certainly nicer on poor, tired coder eyes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def strip_string_and_lowercase(s):\n    return ''.join(c for c in s.lower() if c in string.ascii_lowercase)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "lowercase the string", "tag": "none", "senID": 1}, {"text": "replace all ", "tag": "none", "senID": 2}]}, {"text": ["Like that:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def strip_string_to_lowercase():\n  nonascii = re.compile('[^a-z]')\n  return lambda s: nonascii.sub('', s.lower().strip())\n</code>\n</pre>\n", "senID": 4}, {"text": ["EDIT: It turns out that the original version (below) is really slow, though some performance can be gained by converting it into a closure (above)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def strip_string_to_lowercase(s):\n  return re.sub('[^a-z]', '', s.lower().strip())\n</code>\n</pre>\n", "senID": 6}, {"tag": "hr", "senID": 7}, {"text": ["My performance measurements with 100,000 iterations against the string  "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n \"A235th@#$&amp;( er Ra{}|?&gt;ndom\"\n</code>\n</pre>\n", "senID": 9}, {"text": ["revealed that:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"tag": "ul", "num": 6, "lis": [{"text": ["f_re_0 took 2672.000 ms"], "childNum": 0, "tag": "code", "senID": 11, "childList": []}, {"text": ["f_re_1 took 2109.000 ms"], "childNum": 0, "tag": "code", "senID": 12, "childList": []}, {"text": ["f_re_2 took 2031.000 ms"], "childNum": 0, "tag": "code", "senID": 13, "childList": []}, {"text": ["f_fl_1 took 1953.000 ms"], "childNum": 0, "tag": "code", "senID": 14, "childList": []}, {"text": ["f_fl_2 took 1485.000 ms"], "childNum": 0, "tag": "code", "senID": 15, "childList": []}, {"text": ["f_jn_1 took 1860.000 ms"], "childNum": 0, "tag": "code", "senID": 16, "childList": []}]}, {"text": ["For the sake of the test, I did not print the results."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "print", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Similar to @Dana's, but I think this sounds like a filtering job, and that should be visible in the code.", "Also without the need to explicitly call join():"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "join()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def strip_string_to_lowercase(s):\n  return filter(lambda x: x in string.ascii_lowercase, s.lower())\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Convert to lowercase and filter non-ascii non-alpha characters:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from string import ascii_letters, ascii_lowercase, maketrans\n\ntable = maketrans(ascii_letters, ascii_lowercase*2)\ndeletechars = ''.join(set(maketrans('','')) - set(ascii_letters))\n\nprint \"A235th@#$&amp;( er Ra{}|?&gt;ndom\".translate(table, deletechars)\n# -&gt; 'atherrandom'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Filter non-ascii:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ascii_bytes = \"A235th@#$&amp;(\u0660\u066b\u0662\u0665 er Ra{}|?&gt;ndom\".encode('ascii', 'ignore')\n</code>\n</pre>\n", "senID": 3}, {"text": ["Use bytes.translate() to convert to lowercase and delete non-alpha bytes:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "bytes.translate()", "tag": "a", "pos": 0, "childList": [{"text": "bytes.translate()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/py3k/library/stdtypes.html#bytes.translate"}, {"text": "bytes.translate()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from string import ascii_letters, ascii_lowercase\n\nalpha, lower = [s.encode('ascii') for s in [ascii_letters, ascii_lowercase]]\ntable = bytes.maketrans(alpha, lower*2)           # convert to lowercase\ndeletebytes = bytes(set(range(256)) - set(alpha)) # delete nonalpha\n\nprint(ascii_bytes.translate(table, deletebytes))\n# -&gt; b'atherrandom'\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import string\n&gt;&gt;&gt; a = \"O235th@#$&amp;( er Ra{}|?&amp;lt;ndom\"\n&gt;&gt;&gt; ''.join(i for i in a.lower() if i in string.ascii_lowercase)\n'otheraltndom'\n</code>\n</pre>\n", "senID": 0}, {"text": ["doing essentially the same as you."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This is a typical application of list compehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import string\ns = \"O235th@#$&amp;( er Ra{}|?&lt;ndom\"\nprint ''.join(c for c in s.lower() if c in string.ascii_lowercase)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It won't filter out \"&lt;\" (html entity), as in your example, but I assume that was accidental cut and past problem."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I added the filter solutions to Brian's code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import string, re, timeit\n\n# Precomputed values (for str_join_set and translate)\n\nletter_set = frozenset(string.ascii_lowercase + string.ascii_uppercase)\ntab = string.maketrans(string.ascii_lowercase + string.ascii_uppercase,\n                       string.ascii_lowercase * 2)\ndeletions = ''.join(ch for ch in map(chr,range(256)) if ch not in letter_set)\n\ns=\"A235th@#$&amp;( er Ra{}|?&gt;ndom\"\n\ndef test_original(s):\n    tmpStr = s.lower().strip()\n    retStrList = []\n    for x in tmpStr:\n        if x in string.ascii_lowercase:\n            retStrList.append(x)\n\n    return ''.join(retStrList)\n\n\ndef test_regex(s):\n    return re.sub('[^a-z]', '', s.lower())\n\ndef test_regex_closure(s):\n  nonascii = re.compile('[^a-z]')\n  def replacer(s):\n    return nonascii.sub('', s.lower().strip())\n  return replacer(s)\n\n\ndef test_str_join(s):\n    return ''.join(c for c in s.lower() if c in string.ascii_lowercase)\n\ndef test_str_join_set(s):\n    return ''.join(c for c in s.lower() if c in letter_set)\n\ndef test_filter_set(s):\n    return filter(letter_set.__contains__, s.lower())\n\ndef test_filter_isalpha(s):\n    return filter(str.isalpha, s).lower()\n\ndef test_filter_lambda(s):\n    return filter(lambda x: x in string.ascii_lowercase, s.lower())\n\ndef test_translate(s):\n    return string.translate(s, tab, deletions)\n\nfor test in sorted(globals()):\n    if test.startswith(\"test_\"):\n        print \"%30s : %s\" % (test, timeit.Timer(\"f(s)\", \n              \"from __main__ import %s as f, s\" % test).timeit(200000))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This gives me:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n test_filter_isalpha : 1.31981746283\n        test_filter_lambda : 2.23935583992\n           test_filter_set : 0.76511679557\n             test_original : 2.13079176264\n                test_regex : 2.44295629752\n        test_regex_closure : 2.65205913042\n             test_str_join : 2.25571266739\n         test_str_join_set : 1.75565888961\n            test_translate : 0.269259640541\n</code>\n</pre>\n", "senID": 3}, {"text": ["It appears that isalpha is using a similar algorithm, at least in terms of O(), to the set algorithm."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "hr", "senID": 5}, {"text": ["Edit: \nAdded the filter set, and renamed the filter functions to be a little more clear."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Personally I would use a regular expression and then convert the final string to lower case.", "I have no idea how to write it in Python, but the basic idea is to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["or vice versa."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n import string\nvalid_chars= string.ascii_lowercase + string.ascii_uppercase\n\ndef only_lower_ascii_alpha(text):\n    return filter(valid_chars.__contains__, text).lower()\n</code>\n</pre>\n", "senID": 0}, {"text": ["Works with either str or unicode arguments."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "unicode", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; only_lower_ascii_alpha(\"Hello there 123456!\")\n'hellothere'\n&gt;&gt;&gt; only_lower_ascii_alpha(u\"435 caf\u00e9\")\nu'caf'\n</code>\n</pre>\n", "senID": 2}]]