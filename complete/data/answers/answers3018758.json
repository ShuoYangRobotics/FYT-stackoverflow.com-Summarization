[[{"text": ["I think you should consider using the decimal type instead of a float.", "The float type will give rounding errors because the numbers are represented internally in binary but many decimal numbers don't have an exact binary representation."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "decimal", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/decimal.html"}, {"text": "float", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Not possible with floating point variables.", "For example, typing "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 10.2345\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 10.234500000000001\n</code>\n</pre>\n", "senID": 3}, {"text": ["So, to get 6,4 out of this, you will have to find a way to distinguish between a user entering 10.2345 and 10.234500000000001, which is impossible using floats.", "This has to do with the way floating point numbers are stored.", "Use decimal."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "10.2345", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "10.234500000000001", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "decimal", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n import decimal\na = decimal.Decimal('10.234539048538495')\n&gt;&gt;&gt; str(a)\n'10.234539048538495'\n&gt;&gt;&gt;  (len(str(a))-1, len(str(a).split('.')[1]))\n(17,15)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["(0) Please confirm or deny: You are given floats to use, this is unavoidable, you can't get your data as decimal, the Oracle datatypes include decimal-based types, and this fundamental mismatch is unavoidable.", "Please explain any full or partial denial. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(1) Your \"fail for large numbers\" remark is misleading/irrelevant/wrong -- you say that your starting point is a float, but 1234567890.0987654321 can't be represented as a float, as shown by the result of repr()."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(2) Perhaps you could use the NEW repr (Python 2.7 and 3.1) which provides the minimum possible precision of repr(x) that still satisfies float(repr(x)) == x"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "float(repr(x)) == x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["E.g.", "old repr(1.1) produces \"1.1000000000000001\", new repr(1.1) produces \"1.1\""], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["About \"I guess map(len, repr(num).split('.", "')) is the closest I'll get to the precision and scale of the float?", "\": You need a strategy to handle (a) negative and zero numbers (b) numbers like 1.1e20"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "1.1e20", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Digging in Objects/floatobject.c should turn up the C code for the new repr() of a float object, should you need to use Python 2.6 or earlier."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["(3) Perhaps if you told us the specs for the relevant Oracle data types, we could help you devise checks for choosing which type can contain a given float value."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Basically, you can't with floating point numbers.", "Using the decimal type would help and if you want really large precision, consider using gmpy, the GNU Multiple Precision library's port to Python."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Basically, you can't with floating point numbers.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/floatingpoint.html"}, {"text": "gmpy", "tag": "a", "pos": 1, "childList": [{"text": "gmpy", "tag": "code"}], "childNum": 1, "href": "http://code.google.com/p/gmpy/"}, {"text": "gmpy", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Getting the number of digits to the left of the decimal point is easy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n int(log10(x))+1\n</code>\n</pre>\n", "senID": 1}, {"text": ["The number of digits to the right of the decimal point is trickier, because of the inherent inaccuracy of floating point values.", "I'll need a few more minutes to figure that one out."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: Based on that principle, here's the complete code."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import math\n\ndef precision_and_scale(x):\n    max_digits = 14\n    int_part = int(abs(x))\n    magnitude = 1 if int_part == 0 else int(math.log10(int_part)) + 1\n    if magnitude &gt;= max_digits:\n        return (magnitude, 0)\n    frac_part = abs(x) - int_part\n    multiplier = 10 ** (max_digits - magnitude)\n    frac_digits = multiplier + int(multiplier * frac_part + 0.5)\n    while frac_digits % 10 == 0:\n        frac_digits /= 10\n    scale = int(math.log10(frac_digits))\n    return (magnitude + scale, scale)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["seems like str is better choice than repr:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "repr", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; r=10.2345678\n&gt;&gt;&gt; r\n10.234567800000001\n&gt;&gt;&gt; repr(r)\n'10.234567800000001'\n&gt;&gt;&gt; str(r)\n'10.2345678'\n</code>\n</pre>\n", "senID": 1}]]