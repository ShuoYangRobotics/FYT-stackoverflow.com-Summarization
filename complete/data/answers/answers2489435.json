[[{"text": ["The problem with relying on any floating point computation (math.sqrt(x), or x**0.5) is that you can't really be sure it's exact (for sufficiently large integers x, it won't be, and might even overflow).", "Fortunately (if one's in no hurry;-) there are many pure integer approaches, such as the following...:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "math.sqrt(x)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x**0.5", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def is_square(apositiveint):\n  x = apositiveint // 2\n  seen = set([x])\n  while x * x != apositiveint:\n    x = (x + (apositiveint // x)) // 2\n    if x in seen: return False\n    seen.add(x)\n  return True\n\nfor i in range(110, 130):\n   print i, is_square(i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Hint: it's based on the \"Babylonian algorithm\" for square root, see wikipedia.", "It does work for any positive number for which you have enough memory for the computation to proceed to completion;-)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "wikipedia", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Methods_of_computing_square_roots"}, {"text": "does", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Edit: let's see an example..."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n x = 12345678987654321234567 ** 2\n\nfor i in range(x, x+2):\n   print i, is_square(i)\n</code>\n</pre>\n", "senID": 4}, {"text": ["this prints, as desired (and in a reasonable amount of time, too;-):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n 152415789666209426002111556165263283035677489 True\n152415789666209426002111556165263283035677490 False\n</code>\n</pre>\n", "senID": 6}, {"text": ["Please, before you propose solutions based on floating point intermediate results, make sure they work correctly on this simple example -- it's not that hard (you just need a few extra checks in case the sqrt computed is a little off), just takes a bit of care."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "that", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["And then try with x**7 and find clever way to work around the problem you'll get,"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "x**7", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n OverflowError: long int too large to convert to float\n</code>\n</pre>\n", "senID": 9}, {"text": ["you'll have to get more and more clever as the numbers keep growing, of course."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["If I was in a hurry, of course, I'd use gmpy -- but then, I'm clearly biased;-)."], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "was", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"href": "http://www.gmpy.org/", "text": "gmpy", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import gmpy\n&gt;&gt;&gt; gmpy.is_square(x**7)\n1\n&gt;&gt;&gt; gmpy.is_square(x**7 + 1)\n0\n</code>\n</pre>\n", "senID": 12}, {"text": ["Yeah, I know, that's just so easy it feels like cheating (a bit the way I feel towards Python in general;-) -- no cleverness at all, just perfect directness and simplicity (and, in the case of gmpy, sheer speed;-)..."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Use newton's method to quickly zero in the nearest integer square root, then square it and see if it's your number.", "See isqrt."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "isqrt", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Isqrt"}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; def f(x):\n...     x = x ** 0.5\n...     return int(x) == x\n...\n&gt;&gt;&gt; for i in range(10):\n...     print i, f(i)\n...\n0 True\n1 True\n2 False\n3 False\n4 True\n5 False\n6 False\n7 False\n8 False\n9 True\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Since you can never depend on exact comparisons when dealing with floating point computations (such as these ways of calculating the square root), a less error-prone implementation would be"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import math\ndef is_square(integer):\n    root = math.sqrt(integer)\n    if int(root + 0.5) ** 2 == integer: \n        return True\n    else:\n        return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["Imagine integer is 9. math.sqrt(9) could be 3.0, but it could also be something like 2.99999 or 3.00001, so squaring the result right off isn't reliable.", "Knowing that int takes the floor value, increasing the float value by 0.5 first means we'll get the value we're looking for if we're in a range where float still has a fine enough resolution to represent numbers near the one for which we are looking."], "childNum": 9, "tag": "p", "senID": 2, "childList": [{"text": "integer", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "9", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "math.sqrt(9)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "3.0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "2.99999", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "3.00001", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "0.5", "childNum": 0, "tag": "code", "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You could binary-search for the rounded square root.", "Square the result to see if it matches the original value."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You're probably better off with FogleBirds answer - though beware, as floating point arithmetic is approximate, which can throw this approach off.", "You could in principle get a false positive from a large integer which is one more than a perfect square, for instance, due to lost precision."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'm new to Stack Overflow, and did a quick skim to find a solution.", "I just posted a slight variation on some of the examples above on another thread (Finding perfect squares) and thought I'd include a slight variation of what I posted there here (using nsqrt as a temporary variable), in case it's of interest / use:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Finding perfect squares", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1547196/finding-perfect-square/5750159#5750159"}]}, {"code": "<pre>\n<code>\n import math\ndef is_perfect_square(n):\n  if not ( ( isinstance(n, int) or isinstance(n, long) ) and ( n &gt;= 0 ) ):\n    return False \n  else:\n    nsqrt = math.sqrt(n)\n    return nsqrt == math.trunc(nsqrt)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm not sure of the Python, but you could do something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n function isSquare(x) = x == floor(sqrt(x) + 0.5)^2\n</code>\n</pre>\n", "senID": 1}, {"text": ["That is, take a number, find the square root, round it to the nearest integer, square it, and test if it's the same as the original number.", "(floor and adding 0.5 is done to prevent cases like sqrt(4) returning 1.9999999... due to floating point math, as Mike Graham pointed out."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "floor", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "0.5", "childNum": 0, "tag": "code", "childList": []}, {"text": "sqrt(4)", "childNum": 0, "tag": "code", "childList": []}, {"text": "1.9999999...", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In case you're interested, there was once a very good discussion on the Fastest way to determine if an integer\u2019s square root is an integer."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Fastest way to determine if an integer\u2019s square root is an integer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/295579/fastest-way-to-determine-if-an-integers-square-root-is-an-integer"}]}, {"text": ["Edited for clarification."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edited for clarification.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [], [{"text": ["This response doesn't pertain to your stated question, but to an implicit question I see in the code you posted, ie, \"how to check if something is an integer?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first answer you'll generally get to that question is \"Don't!", "\" And it's true that in Python, typechecking is usually not the right thing to do."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For those rare exceptions, though, instead of looking for a decimal point in the string representation of the number, the thing to do is use the isinstance function:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "isinstance", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; isinstance(5,int)\nTrue\n&gt;&gt;&gt; isinstance(5.0,int)\nFalse\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course this applies to the variable rather than a value.", "If I wanted to determine whether the value was an integer, I'd do this:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "value", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x=5.0\n&gt;&gt;&gt; round(x) == x\nTrue\n</code>\n</pre>\n", "senID": 5}, {"text": ["But as everyone else has covered in detail, there are floating-point issues to be considered in most non-toy examples of this kind of thing."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]