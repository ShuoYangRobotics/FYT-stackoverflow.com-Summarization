[[{"text": ["You're using the wrong data type.", "Use a dict of sets instead:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def add(key, value, userdict):\n    userdict.setdefault(key, set())\n    userdict[key].add(value)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n animaldict = {}\nadd('bird', 'peck', animaldict)\nadd('bird', 'screech', animaldict)\nadd('turtle', 'hide', animaldict)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["While it is possible to construct a generic function that finds the animal in the list using a.index or testing with \"dog\" in animals, you really want a dictionary here, otherwise the add function will scale abysmally as more animals are added:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n animals = {'dog':set(['bite']),\n           'cat':set(['bite', 'scratch'])}\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can then \"one-shot\" the add function using setdefault:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n animals.setdefault('dog', set()).add('bite')\n</code>\n</pre>\n", "senID": 3}, {"text": ["It will create the 'dog' key if it doesn't exist, and since setdefault returns the set that either exists or was just created, you can then add the bite action.", "Sets ensure that there are no duplicates automatically."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Based on recursive's solution, in Python 2.5 or newer you can use the defaultdict class, something like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\na = defaultdict(set)\n\ndef add(animal, behavior):\n    a[animal].add(behavior)\n\nadd('bird', 'peck')\nadd('bird', 'screech')\nadd('turtle', 'hide')\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n animals_dict = dict(animals)\n\ndef add(key, action):\n    animals_dict.setdefault(key, [])\n    if action not in animals_dict[key]:\n        animals_dict[key].append(action)\n</code>\n</pre>\n", "senID": 0}, {"text": ["(Updated to use setdefault - nice one @recursive)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "setdefault", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You really should use a dictionary for this purpose.", "Or alternatively a class Animal."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Animal", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You could improve your code like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if not any((animal[0] == \"bird\") for animal in animals):\n    # append \"bird\" to animals\n</code>\n</pre>\n", "senID": 2}], [{"text": ["While I agree with the others re.", "your choice of data structure, here is an answer to your question:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def add(name, action):\n    for animal in animals:\n        if animal[0] == name:\n            if action not in animal[1]:\n                animal[1].append(action)\n            return\n    else:\n        animals.append([name, [action]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["The for loop is an inevitable consequence of your data structure, which is why everyone is advising you to consider dictionaries instead."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]