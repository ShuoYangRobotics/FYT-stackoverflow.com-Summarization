[[{"text": ["In python, the code in a class is run when the class is loaded."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Now, what the hell does that mean?", ";-)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Consider the following code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class x:\n    print \"hello\"\n    def __init__(self): print \"hello again\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["When you load the module that contains the code, python will print hello.", "Whenever you create an x, python will print hello again."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "hello", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "hello again", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can think of def __init__(self): ... as equivalent with __init__ = lambda self: ..., except none of the python lambda restrictions apply.", "That is, def is an assignment, which might explain why code outside methods but not inside methods is run."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "def __init__(self): ...", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__ = lambda self: ...", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["When your code says"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class X(models.Model):\n    creator = Registry()\n    creator.register(Y)\n</code>\n</pre>\n", "senID": 7}, {"text": ["You refer to Y when the module is loaded, before Y has a value.", "You can think of class X as an assignment (but I can't remember the syntax for creating anonymous classes off-hand; maybe it's an invocation of type?"], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "Y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Y", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "class X", "childNum": 0, "tag": "code", "childList": []}, {"text": "type", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What you may want to do is this:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n class X(models.Model):\n    pass\nclass Y(models.Model):\n    foo = something_that_uses_(X)\nX.bar = something_which_uses(Y)\n</code>\n</pre>\n", "senID": 10}, {"text": ["That is, create the class attributes of X which reference Y after Y is created.", "Or vice versa: create Y first, then X, then the attributes of Y which depend on X, if that's easier."], "childNum": 7, "tag": "p", "senID": 11, "childList": [{"text": "X", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Y", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Y", "childNum": 0, "tag": "code", "childList": []}, {"text": "Y", "childNum": 0, "tag": "code", "childList": []}, {"text": "X", "childNum": 0, "tag": "code", "childList": []}, {"text": "Y", "childNum": 0, "tag": "code", "childList": []}, {"text": "X", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Hope this helps :)"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["As long as you are working within a method you can access the class object.", "Thus the example above has no problems if creator.register(Y) is moved inside init.", "However, you cannot have circular references to classes outside of methods."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "init", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"text": ["UPDATE: He changed the question after my answer.", "The currently accepted solution is better in light of the new question."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What are you saying is the problem?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def __init__(self):\n        super(A, self).__init__()\n\n\n    def b(self):\n        return B()\n\n\nclass B(object):\n    def __init__(self):\n        super(B, self).__init__()\n\n\n    def a(self):\n        return A()\n</code>\n</pre>\n", "senID": 2}, {"text": ["This compiles and runs just fine."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The error is that execution of creator.register(Y) is attempted during the (executable) definition of class X, and at that stage, class Y is not defined.", "Understand this: class and def are statements that are executed (typically at import time); they are not \"declarations\". "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "creator.register(Y)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "class", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Suggestion: tell us what you are trying to achieve -- perhaps as a new question."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["http://amix.dk/blog/viewEntry/19343"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://amix.dk/blog/viewEntry/19343", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://amix.dk/blog/viewEntry/19343"}]}], [{"text": ["The problem is most likely not Python.", "I would think it is an SQL issue.", "The classes are via an abstraction layer converted to an SQL query to create a table.", "You are trying to reference from one table another one that at the time does not exist yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In SQL you would solve this by creating the table first without the references and after that modify them to make those references,"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["However I am not sure about my answer, so take it with lots of seasoning, I would be actually quite surprised if Django's database abstraction layer doesn't deal with cross references nicely."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]