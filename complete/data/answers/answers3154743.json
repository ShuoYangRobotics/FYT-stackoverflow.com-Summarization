[[{"text": ["If you're allergic to REs, you could use pyparsing:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/Download+and+Installation"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import pyparsing as p\n&gt;&gt;&gt; ope, clo, com = map(p.Suppress, '(),')\n&gt;&gt;&gt; w = p.Word(p.alphas)\n&gt;&gt;&gt; s = ope + w + com + w + com + ope + p.delimitedList(w) + clo + clo\n&gt;&gt;&gt; x = '(xx,yyy,(aa,bb,cc))'\n&gt;&gt;&gt; list(s.parseString(x))\n['xx', 'yyy', 'aa', 'bb', 'cc']\n</code>\n</pre>\n", "senID": 1}, {"text": ["pyparsing also makes it easy to control the exact form of results (e.g.", "by grouping the last 3 items into their own sublist), if you want.", "But I think the nicest aspect is how natural (depending on how much space you want to devote to it) you can make the \"grammar specification\" read: an open paren, a word, a comma, a word, a comma, an open paren, a delimited list of words, two closed parentheses (if you find the assignment to s above not so easy to read, I guess it's my fault for not choosing longer identifiers;-)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "pyparsing", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "s", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Let's use regular expressions!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n /\\(([^,]+),([^,]+),\\(([^)]+)\\)\\)/\n</code>\n</pre>\n", "senID": 1}, {"text": ["Match against that, first capturing group contains xx, second contains yyy, split the third on , and you have your list."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": ",", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["How about like this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import ast\n&gt;&gt;&gt; import re\n&gt;&gt;&gt;\n&gt;&gt;&gt; s=\"(xx,yyy,(aa,bb,ccc))\"\n&gt;&gt;&gt; x=re.sub(\"(\\w+)\",'\"\\\\1\"',s)\n# '(\"xx\",\"yyy\",(\"aa\",\"bb\",\"ccc\"))'\n&gt;&gt;&gt; ast.literal_eval(x)\n('xx', 'yyy', ('aa', 'bb', 'ccc'))\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If your parenthesis nesting can be arbitrarily deep, then regexen won't do, you'll need a state machine or a parser.", "Pyparsing supports recursive grammars using forward-declaration class Forward:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from pyparsing import *\n\nLPAR,RPAR,COMMA = map(Suppress,\"(),\")\nnestedParens = Forward()\nlistword = Word(alphas) | '...'\nnestedParens &lt;&lt; Group(LPAR + delimitedList(listword | nestedParens) + RPAR)\n\ntext = \"(xx,yyy,(aa,bb,...))\"\nresults = nestedParens.parseString(text).asList()\nprint results\n\ntext = \"(xx,yyy,(aa,bb,(dd,ee),ff,...))\"\nresults = nestedParens.parseString(text).asList()\nprint results\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [['xx', 'yyy', ['aa', 'bb', '...']]]\n[['xx', 'yyy', ['aa', 'bb', ['dd', 'ee'], 'ff', '...']]]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I don't know that this is better, but it's a different way to do it.", "Using the regex previously suggested"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def processInput(inputStr):\n        value = [re.sub('\\(*\\)*','',i) for i in inputStr.split(',')]\n        return value[0], value[1], value[2:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Alternatively, you could use two chained replace functions in lieu of the regex. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Your solution is decent (simple, efficient).", "You could use regular expressions to restrict the syntax if you don't trust your data source."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nparser_re = re.compile(r'\\(([^,)]+),([^,)]+),\\(([^)]+)\\)')\ndef parse(input):\n    m = parser_re.match(input)\n    if m:\n        first = m.group(1)\n        second = m.group(2)\n        rest = m.group(3).split(\",\")\n        return (first, second, rest)\n    else:\n        return None\n\nprint parse( '(xx,yy,(aa,bb,cc,dd))' )\nprint parse( 'xx,yy,(aa,bb,cc,dd)' ) # doesn't parse, returns None\n\n# can use this to unpack the various parts.\n# first,second,rest = parse(...)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ('xx', 'yy', ['aa', 'bb', 'cc', 'dd'])\nNone\n</code>\n</pre>\n", "senID": 3}]]