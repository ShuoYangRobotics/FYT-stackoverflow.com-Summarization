[[{"text": ["You have several choices for the Head-Tail design pattern."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Head-Tail", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n seq= something.get()\nroot.copy( seq[0] )\nfoo( seq[0] )\nfor member in seq[1:]:\n    somewhereElse.copy(member)\n    foo( member )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or this"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n seq_iter= iter( something.get() )\nhead = seq_iter.next()\nroot.copy( head )\nfoo( head )\nfor member in seq_iter:\n    somewhereElse.copy( member )\n    foo( member )\n</code>\n</pre>\n", "senID": 3}, {"text": ["People whine that this is somehow not \"DRY\" because the \"redundant foo(member)\" code.", "That's a ridiculous claim.", "If that was true then all functions could only be used once.", "What's the point of defining a function if you can only have one reference?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Something like this should work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i, member in enumerate(something.get()):\n    if i == 0:\n         # Do thing\n    # Code for everything\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, I would strongly recommend thinking about your code to see if you really have to do it this way, because it's sort of \"dirty\".", "Better would be to fetch the element that needs special handling up front, then do regular handling for all the others in the loop."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The only reason I could see for not doing it this way is for a big list you'd be getting from a generator expression (which you wouldn't want to fetch up front because it wouldn't fit in memory), or similar situations."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I think this is quite elegant, but maybe too convoluted for what it does..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import chain, repeat, izip\nfor place, member in izip(chain([root], repeat(somewhereElse)), something.get()):\n    place.copy(member)\n    foo(member)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If something.get() iterates over something, you can do it also as follows:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n root.copy(something.get())\n\nfor member in something.get():\n  #  the rest of the loop\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here, I could come with a Pythonic idiom that can look \"pertty\".", "Although, most likely I'd use the form you suggested in asking the question, just for the code to remain more obvious, though less elegant."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def copy_iter():\n    yield root.copy\n    while True:\n        yield somewhereElse.copy\n\nfor member, copy in zip(something.get(), copy_iter()):\n    copy(member)\n    foo(member)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(sorry - the first I posted, before editing, form would not work, I had forgotten to actually get an iterator for the 'copy' object)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["How about using iter, and consuming the first element?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "iter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: Going back on the OP's question, there is a common operation that you want to perform on all elements, and then one operation you want to perform on the first element, and another on the rest."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If it's just a single function call, I'd say just write it twice.", "It won't end the world.", "If it's more involved, you can use a decorator to wrap your \"first\" function and \"rest\" function with a common operation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def common(item):\n    print \"common (x**2):\", item**2\n\ndef wrap_common(func):\n    \"\"\"Wraps `func` with a common operation\"\"\"\n    def wrapped(item):\n        func(item)\n        common(item)\n    return wrapped\n\n@wrap_common\ndef first(item):\n    \"\"\"Performed on first item\"\"\"\n    print \"first:\", item+2\n\n@wrap_common\ndef rest(item):\n    \"\"\"Performed on rest of items\"\"\"\n    print \"rest:\", item+5\n\nitems = iter(range(5))\nfirst(items.next())\n\nfor item in items:\n    rest(item)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Output:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Output:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n first: 2\ncommon (x**2): 0\nrest: 6\ncommon (x**2): 1\nrest: 7\ncommon (x**2): 4\nrest: 8\ncommon (x**2): 9\nrest: 9\ncommon (x**2): 16\n</code>\n</pre>\n", "senID": 5}, {"text": ["or you could do a slice:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n first(items[0])\nfor item in items[1:]:\n    rest(item)\n</code>\n</pre>\n", "senID": 7}], [{"text": ["I think the first S.Lott solution is the best, but there's another choice if you're using a pretty recent python (>= 2.6 I think, since izip_longest doesn't seem available before that version) that lets doing different things for the first element and successive one, and can be easily modified to do distinct operations for 1st, 2nd, 3rd element... as well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip_longest\n\nseq = [1, 2, 3, 4, 5]\n\ndef headfunc(value):\n    # do something\n    print \"1st value: %s\" % value\n\ndef tailfunc(value):\n    # do something else\n    print \"this is another value: %s\" % value\n\ndef foo(value):\n    print \"perform this at ANY iteration.\"\n\nfor member, func in izip_longest(seq, [headfunc], fillvalue=tailfunc):\n    func(member)\n    foo(member)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["how about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my_array = something.get()\nfor member in my_array:\n    if my_array.index(member) == 0:\n        root.copy(member)\n    else:\n        somewhereElse.copy(member)\n    foo(member)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or maybe:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for index, member in enumerate(something.get()):\n    if index == 0:\n        root.copy(member)\n    else:\n        somewhereElse.copy(member)\n    foo(member)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Documentation of index-method."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "index-method", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/array.html#array.array.index"}]}], [{"text": ["Can't you do root.copy(something.get()) before the loop?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "root.copy(something.get())", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT: Sorry, I missed the second bit.", "But you get the general idea.", "Otherwise, enumerate and check for 0?"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["EDIT2: Ok, got rid of the silly second idea."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["This works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for number, member in enumerate(something.get()):\n    if not number:\n        root.copy(member)\n    else:\n        somewhereElse.copy(member)\n    foo(member)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In most cases, though, I'd suggest just iterating over whatever[1:] and doing the root thing outside the loop; that's usually more readable.", "Depends on your use case, of course."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "whatever[1:]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I don't know Python, but I use almost the exact pattern of your example.", "What I do also is making the if condition the most frequent, so usually check for if( first == false )\nWhy?", "for long loops, first will be true only one time and will be false all the other times, meaning that in all loops but the first, the program will check for the condition and jump to the else part.", "By checking for first being false, there will be only one jump to the else part.", "I don't really know if this adds efficiency at all, but I do it anyway, just to be in peace with my inner nerd.  "], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "if( first == false )", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 3, "childList": []}]}, {"text": ["PS: Yes, I know that when entering the if part, it also has to jump over the else to continue execution, so probably my way of doing it is useless, but it feels nice.", ":D"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]