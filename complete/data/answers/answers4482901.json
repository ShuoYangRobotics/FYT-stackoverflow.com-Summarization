[[{"text": ["The main reason for putting one class in another is to avoid polluting the global namespace with things that are used only inside one class and therefore doesn't belong in the global namespace.", "This is applicable even to Python, with the global namespace being a namespace of a particular module.", "For example if you have SomeClass and OtherClass, and both of them need to read something in a specialized way, it is better to have SomeClass.Reader and OtherClass.Reader rather than SomeClassReader and OtherClassReader."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I have never encountered this in C++, though.", "It can be problematic to control access to the outer class' fields from a nested class.", "And it is also pretty common to have just one public class in a compilation unit defined in the header file and some utility classes defined in the CPP file (the Qt library is a great example of this).", "This way they aren't visible to \"outsiders\" which is good, so it doesn't make much sense to include them in the header.", "It also helps to increase binary compatibility which is otherwise a pain to maintain.", "Well, it's a pain anyway, but much less so."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "It can be problematic to control access to the outer class' fields from a nested class.", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "https://developer.mozilla.org/en/C___Portability_Guide#Be_careful_with_inner_%28nested%29_classes"}]}, {"text": ["A great example of a language where nested classes are really useful is Java.", "Nested classes there automatically have a pointer to the instance of the outer class that creates them (unless you declare the inner class as static).", "This way you don't need to pass \"outer\" to their constructors and you can address the outer class' fields just by their names."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It allows you to control the access of the nested class- for example, it's often used for implementation detail classes.", "In C++ it also has advantages in terms of when various things are parsed and what you can access without having to declare first."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I am not a big fan of python, but to me this type of decisions are more semantical than syntactical.", "If you are implementing a list, the class Node inside List is not a class in itself meant to be used from anywhere, but an implementation detail of the list.", "At the same time you can have a Node internal class inside Tree, or Graph.", "Whether the compiler/interpreter allows you to access the class or not is in a different thing.", "Programing is about writing specifications that the computer can follow and other programers can read, List.Node is more explicit in that Node is internal to List than having ListNode as a first level class."], "childNum": 9, "tag": "p", "senID": 0, "childList": [{"text": "Node", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "List", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "Node", "childNum": 0, "tag": "code", "childList": []}, {"text": "Tree", "childNum": 0, "tag": "code", "childList": []}, {"text": "Graph", "childNum": 0, "tag": "code", "childList": []}, {"text": "List.Node", "childNum": 0, "tag": "code", "childList": []}, {"text": "Node", "childNum": 0, "tag": "code", "childList": []}, {"text": "List", "childNum": 0, "tag": "code", "childList": []}, {"text": "ListNode", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["In some languages, the nested class will have access to variables that are in scope within the outer class.", "(Similarly with functions, or with class-in-function nesting.", "Of course, function-in-class nesting just creates a method, which behaves fairly unsurprisingly.", ";) )"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In more technical terms, we create a closure."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "closure", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Closure_%28computer_science%29"}]}], [{"text": ["Python lets you do a lot of things with functions (including lambdas) that in C++03 or Java you need a class for (although Java has anonymous inner classes, so a nested class doesn't always look like your example).", "Listeners, visitors, that kind of thing.", "A list comprehension is loosely a kind of visitor:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n (foo(x) if x.f == target else bar(x) for x in bazes)\n</code>\n</pre>\n", "senID": 2}, {"text": ["C++:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n struct FooBar {\n    Sommat operator()(const Baz &amp;x) const {\n        return (x.f == val) ? foo(x) : bar(x);\n    }\n    FooBar(int val) : val(val) {}\n    int val;\n};\n\nvector&lt;Sommat&gt; v(bazes.size());\nstd::transform(bazes.begin(), bazes.end(), v.begin(), FooBar(target));\n</code>\n</pre>\n", "senID": 4}, {"text": ["The question that C++ and Java programmers then ask themselves is, \"this little class that I'm writing: should it appear in the same scope as the big class that needs to use it, or should I confine it within the scope of the only class that uses it?", "\"[*]"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Since you don't want to publish the thing, or allow anyone else to rely on it, often the answer in these cases is a nested class.", "In Java, private classes can serve, and in C++ you can restrict classes to a TU, in which case you may no longer care too much what namespace scope the name appears in, so nested classes aren't actually required.", "It's just a style thing, plus Java provides some syntactic sugar."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["As someone else said, another case is iterators in C++.", "Python can support iteration without an iterator class, but if you're writing a data structure in C++ or Java then you have to put the blighters somewhere.", "To follow the standard library container interface you'll have a nested typedef for it whether the class is nested or not, so it's fairly natural to think, \"nested class\"."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["[*] They also ask themselves, \"should I just write a for loop?", "\", but let's suppose a case where the answer to that is no..."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["In C++ at least, one major common use-case for nested classes is iterators in containers.", "For example, a hypothetical implementation might look something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class list\n{\n   public:\n\n   class iterator \n   {\n      // implementation code\n   };\n\n   class const_iterator\n   {\n      // implementation code\n   };\n};\n</code>\n</pre>\n", "senID": 1}, {"text": ["Another reason for nested classes in C++ would be private implementation details like node classes for maps, linked lists, etc."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["\"Nested classes\" can mean two different things, which can be split into three different categories by intent.", "The first one is purely stylistic, the other two are used for practical purposes, and are highly dependent on the features language where they are used. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In Python, a more usefull pattern is declaration of a class inside a function or method.", "Declaration of a class in teh body of another class, as people have noted in other answers, is of little use - yes, it does avoid polution of the module namespace, but since there_is_ a module namespace at all, a few more names on it do not bother.", "Eve3n if the extra classes are not intended to be instantiatiated directly by users of the module, putting then on the module root make their documentation more easily acessible to others."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, a class inside a function is a completely different creature: It is \"declared\" and created each time the code containing the class body is run.", "This gives one the possibility of creating dynamic classes for various uses - in a very simple way.", "For example, each class created this way is in a different closure, and can have access to different instances of the variables on the containing function."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def call_count(func):\n    class Counter(object):\n       def __init__(self):\n           self.counter = 0\n       def __repr__(self):\n           return str(func)\n       def __call__(self, *args, **kw):\n           self.counter += 1\n           return func(*args, **kw)\n    return Counter()\n</code>\n</pre>\n", "senID": 2}, {"text": ["And using it on the console:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; @call_count\n... def noop(): pass\n...\n&gt;&gt;&gt; noop()\n&gt;&gt;&gt; noop()\n&gt;&gt;&gt; noop.counter\n2\n&gt;&gt;&gt; noop\n&lt;function noop at 0x7fc251b0b578&gt;\n</code>\n</pre>\n", "senID": 4}, {"text": ["So, a  simple call_counter decorator culd use a static \"Counter\" class, defined outside the function, and receiving func as a parameter to its constructor - but if you want to tweak other behaviors, like in this example, makin repr(func) return the function representation, not the class representation, it is easier to be made this way."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]