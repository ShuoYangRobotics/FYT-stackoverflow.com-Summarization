[[{"text": ["using sets"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from datetime import date, timedelta\n&gt;&gt;&gt; d = [date(2010, 2, 23),date(2010, 2, 24),date(2010, 2, 25),\n         date(2010, 2, 26),date(2010, 3, 1),date(2010, 3, 2)]\n&gt;&gt;&gt; date_set = set(d[0]+timedelta(x) for x in range((d[-1]-d[0]).days))\n&gt;&gt;&gt; missing = sorted(date_set-set(d))\n&gt;&gt;&gt; missing\n[datetime.date(2010, 2, 27), datetime.date(2010, 2, 28)]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Sort the list of dates and iterate over it, remembering the previous entry.", "If the difference between the previous and current entry is more than one day, you have missing days."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's one way to implement it:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from datetime import date, timedelta\nfrom itertools import tee, izip\n\ndef pairwise(iterable):\n    \"s -&gt; (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = tee(iterable)\n    b.next()\n    return izip(a, b)\n\ndef missing_dates(dates):\n    for prev, curr in pairwise(sorted(dates)):\n        i = prev\n        while i + timedelta(1) &lt; curr:\n            i += timedelta(1)\n            yield i\n\ndates = [ date(2010, 1, 8),\n          date(2010, 1, 2),\n          date(2010, 1, 5),\n          date(2010, 1, 1),\n          date(2010, 1, 7) ]\n\nfor missing in missing_dates(dates):\n    print missing\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 2010-01-03\n2010-01-04\n2010-01-06\n</code>\n</pre>\n", "senID": 4}, {"text": ["Performance is O(n*log(n)) where n is the number of days in the span when the input is unsorted.", "As your list is already sorted, it will run in O(n)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; date_list = [datetime(2010, 2, 23),datetime(2010, 2, 24),datetime(2010, 2, 25),datetime(2010, 2, 26),datetime(2010, 3, 1),datetime(2010, 3, 2)]\n&gt;&gt;&gt; \n&gt;&gt;&gt; date_set=set(date_list)         # for faster membership tests than list\n&gt;&gt;&gt; one_day = timedelta(days=1)\n&gt;&gt;&gt; \n&gt;&gt;&gt; test_date = date_list[0]\n&gt;&gt;&gt; missing_dates=[]\n&gt;&gt;&gt; while test_date &lt; date_list[-1]:\n...     if test_date not in date_set:\n...         missing_dates.append(test_date)\n...     test_date += one_day\n... \n&gt;&gt;&gt; print missing_dates\n[datetime.datetime(2010, 2, 27, 0, 0), datetime.datetime(2010, 2, 28, 0, 0)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["This also works for datetime.date objects, but the OP says the list is datetime.datetime objects"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "datetime.date", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "datetime.datetime", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Put the dates in a set and then iterate from the first date to the last using datetime.timedelta(), checking for containment in the set each time."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "datetime.timedelta()", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n import datetime\n\nDAY = datetime.timedelta(days=1)\n# missing dates: a list of [start_date, end)\nmissing = [(d1+DAY, d2) for d1, d2 in zip(dates, dates[1:]) if (d2 - d1) &gt; DAY]\n\ndef date_range(start_date, end, step=DAY):\n    d = start_date\n    while d &lt; end:\n        yield d\n        d += step\n\nmissing_dates = [d for d1, d2 in missing for d in date_range(d1, d2)]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Using a list comprehension"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from datetime import date, timedelta\n&gt;&gt;&gt; d = [date(2010, 2, 23),date(2010, 2, 24),date(2010, 2, 25),date(2010, 2, 26),date(2010, 3, 1),date(2010, 3, 2)]\n&gt;&gt;&gt; date_set=set(d)\n&gt;&gt;&gt; missing = [x for x in (d[0]+timedelta(x) for x in range((d[-1]-d[0]).days)) if x not in date_set]\n\n&gt;&gt;&gt; missing\n[datetime.date(2010, 2, 27), datetime.date(2010, 2, 28)]\n</code>\n</pre>\n", "senID": 1}]]