[[{"text": ["Yes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Filter( object ):\n    def __init__( self, content ):\n        self.content = content\n    def __call__( self, someParam ):\n        self.someParam = someParam\n        for line in self.content:\n            if line == someParam:\n                yield line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Unfortunately, generator objects (the results returned from calling a generator function) do not support adding arbitrary attributes.", "You can work around it to some extent by using an external dict indexed by the generator objects, since such objects are usable as keys into a dict.", "So where you'd like to do, say:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "are", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "like", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n a = filter(23)\nb = filter(45)\n...\na.foo = 67\n...\nx = random.choice([a,b])\nif hasattr(x, 'foo'): munge(x.foo)\n</code>\n</pre>\n", "senID": 1}, {"text": ["you may instead do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n foos = dict()\na = filter(23)\nb = filter(45)\n...\nfoos[a] = 67\n...\nx = random.choice([a,b])\nif x in foos: munge(foos[x])\n</code>\n</pre>\n", "senID": 3}, {"text": ["For anything fancier, use a class instead of a generator (one or more of the class's methods can be generators, after all)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["No.", "You can't set arbitrary attributes on generators."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As S. Lott points out, you can have a object that looks like a generator, and acts like a generator.", "And if it looks like a duck, and acts like a duck, you've got yourself the very definition of duck typing, right there."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "looks", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "acts", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["It won't support generator attributes like gi_frame without the appropriate proxy methods, however."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "gi_frame", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you want to interrogate them for debugging purposes, then the following function will help:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import inspect\n\ndef inspect_generator(g):\n    sourcecode = open(g.gi_code.co_filename).readlines()\n    gline = g.gi_code.co_firstlineno\n    generator_code = inspect.getblock(sourcecode[gline-1:])\n\n    output = \"Generator %r from %r\\n\" % (g.gi_code.co_name, g.gi_code.co_filename)\n    output += \"\".join(\"%4s: %s\" % (idx+gline, line) for idx, line in enumerate(generator_code))\n\n    output += \"Local variables:\\n\"\n    output += \"\".join(\"%s = %r\\n\" % (key,value) for key,value in g.gi_frame.f_locals.items())\n\n    return output\n\nprint inspect_generator(filter(6))\n\"\"\"Output:\nGenerator 'filter' from 'generator_introspection.py'\n   1: def filter(x):\n   2:     for line in myContent:\n   3:         if line == x:\n   4:             yield x\nLocal variables:\nx = 6\n\"\"\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to interrogate them to implement functionality then classes implementing the iterator protocol are probably a better idea."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I just wrote a decorator to do this here:\nhttp://code.activestate.com/recipes/577057-generator-attributes/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/577057-generator-attributes/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/577057-generator-attributes/"}]}], [{"text": ["Thinking about the problem, there is a way of having generators carry around a set of attributes.", "It's a little crazy--I'd strongly recommend Alex Martelli's suggestion instead of this--but it might be useful in some situations."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n my_content = ['cat', 'dog days', 'catfish', 'dog', 'catalog']\n\ndef filter(x):\n    _query = 'I\\'m looking for %r' % x\n\n    def _filter():\n        query = yield None\n        for line in my_content:\n            while query:\n                query = yield _query\n\n            if line.startswith(x):\n                query = yield line\n\n        while query:\n            query = yield _query\n\n    _f = _filter()\n    _f.next()\n    return _f\n\nfor d in filter('dog'):\n    print 'Found %s' % d\n\ncats = filter('cat')\nfor c in cats:\n    looking = cats.send(True)\n    print 'Found %s (filter %r)' % (c, looking)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to ask the generator what it's filtering on, just call send with a value that evaluates to true.", "Of course, this code is probably too clever by half.", "Use with caution."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "send", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]