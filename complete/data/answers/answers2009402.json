[[{"text": ["To expand on Ignacio's answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def counter():\n    count = 0\n    def c():\n        nonlocal count\n        count += 1\n        return count\n    return c\n\nx = counter()\nprint([x(),x(),x()])\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives [1,2,3] in Python 3; invocations of counter() give independent counters.", "Other solutions - especially using itertools/yield are more idiomatic."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "counter()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You could do this and it would work more or less the same way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class counter(object):\n    def __init__(self, count=0):\n        self.count = count\n    def __call__(self):\n        self.count += 1\n        return self.count\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or, a bit of a hack:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def counter():\n    count = [0]\n    def incr(n):\n        n[0] += 1\n        return n[0]\n    return lambda: incr(count)\n</code>\n</pre>\n", "senID": 3}, {"text": ["I'd go with the first solution."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["EDIT: That's what I get for not reading the big blog of text."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Anyway, the reason Python closures are rather limited is \"because Guido felt like it.", "\" Python was designed in the early 90s, in the heyday of OO.", "Closures were rather low on the list of language features people wanted.", "As functional ideas like first class functions, closures, and other things make their way into mainstream popularity, languages like Python have had to tack them on, so their use may a bit awkward, because that's not what the language was designed for."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["&lt;rant on=\"Python scoping\"&gt;"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "&lt;rant on=\"Python scoping\"&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Also, Python (2.x) has rather odd (in my opinion) ideas about scoping that interferes with a sane implementation of closures, among other things.", "It always bothers me that this:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n new = [x for x in old]\n</code>\n</pre>\n", "senID": 9}, {"text": ["Leaves us with the name x defined in the scope we used it in, as it is (in my opinion) a conceptually smaller scope.", "(Though Python gets points for consistency, as doing the same thing with a for loop has the same behavior.", "The only way to avoid this is to use map."], "childNum": 3, "tag": "p", "senID": 10, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Anyway, &lt;/rant&gt;"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "&lt;/rant&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["nonlocal in 3.x should remedy this."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I would use a generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def counter():\n    count = 0\n    while True:\n        count += 1\n        yield(count)\n\n&gt;&gt;&gt; c = counter()\n&gt;&gt;&gt; c.next()\n1\n&gt;&gt;&gt; c.next()\n2\n&gt;&gt;&gt; c.next()\n3\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: I believe the ultimate answer to your question is PEP-3104:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://www.python.org/dev/peps/pep-3104/", "text": "PEP-3104", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Functions can also have attributes, so this would work, too:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def counter():\n    def c():\n        while True:\n            yield c.count\n            c.count += 1\n    c.count = 0\n    return c\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, in this specific example, I'd use a generator as suggested by jbochi."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As for why, I can't say for sure, but I imagine it's not an explicit design choice, but rather a remnant of Python's sometimes-odd scoping rules (and especially the somewhat-odd evolution of its scoping rules)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "why", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["This behavior is quite thoroughly explained the official Python tutorial as well as in the Python execution model.", "In particular, from the tutorial:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Python tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#python-scopes-and-namespaces"}, {"text": "Python execution model", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/executionmodel.html"}]}, {"text": ["However, this does not say anything about why it behaves in this way."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "why", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Some more information comes from PEP 3104, that tries to tackle this situation for Python 3.0.", "There, you can see that it is this way because at a certain point in time, it was seen as the best solution instead of introducing classic static nested scopes (see Re: Scoping (was Re: Lambda binding solved?", "))."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "PEP 3104", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ftp.python.org/dev/peps/pep-3104/"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "Re: Scoping (was Re: Lambda binding solved?)", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.python.org/search/hypermail/python-1994q1/0313.html"}]}, {"text": ["That said, I have also my own interpretation.", "Python implements namespaces as dictionaries; when a lookup for a variable fails in the inner, then it tries in the outer and so on, until it reaches the builtins.", "However, binding a variable is a completely different stuff, because you need to specify a particular namespace - that it is always the innermost one (unless you set the \"global\" flag, that means it is always the global namespace).", "Eventually, the different algorithms used for looking up and binding variables are the reason for closures to be read-only in Python.", "But, again, this is just my speculation :-)"], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "lookup", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "binding", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 4, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}], [{"text": ["It is not that they are read-only, as much as the scope is more strict that you realize.", "If you can't nonlocal in Python 3+, then you can at least use explicit scoping.", "Python 2.6.1, with explicit scoping at the module level:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def counter():\n...     sys.modules[__name__].count = 0\n...     def c():\n...         sys.modules[__name__].count += 1\n...         return sys.modules[__name__].count\n...     sys.modules[__name__].c = c\n...     \n&gt;&gt;&gt; counter()\n&gt;&gt;&gt; c()\n1\n&gt;&gt;&gt; c()\n2\n&gt;&gt;&gt; c()\n3\n</code>\n</pre>\n", "senID": 1}, {"text": ["A little more work is required to have a more restricted scope for the count variable, instead of using a pseudo-global module variable (still Python 2.6.1):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def counter():\n...     class c():\n...         def __init__(self):\n...             self.count = 0\n...     cinstance = c()\n...     def iter():\n...         cinstance.count += 1\n...         return cinstance.count\n...     return iter\n... \n&gt;&gt;&gt; c = counter()\n&gt;&gt;&gt; c()\n1\n&gt;&gt;&gt; c()\n2\n&gt;&gt;&gt; c()\n3\n&gt;&gt;&gt; d = counter()\n&gt;&gt;&gt; d()\n1\n&gt;&gt;&gt; c()\n4\n&gt;&gt;&gt; d()\n2\n</code>\n</pre>\n", "senID": 3}]]