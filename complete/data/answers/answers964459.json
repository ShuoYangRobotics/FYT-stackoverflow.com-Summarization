[[{"text": ["You can use BeautifulSoup with this (and other) methods:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "BeautifulSoup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}]}, {"code": "<pre>\n<code>\n soup = BeautifulSoup(source.lower())\nto_extract = soup.findAll('script')\nfor item in to_extract:\n    item.extract()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This actually removes the nodes from the HTML.", "If you wanted to leave the empty &lt;script&gt;&lt;/script&gt; tags you'll have to work with the item attributes rather than just extracting it from the soup."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "&lt;script&gt;&lt;/script&gt;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "item", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Are you trying to prevent XSS?", "Just eliminating the &lt;script&gt; tags will not solve all possible attacks!", "Here's a great list of the many ways (some of them very creative) that you could be vulnerable http://ha.ckers.org/xss.html.", "After reading this page you should understand why just elimintating the &lt;script&gt; tags using a regular expression is not robust enough.", "The python library lxml has a function that will robustly clean your HTML to make it safe to display."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "XSS", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Cross-site%5Fscripting"}, {"text": "&lt;script&gt;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "http://ha.ckers.org/xss.html", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://ha.ckers.org/xss.html"}, {"text": "&lt;script&gt;", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "lxml", "tag": "a", "pos": 4, "childList": [], "childNum": 0, "href": "http://codespeak.net/lxml/lxmlhtml.html#cleaning-up-html"}]}, {"text": ["If you are sure that you just want to eliminate the &lt;script&gt; tags this code in lxml should work:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "If", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "&lt;script&gt;", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from lxml.html import parse\n\nroot = parse(filename_or_url).getroot()\nfor element in root.iter(\"script\"):\n    element.drop_tree()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note: I downvoted all the solutions using regular expresions.", "See here why you shouldn't parse HTML using regular expressions: http://stackoverflow.com/questions/590747/using-regular-expressions-to-parse-html-why-not"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "http://stackoverflow.com/questions/590747/using-regular-expressions-to-parse-html-why-not", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/590747/using-regular-expressions-to-parse-html-why-not"}]}, {"text": ["Note 2: Another SO question showing HTML that is impossible to parse with regular expressions: http://stackoverflow.com/questions/701166/can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-rege"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Note 2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/701166/can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-rege", "text": "http://stackoverflow.com/questions/701166/can-you-provide-some-examples-of-why-it-is-hard-to-parse-xml-and-html-with-a-rege", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I don't know Python good enough to tell you a solution.", "But if you want to use that to sanitize the user input you have to be very, very careful.", "Removing stuff between  and  just doesn't catch everything.", "Maybe you can have a look at existing solutions (I assume Django includes something like this)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you're removing everything between &lt;script&gt; and &lt;/script&gt; why not just remove the entire node? "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "&lt;script&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&lt;/script&gt;", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Are you expecting a resig-style src and body?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Element Tree is the best simplest and sweetest package to do this.", "Yes, there are other ways to do it too; but don't use any 'coz they suck!", "(via Mark Pilgrim)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Element Tree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython3.org/xml.html"}]}], [{"text": ["You can do this with the HTMLParser module (complicated) or use regular expressions:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "HTMLParser", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/htmlparser.html"}]}, {"code": "<pre>\n<code>\n import re\ncontent = \"asdf &lt;script&gt; bla &lt;/script&gt; end\"\nx=re.search(\"&lt;script&gt;.*?&lt;/script&gt;\", content, re.DOTALL)\nspan = x.span() # gives (5, 27)\n\nstripped_content = content[:span[0]] + content[span[1]:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: re.DOTALL, thanks to tgray"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n example_text = \"This is some text &lt;script&gt; blah blah blah &lt;/script&gt; this is some more text.\"\n\nimport re\nmyre = re.compile(\"(^.*)&lt;script&gt;(.*)&lt;/script&gt;(.*$)\")\nresult = myre.match(example_text)\nresult.groups()\n  &lt;52&gt; ('This is some text ', ' blah blah blah ', ' this is some more text.')\n\n# Text between &lt;script&gt; .. &lt;/script&gt;\nresult.group(2)\n  &lt;56&gt; 'blah blah blah'\n\n# Text outside of &lt;script&gt; .. &lt;/script&gt;\nresult.group(1)+result.group(3)\n  &lt;57&gt; 'This is some text  this is some more text.'\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If you don't want to import any modules:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n string = \"&lt;script&gt; this is some js. begone! &lt;/script&gt;\"\n\nstring = string.split(' ')\n\nfor i, s in enumerate(string):\n    if s == '&lt;script&gt;' or s == '&lt;/script&gt;' :\n    \tdel string[i]\n\nprint ' '.join(string)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["According to answers posted by Pev and wr, why not to upgrade a regular expression, e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n pattern = r\"(?is)&lt;script[^&gt;]*&gt;(.*?)&lt;/script&gt;\"\ntext = \"\"\"&lt;script&gt;foo bar  \nbaz bar foo  &lt;/script&gt;\"\"\"\nre.sub(pattern, '', text)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(?is) - added to ignore case and allow new lines in text.", "This version should also support script tags with attributes."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: I can't add any comments yet, so I'm just editing my answer.", "I totally agree with the comment below, regexps are totally wrong for such tasks and b. soup ot lxml are a lot better.", "But question asked gave just a simple example and regexps should be enough for such simple task.", "Using Beautiful Soup for a simple text removing could just be too much (overload?", "I don't how to express what I mean, excuse my english)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["BTW I made a mistake, the code should look like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n pattern = r\"(?is)(&lt;script[^&gt;]*&gt;)(.*?)(&lt;/script&gt;)\"\ntext = \"\"\"&lt;script&gt;foo bar  \nbaz bar foo  &lt;/script&gt;\"\"\"\nre.sub(pattern, '\\1\\3', text)\n</code>\n</pre>\n", "senID": 5}]]