[[{"text": ["Python tries to discourage you from \"summing\" strings.", "You're supposed to join them:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"\".join(list_of_strings)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's a lot faster, and uses much less memory."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A quick benchmark:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n $ python -m timeit -s 'import operator; strings = [\"a\"]*10000' 'r = reduce(operator.add, strings)'\n100 loops, best of 3: 8.46 msec per loop\n$ python -m timeit -s 'import operator; strings = [\"a\"]*10000' 'r = \"\".join(strings)'\n1000 loops, best of 3: 296 usec per loop\n</code>\n</pre>\n", "senID": 4}, {"text": ["Edit (to answer OP's edit): As to why strings were apparently \"singled out\", I believe it's simply a matter of optimizing for a common case, as well as of enforcing best practice: you can join strings much faster with ''.join, so explicitly forbidding strings on sum will point this out to newbies."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["BTW, this restriction has been in place \"forever\", i.e., since the sum was added as a built-in function (rev.", "32347)"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "rev. 32347", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Python/bltinmodule.c?revision=32347&view=markup&pathrev=32347"}]}], [{"text": ["From the docs:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#sum"}]}, {"text": ["By making sum refuse to operate on strings, Python has encouraged you to use the correct method."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can in fact use sum(..) to concatenate strings, if you use the appropriate starting object!", "Of course, if you go this far you have already understood enough to use \"\".join(..) anyway.."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sum(..)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"\".join(..)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class ZeroObject(object):\n...  def __add__(self, other):\n...   return other\n...\n&gt;&gt;&gt; sum([\"hi\", \"there\"], ZeroObject())\n'hithere'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Edit: Moved the parts about immutability to history."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Basically, its a question of preallocation.", "When you use a statement such as "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n sum([\"a\", \"b\", \"c\", ..., ])\n</code>\n</pre>\n", "senID": 2}, {"text": ["and expect it to work similar to a reduce statement, the code generated looks something like"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n v1 = \"\" + \"a\" # must allocate v1 and set its size to len(\"\") + len(\"a\")\nv2 = v1 + \"b\" # must allocate v2 and set its size to len(\"a\") + len(\"b\")\n...\nres = v10000 + \"$\" # must allocate res and set its size to len(v9999) + len(\"$\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["In each of these steps a new string is created, which for one might give some copying overhead as the strings are getting longer and longer.", "But that\u2019s maybe not the point here.", "What\u2019s more important, is that every new string on each line must be allocated to it\u2019s specific size (which.", "I don\u2019t know it it must allocate in every iteration of the reduce statement, there might be some obvious heuristics to use and Python might allocate a bit more here and there for reuse \u2013 but at several points the new string will be large enough that this won\u2019t help anymore and Python must allocate again, which is rather expensive."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "allocated", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "reduce", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["A dedicated method like join, however has the job to figure out the real size of the string before it starts and would therefore in theory only allocate once, at the beginning and then just fill that new string, which is much cheaper than the other solution."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "join", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here's the source: http://svn.python.org/view/python/trunk/Python/bltinmodule.c?revision=81029&amp;view=markup"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://svn.python.org/view/python/trunk/Python/bltinmodule.c?revision=81029&amp;view=markup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Python/bltinmodule.c?revision=81029&view=markup"}]}, {"text": ["In the builtin_sum function we have this bit of code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n /* reject string values for 'start' parameter */\n        if (PyObject_TypeCheck(result, &amp;PyBaseString_Type)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"sum() can't sum strings [use ''.join(seq) instead]\");\n            Py_DECREF(iter);\n            return NULL;\n        }\n        Py_INCREF(result);\n    }\n</code>\n</pre>\n", "senID": 2}, {"text": ["So.. that's your answer."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It's explicitly checked in the code and rejected."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Short answer: Efficiency."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Long answer: The sum function has to create an object for each partial sum."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Assume that the amount of time required to create an object is directly proportional to the size of its data.", "Let N denote the number of elements in the sequence to sum."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["doubles are always the same size, which makes sum's running time O(1)\u00d7N = O(N)."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "double", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "childList": []}, {"text": "O(N)", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["int (formerly known as long) is arbitary-length.", "Let M denote the absolute value of the largest sequence element.", "Then sum's worst-case running time is lg(M) + lg(2M) + lg(3M) + ... + lg(NM) = N\u00d7lg(M) + lg(N!", ") = O(N log N)."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "long", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "O(N log N)", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["For str (where M = the length of the longest string), the worst-case running time is M + 2M + 3M + ... + NM = M\u00d7(1 + 2 + ... + N) = O(N\u00b2)."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(N\u00b2)", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Thus, summing strings would be much slower than summing numbers."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["str.join does not allocate any intermediate objects.", "It preallocates a buffer large enough to hold the joined strings, and copies the string data.", "It runs in O(N) time, much faster than sum."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "str.join", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(N)", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "childList": []}]}]]