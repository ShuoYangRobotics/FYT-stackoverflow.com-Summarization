[[{"text": ["The real speed increase would be gained by moving to numpy or scipy.", "Short of that, there are microoptimizations: e.g.", "x*x is faster than pow(x,2); you could extract the values at the same time as the keys by doing, instead of:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "x*x", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "pow(x,2)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n si = [val for val in v1 if val in v2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["something like"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n vs = [ (v1[val],v2[val]) for val in v1 if val in v2]\n</code>\n</pre>\n", "senID": 3}, {"text": ["and then"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n sum1 = sum(x for x, y in vs)\n</code>\n</pre>\n", "senID": 5}, {"text": ["and so on; whether each of these brings time advantage needs microbenchmarking.", "Depending on how you're using these coefficients returning the square would save you a sqrt (that's a similar idea to using squares of distances between points, in geometry, rather than the distances themselves, and for the same reason -- saves you a sqrt; which makes sense because the coefficient IS a distance, kinda...;-)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["If you can use scipy, you could use the pearson function: http://www.scipy.org/doc/api%5Fdocs/SciPy.stats.stats.html#pearsonr"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.scipy.org/doc/api%5Fdocs/SciPy.stats.stats.html#pearsonr", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scipy.org/doc/api%5Fdocs/SciPy.stats.stats.html#pearsonr"}]}, {"text": ["Or you could copy/paste the code (it has a liberal license) from http://svn.scipy.org/svn/scipy/trunk/scipy/stats/stats.py (search for def pearson()).", "In the code np is just numpy (the code does import numpy as np)."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "http://svn.scipy.org/svn/scipy/trunk/scipy/stats/stats.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.scipy.org/svn/scipy/trunk/scipy/stats/stats.py"}, {"text": "def pearson()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "np", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "import numpy as np", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I'd suggest changing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [val for val in v1 if val in v2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n set(v1) &amp; set(v2)\n</code>\n</pre>\n", "senID": 3}, {"text": ["do"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if not n: return 0.0    # and similar for den\n</code>\n</pre>\n", "senID": 5}, {"text": ["instead of"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n if n == 0: return 0.0\n</code>\n</pre>\n", "senID": 7}, {"text": ["and it's worth replacing last 6 lines with:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n try:\n    return num / sqrt(abs(temp))\nexcept ZeroDivisionError:\n    return 1.0\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Since it looks like you're doing quite a bit of numeric computation you should give Psyco a shot.", "It's a JIT compiler that analyzes running code and optimizes certain operations.", "Install it, then at the top of your file put:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Psyco", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "Psyco", "tag": "a"}]}, {"text": "Psyco", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://psyco.sourceforge.net/"}]}, {"code": "<pre>\n<code>\n try:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will enable Psyco's JIT and should speed up your code somewhat, for free :) (actually not, it takes up more memory)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Scipy is the fastest!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I have don some tests with the code above and also with a version I found on my comp, see below for results and the code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\npearson 14.7597990757\nsim_pearson 15.6806837987\nscipy:pearsonr 0.451986019188\n</pre>\n", "senID": 2}, {"code": "<pre>\ntry:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\nfrom math import sqrt\n\ndef sim_pearson(set1, set2):\n    si={}\n    for item in set1:\n        if item in set2:\n            si[item] = 1\n\n    #number of elements\n    n = len(si)\n\n    #if none common, return 0 similarity\n    if n == 0: return 0\n\n    #add up all the preferences\n    sum1 = sum([set1[item] for item in si])\n    sum2 = sum([set2[item] for item in si])\n\n    #sum up the squares\n    sum_sq1 = sum([pow(set1[item], 2) for item in si])\n    sum_sq2 = sum([pow(set2[item], 2) for item in si])\n\n    #sum up the products\n    sum_p = sum([set1[item] * set2[item] for item in si])\n\n    nom = sum_p - ((sum1 * sum2) / n )\n    den = sqrt( (sum_sq1 - (sum1)**2 / n) * (sum_sq2 - (sum2)**2 / n) )\n\n    if den==0: return 0\n    return nom/den\n\n\n\n# from http://stackoverflow.com/questions/1307016/pearson-similarity-score-how-can-i-optimise-this-further\ndef pearson(v1, v2):\n    vs = [(v1[val],v2[val]) for val in v1 if val in v2]\n\n    n = len(vs)\n\n    if n==0: return 0.0\n\n    sum1,sum2,sum1_sq,sum2_sq,p_sum = 0.0, 0.0, 0.0, 0.0, 0.0\n\n    for v1,v2 in vs:\n        sum1+=v1\n        sum2+=v2\n        sum1_sq+=v1*v1\n        sum2_sq+=v2*v2\n        p_sum+=v1*v2\n\n    # Calculate Pearson score\n    num = p_sum-(sum1*sum2/n)\n    temp = max((sum1_sq-pow(sum1,2)/n) * (sum2_sq-pow(sum2,2)/n),0)\n    if temp:\n        return num / sqrt(temp)\n    return 1.0\n\n\n\n\n\n\nif __name__ == \"__main__\":\n    import timeit\n\n    tsetup = \"\"\"\nfrom random import randrange\nfrom __main__ import pearson, sim_pearson\nfrom scipy.stats import pearsonr\nv1 = [randrange(0,1000) for x in range(1000)]\nv2 = [randrange(0,1000) for x in range(1000)]\n#gc.enable()\n\"\"\"\n    t1 = timeit.Timer(stmt=\"pearson(v1,v2)\", setup=tsetup)\n    t2 = timeit.Timer(stmt=\"sim_pearson(v1,v2)\", setup=tsetup)\n    t3 = timeit.Timer(stmt=\"pearsonr(v1,v2)\", setup=tsetup)\n\n    tt = 1000\n\n    print 'pearson', t1.timeit(tt)\n    print 'sim_pearson', t2.timeit(tt)\n    print 'scipy:pearsonr', t3.timeit(tt)\n</pre>\n", "senID": 3}], [{"text": ["If the inputs to any of your math functions are fairly constrained, you can use a lookup table instead of the math function.", "This can earn you some performance (speed) at the cost of extra memory to store the table."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I'm not sure if this holds in Python.", "But calculating the sqrt is a processor intensive calculation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You might go for a fast approximation newton"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "newton", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Methods%5Fof%5Fcomputing%5Fsquare%5Froots"}]}], [{"text": ["I'll post what I've got so far as an answer to differentiate it from the question.", "This is a combination of some techniques described above that seem to have given the best improvement s far."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def pearson(v1,v2):\n    vs = [(v1[val],v2[val]) for val in v1 if val in v2]\n\n    n = len(vs)\n\n    if n==0: return 0.0\n\n    sum1,sum2,sum1_sq,sum2_sq,p_sum = 0.0, 0.0, 0.0, 0.0, 0.0\n\n    for v1,v2 in vs:\n        sum1+=v1\n        sum2+=v2\n        sum1_sq+=v1*v1\n        sum2_sq+=v2*v2\n        p_sum+=v1*v2\n\n    # Calculate Pearson score\n    num = p_sum-(sum1*sum2/n)\n    temp = max((sum1_sq-pow(sum1,2)/n) * (sum2_sq-pow(sum2,2)/n),0)\n    if temp:\n        return num / sqrt(temp)\n    return 1.0\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: It looks like psyco gives a 15% improvment for this version which isn't massive but is enough to justify its use."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]