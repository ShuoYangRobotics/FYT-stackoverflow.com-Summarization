[[{"text": ["From: http://mail.python.org/pipermail/tutor/2008-April/061426.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://mail.python.org/pipermail/tutor/2008-April/061426.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/tutor/2008-April/061426.html"}]}, {"text": ["You should consider that what you are trying to do is usually done with a Factory and that's the best way to do it.", "Using __new__ is not a good clean solution so please consider the usage of a factory.", "Here you have a good factory example."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "Factory", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Factory%5Fobject"}, {"text": "__new__", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "a good factory example", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/86900/"}]}], [{"text": ["__new__ is static class method, while __init__ is instance method.", "__new__ has to create the instance first, so __init__ can initialize it.", "Note that __init__ takes self as parameter.", "Until you create instance there is no self."], "childNum": 14, "tag": "p", "senID": 0, "childList": [{"text": "__new__", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "__new__", "tag": "code"}]}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__init__", "childNum": 1, "tag": "strong", "pos": 2, "childList": [{"text": "__init__", "tag": "code"}]}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__new__", "childNum": 1, "tag": "strong", "pos": -1, "childList": [{"text": "__new__", "tag": "code"}]}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__init__", "childNum": 1, "tag": "strong", "pos": -1, "childList": [{"text": "__init__", "tag": "code"}]}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__init__", "childNum": 1, "tag": "strong", "pos": -1, "childList": [{"text": "__init__", "tag": "code"}]}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "self", "childNum": 1, "tag": "strong", "pos": 3, "childList": [{"text": "self", "tag": "code"}]}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}, {"text": "self", "childNum": 1, "tag": "strong", "childList": [{"text": "self", "tag": "code"}]}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Now, I gather, that you're trying to implement singleton pattern in Python.", "There are a few ways to do that."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "singleton pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Singleton_pattern"}]}, {"text": ["Also, as of Python 2.6, you can use class decorators. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "decorators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0318/"}]}, {"code": "<pre>\n<code>\n def singleton(cls):\n    instances = {}\n    def getinstance():\n        if cls not in instances:\n            instances[cls] = cls()\n        return instances[cls]\n    return getinstance\n\n@singleton\nclass MyClass:\n  ...\n</code>\n</pre>\n", "senID": 3}], [{"text": ["To quote the documentation:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.wingide.com/psupport/python-manual/2.4/ref/customization.html"}]}, {"text": ["\"Typical implementations create a new instance of the class by invoking the superclass's __new__() method using \"super(currentclass, cls).__new__(cls[, ...])\"with appropriate arguments and then modifying the newly-created instance as necessary before returning it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["\"If __new__() does not return an instance of cls, then the new instance's __init__() method will not be invoked."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["__new__() is intended mainly to allow subclasses of immutable types (like int, str, or tuple) to customize instance creation."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["__new__ should return a new, blank instance of a class.", "__init__ is then called to initialise that instance.", "You're not calling __init__ in the \"NEW\" case of __new__, so it's being called for you.", "The code that is calling __new__ doesn't keep track of whether __init__ has been called on a particular instance or not nor should it, because you're doing something very unusual here."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__new__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You could add an attribute to the object in the __init__ function to indicate that it's been initialised.", "Check for the existence of that attribute as the first thing in __init__ and don't proceed any further if it has been."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["In most well-known OO languages, an expression like SomeClass(arg1, arg2) will allocate a new instance, initialise the instance's attributes, and then return it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "SomeClass(arg1, arg2)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In most well-known OO languages, the \"initialise the instance's attributes\" part can be customised for each class by defining a constructor, which is basically just a block of code that operates on the new instance (using the arguments provided to the constructor expression) to set up whatever initial conditions are desired.", "In Python, this corresponds to the class' __init__ method."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "constructor", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Python's __new__ is nothing more and nothing less than similar per-class customisation of the \"allocate a new instance\" part.", "This of course allows you to do unusual things such as returning an existing instance rather than allocating a new one.", "So in Python, we shouldn't really think of this part as necessarily involving allocation; all that we require is that __new__ comes up with a suitable instance from somewhere."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__new__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["But it's still only half of the job, and there's no way for the Python system to know that sometimes you want to run the other half of the job (__init__) afterwards and sometimes you don't.", "If you want that behavior, you have to say so explicitly."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Often, you can refactor so you only need __new__, or so you don't need __new__, or so that __init__ behaves differently on an already-initialised object.", "But if you really want to, Python does actually allow you to redefine \"the job\", so that SomeClass(arg1, arg2) doesn't necessarily call __new__ followed by __init__.", "To do this, you need to create a metaclass, and define its __call__ method."], "childNum": 7, "tag": "p", "senID": 4, "childList": [{"text": "__new__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "SomeClass(arg1, arg2)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__call__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["A metaclass is just the class of a class.", "And a class' __call__ method controls what happens when you call instances of the class.", "So a metaclass' __call__ method controls what happens when you call a class; i.e.", "it allows you to redefine the instance-creation mechanism from start to finish.", "This is the level at which you can most elegantly implement a completely non-standard instance creation process such as the singleton pattern.", "In fact, with less than 10 lines of code you can implement a Singleton metaclass that then doesn't even require you to futz with __new__ at all, and can turn any otherwise-normal class into a singleton by simply adding __metaclass__ = Singleton!"], "childNum": 9, "tag": "p", "senID": 5, "childList": [{"text": "__call__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "metaclass", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "__call__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "redefine the instance-creation mechanism from start to finish", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}, {"text": "Singleton", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "childList": []}, {"text": "at all", "childNum": 0, "tag": "strong", "childList": []}, {"text": "any", "childNum": 0, "tag": "em", "childList": []}, {"text": "__metaclass__ = Singleton", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class Singleton(type):\n    def __init__(self, *args, **kwargs):\n        super(Singleton, self).__init__(*args, **kwargs)\n        self.__instance = None\n    def __call__(self, *args, **kwargs):\n        if self.__instance is None:\n            self.__instance = super(Singleton, self).__call__(*args, **kwargs)\n        return self.__instance\n</code>\n</pre>\n", "senID": 6}, {"text": ["However this is probably deeper magic than is really warranted for this situation!"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Not much of a reason other than that it just is done that way.", "__new__ doesn't have the responsibility of initializing the class, some other method does (__call__, possibly-- I don't know for sure)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__new__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__call__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You could have __init__ do nothing if it's already been initialized, or you could write a new metaclass with a new __call__ that only calls __init__ on new instances, and otherwise just returns __new__(...)."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__call__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__new__(...)", "childNum": 0, "tag": "code", "childList": []}]}]]