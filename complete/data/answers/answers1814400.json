[[{"text": ["This works for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # get all the items\nmatches = re.findall(r'\\w+=\".+?\"', s) + re.findall(r'\\w+=[\\d.]+',s)\n\n# partition each match at '='\nmatches = [m.group().split('=', 1) for m in matches]\n\n# use results to make a dict\nd = dict(matches)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Edit: since the csv module doesn't deal as desired with quotes inside fields, it takes a bit more work to implement this functionality:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "csv", "childNum": 0, "tag": "code", "childList": []}, {"text": "inside", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n import re\nquoted = re.compile(r'\"[^\"]*\"')\n\nclass QuoteSaver(object):\n\n  def __init__(self):\n    self.saver = dict()\n    self.reverser = dict()\n\n  def preserve(self, mo):\n    s = mo.group()\n    if s not in self.saver:\n      self.saver[s] = '\"%d\"' % len(self.saver)\n      self.reverser[self.saver[s]] = s\n    return self.saver[s]\n\n  def expand(self, mo):\n    return self.reverser[mo.group()]\n\nx = 'name=\"John Smith\", age=34, height=173.2, location=\"US\", avatar=\":,=)\"'\n\nqs = QuoteSaver()\ny = quoted.sub(qs.preserve, x)\nkvs_strings = y.split(',')\nkvs_pairs = [kv.split('=') for kv in kvs_strings]\nkvs_restored = [(k, quoted.sub(qs.expand, v)) for k, v in kvs_pairs]\n\ndef converter(v):\n  if v.startswith('\"'): return v.strip('\"')\n  try: return int(v)\n  except ValueError: return float(v)\n\nthedict = dict((k.strip(), converter(v)) for k, v in kvs_restored)\nfor k in thedict:\n  print \"%-8s %s\" % (k, thedict[k])\nprint thedict\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm emitting thedict twice to show exactly how and why it differs from the required result; the output is:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "thedict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n age      34\nlocation US\nname     John Smith\navatar   :,=)\nheight   173.2\n{'age': 34, 'location': 'US', 'name': 'John Smith', 'avatar': ':,=)',\n 'height': 173.19999999999999}\n</code>\n</pre>\n", "senID": 3}, {"text": ["As you see, the output for the floating point value is as requested when directly emitted with print, but it isn't and cannot be (since there IS no floating point value that would display 173.2 in such a case!-) when the print is applied to the whole dict (because that inevitably uses repr on the keys and values -- and the repr of 173.2 has that form, given the usual issues about how floating point values are stored in binary, not in decimal, etc, etc).", "You might define a dict subclass which overrides __str__ to specialcase floating-point values, I guess, if that's indeed a requirement."], "childNum": 11, "tag": "p", "senID": 4, "childList": [{"text": "print", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cannot", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "IS", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "173.2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "print", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "repr", "childNum": 0, "tag": "code", "childList": []}, {"text": "repr", "childNum": 0, "tag": "code", "childList": []}, {"text": "173.2", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "__str__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["But, I hope this distraction doesn't interfere with the core idea -- as long as the doublequotes are properly balanced (and there are no doublequotes-inside-doublequotes), this code does perform the required task of preserving \"special characters\" (commas and equal signs, in this case) from being taken in their normal sense when they're inside double quotes, even if the double quotes start inside a \"field\" rather than at the beginning of the field (csv only deals with the latter condition).", "Insert a few intermediate prints if the way the code works is not obvious -- first it changes all \"double quoted fields\" into a specially simple form (\"0\", \"1\" and so on), while separately recording what the actual contents corresponding to those simple forms are; at the end, the simple forms are changed back into the original contents.", "Double-quote stripping (for strings) and transformation of the unquoted strings into integers or floats is finally handled by the simple converter function."], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "inside", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "csv", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\"0\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\"1\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "converter", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Here is a more verbose approach to the problem using pyparsing.", "Note the parse actions\nwhich do the automatic conversion of types from strings to ints or floats.", "Also, the\nQuotedString class implicitly strips the quotation marks from the quoted value.", "Finally,\nthe Dict class takes each 'key = val' group in the comma-delimited list, and assigns \nresults names using the key and value tokens."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from pyparsing import *\n\nkey = Word(alphas)\nEQ = Suppress('=')\nreal = Regex(r'[+-]?\\d+\\.\\d+').setParseAction(lambda t:float(t[0]))\ninteger = Regex(r'[+-]?\\d+').setParseAction(lambda t:int(t[0]))\nqs = QuotedString('\"')\nvalue = real | integer | qs\n\ndictstring = Dict(delimitedList(Group(key + EQ + value)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now to parse your original text string, storing the results in dd.", "Pyparsing returns an \nobject of type ParseResults, but this class has many dict-like features (support for keys(), \nitems(), in, etc.", "), or can emit a true Python dict by calling asDict().", "Calling dump() \nshows all of the tokens in the original parsed list, plus all of the named items.", "The last\ntwo examples show how to access named items within a ParseResults as if they were attributes of\na Python object."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n text = 'name=\"John Smith\", age=34, height=173.2, location=\"US\", avatar=\":,=)\"'\ndd = dictstring.parseString(text)\nprint dd.keys()\nprint dd.items()\nprint dd.dump()\nprint dd.asDict()\nprint dd.name\nprint dd.avatar\n</code>\n</pre>\n", "senID": 3}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n ['age', 'location', 'name', 'avatar', 'height']\n[('age', 34), ('location', 'US'), ('name', 'John Smith'), ('avatar', ':,=)'), ('height', 173.19999999999999)]\n[['name', 'John Smith'], ['age', 34], ['height', 173.19999999999999], ['location', 'US'], ['avatar', ':,=)']]\n- age: 34\n- avatar: :,=)\n- height: 173.2\n- location: US\n- name: John Smith\n{'age': 34, 'height': 173.19999999999999, 'location': 'US', 'avatar': ':,=)', 'name': 'John Smith'}\nJohn Smith\n:,=)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The following code produces the correct behavior, but is just a bit long!", "I've added a space in the avatar to show that it deals well with commas and spaces and equal signs inside the string.", "Any suggestions to shorten it?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import hashlib\n\nstring = 'name=\"John Smith\", age=34, height=173.2, location=\"US\", avatar=\":, =)\"'\n\nstrings = {}\n\ndef simplify(value):\n    try:\n        return int(value)\n    except:\n        return float(value)\n\nwhile True:\n    try:\n        p1 = string.index('\"')\n        p2 = string.index('\"',p1+1)\n        substring = string[p1+1:p2]\n        key = hashlib.md5(substring).hexdigest()\n        strings[key] = substring\n        string = string[:p1] + key + string[p2+1:]\n    except:\n        break\n\nd = {}    \nfor pair in string.split(', '):\n    key, value = pair.split('=')\n    if value in strings:\n        d[key] = strings[value]\n    else:\n        d[key] = simplify(value)\n\nprint d\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is a approach with eval, I considered it is as unreliable though, but its works for your example."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt;\n&gt;&gt;&gt; s='name=\"John Smith\", age=34, height=173.2, location=\"US\", avatar=\":,=)\"'\n&gt;&gt;&gt;\n&gt;&gt;&gt; eval(\"{\"+re.sub('(\\w+)=(\"[^\"]+\"|[\\d.]+)','\"\\\\1\":\\\\2',s)+\"}\")\n{'age': 34, 'location': 'US', 'name': 'John Smith', 'avatar': ':,=)', 'height': 173.19999999999999}\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Better use the one pointed by Chris Lutz in the comment, I believe Its more reliable, because even there is (single/double) quotes in dict values, it might works."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I think you just need to set maxsplit=1, for instance the following should work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n string = 'name=\"John Smith\", age=34, height=173.2, location=\"US\", avatar=\":, =)\"'\nnewDict = dict(map( lambda(z): z.split(\"=\",1), string.split(\", \") ))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit (see comment): "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I didn't notice that \", \" was a value under avatar, the best approach would be to escape \", \" wherever you are generating data.", "Even better would be something like JSON ;).", "However, as an alternative to regexp, you could try using shlex, which I think produces cleaner looking code. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import shlex\n\nstring = 'name=\"John Smith\", age=34, height=173.2, location=\"US\", avatar=\":, =)\"'\nlex = shlex.shlex ( string ) \nlex.whitespace += \",\" # Default whitespace doesn't include commas\nlex.wordchars += \".\"  # Word char should include . to catch decimal \nwords = [ x for x in iter( lex.get_token, '' ) ]\nnewDict = dict ( zip( words[0::3], words[2::3]) )\n</code>\n</pre>\n", "senID": 4}], [{"text": ["do it step by step"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d={}\nmystring='name=\"John Smith\", age=34, height=173.2, location=\"US\", avatar=\":,=)\"';\ns = mystring.split(\", \")\nfor item in s:\n    i=item.split(\"=\",1)\n    d[i[0]]=i[-1]\nprint d\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a somewhat more robust version of the regexp solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nkeyval_re = re.compile(r'''\n   \\s*                                  # Leading whitespace is ok.\n   (?P&lt;key&gt;\\w+)\\s*=\\s*(                 # Search for a key followed by..\n       (?P&lt;str&gt;\"[^\"]*\"|\\'[^\\']*\\')|     #   a quoted string; or\n       (?P&lt;float&gt;\\d+\\.\\d+)|             #   a float; or\n       (?P&lt;int&gt;\\d+)                     #   an int.\n   )\\s*,?\\s*                            # Handle comma &amp; trailing whitespace.\n   |(?P&lt;garbage&gt;.+)                     # Complain if we get anything else!\n   ''', re.VERBOSE)\n\ndef handle_keyval(match):\n    if match.group('garbage'):\n        raise ValueError(\"Parse error: unable to parse: %r\" %\n                         match.group('garbage'))\n    key = match.group('key')\n    if match.group('str') is not None:\n        return (key, match.group('str')[1:-1]) # strip quotes\n    elif match.group('float') is not None:\n        return (key, float(match.group('float')))\n    elif match.group('int') is not None:\n        return (key, int(match.group('int')))\n</code>\n</pre>\n", "senID": 1}, {"text": ["It automatically converts floats &amp; ints to the right type; handles single and double quotes; handles extraneous whitespace in various locations; and complains if a badly formatted string is supplied"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s='name=\"John Smith\", age=34, height=173.2, location=\"US\", avatar=\":,=)\"'\n&gt;&gt;&gt; print dict(handle_keyval(m) for m in keyval_re.finditer(s))\n{'age': 34, 'location': 'US', 'name': 'John Smith', 'avatar': ':,=)', 'height': 173.19999999999999}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Always comma separated?", "Use the CSV module to split the line into parts (not checked):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import csv\nimport cStringIO\n\nparts=csv.reader(cStringIO.StringIO(&lt;string to parse&gt;)).next()\n</code>\n</pre>\n", "senID": 1}]]