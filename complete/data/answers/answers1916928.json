[[{"text": ["To convert to hex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["hexdata = ''.join('%02x' % ord(byte) for byte in bindata)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "hexdata = ''.join('%02x' % ord(byte) for byte in bindata)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To reverse every other hex character (if I'm understanding correctly):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["hexdata = ''.join(('%02x' % ord(byte))[::-1] for byte in bindata)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "hexdata = ''.join(('%02x' % ord(byte))[::-1] for byte in bindata)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This should get you started:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = b'\\x90\\x21\\x51\\x91\\x40\\x33'\n&gt;&gt;&gt; lst = [hex(z)[2:] for z in s]\n&gt;&gt;&gt; lst\n['90', '21', '51', '91', '40', '33']\n\n&gt;&gt;&gt; string = ''.join(hex(z)[3:1:-1] for z in s)\n&gt;&gt;&gt; string\n'091215190433'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What you mean is that you do want to do some processing!", "The unprocessed bytes are most easily represented as characters."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I think what you want is something along the lines of:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n r = ''\nfor num in array:\n    r += '%2X' % num\nreturn r\n</code>\n</pre>\n", "senID": 2}, {"text": ["Which I'm sure could be wrapped up in an anonymous function, if necessary."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If, in your question, the string you have provided is the literal set of bytes (as ascii) including the \\ and , and you wish to strip them out you could use the binascii module and str.replace:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import binascii\nqp = binascii.b2a_qp( bunchabytes )\nplainstring = qp.replace( '\\\\x', '' ).replace( ',', '' )\n</code>\n</pre>\n", "senID": 1}, {"text": ["The resultant plainstring will consist of only the digits."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Many thanks for all your replies."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["lpthnc's solution is exactly what I wanted.", "I ahve run into one more problem though."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If the bytearray contains b'\\x00\\x00\\x00"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["the conversion will return only 000"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["the digits need to stay as 000000 because the 0000 could represent the time 00:00"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Could I also ask someone to explain lpthnc's solution as I am having trouble working out exactly how it does the conversion?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Many thanks for your patience"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"code": "<pre>\n<code>\n switcher= dict(\n    (n1*16 + n2, n2*16 + n1)\n    for n1 in range(16)\n    for n2 in range(16)\n)\n\ndef nibble_switcher(bindata):\n    return type(bindata)(switcher[i] for i in bindata)\n    # will work with many types, not only bytearray\n\ndef nibble_switcher_as_hex_string(bindata):\n    return ''.join(\"%02x\" % i for i in nibble_switcher(bindata))\n</code>\n</pre>\n", "senID": 0}]]