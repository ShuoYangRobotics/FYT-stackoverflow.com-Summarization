[[{"text": ["A little shorter and hopefully more pythonic way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; A=[0,0,0,1,0,1]\n&gt;&gt;&gt; B=[0,0,1,1,1,1]\n\nx = sum(1 for a,b in zip(A,B) if (a==b==1))\n&gt;&gt;&gt; x\n2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Slightly shorter variation of Drakosha's:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; A = [0,0,0,1,0,1]\n&gt;&gt;&gt; B = [0,0,1,1,1,1] \n&gt;&gt;&gt; sum(a*b for a, b in zip(A, B) )\n2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm not an expert of Python, but what is wrong with a simple loop from start to end of first array? "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In C# I would do something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n int match=0;\n\nfor (int cnt=0; cnt&lt; A.Count;cnt++)\n{\n    if ((A[cnt]==B[cnt]==1)) match++;\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Would that be possible in your language?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Motivated by brief need to be perverse, I offer the following solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n A = [0,0,0,1,0,1]\nB = [0,0,1,1,1,1]\n\nprint len(set(i for i, n in enumerate(A) if n == 1) &amp;\n          set(i for i, n in enumerate(B) if n == 1))\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Drakosha's suggestion is a far more reasonable way to solve this problem.", "This just demonstrates that one can often look at the same problem in different ways."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["With SciPy:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "SciPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scipy.org"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from scipy import array\n&gt;&gt;&gt; A=array([0,0,0,1,0,1])\n&gt;&gt;&gt; B=array([0,0,1,1,1,1])\n\n&gt;&gt;&gt; A==B\narray([ True,  True, False,  True, False,  True], dtype=bool)\n&gt;&gt;&gt; sum(A==B)\n4\n\n&gt;&gt;&gt; A!=B\narray([False, False,  True, False,  True, False], dtype=bool)\n&gt;&gt;&gt; sum(A!=B)\n2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here comes another method which exploits the fact that the array just contains zeros and ones."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The scalar product of two vectors x and y is sum( x(i)*y(i) ) the only situation yielding a non zero result is if x(i)==y(i)==1 thus using numpy for instance"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from numpy import *\nx = array([0,0,0,1,0,1])\ny = array([0,0,1,1,1,1])\nprint dot(x,y)\n</code>\n</pre>\n", "senID": 2}, {"text": ["simple and nice.", "This method does n multiplications and adds n-1 times, however there are fast implementations using SSE, GPGPU, vectorisation, (add your fancy word here) for dot products (scalar products)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I timed the numpy-method against this method:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n sum(1 for a,b in zip(x,y) if (a==b==1))\n</code>\n</pre>\n", "senID": 5}, {"text": ["and found that for 1000000 loops the numpy-version did it in 2121ms and the zip-method did it in 9502ms thus the numpy-version is a lot faster"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I did a better analysis of the efectivness and found that\nfor n element(s) in the array the zip method took t1 ms and the dot product took t2 ms for one itteration"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\nelements      zip       dot\n1          0.0030    0.0207\n10         0.0063    0.0230\n100        0.0393    0.0476\n1000       0.3696    0.2932\n10000      7.6144    2.7781\n100000   115.8824   30.1305\n</pre>\n", "senID": 8}, {"text": ["From this data one could draw the conclusion that if the number of elements in the array is expected to (in mean) be more than 350 (or say 1000) one should consider to use the dot-product method instead."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"code": "<pre>\n<code>\n [A[i]+B[i] for i in range(min([len(A), len(B)]))].count(2)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Basically this just creates a new list which has all the elements of the other two added together.", "You know there were two 1's if the sum is 2 (assuming only 0's and 1's in the list).", "Therefore just perform the count operation on 2."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]