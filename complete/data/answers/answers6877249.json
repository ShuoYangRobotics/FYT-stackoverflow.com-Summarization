[[{"text": ["This is a classical dynamic programming problem (and not typically solved using regular expressions)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dynamic programming", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Dynamic_programming"}]}, {"text": ["That would be an exhaustive search approach which runs in exponential time.", "(I'm surprised it runs for hours though)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's a suggestion for a dynamic programming solution:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Outline for a recursive solution:"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["(Apologies for the long description, but each step is really simple so bare with me ;-)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 8, "lis": [{"text": ["If the subsequence is empty a match is found (no digits left to match!", ") and we return 1"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "subsequence", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If the input sequence is empty we've depleted our digits and can't possibly find a match thus we return 0"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "input sequence", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["(Neither the sequence nor the subsequence are empty."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["(Assume that \"abcdef\" denotes the input sequence, and \"xyz\" denotes the subsequence."], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "abcdef", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "abcdef", "tag": "em"}]}, {"text": "abcdef", "childNum": 0, "tag": "em", "childList": []}, {"text": "xyz", "childNum": 1, "tag": "strong", "childList": [{"text": "xyz", "tag": "em"}]}, {"text": "xyz", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Set result to 0"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "result", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Add to the result the number of matches for bcdef and xyz (i.e., discard the first input digit and recurse)"], "childNum": 5, "tag": "p", "senID": 10, "childList": [{"text": "result", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "bcdef", "childNum": 1, "tag": "strong", "childList": [{"text": "bcdef", "tag": "em"}]}, {"text": "bcdef", "childNum": 0, "tag": "em", "childList": []}, {"text": "xyz", "childNum": 1, "tag": "strong", "childList": [{"text": "xyz", "tag": "em"}]}, {"text": "xyz", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["If the first two digits match, i.e., a = x"], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "a", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Return result"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "result", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["Here's an illustration of the recursive calls for input 1221 / 12.", "(Subsequence in bold font, &middot; represents empty string."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "12", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"src": "http://aoeu.se/so/dp_ss.png", "tag": "img", "senID": 14}, {"text": ["If implemented naively, some (sub-)problems are solved multiple times (&middot; / 2 for instance in the illustration above).", "Dynamic programming avoids such redundant computations by remembering the results from previously solved subproblems (usually in a lookup table)."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["In this particular case we set up a table with"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "[length of sequence + 1] rows, and", "tag": "none", "senID": 17}, {"text": "[length of subsequence + 1] columns:", "tag": "none", "senID": 18}]}, {"text": ["&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}]}, {"text": ["The idea is that we should fill in the number of matches for 221 / 2 in the corresponding row / column.", "Once done, we should have the final solution in cell 1221 / 12."], "childNum": 2, "tag": "p", "senID": 20, "childList": [{"text": "2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "12", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["We start populating the table with what we know immediately (the \"base cases\"):"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "When no subsequence digits are left, we have 1 complete match:", "tag": "none", "senID": 22}]}, {"text": ["&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 1, "lis": [{"text": ["When no sequence digits are left, we can't have any matches:"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}]}, {"text": ["We then proceed by populating the table top-down / left-to-right according to the following rule:"], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["In cell [row][col] write the value found at [row-1][col]."], "childNum": 3, "tag": "p", "senID": 26, "childList": [{"text": "row", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "col", "childNum": 0, "tag": "em", "childList": []}, {"text": "row", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["If sequence at row row and subseq at column col start with the same digit, add the value found at [row-1][col-1] to the value just written to [row][col]."], "childNum": 6, "tag": "p", "senID": 27, "childList": [{"text": "row", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "col", "childNum": 0, "tag": "em", "childList": []}, {"text": "row", "childNum": 0, "tag": "em", "childList": []}, {"text": "col", "childNum": 0, "tag": "em", "childList": []}, {"text": "row", "childNum": 0, "tag": "em", "childList": []}, {"text": "col", "childNum": 0, "tag": "em", "childList": []}]}]}, {"text": ["&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"], "childNum": 1, "tag": "p", "senID": 28, "childList": [{"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}]}, {"text": ["The final result looks as follows:"], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"text": ["&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"], "childNum": 1, "tag": "p", "senID": 30, "childList": [{"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}]}, {"text": ["and the value at the bottom right cell is indeed 2."], "childNum": 0, "tag": "p", "senID": 31, "childList": []}, {"text": ["Not in Python, (my apologies)."], "childNum": 0, "tag": "p", "senID": 32, "childList": []}, {"code": "<pre>\n<code>\n class SubseqCounter {\n\n    String seq, subseq;\n    int[][] tbl;\n\n    public SubseqCounter(String seq, String subseq) {\n        this.seq = seq;\n        this.subseq = subseq;\n    }\n\n    public int countMatches() {\n        tbl = new int[seq.length() + 1][subseq.length() + 1];\n\n        for (int row = 0; row &lt; tbl.length; row++)\n            for (int col = 0; col &lt; tbl[row].length; col++)\n                tbl[row][col] = countMatchesFor(row, col);\n\n        return tbl[seq.length()][subseq.length()];\n    }\n\n    private int countMatchesFor(int seqDigitsLeft, int subseqDigitsLeft) {\n        if (subseqDigitsLeft == 0)\n            return 1;\n\n        if (seqDigitsLeft == 0)\n            return 0;\n\n        char currSeqDigit = seq.charAt(seq.length()-seqDigitsLeft);\n        char currSubseqDigit = subseq.charAt(subseq.length()-subseqDigitsLeft);\n\n        int result = 0;\n\n        if (currSeqDigit == currSubseqDigit)\n            result += tbl[seqDigitsLeft - 1][subseqDigitsLeft - 1];\n\n        result += tbl[seqDigitsLeft - 1][subseqDigitsLeft];\n\n        return result;\n    }\n}\n</code>\n</pre>\n", "senID": 33}, {"text": ["A bonus for this \"fill-in-the-table\" approach is that it is trivial to figure out complexity.", "A constant amount of work is done for each cell, and we have length-of-sequence rows and length-of-subsequence columns.", "Complexity is therefor O(MN) where M and N denote the lengths of the sequences."], "childNum": 3, "tag": "p", "senID": 34, "childList": [{"text": "O(MN)", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "M", "childNum": 0, "tag": "em", "childList": []}, {"text": "N", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Great answer, aioobe!", "to complement your answer, some possible implementations in Python:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "aioobe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/276052/aioobe"}]}, {"code": "<pre>\n<code>\n # straightforward, na\u00efve solution; too slow!\n\ndef num_subsequences(seq, sub):\n    if not sub:\n        return 1\n    elif not seq:\n        return 0\n    result = num_subsequences(seq[1:], sub)\n    if seq[0] == sub[0]:\n        result += num_subsequences(seq[1:], sub[1:])\n    return result\n\n# top-down solution using explicit memoization\n\ndef num_subsequences(seq, sub):\n    m, n, cache = len(seq), len(sub), {}\n    def count(i, j):\n        if j == n:\n            return 1\n        elif i == m:\n            return 0\n        k = (i, j)\n        if k not in cache:\n            cache[k] = count(i+1, j) + (count(i+1, j+1) if seq[i] == sub[j] else 0)\n        return cache[k]\n    return count(0, 0)\n\n# top-down solution using the lru_cache decorator\n# available from functools in python &gt;= 3.2\n\nfrom functools import lru_cache\n\ndef num_subsequences(seq, sub):\n    m, n = len(seq), len(sub)\n    @lru_cache(maxsize=None)\n    def count(i, j):\n        if j == n:\n            return 1\n        elif i == m:\n            return 0\n        return count(i+1, j) + (count(i+1, j+1) if seq[i] == sub[j] else 0)\n    return count(0, 0)\n\n# bottom-up, dynamic programming solution using a lookup table\n\ndef num_subsequences(seq, sub):\n    m, n = len(seq)+1, len(sub)+1\n    table = [[0]*n for i in xrange(m)]\n    def count(iseq, isub):\n        if not isub:\n            return 1\n        elif not iseq:\n            return 0\n        return (table[iseq-1][isub] +\n               (table[iseq-1][isub-1] if seq[m-iseq-1] == sub[n-isub-1] else 0))\n    for row in xrange(m):\n        for col in xrange(n):\n            table[row][col] = count(row, col)\n    return table[m-1][n-1]\n\n# bottom-up, dynamic programming solution using a single array\n\ndef num_subsequences(seq, sub):\n    m, n = len(seq), len(sub)\n    table = [0] * n\n    for i in xrange(m):\n        previous = 1\n        for j in xrange(n):\n            current = table[j]\n            if seq[i] == sub[j]:\n                table[j] += previous\n            previous = current\n    return table[n-1] if n else 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One way to do it would be with two lists.", "Call them Ones and OneTwos."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Ones", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "OneTwos", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Go through the string, character by character."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Whenever you see the digit ", "tag": "none", "senID": 2}, {"text": "Whenever you see the digit ", "tag": "none", "senID": 3}, {"text": "Whenever you see the digit ", "tag": "none", "senID": 4}]}, {"text": ["In the general case that algorithm will be very fast, since it's a single pass through the string and multiple passes through what will normally be much smaller lists.", "Pathological cases will kill it, though.", "Imagine a string like 111111222222333333, but with each digit repeated hundreds of times."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "111111222222333333", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"code": "<pre>\n<code>\n from functools import lru_cache\n\ndef subseqsearch(string,substr):\n    substrset=set(substr)\n    #fixs has only element in substr\n    fixs = [i for i in string if i in substrset]\n    @lru_cache(maxsize=None) #memoisation decorator applyed to recs()\n    def recs(fi=0,si=0):\n        if si &gt;= len(substr):\n            return 1\n        r=0\n        for i in range(fi,len(fixs)):\n            if substr[si] == fixs[i]:\n                r+=recs(i+1,si+1)\n        return r\n    return recs()\n\n#test\nfrom functools import reduce\ndef flat(i) : return reduce(lambda x,y:x+y,i,[])\nN=5\nstring = flat([[i for j in range(10) ] for i in range(N)])\nsubstr = flat([[i for j in range(5) ] for i in range(N)]) \nprint(\"string:\",\"\".join(str(i) for i in string),\"substr:\",\"\".join(str(i) for i in substr),sep=\"\\n\")\nprint(\"result:\",subseqsearch(string,substr))\n</code>\n</pre>\n", "senID": 0}, {"text": ["output (instantly):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n string:\n00000000001111111111222222222233333333334444444444\nsubstr:\n0000011111222223333344444\nresult: 1016255020032\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Given an input of one digit per line, this can be solved with one line in awk."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["My quick attempt:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def count_subseqs(string, subseq):\n    string = [c for c in string if c in subseq]\n    count = i = 0\n    for c in string:\n        if c == subseq[0]:\n            pos = 1\n            for c2 in string[i+1:]:\n                if c2 == subseq[pos]:\n                    pos += 1\n                    if pos == len(subseq):\n                        count += 1\n                        break\n        i += 1\n    return count\n\nprint count_subseqs(string='3141592653', subseq='123')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: This one should be correct also if 1223 == 2 and more complicated cases:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "1223 == 2", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def count_subseqs(string, subseq):\n    string = [c for c in string if c in subseq]\n    i = 0\n    seqs = []\n    for c in string:\n        if c == subseq[0]:\n            pos = 1\n            seq = [1]\n            for c2 in string[i + 1:]:\n                if pos &gt; len(subseq):\n                    break\n                if pos &lt; len(subseq) and c2 == subseq[pos]:\n                    try:\n                        seq[pos] += 1\n                    except IndexError:\n                        seq.append(1)\n                        pos += 1\n                elif pos &gt; 1 and c2 == subseq[pos - 1]:\n                    seq[pos - 1] += 1\n            if len(seq) == len(subseq):\n                seqs.append(seq)\n        i += 1\n    return sum(reduce(lambda x, y: x * y, seq) for seq in seqs)\n\nassert count_subseqs(string='12', subseq='123') == 0\nassert count_subseqs(string='1002', subseq='123') == 0\nassert count_subseqs(string='0123', subseq='123') == 1\nassert count_subseqs(string='0123', subseq='1230') == 0\nassert count_subseqs(string='1223', subseq='123') == 2\nassert count_subseqs(string='12223', subseq='123') == 3\nassert count_subseqs(string='121323', subseq='123') == 3\nassert count_subseqs(string='12233', subseq='123') == 4\nassert count_subseqs(string='0123134', subseq='1234') == 2\nassert count_subseqs(string='1221323', subseq='123') == 5\n</code>\n</pre>\n", "senID": 3}], [{"text": [" Quickly and simply"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["That is all.", "The complexity is O(N).", "Really, for the normal line of digits, it will take about twice the time of the shortening of the source line.  "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "That is all. The complexity is O(N).", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["If the sequence will be longer, of , say, M members, the procedure could be repeated M times.", "And complexity will be O(MN), where N already will be the length of the shortened source string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]