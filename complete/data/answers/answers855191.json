[[{"text": ["According to the source code, the maximum size of a list is PY_SSIZE_T_MAX/sizeof(PyObject*)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "source code", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Objects/listobject.c?revision=69227&view=markup"}]}, {"text": ["PY_SSIZE_T_MAX is defined in pyport.h to be ((size_t) -1)>>1"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "pyport.h", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Include/pyport.h?revision=70489&view=markup"}]}, {"text": ["On a regular 32bit system, this is (4294967295 / 2) / 4  or 536870912."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Therefore the maximum size of a python list on a 32 bit system is 536,870,912 elements. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "536,870,912", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["As long as the number of elements you have is equal or below this, all list functions should operate correctly."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Sure it is OK. Actually you can see for yourself easily:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = range(12000)\nl = sorted(l, reverse=True)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Running the those lines on my machine took:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n real    0m0.036s\nuser    0m0.024s\nsys  0m0.004s\n</code>\n</pre>\n", "senID": 3}, {"text": ["But sure as everyone else said.", "The larger the array the slower the operations will be."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["In casual code I've created lists with millions of elements.", "I believe that Python's implementation of lists are only bound by the amount of memory on your system. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In addition, the list methods / functions should continue to work despite the size of the list. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you care about performance, it might be worthwhile to look into a library such as NumPy."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "NumPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}], [{"text": ["12000 elements is nothing in Python... and actually the number of elements can go as far as the Python interpreter has memory on your system."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Performance characteristics for lists are described on Effbot."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Performance characteristics for lists", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/python-list.htm#performance"}]}, {"text": ["Python lists are actually implemented as vector for fast random access, so the container will basically hold as many items as there is space for in memory.", "(You need space for pointers contained in the list as well as space in memory for the object(s) being pointed to."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Appending is O(1) (amortized constant complexity), however, inserting into/deleting from the middle of the sequence will require an O(n) (linear complexity) reordering, which will get slower as the number of elements in your list."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "O(1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(n)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Your sorting question is more nuanced, since the comparison operation can take an unbounded amount of time.", "If you're performing really slow comparisons, it will take a long time, though it's no fault of Python's list data type."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Python's list data type", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#sequence-types-str-unicode-list-tuple-buffer-xrange"}]}, {"text": ["Reversal just takes the amount of time it required to swap all the pointers in the list (necessarily O(n) (linear complexity), since you touch each pointer once)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "O(n)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I'd say you're only limited by the total amount of RAM available.", "Obviously the larger the array the longer operations on it will take."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]