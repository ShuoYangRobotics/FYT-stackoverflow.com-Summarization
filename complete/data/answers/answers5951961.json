[[{"text": ["If title_words is a set, then there is only one occurrence of any one word.", "So you only need to remove one occurrence.", "Have I misunderstood your question? "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "title_words", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I'm still a bit confused by this question, but I notice that one problem might be that when you pass your initial data through set, the punctuation hasn't been stripped yet.", "So there may be multiple punctuated versions of a word slipping through the .difference() operation.", "Try this: "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".difference()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n title_words = set(word.strip(punctuation) for word in title.lower().split())\n</code>\n</pre>\n", "senID": 2}, {"text": ["Also, your words_gen generator is written in a slightly confusing way.", "Why line in keywords -- what's the line?", "And why are you calling split() again?", "keywords ought to be a set of straight words, right?"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "words_gen", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "line in keywords", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "split()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "keywords", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["I agree with senderle.", "Try this code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for common_word in common_words:\n    try:\n        title.words.remove(common_word)\n    except:\n        print \"The common word %s was not in title_words\" %common_word\n</code>\n</pre>\n", "senID": 1}, {"text": ["That should do it"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Strip punctuation out before you make it a set, you do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n keywords = title_words.strip(punctuation).difference(common_words)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which tries to call the strip method of the title_words, which is a set (only str has this method).", "You could do something like this instead:"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "strip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "title_words", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n for chr in punctuation:\n    title = title.replace(chr, '')\n\ntitle_words = set(title.lower().split())\n\nkeywords = title_words.difference(common_words)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You just want the difference() method for this, but it looks like your example is buggy."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "difference()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["title_words is a set, and doesn't have the strip() method."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "title_words", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "strip()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Try this instead:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n title_words = set(title.lower().split())\nkeywords = title_words.difference(common_words)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Not ideal, but works as a word frequency counter (which is what this appears to be aiming at):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from string import punctuation\nfrom operator import itemgetter\nimport itertools\n\nN = 10\nwords = {}\n\nlinestring = open('test.txt', 'r').read()\n\ncommon_words = set((\"if\", \"but\", \"and\", \"the\", \"when\", \"use\", \"to\", \"for\"))\n\nwords = [w.strip(punctuation) for w in linestring.lower().split()]\n\nkeywords = itertools.ifilterfalse(lambda w: w in common_words, words)\n\nwords = {}\nfor word in keywords:\n    words[word] = words.get(word, 0) + 1\n\ntop_words = sorted(words.iteritems(), key=itemgetter(1), reverse=True)[:N]\n\nfor word, frequency in top_words:\n    print \"%s: %d\" % (word, frequency)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I wrote some code recently that does something similar, although the style is very different from yours.", "Maybe it will help you out."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import string\nimport sys\n\ndef main():\n    # get some stop words\n    stopf = open('stop_words.txt', \"r\")\n    stopwords = {}\n    for s in stopf:\n        stopwords[string.strip(s)] = 1\n\n    file = open(sys.argv[1], \"r\")\n    filedata = file.read()\n    words=string.split(filedata)\n    histogram = {}\n    count = 0\n    for word in words:\n        word = string.strip(word, string.punctuation)\n        word = string.lower(word)\n        if word in stopwords:\n            continue\n        histogram[word] = histogram.get(word, 0) + 1\n        count = (count+1) % 1000\n        if count == 0:\n            print '*',\n    flist = []\n    for word, count in histogram.items():\n        flist.append([count, word])\n    flist.sort()\n    flist.reverse()\n    for pair in flist[0:100]:\n        print \"%30s: %4d\" % (pair[1], pair[0])\n\nmain()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You've succeeded in finding the top N most uniquely punctuated words in your input file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Run this input file through your original code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n the quick brown fox.\nThe quick brown fox?\nThe quick brown fox! \nthe quick, brown fox\n</code>\n</pre>\n", "senID": 2}, {"text": ["And you'll get the following output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n fox: 4\nquick: 2\nbrown: 1\n</code>\n</pre>\n", "senID": 4}, {"text": ["Notice that fox appears in 4 variations: fox, fox?, fox!, and fox.", "The word brown appears only one way.", "And quick appears only with and without a comma (2 variations)."], "childNum": 7, "tag": "p", "senID": 5, "childList": [{"text": "fox", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fox", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fox?", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fox!", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fox.", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "brown", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "quick", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["What happens when we add fox to the common_words set?", "Only the variation that has no trailing punctuation is removed, and we're left with the three punctuation-adorned variants, giving this output:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "fox", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "common_words", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n fox: 3\nquick: 2\nbrown: 1\n</code>\n</pre>\n", "senID": 7}, {"text": ["For a more realistic example, run MLK's I Have a Dream speech through your method:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "MLK's I Have a Dream", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.americanrhetoric.com/speeches/mlkihaveadream.htm"}]}, {"code": "<pre>\n<code>\n justice: 4\nchildren: 3\ntoday: 3\nrights: 3\nsatisfied: 3\nnation: 3\nday: 3\nring: 3\nhope: 3\ninjustice: 3\n</code>\n</pre>\n", "senID": 9}, {"text": ["Dr. King says \"I Have a Dream\" eight times in that speech, yet dream doesn't show up at all on the list.", "Do a search for justice and you'll find four (4) punctuated flavors:"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "dream", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "justice", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"tag": "ul", "num": 4, "lis": [{"text": "until \"justice rolls", "tag": "none", "senID": 11}, {"text": "palace of justice: In the", "tag": "none", "senID": 12}, {"text": "make justice a reality", "tag": "none", "senID": 13}, {"text": "path of racial justice.", "tag": "none", "senID": 14}]}, {"text": ["So what went wrong?", "It looks like this method has been through a lot of rework, considering the names of the variables don't seem to match their purpose.", "So let's go through (moving some code around a bit, my apologies):"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["Open the file and slurp the whole thing into linestring, good so far except for the variable name:"], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "linestring", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n linestring = open(filename, 'r').read()\n</code>\n</pre>\n", "senID": 17}, {"text": ["Is this a line or a title?", "Both?", "In any event, we now lowercase the whole file and split it up by whitespace.", "Using my test file, this means title_words now contains fox?, fox!, fox, and fox."], "childNum": 4, "tag": "p", "senID": 18, "childList": [{"text": "fox?", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "fox!", "childNum": 0, "tag": "code", "childList": []}, {"text": "fox", "childNum": 0, "tag": "code", "childList": []}, {"text": "fox.", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n title = linestring\ntitle_words = set(title.lower().split())\n</code>\n</pre>\n", "senID": 19}, {"text": ["Now the attempt to remove the common words.", "Let's assume our common_words contains fox.", "This next line removes fox but leaves fox?, fox!, and fox."], "childNum": 5, "tag": "p", "senID": 20, "childList": [{"text": "fox", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "fox", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "fox?", "childNum": 0, "tag": "code", "childList": []}, {"text": "fox!", "childNum": 0, "tag": "code", "childList": []}, {"text": "fox.", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n keywords = title_words.difference(common_words)\n</code>\n</pre>\n", "senID": 21}, {"text": ["The next line really looks legacy to me, as if it was meant to be something like for line in linestring.split('\\n') for word in line.split().", "In the current form, keywords is just a list of words, so line is just a word without spaces, so for word in line.split() has no effect.", "We just iterate over every word, remove punctuation, and make it lowercase.", "words_gen now contains 3 copies of fox: fox, fox, fox.", "We've removed the one un-punctuated version."], "childNum": 8, "tag": "p", "senID": 22, "childList": [{"text": "for line in linestring.split('\\n') for word in line.split()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "keywords", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "line", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "for word in line.split()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "words_gen", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "fox", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fox", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fox", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n words_gen = (word.strip(punctuation).lower() for line in keywords\n                                             for word in line.split())\n</code>\n</pre>\n", "senID": 23}, {"text": ["The frequency analysis is pretty spot-on.", "This creates a histogram based on the words in the words_gen generator.", "Which ultimately gives us the N most uniquely punctuated words!", "In this example, fox=3:"], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "fox=3", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n words = {}\nfor word in words_gen:\n    words[word] = words.get(word, 0) + 1\ntop_words = sorted(words.iteritems(), key=itemgetter(1), reverse=True)[:N]\n</code>\n</pre>\n", "senID": 25}, {"text": ["So there's the what-went-wrong.", "Others have posted clear solutions for word frequency analysis, but I'm in a bit of a performance frame of mind, and came up with my own variant.", "First, split the text into words using a regular expression:"], "childNum": 1, "tag": "p", "senID": 26, "childList": [{"text": "what-went-wrong", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # 1. assumes proper word spacing after punctuation, if not, then something like\n#    \"I ate.I slept\" will return \"I\", \"ATEI\", \"SLEPT\"\n# 2. handles contractions properly. E.g., \"don't\" becomes \"DONT\"\n# 3. removes any unexpected characters such as Unicode Non-breaking space and\n#    non-printable ascii characters (MS Word inserts ASCII 0x05 for\n#    in-line review comments)\nclean = re.sub(\"[^\\w\\s]+\", \"\", text.upper())\nwords = clean.split()\n</code>\n</pre>\n", "senID": 27}, {"text": ["Now based on Python Performance Tips for Initializing Dictionary Entries (and my own measured performance), find the top N most frequent words:"], "childNum": 1, "tag": "p", "senID": 28, "childList": [{"text": "Python Performance Tips for Initializing Dictionary Entries", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonSpeed/PerformanceTips#Initializing_Dictionary_Elements"}]}, {"code": "<pre>\n<code>\n # first create a dictionary that will count the number of words. \n# using defaultdict(int) is the 2nd fastest method I measured but \n# the most readable. It was very close in speed to \"if not w in freq\" technique\nfreq = defaultdict(int)\nfor w in words:\n    freq[w] += 1\n\n# remove any of the common words by deleting common keys from the dictionary\nfor k in common_words:\n    if k in freq:\n        del freq[k]\n\n# Ryan's original top-N selection was the fastest of several\n# methods I tried including using dictview and lambda functions\n# - sort the items by directly accessing item[1] (i.e., the value/frequency count)\ntop = sorted( freq.iteritems(), key=itemgetter(1), reverse=True)[:N]\n</code>\n</pre>\n", "senID": 29}, {"text": ["And to close with Dr. King's speech with all articles and pronouns removed:"], "childNum": 0, "tag": "p", "senID": 30, "childList": []}, {"code": "<pre>\n<code>\n ('OF', 99)\n('TO', 59)\n('AND', 53)\n('BE', 33)\n('WE', 30)\n('WILL', 27)\n('THAT', 24)\n('IS', 23)\n('IN', 22)\n('THIS', 20)\n</code>\n</pre>\n", "senID": 31}, {"text": ["And, for kicks, my performance measurments:"], "childNum": 0, "tag": "p", "senID": 32, "childList": []}, {"code": "<pre>\n<code>\n Original                      ; 0:00:00.645000 ************\nSortAllWords                  ; 0:00:00.571000 ***********\nMyFind                        ; 0:00:00.870000 *****************\nMyImprovedFind                ; 0:00:00.551000 ***********\nDontInsertCommon              ; 0:00:00.649000 ************\nJohnGainsJr                   ; 0:00:00.857000 *****************\nReturnImmediate               ; 0:00:00\nSortWordsAndReverse           ; 0:00:00.572000 ***********\nJustCreateDic_GetZero         ; 0:00:00.439000 ********\nJustCreateDic_TryExcept       ; 0:00:00.732000 **************\nJustCreateDic_IfNotIn         ; 0:00:00.309000 ******\nJustCreateDic_defaultdict     ; 0:00:00.328000 ******\nCreateDicAndRemoveCommon      ; 0:00:00.437000 ********\n</code>\n</pre>\n", "senID": 33}, {"text": ["Cheers,\nE"], "childNum": 0, "tag": "p", "senID": 34, "childList": []}]]