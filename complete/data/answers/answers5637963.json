[[{"text": ["It's much easier to write a regex that matches words that do have repeating letters, and then negate the match:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n my @input = qw(abducts abe abeam abel abele);\nmy @output = grep { not /(\\w).*\\1/ } @input;\n</code>\n</pre>\n", "senID": 1}, {"text": ["(This code assumes that @input contains one word per entry.", ") But this problem isn't necessarily best solved with a regex."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "@input", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I've given the code in Perl, but it could easily be translated into any regex flavor that supports backreferences, including grep (which also has the -v switch to negate the match)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "grep", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "-v", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n $ egrep -vi '(.).*\\1' wordlist\n</code>\n</pre>\n", "senID": 0}], [{"text": ["It is possible to use regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ninp = [\n    'abducts'\n,   'abe'\n,   'abeam'\n,   'abel'\n,   'abele'\n]\n\n# detect word which contains a character at least twice\nrgx = re.compile(r'.*(.).*\\1.*') \n\ndef filter_words(inp):\n    for word in inp:\n        if rgx.match(word) is None:\n            yield word\n\nprint list(filter_words(inp))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Despite the inaccurate protestation that this is impossible with a regex, it certainly is."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["While @cjm justly states that it is a lot easier to negate a positive match than  it is to express a negative one as a single pattern, the model for doing so is sufficiently well-known that it becomes a mere matter of plugging things into that model.", "Given that:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n/X/\n</pre>\n", "senID": 2}, {"text": ["matches something, then the way to express the condition"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n! /X/\n</pre>\n", "senID": 4}, {"text": ["in a single, positively-matching pattern is to write it as"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n/\\A (?: (?! X ) . ) * \\z /sx\n</pre>\n", "senID": 6}, {"text": ["Therefore, given that the positive pattern is"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n/ (\\pL) .* \\1 /sxi\n</pre>\n", "senID": 8}, {"text": ["the corresponding negative needs must be"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n/\\A (?: (?! (\\pL) .* \\1  ) . ) * \\z /sxi\n</pre>\n", "senID": 10}, {"text": ["by way of simple substitution for X."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "X.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["That said, there are extenuating concerns that may sometimes require more work.", "For example, while \\pL describes any code point having the GeneralCategory=Letter property, it does not consider what to do with words like red\u2010violet\u2013colored, \u2019Tisn\u2019t, or fianc\u00e9e \u2014 the latter of which is different in otherwise-equivalent NFD vs NFC forms."], "childNum": 5, "tag": "p", "senID": 12, "childList": [{"text": "\\pL", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "GeneralCategory=Letter", "childNum": 0, "tag": "em", "childList": []}, {"text": "red\u2010violet\u2013colored", "childNum": 0, "tag": "em", "childList": []}, {"text": "\u2019Tisn\u2019t", "childNum": 0, "tag": "em", "childList": []}, {"text": "fianc\u00e9e", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["You therefore must first run it through full decomposition, so that a string like \"r\\x{E9}sume\\x{301}\" would correctly detect the duplicate \u201cletter \u00e9\u2019s\u201d \u2014 that is, all canonically equivalent grapheme cluster units."], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "\"r\\x{E9}sume\\x{301}\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\u00e9", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["To account for such as these, you must at a bare minimum first run your string through an NFD decomposition, and then afterwards also use grapheme clusters via \\X instead of arbitrary code points via .. "], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "\\X", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So for English, you would want something that followed along these lines for the positive match, with the corresponding negative match per the substitution give above:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\nNFD($string) =~ m{\n        (?&lt;ELEMENT&gt;\n           (?= [\\p{Alphabetic}\\p{Dash}\\p{Quotation_Mark}] ) \\X \n        )\n        \\X *\n        \\k&lt;ELEMENT&gt;\n    }xi\n</pre>\n", "senID": 16}, {"text": ["But even with that there still remain certain outstanding issues unresolved, such as for example whether \\N{EN DASH} and \\N{HYPHEN} should be considered equivalent elements or different ones. "], "childNum": 2, "tag": "p", "senID": 17, "childList": [{"text": "\\N{EN DASH}", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\N{HYPHEN}", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["That\u2019s because properly written,  hyphenating two elements like red\u2010violet and colored to form the single compound word red\u2010violet\u2013colored, where at least one of the pair already contains a hyphen, requires that one employ an EN DASH as the separator instead of a mere HYPHEN."], "childNum": 4, "tag": "p", "senID": 18, "childList": [{"text": "red\u2010violet", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "colored", "childNum": 0, "tag": "em", "childList": []}, {"text": "red\u2010violet\u2013colored", "childNum": 0, "tag": "em", "childList": []}, {"text": "already contains a hyphen", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Normally the EN DASH is reserved for compounds of like nature, such as a time\u2013space trade\u2010off.", "People using typewriter\u2010English don\u2019t even do that, though, using that super\u2010massively overloaded legacy code point, HYPHEN-MINUS, for both: red-violet-colored. "], "childNum": 2, "tag": "p", "senID": 19, "childList": [{"text": "a time\u2013space trade\u2010off", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "red-violet-colored", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["It just depends whether your text came from some 19th\u2010century manual typewriter \u2014 or whether it represents English text properly rendered under modern typesetting rules.", ":)"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["You will note I am here considering letter that differ in case alone to be the same one.", "That\u2019s because I use the /i regex switch, \u1d00\u1d0b\u1d00 the (?i) pattern modifier."], "childNum": 2, "tag": "p", "senID": 21, "childList": [{"text": "/i", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(?i)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["That\u2019s rather like saying that they are the same as collation strength 1 \u2014 but not quite, because Perl uses only case folding (albeit full case folding not simple) for its case insensitive matches, not some higher collation strength than the tertiary level as might be preferred."], "childNum": 3, "tag": "p", "senID": 22, "childList": [{"text": "rather", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "full", "childNum": 0, "tag": "em", "childList": []}, {"text": "simple", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Full equivalence at the primary collation strength is a significantly stronger statement, but one that may well be needed to fully solve the problem in the general case.", "However, that requires a lot more work than the problem necessarily requires in many specific instances.", "In short, it is overkill for many specific cases that actually arise, no matter how much it might be needed for the hypothetical general case. "], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "that", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["This is made even more difficult because, although you can for example do this:"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"code": "<pre>\nmy $collator = new Unicode::Collate::Locale::\n                       level =&gt; 1, \n                       locale =&gt; \"de__phonebook\",\n                       normalization =&gt; undef,\n                    ;\n\n    if ($collator-&gt;cmp(\"m\u00fc\u00df\", \"MUESS\") == 0) { ... }\n</pre>\n", "senID": 25}, {"text": ["and expect to get the right answer \u2014 and you do, hurray!", "\u2014 this sort of robust string comparison is not easily extended to regex matches."], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"text": ["Yet.", ":)"], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"text": ["The choice of whether to under\u2010engineer \u2014 or to over\u2010engineer \u2014 a solution will vary according to individual circumstances, which no one can decide for you."], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"text": ["I like CJM\u2019s solution that negates a positive match, myself, although it\u2019s somewhat cavalier about what it considers a duplicate letter.", "Notice:"], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"code": "<pre>\nwhile (\"de__phonebook\" =~ /(?=((\\w).*?\\2))/g) {\n        print \"The letter &lt;$2&gt; is duplicated in the substring &lt;$1&gt;.\\n\";\n    }\n</pre>\n", "senID": 30}, {"text": ["produces:"], "childNum": 0, "tag": "p", "senID": 31, "childList": []}, {"code": "<pre>\nThe letter &lt;e&gt; is duplicated in the substring &lt;e__phone&gt;.\n    The letter &lt;_&gt; is duplicated in the substring &lt;__&gt;.\n    The letter &lt;o&gt; is duplicated in the substring &lt;onebo&gt;.\n    The letter &lt;o&gt; is duplicated in the substring &lt;oo&gt;.\n</pre>\n", "senID": 32}, {"text": ["That shows why when you need to match a letter, you should alwasy use \\pL \u1d00\u1d0b\u1d00 \\p{Letter} instead of \\w, which actually matches [\\p{alpha}\\p{GC=Mark}\\p{NT=De}\\p{GC=Pc}]. "], "childNum": 5, "tag": "p", "senID": 33, "childList": [{"text": "alwasy", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "\\pL", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\p{Letter}", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\w", "childNum": 0, "tag": "code", "childList": []}, {"text": "[\\p{alpha}\\p{GC=Mark}\\p{NT=De}\\p{GC=Pc}]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Of course, when you need to match an alphabetic, you need to use \\p{alpha} \u1d00\u1d0b\u1d00\\p{Alphabetic}, which isn\u2019t at all the same as a mere letter \u2014 contrary to popular misunderstanding.", ":)"], "childNum": 2, "tag": "p", "senID": 34, "childList": [{"text": "\\p{alpha}", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\p{Alphabetic}", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["If you're dealing with long strings that are likely to have duplicate letters, stopping ASAP may help."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "long", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n INPUT: for (@input) {\n   my %seen;\n   while (/(.)/sg) {\n      next INPUT if $seen{$1}++;\n   }\n   say;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'd go with the simplest solution unless the performance is found to be really unacceptable."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n my @output = grep !/(.).*?\\1/s, @input;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I was very curious about the relative speed of the various Perl-based methods submitted by other authors for this question.", "So, I decided to benchmark them. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Where necessary, I slightly modified each method so that it would populate an @output array, to keep the input and output consistent.", "I verified that all the methods produce the same @output, although I have not documented that assertion here. "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "@output", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "@output", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Here is the script to benchmark the various methods:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\nuse Benchmark qw(cmpthese :hireswallclock);\n\n# get a convenient list of words (on Mac OS X 10.6.6, this contains 234,936 entries)\nopen (my $fh, '&lt;', '/usr/share/dict/words') or die \"can't open words file: $!\\n\";\nmy @input = &lt;$fh&gt;;\nclose $fh;\n\n# remove line breaks\nchomp @input;\n\n# set-up the tests (\nmy %tests = (\n\n  # Author: cjm\n  RegExp =&gt; sub { my @output = grep { not /(\\w).*\\1/ } @input },\n\n  # Author: daotoad\n  SplitCount =&gt; sub { my @output = grep { my @l = split ''; my %l; @l{@l} = (); keys %l == @l } @input; },\n\n  # Author: ikegami\n  NextIfSeen =&gt; sub {\n    my @output;\n    INPUT: for (@input) {\n      my %seen;\n      while (/(.)/sg) {\n        next INPUT if $seen{$1}++;\n      }\n      push @output, $_;\n    }\n\n  },\n\n  # Author: ysth\n  BitMask =&gt; sub {\n    my @output;\n    for my $word (@input) {\n      my $mask1 = $word x ( length($word) - 1 );\n      my $mask2 = join( '', map { substr($word, $_), substr($word, 0, $_) } 1..length($word)-1 );\n      if ( ( $mask1 ^ $mask2 ) !~ tr/\\0// ) {\n        push @output, $word;\n      }\n    }\n  },\n\n);\n\n# run each test 100 times\ncmpthese(100, \\%tests);\n</code>\n</pre>\n", "senID": 3}, {"text": ["Here are the results for 100 iterations. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n s/iter SplitCount    BitMask NextIfSeen     RegExp\nSplitCount   2.85         --       -11%       -58%       -85%\nBitMask      2.54        12%         --       -53%       -83%\nNextIfSeen   1.20       138%       113%         --       -64%\nRegExp      0.427       567%       496%       180%         --\n</code>\n</pre>\n", "senID": 5}, {"text": ["As you can see, cjm's \"RegExp\" method is the fastest by far.", "It is 180% faster than the next fastest method, ikegami's \"NextIfSeen\" method.", "I suspect that the relative speed of the RegExp and NextIfSeen methods will converge as the average length of the input strings increases.", "But for \"normal\" length English words, the RegExp method is the fastest."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["cjm gave the regex, but here's an interesting non-regex way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @words = qw/abducts abe abeam abel abele/;\nfor my $word (@words) {\n    my $mask1 = $word x ( length($word) - 1 );\n    my $mask2 = join( '', map { substr($word, $_), substr($word, 0, $_) } 1..length($word)-1 );\n    if ( ( $mask1 ^ $mask2 ) !~ tr/\\0// ) {\n        print \"$word\\n\";\n    }\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In response to cjm's solution, I wondered about how it compared to some rather terse Perl:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my @output = grep { my @l = split ''; my %l; @l{@l} = (); keys %l == @l } @input;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Since I am not constrained in character count and formatting here, I'll be a bit clearer, even to the point of over-documenting:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n my @output = grep {\n\n    # Split $_ on the empty string to get letters in $_. \n    my @letters = split '';\n\n    # Use a hash to remove duplicate letters.\n    my %unique_letters;\n    @unique_letters{@letters} = ();  # This is a hash slice assignment.\n                                     # See perldoc perlvar for more info\n\n    # is the number of unique letters equal to the number of letters?\n    keys %unique_letters == @letters\n\n} @input;\n</code>\n</pre>\n", "senID": 3}, {"text": ["And, of course in production code, please do something like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n my @output = grep ! has_repeated_chars($_), @input;\n\nsub has_repeated_letters {\n    my $word = shift;\n    #blah blah blah\n    # see example above for the code to use here, with a nip and a tuck.\n}\n</code>\n</pre>\n", "senID": 5}], [{"text": ["In python with a regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n python -c 'import re, sys; print \"\".join(s for s in open(sys.argv[1]) if not re.match(r\".*(\\w).*\\1\", s))' wordlist.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["In python without a regex:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n python -c 'import sys; print \"\".join(s for s in open(sys.argv[1]) if len(s) == len(frozenset(s)))' wordlist.txt\n</code>\n</pre>\n", "senID": 3}, {"text": ["I performed some timing tests with a hardcoded file name and output redirected to /dev/null to avoid including output in the timing:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Timings without the regex:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n python -m timeit 'import sys' 'print &gt;&gt; sys.stderr, \"\".join(s for s in open(\"wordlist.txt\") if len(s) == len(frozenset(s)))' 2&gt;/dev/null\n10000 loops, best of 3: 91.3 usec per loop\n</code>\n</pre>\n", "senID": 6}, {"text": ["Timings with the regex:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n python -m timeit 'import re, sys' 'print &gt;&gt; sys.stderr, \"\".join(s for s in open(\"wordlist.txt\") if re.match(r\".*(\\w).*\\1\", s))' 2&gt;/dev/null\n10000 loops, best of 3: 105 usec per loop\n</code>\n</pre>\n", "senID": 8}, {"text": ["Clearly the regex is a tiny bit slower than a simple frozenset creation and len comparison in python."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["You can't do this with Regex.", "Regex is a Finite State Machine, and this would require a stack to store what letters have been seen."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would suggest doing this with a foreach and manually check each word with code.", "Something like"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n List chars\nforeach word in list\n    foreach letter in word\n        if chars.contains letter then remove word from list\n        else\n            chars.Add letter\n    chars.clear\n</code>\n</pre>\n", "senID": 2}]]