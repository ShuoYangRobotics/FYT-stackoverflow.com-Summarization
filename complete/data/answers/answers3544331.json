[[{"text": ["If order matters, try the comm utility.", "If order doesn't matter, sort file1 file2 | uniq -u."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "comm", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sort file1 file2 | uniq -u", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["With 60,000 or 80,000 unique lines you could just create a dictionary for each unique line, mapping it to a number.", "mydict[\"hello world\"] =&gt; 1, etc.", "If your average line is around 40-80 characters this will be in the neighborhood of 10 MB of memory."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mydict[\"hello world\"] =&gt; 1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Then read each file, converting it to an array of numbers via the dictionary.", "Those will fit easily in memory (2 files of 8 bytes * 3GB / 60k lines is less than 1 MB of memory).", "Then diff the lists.", "You could invert the dictionary and use it to print out the text of the lines that differ."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "invert the dictionary", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/483666/python-reverse-inverse-a-mapping"}]}, {"text": ["EDIT:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["In response to your comment, here's a sample script that assigns numbers to unique lines as it reads from a file."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\nclass Reader:\n\n    def __init__(self, file):\n        self.count = 0\n        self.dict = {}\n        self.file = file\n\n    def readline(self):\n        line = self.file.readline()\n        if not line:\n            return None\n        if self.dict.has_key(line):\n            return self.dict[line]\n        else:\n            self.count = self.count + 1\n            self.dict[line] = self.count\n            return self.count\n\nif __name__ == '__main__':\n    print \"Type Ctrl-D to quit.\"\n    import sys\n    r = Reader(sys.stdin)\n    result = 'ignore'\n    while result:\n        result = r.readline()\n        print result\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I think this is the fastest method (whether it's in Python or another language shouldn't matter too much IMO). "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Notes:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["1.I only store each line's hash to save space (and time if paging might occur)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["2.Because of the above, I only print out line numbers; if you need actual lines, you'd just need to read the files in again"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["3.I assume that the hash function results in no conflicts.", "This is nearly, but not perfectly, certain."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["4.I import hashlib because the built-in hash() function is too short to avoid conflicts."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import sys\nimport hashlib\n\nfile = []\nlines = []\nfor i in range(2):\n    # open the files named in the command line\n    file.append(open(sys.argv[1+i], 'r'))\n    # stores the hash value and the line number for each line in file i\n    lines.append({})\n    # assuming you like counting lines starting with 1\n    counter = 1\n    while 1:\n        # assuming default encoding is sufficient to handle the input file\n        line = file[i].readline().encode()\n        if not line: break\n        hashcode = hashlib.sha512(line).hexdigest()\n        lines[i][hashcode] = sys.argv[1+i]+': '+str(counter)\n        counter += 1\nunique0 = lines[0].keys() - lines[1].keys()\nunique1 = lines[1].keys() - lines[0].keys()\nresult = [lines[0][x] for x in unique0] + [lines[1][x] for x in unique1]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["If I understand correctly, you want the lines of these files without duplicates.", "This does the job:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n uniqA = set(open('fileA', 'r'))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["http://www.emeditor.com/ can handle large files and can also compare them."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.emeditor.com/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.emeditor.com/"}]}], [{"text": ["Python has difflib which claims to be quite competitive with other diff utilities see:\nhttp://docs.python.org/library/difflib.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/difflib.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/difflib.html"}]}]]