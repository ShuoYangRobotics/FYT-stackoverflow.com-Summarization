[[{"text": ["you could do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n echo -e \"import sys\\nfor r in range(10): print 'rob'\" | python\n</code>\n</pre>\n", "senID": 1}, {"text": ["or w/out pipes:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n python -c \"exec(\\\"import sys\\\\nfor r in range(10): print 'rob'\\\")\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n (echo \"import sys\" ; echo \"for r in range(10): print 'rob'\") | python\n</code>\n</pre>\n", "senID": 5}, {"text": ["or @SilentGhost's answer / @Crast's answer"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "SilentGhost's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2043453/executing-one-liners-that-import-modules-in-python/2043472#2043472"}, {"href": "http://stackoverflow.com/questions/2043453/executing-python-multi-line-statements-in-the-one-line-command-line/2043633#2043633", "text": "@Crast's answer", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["The problem is not with the import statement.", "The problem is that the control flow statements don't work inlined in a python command.", "Replace that import statement with any other statement and you'll see the same problem."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "import", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "import", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Think about it: python can't possibly inline everything.", "It uses indentation to group control-flow."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["this style can be used in makefiles too (and in fact it is used quite often)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n cat &lt;&lt;EOF | python -\nimport sys\nfor r in range(3): print 'rob'\nEOF\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n cat &lt;&lt;-EOF | python -\n    import sys\n    for r in range(3): print 'rob'\nEOF\n</code>\n</pre>\n", "senID": 3}, {"text": ["in latter case leading tab characters are removed too (and some structured outlook can be achieved)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "tab characters", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["instead of EOF can stand any marker word not appearing in the here document at a beginning of a line (see also here documents in the bash manpage or here)."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://tldp.org/LDP/abs/html/here-docs.html"}]}], [{"text": ["If your system is Posix.2 compliant it should supply the printf utility:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "printf", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ printf \"print 'zap'\\nfor r in range(3): print 'rob'\" | python\nzap\nrob\nrob\nrob\n</code>\n</pre>\n", "senID": 1}], [{"text": ["just use return and type it on the next line:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n user@host:~$ python -c \"import sys\n&gt; for r in range(10): print 'rob'\"\nrob\nrob\n...\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The issue is not actually with the import statement, it's with anything being before the for loop.", "Or more specifically, anything appearing before an inlined block."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, these all work:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n python -c \"import sys; print 'rob'\"\npython -c \"import sys; sys.stdout.write('rob\\n')\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["If import being a statement were an issue, this would work, but it doesn't:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n python -c \"__import__('sys'); for r in range(10): print 'rob'\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["For your very basic example, you could rewrite it as this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n python -c \"import sys; map(lambda x: sys.stdout.write('rob%d\\n' % x), range(10))\"\n</code>\n</pre>\n", "senID": 6}, {"text": ["However, lambdas can only execute expressions, not statements or multiple statements, so you may still be unable to do the thing you want to do.", "However, between generator expressions, list comprehension, lambdas, sys.stdout.write, the \"map\" builtin, and some creative string interpolation, you can do some powerful one-liners."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["The question is, how far do you want to go, and at what point is it not better to write a small .py file which your makefile executes instead?"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": ".py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I'm not really a big Pythoner - but I found this syntax once, forgot where from, so I thought I'd document it: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["if you use sys.stdout.write instead of print (the difference being,sys.stdout.writetakes arguments as a function, in parenthesis - whereasprintdoesn't), then for a one-liner, you can get away with inverting the order of the command and the for, removing the semicolon, and enclosing the command in square brackets, i.e.", ": "], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "sys.stdout.write", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "print", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "the difference being,sys.stdout.writetakes arguments as a function, in parenthesis - whereasprintdoesn't", "childNum": 2, "tag": "em", "pos": -1, "childList": [{"text": "sys.stdout.write", "tag": "code"}, {"text": "print", "tag": "code"}]}, {"text": "sys.stdout.write", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "print", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n python -c \"import sys; [sys.stdout.write('rob\\n') for r in range(10)]\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["Have no idea how this syntax would be called in Python :) "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Hope this helps, "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Cheers! "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["single/double quotes and backslash everywhere:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "single/double quotes", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "backslash", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n $ python -c 'exec(\"import sys\\nfor i in range(10): print \\\"bob\\\"\")'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Much better:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ python -c '\n&gt; import sys\n&gt; for i in range(10):\n&gt;   print \"bob\"\n&gt; '\n</code>\n</pre>\n", "senID": 3}], [{"text": ["$ python2.6 -c \"import sys; [sys.stdout.write('rob\\n') for r in range(10)]\""], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "$ python2.6 -c \"import sys; [sys.stdout.write('rob\\n') for r in range(10)]\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Works fine.", "Use \"[ ]\" to inline your for loop."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]