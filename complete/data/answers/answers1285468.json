[[{"text": ["You'll need two loops (or equivalently a loop and a listcomp, like below), but not nested ones:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\nd = collections.defaultdict(int)\nfor x in L: d[x] += 1\nL[:] = [x for x in L if d[x] == 1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This solution assumes that the list items are hashable, that is, that they're usable as indices into dicts, members of sets, etc."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "hashable", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The OP indicates they care about object IDENTITY and not VALUE (so for example two sublists both worth [1,2,3 which are equal but may not be identical would not be considered duplicates).", "If that's indeed the case then this code is usable, just replace d[x] with d[id(x)] in both occurrences and it will work for ANY types of objects in list L."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "[1,2,3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "d[x]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "d[id(x)]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Mutable objects (lists, dicts, sets, ...) are typically not hashable and therefore cannot be used in such ways.", "User-defined objects are by default hashable (with hash(x) == id(x)) unless their class defines comparison special methods (__eq__, __cmp__, ...) in which case they're hashable if and only if their class also defines a __hash__ method."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "hash(x) == id(x)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__eq__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__cmp__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__hash__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If list L's items are not hashable, but are comparable for inequality (and therefore sortable), and you don't care about their order within the list, you can perform the task in time O(N log N) by first sorting the list and then applying itertools.groupby (almost but not quite in the way another answer suggested)."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "are", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "O(N log N)", "childNum": 0, "tag": "code", "childList": []}, {"text": "itertools.groupby", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Other approaches, of gradually decreasing perfomance and increasing generality, can deal with unhashable sortables when you DO care about the list's original order (make a sorted copy and in a second loop check out repetitions on it with the help of bisect -- also O(N log N) but a tad slower), and with objects whose only applicable property is that they're comparable for equality (no way to avoid the dreaded O(N**2) performance in that maximally general case)."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "bisect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If the OP can clarify which case applies to his specific problem I'll be glad to help (and in particular, if the objects in his are ARE hashable, the code I've already given above should suffice;-)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"code": "<pre>\n<code>\n [x for x in the_list if the_list.count(x)==1]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Though that's still a nested loop behind the scenes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here's another dictionary oriented way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = [0, 1, 1, 2, 2]\nd = {}\nfor i in l: d[i] = d.has_key(i)\n\n[k for k in d.keys() if not d[k]]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; l = [0,1,1,2,2]\n&gt;&gt;&gt; [x for x in l if l.count(x) is 1]\n[0]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n l = [0,1,2,1,2]\ndef justonce( l ):\n    once = set()\n    more = set()\n    for x in l:\n        if x not in more:\n            if x in once:\n                more.add(x)\n                once.remove( x )\n            else:\n                once.add( x )\n    return once\n\nprint justonce( l )\n</code>\n</pre>\n", "senID": 0}], [{"text": ["In the same spirit as Alex's solution you can use a Counter/multiset (built in 2.7, recipe compatible from 2.5 and above) to do the same thing:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Counter", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/576611/"}]}, {"code": "<pre>\n<code>\n In [1]: from counter import Counter\n\nIn [2]: L = [0, 1, 1, 2, 2]\n\nIn [3]: multiset = Counter(L)\n\nIn [4]: [x for x in L if multiset[x] == 1]\nOut[4]: [0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think the actual timings are kind of interesting:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Alex' answer:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n python -m timeit -s \"l = range(1,1000,2) + range(1,1000,3); import collections\" \"d = collections.defaultdict(int)\" \"for x in l: d[x] += 1\" \"l[:] = [x for x in l if d[x] == 1]\"\n1000 loops, best of 3: 370 usec per loop\n</code>\n</pre>\n", "senID": 2}, {"text": ["Mine:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n python -m timeit -s \"l = range(1,1000,2) + range(1,1000,3)\" \"once = set()\" \"more = set()\" \"for x in l:\" \" if x not in more:\" \"  if x in once:\" \"   more.add(x)\" \"   once.remove( x )\" \"  else:\" \"   once.add( x )\"\n1000 loops, best of 3: 275 usec per loop\n</code>\n</pre>\n", "senID": 4}, {"text": ["sepp2k's O(n**2) version, to demonstrate why compexity matters ;-)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n python -m timeit -s \"l = range(1,1000,2) + range(1,1000,3)\" \"[x for x in l if l.count(x)==1]\"\n100 loops, best of 3: 16 msec per loop\n</code>\n</pre>\n", "senID": 6}, {"text": ["Roberto's + sorted:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n python -m timeit -s \"l = range(1,1000,2) + range(1,1000,3); import itertools\" \"[elem[0] for elem in itertools.groupby(sorted(l)) if elem[1].next()== 0]\"\n1000 loops, best of 3: 316 usec per loop\n</code>\n</pre>\n", "senID": 8}, {"text": ["mhawke's:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n python -m timeit -s \"l = range(1,1000,2) + range(1,1000,3)\" \"d = {}\" \"for i in l: d[i] = d.has_key(i)\" \"[k for k in d.keys() if not d[k]]\"\n1000 loops, best of 3: 251 usec per loop\n</code>\n</pre>\n", "senID": 10}, {"text": ["I like the last, clever and fast ;-)"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertool\nres = [elem[0] for elem in itertools.groupby(l) if elem[1].next() == 0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["should work.", "I do not know about its complexity, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; l = [0,1,1,2,2]\n&gt;&gt;&gt; [x for x in l if l.count(x) == 1]\n[0]\n</code>\n</pre>\n", "senID": 0}]]