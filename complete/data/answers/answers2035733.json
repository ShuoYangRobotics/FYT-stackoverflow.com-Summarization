[[{"text": ["\"When you install a new django application, you have to add/modify your settings.py module."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think this is fine as is. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I don't see any reason to change or modify this at all."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["What we do, however, is to \"subclass\" the core settings module."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Our developer-specific and installation-specific files have names like settings_devxy_linux2 and settings_checkout_win32, etc.  "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "settings_devxy_linux2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "settings_checkout_win32", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Each of these files starts with from settings import * to import the core settings and extend those core settings with overrides for a specific installation and platform."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "from settings import *", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It doesn't require any real work.", "It does, however, mean that we do most things with django-admin.py because our settings aren't called settings."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "django-admin.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "settings", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You might be interested in this solution; uses execfile() to load a series of settings files in order, where each file has full access to settings from previously-loaded files, to update, modify, etc."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this solution", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/wiki/SplitSettings#UsingalistofconffilesTransifex"}]}], [{"text": ["I've used this work-around:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["settings.py:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "settings.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n INSTALLED_APPS = ('whatever',)\nimport more_settings\nmore_settings.modify(globals())\n</code>\n</pre>\n", "senID": 2}, {"text": ["more_settings.py:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "more_settings.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def modify(settings):\n    settings['INSTALLED_APPS'] += ('another_app',)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Presumably the best way to \"merge\" varies, attributes by attributes.", "For example, given several tuples (from the INSTALLED_APPS of various submodules), you might simply concatenate them into a new tuple (for the INSTALLED_APPS attribute of the package as a whole), or, if possible duplications are a problem, so something smarter to remove the duplications (in this case you may not care about ordering, so simply tuple(set(tup1+tup2+tup3)) might suffice)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "INSTALLED_APPS", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "INSTALLED_APPS", "childNum": 0, "tag": "code", "childList": []}, {"text": "tuple(set(tup1+tup2+tup3))", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For other cases (\"merging\" dictionaries, \"merging\" settings which are just scalars or strings, etc) you'll need different strategies (maybe successive .update calls for the dictionaries, pick just one according to some criteria for the scalars or strings, etc, etc) -- I just don't see a \"one size fits all\" approach working here."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": ".update", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you prefer more magic than in my previous more_settings.modify() approach, try this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "more_settings.modify()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["settings.py:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "settings.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n INSTALLED_APPS = ('whatever',)\nimport more_settings\nmore_settings.modify(globals())\n</code>\n</pre>\n", "senID": 2}, {"text": ["more_settings.py:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "more_settings.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def config(INSTALLED_APPS=(), **other_settings):\n    INSTALLED_APPS += ('another_app',)\n    del other_settings\n    return locals()\n\ndef modify(settings):\n    settings.update(config(**settings))\n</code>\n</pre>\n", "senID": 4}, {"text": ["Pros: no need to refer to settings with dict notation"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Cons: must define modified settings as kwargs for config()"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "config()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["just put"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from base import *\nfrom admin import *\n...\n</code>\n</pre>\n", "senID": 1}, {"text": ["in ur init.py\nthat should work"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "init", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["i used it for different sites"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n base/settings.py # common settings: db, apps, ...\nbase/sites/website1/settings.py # site_id, custom middleware \nbase/sites/website2/settings.py # site_id, custom middleware\n</code>\n</pre>\n", "senID": 4}, {"text": ["the website settings import the common settings with"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from base.settings import *\n</code>\n</pre>\n", "senID": 6}, {"text": ["and define custom attribtues"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I have the same structure of settings files and I do the following to import the settings of the submodules:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def load_settings_file(file):\n    file = open(os.path.join(INSTALL_DIR, '&lt;projectname&gt;', 'settings', file + '.py'))\n    content = file.read()\n    file.close()\n    return content\n\nfor submodule in ['base', 'admin', 'feincms']:\n    exec(load_settings_file(submodule))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I created https://code.djangoproject.com/wiki/SplitSettings#SettingInheritancewithHierarchy as my preferred solution.", "Allows for inheritance from a common file in any deployment environment. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "https://code.djangoproject.com/wiki/SplitSettings#SettingInheritancewithHierarchy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://code.djangoproject.com/wiki/SplitSettings#SettingInheritancewithHierarchy"}]}]]