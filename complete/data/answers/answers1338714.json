[[{"text": ["For that purpose, lo that many years ago, I invented the simple Bunch idiom; one simple way to implement Bunch is:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Bunch", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Bunch", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class Bunch(object):\n  def __init__(self, adict):\n    self.__dict__.update(adict)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If config is a dict, you can't use config.account_receivable -- that's absolutely impossible, because a dict doesn't have that attribute, period.", "However, you can wrap config into a Bunch:"], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "config", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "config.account_receivable", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "have", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "can", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "config", "childNum": 0, "tag": "code", "childList": []}, {"text": "Bunch", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n cb = Bunch(config)\n</code>\n</pre>\n", "senID": 3}, {"text": ["and then access cb.config_account to your heart's content!"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "cb.config_account", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: if you want attribute assignment on the Bunch to also affect the original dict (config in this case), so that e.g.", "cb.foo = 23 will do config['foo'] = 23, you need a slighly different implementation of Bunch:"], "childNum": 8, "tag": "p", "senID": 5, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "attribute assignment", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "Bunch", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "config", "childNum": 0, "tag": "code", "childList": []}, {"text": "cb.foo = 23", "childNum": 0, "tag": "code", "childList": []}, {"text": "config['foo'] = 23", "childNum": 0, "tag": "code", "childList": []}, {"text": "Bunch", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class RwBunch(object):\n  def __init__(self, adict):\n    self.__dict__ = adict\n</code>\n</pre>\n", "senID": 6}, {"text": ["Normally, the plain Bunch is preferred, exactly because, after instantiation, the Bunch instance and the dict it was \"primed\" from are entirely decoupled -- changes to either of them do not affect the other; and such decoupling, most often, is what's desired."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "Bunch", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "because", "childNum": 0, "tag": "em", "childList": []}, {"text": "Bunch", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["When you do want \"coupling\" effects, then RwBunch is the way to get them: with it, every attribute setting or deletion on the instance will intrinsically set or delete the item from the dict, and, vice versa, setting or deleting items from the dict will intrinsically set or delete attributes from the instance."], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "do", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "RwBunch", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can do this with collections.namedtuple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import namedtuple\nconfig_object = namedtuple('ConfigClass', config.keys())(*config.values())\nprint config_object.account_receivable\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can learn more about namedtuple here:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://docs.python.org/dev/library/collections.html"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://docs.python.org/dev/library/collections.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/collections.html"}]}], [{"text": ["Have a look at http://stackoverflow.com/questions/1305532/convert-python-dict-to-object."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/questions/1305532/convert-python-dict-to-object", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1305532/convert-python-dict-to-object"}]}], [{"text": ["You need to use one of Python'sspecial methods."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "You need to use one of Python'sspecial methods.", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "special methods", "tag": "a"}]}, {"href": "http://docs.python.org/reference/datamodel.html#customizing-attribute-access", "text": "special methods", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n class config(object):\n    def __init__(self, data):\n        self.data = data\n    def __getattr__(self, name):\n        return self.data[name]\n\n\nc = config(data_dict)\nprint c.account_discount\n-&gt; 36\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Well, you could do it with a bunch of objects."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Config(object):\n    pass\n\nconfig = Config()\nconfig.account_receivable = 4\nprint config.account_receivable\n</code>\n</pre>\n", "senID": 1}, {"text": ["Obviously you can extend this class to do more for you.", "e.g.", "define __init__ so you can create it with arguments, and perhaps defaults."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["You could possibly also use a namedtuple (python 2.4/2.5 link).", "This is a data structure specifically designed to hold structured records."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "namedtuple", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html"}, {"text": "python 2.4/2.5 link", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/500261/"}]}, {"code": "<pre>\n<code>\n from collections import namedtuple\nConfig = namedtuple('Config', 'account_receivable account_payable')  # etc -- list all the fields\nc = Config(account_receivable='4', account_payable='5')\nprint c.account_receivable\n</code>\n</pre>\n", "senID": 4}, {"text": ["With namedtuples, you cannot change values once they have been set."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["You can subclass dict to return items from itself for undefined attributes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class AttrAccessibleDict(dict):\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError:    \n            return AttributeError(key)\n\nconfig = AttrAccessibleDict(config)\nprint(config.account_receivable)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You might also want to override some other methods as well, such as __setattr__, __delattr__, __str__, __repr__ and copy."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "__setattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__delattr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__str__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__repr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "copy", "childNum": 0, "tag": "code", "childList": []}]}]]