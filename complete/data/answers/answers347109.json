[[{"text": ["Here's my favorite approach to the \"family of related tests\".", "I like explicit subclasses of a TestCase that expresses the common features."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyTestF1( unittest.TestCase ):\n    theFunction= staticmethod( f1 )\n    def setUp(self):\n        self.matrix1 = numpy.ones((5,10))\n        self.matrix2 = numpy.identity(5)\n    def testOutputShape( self ):\n        \"\"\"Output of functions be of a certain shape\"\"\"\n        output = self.theFunction(self.matrix1, self.matrix2)\n        fail_message = \"%s produces output of the wrong shape\" % (self.theFunction.__name__,)\n        self.assertEqual(self.matrix1.shape, output.shape, fail_message)\n\nclass TestF2( MyTestF1 ):\n    \"\"\"Includes ALL of TestF1 tests, plus a new test.\"\"\"\n    theFunction= staticmethod( f2 )\n    def testUniqueFeature( self ):\n         # blah blah blah\n         pass\n\nclass TestF3( MyTestF1 ):\n    \"\"\"Includes ALL of TestF1 tests with no additional code.\"\"\"\n    theFunction= staticmethod( f3 )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Add a function, add a subclass of MyTestF1.", "Each subclass of MyTestF1 includes all of the tests in MyTestF1 with no duplicated code of any kind."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "MyTestF1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Unique features are handled in an obvious way.", "New methods are added to the subclass."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It's completely compatible with unittest.main()"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "unittest.main()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You could use a metaclass to dynamically insert the tests.", "This works fine for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import unittest\n\nclass UnderTest(object):\n\n    def f1(self, i):\n        return i + 1\n\n    def f2(self, i):\n        return i + 2\n\nclass TestMeta(type):\n\n    def __new__(cls, name, bases, attrs):\n        funcs = [t for t in dir(UnderTest) if t[0] == 'f']\n\n        def doTest(t):\n            def f(slf):\n                ut=UnderTest()\n                getattr(ut, t)(3)\n            return f\n\n        for f in funcs:\n            attrs['test_gen_' + f] = doTest(f)\n        return type.__new__(cls, name, bases, attrs)\n\nclass T(unittest.TestCase):\n\n    __metaclass__ = TestMeta\n\n    def testOne(self):\n        self.assertTrue(True)\n\nif __name__ == '__main__':\n    unittest.main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You don't have to use Meta Classes here.", "A simple loop fits just fine.", "Take a look at the example below:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import unittest\nclass TestCase1(unittest.TestCase):\n    def check_something(self, param1):\n        self.assertTrue(param1)\n\ndef _add_test(name, param1):\n    def test_method(self):\n        self.check_something(param1)\n    setattr(TestCase1, 'test_'+name, test_method)\n    test_method.__name__ = 'test_'+name\n\nfor i in range(0, 3):\n    _add_test(str(i), False)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Once the for is executed the TestCase1 has 3 test methods that are supported by both the nose and the unittest."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Metaclasses is one option.", "Another option is to use a TestSuite:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "TestSuite", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import unittest\nimport numpy\nimport funcs\n\n# get references to functions\n# only the functions and if their names start with \"matrixOp\"\nfunctions_to_test = [v for k,v in funcs.__dict__ if v.func_name.startswith('matrixOp')]\n\n# suplly an optional setup function\ndef setUp(self):\n    self.matrix1 = numpy.ones((5,10))\n    self.matrix2 = numpy.identity(5)\n\n# create tests from functions directly and store those TestCases in a TestSuite\ntest_suite = unittest.TestSuite([unittest.FunctionTestCase(f, setUp=setUp) for f in functions_to_test])\n\n\nif __name__ == \"__main__\":\nunittest.main()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Haven't tested.", "But it should work fine."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you're already using nose (and some of your comments suggest you are), why don't you just use Test Generators, which are the most straightforward way to implement parametric tests I've come across:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Test Generators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://somethingaboutorange.com/mrl/projects/nose/#test-generators"}]}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from binary_search import search1 as search\n\ndef test_binary_search():\n    data = (\n        (-1, 3, []),\n    \t(-1, 3, [1]),\n    \t(0,  1, [1]),\n    \t(0,  1, [1, 3, 5]),\n    \t(1,  3, [1, 3, 5]),\n    \t(2,  5, [1, 3, 5]),\n    \t(-1, 0, [1, 3, 5]),\n    \t(-1, 2, [1, 3, 5]),\n    \t(-1, 4, [1, 3, 5]),\n    \t(-1, 6, [1, 3, 5]),\n    \t(0,  1, [1, 3, 5, 7]),\n    \t(1,  3, [1, 3, 5, 7]),\n    \t(2,  5, [1, 3, 5, 7]),\n    \t(3,  7, [1, 3, 5, 7]),\n    \t(-1, 0, [1, 3, 5, 7]),\n    \t(-1, 2, [1, 3, 5, 7]),\n    \t(-1, 4, [1, 3, 5, 7]),\n    \t(-1, 6, [1, 3, 5, 7]),\n    \t(-1, 8, [1, 3, 5, 7]),\n    )\n\n    for result, n, ns in data:\n    \tyield check_binary_search, result, n, ns\n\ndef check_binary_search(expected, n, ns):\n    actual = search(n, ns)\n    assert expected == actual\n</code>\n</pre>\n", "senID": 2}, {"text": ["Produces:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n $ nosetests -d\n...................\n----------------------------------------------------------------------\nRan 19 tests in 0.009s\n\nOK\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The above metaclass code has trouble with nose because nose's wantMethod in its selector.py is looking at a given test method's __name__, not the attribute dict key."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__name__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To use a metaclass defined test method with nose, the method name and dictionary key must be the same, and prefixed to be detected by nose (ie with 'test_')."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # test class that uses a metaclass\nclass TCType(type):\n    def __new__(cls, name, bases, dct):\n        def generate_test_method():\n            def test_method(self):\n                pass\n            return test_method\n\n        dct['test_method'] = generate_test_method()\n        return type.__new__(cls, name, bases, dct)\n\nclass TestMetaclassed(object):\n    __metaclass__ = TCType\n\n    def test_one(self):\n        pass\n    def test_two(self):\n        pass\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If you look at it from the point of view that, if a test fails, that is critical and your entire package is invalid, then it doesn't matter that other elements won't get tested, because 'hey, you have an error to fix'."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Once that test passes, the other tests will then run."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Admittedly there is information to be gained from knowledge of which other tests are failing, and that can help with debugging, but apart from that, assume any test failure is an entire application failure."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I've read the above metaclass example, and I liked it, but it was missing two things:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I wrote this more complete example, which is data-driven, and in which the test function is itself unit-tested."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import unittest\n\nTEST_DATA = (\n    (0, 1),\n    (1, 2),\n    (2, 3),\n    (3, 5), # This intentionally written to fail\n)   \n\n\nclass Foo(object):\n\n  def f(self, n):\n    return n + 1\n\n\nclass FooTestBase(object):\n  \"\"\"Base class, defines a function which performs assertions.\n\n  It defines a value-driven check, which is written as a typical function, and\n  can be tested.\n  \"\"\"\n\n  def setUp(self):\n    self.obj = Foo()\n\n  def value_driven_test(self, number, expected):\n    self.assertEquals(expected, self.obj.f(number))\n\n\nclass FooTestBaseTest(unittest.TestCase):\n  \"\"\"FooTestBase has a potentially complicated, data-driven function.\n\n  It needs to be tested.\n  \"\"\"\n  class FooTestExample(FooTestBase, unittest.TestCase):\n    def runTest(self):\n      return self.value_driven_test\n\n  def test_value_driven_test_pass(self):\n    test_base = self.FooTestExample()\n    test_base.setUp()\n    test_base.value_driven_test(1, 2)\n\n  def test_value_driven_test_fail(self):\n    test_base = self.FooTestExample()\n    test_base.setUp()\n    self.assertRaises(\n        AssertionError,\n        test_base.value_driven_test, 1, 3)\n\n\nclass DynamicTestMethodGenerator(type):\n  \"\"\"Class responsible for generating dynamic test functions.\n\n  It only wraps parameters for specific calls of value_driven_test.  It could\n  be called a form of currying.\n  \"\"\"\n\n  def __new__(cls, name, bases, dct):\n    def generate_test_method(number, expected):\n      def test_method(self):\n        self.value_driven_test(number, expected)\n      return test_method\n    for number, expected in TEST_DATA:\n      method_name = \"testNumbers_%s_and_%s\" % (number, expected)\n      dct[method_name] = generate_test_method(number, expected)\n    return type.__new__(cls, name, bases, dct)\n\n\nclass FooUnitTest(FooTestBase, unittest.TestCase):\n  \"\"\"Combines generated and hand-written functions.\"\"\"\n\n  __metaclass__ = DynamicTestMethodGenerator\n\n\nif __name__ == '__main__':\n  unittest.main()\n</code>\n</pre>\n", "senID": 2}, {"text": ["When running the above example, if there's a bug in the code (or wrong test data), the error message will contain function name, which should help in debugging."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n .....F\n======================================================================\nFAIL: testNumbers_3_and_5 (__main__.FooUnitTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"dyn_unittest.py\", line 65, in test_method\n    self.value_driven_test(number, expected)\n  File \"dyn_unittest.py\", line 30, in value_driven_test\n    self.assertEquals(expected, self.obj.f(number))\nAssertionError: 5 != 4\n\n----------------------------------------------------------------------\nRan 6 tests in 0.002s\n\nFAILED (failures=1)\n</code>\n</pre>\n", "senID": 4}]]