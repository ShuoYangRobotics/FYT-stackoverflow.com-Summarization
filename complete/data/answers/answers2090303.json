[[{"text": ["A regex approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\ntwopairs = re.compile(r'(..)(..)')\nstringwithswappedwords = twopairs.sub(r'\\2\\1', basestring)\ntwoquads = re.compile(r'(....)(....)')\nstringwithswappedlongs = twoquads.sub(r'\\2\\1', stringwithswappedwords)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit:\nHowever, this is definitely not the fastest approach in Python -- here's how one finds out about such things: first, write all \"competing\" approaches into a module, here I'm calling it 'swa.py'...:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "'swa.py'", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\ntwopairs = re.compile(r'(..)(..)')\ntwoquads = re.compile(r'(....)(....)')\n\ndef withre(basestring, twopairs=twopairs, twoquads=twoquads):\n  stringwithswappedwords = twopairs.sub(r'\\2\\1', basestring)\n  return twoquads.sub(r'\\2\\1', stringwithswappedwords)\n\ndef withoutre(basestring):\n  asalist = list(basestring)\n  asalist.reverse()\n  for i in range(0, len(asalist), 2):\n    asalist[i+1], asalist[i] = asalist[i], asalist[i+1]\n  return ''.join(asalist)\n\ns = '12345678'\nprint withre(s)\nprint withoutre(s)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that I set s and try out the two approaches for a fast sanity check that they're actually computing the same result -- good practice, in general, for this kind of \"head to head performance races\"!"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Then, at the shell prompt, you use timeit, as follows:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'import swa' 'swa.withre(swa.s)'\n78563412\n78563412\n10000 loops, best of 3: 42.2 usec per loop\n$ python -mtimeit -s'import swa' 'swa.withoutre(swa.s)'\n78563412\n78563412\n100000 loops, best of 3: 9.84 usec per loop\n</code>\n</pre>\n", "senID": 6}, {"text": ["...and you find that in this case the RE-less approach is about 4 times faster, a worthwhile optimization.", "Once you have such a \"measurement harness\" in place, it's also easy to experiment with further alternative and tweaks for further optimization, if there is any need for \"really blazing speed\" in this operation, of course."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Edit: for example, here's an even faster approach (add to the same swa.py, with a final line of print faster(s) of course;-):"], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "swa.py", "childNum": 0, "tag": "code", "childList": []}, {"text": "print faster(s)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def faster(basestring):\n  asal = [basestring[i:i+2]\n          for i in range(0, len(basestring), 2)]\n  asal.reverse()\n  return ''.join(asal)\n</code>\n</pre>\n", "senID": 9}, {"text": ["This gives:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'import swa' 'swa.faster(swa.s)'\n78563412\n78563412\n78563412\n100000 loops, best of 3: 5.58 usec per loop\n</code>\n</pre>\n", "senID": 11}, {"text": ["About 5.6 microseconds, down from about 9.8 for the simplest RE-less approach, is another possibly-worthwhile micro-optimization."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["And so on, of course -- there's an old folk (pseudo)theorem that says that any program can be made at least one byte shorter and at least one nanosecond faster...;-)"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Edit: and to \"prove\" the pseudotheorem, here's a completely different approach (replace the end of swa.py)...:"], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "swa.py", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import array\ndef witharray(basestring):\n  a2 = array.array('H', basestring)\n  a2.reverse()\n  return a2.tostring()\n\ns = '12345678'\n# print withre(s)\n# print withoutre(s)\nprint faster(s)\nprint witharray(s)\n</code>\n</pre>\n", "senID": 15}, {"text": ["This gives:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'import swa' 'swa.witharray(swa.s)'\n78563412\n78563412\n100000 loops, best of 3: 3.01 usec per loop\n</code>\n</pre>\n", "senID": 17}, {"text": ["for a further possible-worthy speedup."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}], [{"code": "<pre>\n<code>\n import re\nre.sub(r'(..)(..)', r'\\2\\1', '12345678')\nre.sub(r'(....)(....)', r'\\2\\1', '34127856')\n</code>\n</pre>\n", "senID": 0}], [{"text": ["just for the string \"12345678\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from textwrap import wrap\ns=\"12345678\"\nt=wrap(s,len(s)/2)\na,b=wrap(t[0],len(t[0])/2)\nc,d=wrap(t[1],len(t[1])/2)\na,b=b,a\nc,d=d,c\nprint a+b+c+d\n</code>\n</pre>\n", "senID": 1}, {"text": ["you can make it to a generic function to do variable length string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["output"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n $ ./python.py\n34127856\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; re.sub(\"(..)(..)\",\"\\\\2\\\\1\",\"12345678\")\n'34127856'\n&gt;&gt;&gt; re.sub(\"(....)(....)\",\"\\\\2\\\\1\",\"34127856\")\n'78563412'\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If you want to do endianness conversion, use Python's struct module on the original binary data."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "endianness conversion", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/struct.html", "text": "struct module", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["If that is not your goal, here's a simple sample code to rearrange one 8 character string:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def wordpairswapper(s):\n    return s[6:8] + s[4:6] + s[2:4] + s[0:2]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Thanks to all the replies."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Thanks to all the replies.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If I'm not mistaken, withoutre() produces '21436587' when I run it, as opposed to"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["\"34127856\" which is my original desired result.", "I want to swap \"byte pairs\", not the order of the bytes."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]