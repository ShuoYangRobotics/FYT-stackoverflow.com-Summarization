[[{"text": ["You could do this with comprehensions only."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n delete_set = set(I for I in my_list if meet_requirement(I))\nanother_list.extend(transform(I) for I in delete_set)\n# or extend(transform(I) for I in my_list if I in delete_set), if duplicates/order matter\nmy_list = [I for I in my_list if I not in delete_set]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Not sure about pythonic, but if python had a partition function similar to haskell (or you could write a simple one yourself), the code wouldn't need to iterate over the original list twice (as in Cat Plus' solution)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "partition", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I would use something like the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n new_my_list, deleted_list = partition(my_list, meet_requirement)\ndeleted_list = [transform(e) for e in deleted_list]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You could do this to avoid the set:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def part(items, others):\n    for item in items:\n        if meet_requirement(item):\n            others.append(item)\n        else:\n            yield item\n\nmylist[:] = part(mylist, another_list)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["you could do this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i in reversed(xrange(len(my_list))):\n    if meet_requirement(my_list[i]):\n        another_list.append(transform(my_list.pop(i)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["then you might or might not want to reverse another_list (or you can use a deque and appendleft)"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "another_list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "deque", "childNum": 0, "tag": "code", "childList": []}, {"text": "appendleft", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; another_list = []\n&gt;&gt;&gt; new_list = []\n&gt;&gt;&gt; \n&gt;&gt;&gt; for item in my_list:\n...     (another_list if meet_requirement(item) else new_list).append(item)\n... \n&gt;&gt;&gt; another_list = map(transform, another_list)\n&gt;&gt;&gt; my_list = new_list\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n zipped = zip(*[(item, transform(item)) for item in my_list \\\n                                                if meet_requirement(item)])\nanother_list = zipped[1]\nmy_list = [item for item in my_list if item not in zipped[0]]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I needed something similar the other day:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def partition(pred, iterable):\n    result = ([], [])\n    for each in iterable:\n        result[pred(each)].append(each)\n    return result\n\nxs = some_list    \nys, xs[:] = partition(meet_some_requirement, xs)\nys = map(do_some_transformation, ys)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or this one-pass variation:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def partition_and_transform(pred, iterable, *transform):\n    result = ([], [])\n    for each in iterable:\n        v = pred(each)\n        result[v].append(transform[v](each))\n    return result\n\nys, xs[:] = partition_and_transform(meet_some_reqirement, xs, do_some_transformation, lambda x:x)\n</code>\n</pre>\n", "senID": 3}]]