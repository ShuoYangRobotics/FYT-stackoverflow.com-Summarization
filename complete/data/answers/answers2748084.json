[[{"text": ["MUDs actions are usually performed on 'ticks' rather than immediately - this allows for limited affect of latency and for monster's commands to be inserted in the queue and processed fairly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Personally, I don't like this approach, but pretty much 99% of MUDs use it.", "You need to design a robust command queue &amp; event queue which can handle both AI and user commands.", "You can then add \"virtual latency\" to AI commands which may be predefined or an average of all users latency, or whatever you like."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Well your AI-controlled entities have some sort of \"what am I going to do next?", "\" method, right?", "Just have that method return \"I'm busy, keep doing what I was doing\" result while another action is underway."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["E.g."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class ToughGuy(AI):\n   Action_Idle, Action_BroadswordSwing, Action_CastingMagic = range(3)\n\n   MagicRange = 10\n   MagicTime = 8\n   MeleeRange = 4\n   MeleeTime = 2\n\n   def __init__(self):\n      self.action = ToughGuy.Action_Idle\n      self.actiontimer = 0\n\n   def Update(self, timestep):\n      if self.actiontimer &lt;= 0:\n         self.action = ToughGuy.ActionIdle\n      else\n         self.actiontimer -= timestep\n\n      if self.action == ToughGuy.Action_Idle:\n         global player # don't do this\n         if self.AmIFacing(player):\n            distance = DistanceBetween(self, player)\n            if distance &lt; ToughGuy.MeleeRange:\n               self.action = ToughGuy.Action_BroadswordSwing\n               self.actiontimer = ToughGuy.MeleeTime\n            elif distance &lt; ToughGuy.MagicRange:\n               self.action = ToughGuy.Action_CastingMagic\n               self.actiontimer = ToughGuy.MagicTime\n</code>\n</pre>\n", "senID": 2}, {"text": ["etc.", "Sorry for the variable coding standards...  ;)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["AI's are clients."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["They're \"part of the server\" only in the most distant view.", "They're actually outside the main game engine.", "They're specialized clients with no human being. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["An AI client has the same interface with the server that a human's client would."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could use threads to handle specific types of Mobs, and put all the instances into an array of some sort.", "Then, the thread simply goes through the list repeatedly applying logic.", "DelayTimeStart and Delay could be attributes of the parent Mob class, and when the thread goes through the loop, it can put off processing any instances of the Mob in which there is time remaining in the delay."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["May be you'll find examples of realization here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 7, "lis": [{"text": ["Evennia MUD Server Alpha"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["Simple Python MUD"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}, {"text": ["Python MUD Game Example"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["Codebases at a glance"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}, {"text": ["16K MUD competition"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}, {"text": ["MUDServ"], "childNum": 0, "tag": "a", "senID": 6, "childList": []}, {"text": ["DjangoMUD"], "childNum": 0, "tag": "a", "senID": 7, "childList": []}]}], [{"text": ["A basic approach would be to have a data structure representing the evil monster's instance of its spell, with a cooldown timer on it.", "When the power is used, the cooldown is set (presumably to a number of seconds defined by the master definition of the spell); an attempt to use it again will fail just like with the player ability.", "This can be integrated with an event queue by having the queue check cooldown, and if it hasn't expired, to wait for it to expire, or abort the action, or reschedule the action, as appropriate."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]