[[{"text": ["Why convert them and use bit operations?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In Python, you can do all of this as a string."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for line in myFile:\n    key, value = line.split()\n    bits = list(value)\n    # bits will be a list of 1-char strings ['1','0','1',...]\n    # ... do stuff to bits ...\n    print key, \"\".join( value )\n</code>\n</pre>\n", "senID": 2}], [{"text": ["In python, you can convert to binary using int, specifying base 2.  ie:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; int('110111111',2)\n447\n</code>\n</pre>\n", "senID": 1}, {"text": ["To convert back, there is a bin function in python2.6 or 3, but not in python2.5, so you'd need to implement it yourself (or use something like the below):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "bin", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def bin(x, width):\n    return ''.join(str((x&gt;&gt;i)&amp;1) for i in xrange(width))[::-1]\n\n&gt;&gt;&gt; bin(447, 9)\n110111111\n</code>\n</pre>\n", "senID": 3}, {"text": ["(The width is the number of digits to pad to - your examples seem to be using 9-bit numbers."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["In C, you can use \"strtol(str, NULL, 2)\" to do the conversion, if you're already doing this in C."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Something like the following would work:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n FILE* f = fopen(\"myfile.txt\", \"r\");\nchar line[1024];\nwhile ((line = fgets(line, sizeof(line), f))\n{\n  char* p;\n  long column1 = strtol(line, &amp;p, 10);\n  long column2 = strtol(p, &amp;p, 2);\n  ...\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["You'll need to add error-handling, etc."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["\"Simple\" Perl one liner (replace foo bar baz quux with your flags"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n perl -le '@f=qw/foo bar baz quux/;$_&amp;&amp;print($f[$i]),$i++for split//, shift' 1011\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is a readable Perl version:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\n#flags that can be turned on and off, the first \n#flag is turned on/off by the left-most bit\nmy @flags = (\n    \"flag one\",\n    \"flag two\",\n    \"flag three\",\n    \"flag four\",\n    \"flag five\",\n    \"flag six\",\n    \"flag seven\",\n    \"flag eight\",\n);\n\n#turn the command line argument into individual\n#ones and zeros\nmy @bits = split //, shift; \n\n#loop through the bits printing the flag that\n#goes with the bit if it is 1\nmy $i = 0;\nfor my $bit (@bits) {\n    if ($bit) {\n    \tprint \"$flags[$i]\\n\";\n    }\n    $i++;\n}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Expanding on Brian's answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Get rid of the '----' line for simplicity\ndata_file = '''id       binary-coded-info\n4657     001001101\n4789     110111111\n'''\nimport cStringIO\nimport csv, sys\ndata = [] # A list for the row dictionaries (we could just as easily have used the regular reader method)\n# Read in the file using the csv module\n# Each row will be a dictionary with keys corresponding to the first row\nreader = csv.DictReader(cStringIO.StringIO(data_file), delimiter=' ', skipinitialspace = True)\ntry:\n    for row in reader:\n        data.append(row) # Add the row dictionary to the data list\nexcept csv.Error, e:\n    sys.exit('file %s, line %d: %s' % (filename, reader.line_num, e))\n# Do something with the bits\nfirst = int(data[0]['binary-coded-info'],2) # First bit string\nassert(first &amp; int('00001101',2) == int('1101',2)) # Bitwise AND\nassert(first | int('00001101',2) == int('1001101',2)) # Bitwise OR\nassert(first ^ int('00001101',2) == int('1000000',2)) # Bitwise XOR\nassert(~first == int('110110010',2)) # Binary Ones Complement\nassert(first &lt;&lt; 2 == int('100110100',2)) # Binary Left Shift\nassert(first &gt;&gt; 2 == int('000010011',2)) # Binary Right Shift\n</code>\n</pre>\n", "senID": 1}, {"text": ["See the python docs on expressions for more information and csv module for more information on the csv module."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "expressions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/expressions.html#binary-arithmetic-operations"}, {"href": "http://docs.python.org/library/csv.html#module-csv", "text": "csv module", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["thanks for all of your answers!", "I started learning python and will hopefully look into perl alongside.", "This was a great starting point!", "- Matt"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]