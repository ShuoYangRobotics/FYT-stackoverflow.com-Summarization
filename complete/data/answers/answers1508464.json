[[{"text": ["@gnosis, beware of all the well-intentioned responders saying you should measure the times: yes, you should (because programmers' instincts are often off-base about performance), but measuring a single case, as in all the timeit examples proffered so far, misses a crucial consideration -- big-O."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "but", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "timeit", "childNum": 0, "tag": "code", "childList": []}, {"text": "big-O", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Your instincts are correct: in general (with a very few special cases where recent Python releases can optimize things a bit, but they don't stretch very far), building a string by a loop of += over the pieces (or a reduce and so on) must be O(N**2) due to the many intermediate object allocations and the inevitable repeated copying of those object's content; joining, regular expressions, and the third option that was not mentioned in the above answers (write method of cStringIO.StringIO instances) are the O(N) solutions and therefore the only ones worth considering unless you happen to know for sure that the strings you'll be operating on have modest upper bounds on their length."], "childNum": 8, "tag": "p", "senID": 1, "childList": [{"text": "in general", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "childList": []}, {"text": "reduce", "childNum": 0, "tag": "code", "childList": []}, {"text": "O(N**2)", "childNum": 0, "tag": "code", "childList": []}, {"text": "write", "childNum": 0, "tag": "code", "childList": []}, {"text": "cStringIO.StringIO", "childNum": 0, "tag": "code", "childList": []}, {"text": "O(N)", "childNum": 0, "tag": "code", "childList": []}, {"text": "know", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["So what, if any, are the upper bounds in length on the strings you're processing?", "If you can give us an idea, benchmarks can be run on representative ranges of lengths of interest (for example, say, \"most often less than 100 characters but some % of the time maybe a couple thousand characters\" would be an excellent spec for this performance evaluation: IOW, it doesn't need to be extremely precise, just indicative of your problem space)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "representative", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["I also notice that nobody seems to follow one crucial and difficult point in your specs: that the strings are Python 2.5 multibyte, UTF-8 encoded, strs, and the insertions must happen only after each \"complete character\", not after each byte.", "Everybody seems to be \"looping on the str\", which give each byte, not each character as you so clearly specify."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "byte", "childNum": 0, "tag": "em", "childList": []}, {"text": "character", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["There's really no good, fast way to \"loop over characters\" in a multibyte-encoded byte str; the best one can do is to .decode('utf-8'), giving a unicode object -- process the unicode object (where loops do correctly go over characters!", "), then .encode it back at the end.", "By far the best approach in general is to only, exclusively use unicode objects, not encoded strs, throughout the heart of your code; encode and decode to/from byte strings only upon I/O (if and when you must because you need to communicate with subsystems that only support byte strings and not proper Unicode)."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".decode('utf-8')", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "do", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": ".encode", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So I would strongly suggest that you consider this \"best approach\" and restructure your code accordingly: unicode everywhere, except at the boundaries where it may be encoded/decoded if and when necessary only.", "For the \"processing\" part, you'll be MUCH happier with unicode objects than you would be lugging around balky multibyte-encoded strings!-)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Edit: forgot to comment on a possible approach you mention -- array.array.", "That's indeed O(N) if you are only appending to the end of the new array you're constructing (some appends will make the array grow beyond previously allocated capacity and therefore require a reallocation and copying of data, but, just like for list, a midly exponential overallocation strategy allows append to be amortized O(1), and therefore N appends to be O(N))."], "childNum": 7, "tag": "p", "senID": 6, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "array.array", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "if", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "appending", "childNum": 0, "tag": "em", "childList": []}, {"text": "but", "childNum": 0, "tag": "strong", "childList": []}, {"text": "append", "childNum": 0, "tag": "code", "childList": []}, {"text": "amortized", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["However, to build an array (again, just like a list) by repeated insert operations in the middle of it is O(N**2), because each of the O(N) insertions must shift all the O(N) following items (assuming the number of previously existing items and the number of newly inserted ones are proportional to each other, as seems to be the case for your specific requirements)."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "insert", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(N**2)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So, an array.array('u'), with repeated appends to it (not inserts!-), is a fourth O(N) approach that can solve your problem (in addition to the three I already mentioned: join, re, and cStringIO) -- those are the ones worth benchmarking once you clarify the ranges of lengths that are of interest, as I mentioned above."], "childNum": 8, "tag": "p", "senID": 8, "childList": [{"text": "array.array('u')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "append", "childNum": 0, "tag": "code", "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "childList": []}, {"text": "insert", "childNum": 0, "tag": "code", "childList": []}, {"text": "join", "childNum": 0, "tag": "code", "childList": []}, {"text": "re", "childNum": 0, "tag": "code", "childList": []}, {"text": "cStringIO", "childNum": 0, "tag": "code", "childList": []}, {"text": "those", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Try to build the result with the remodule.", "It will do the nasty concatenation under the hood, so performance should be OK.", "Example:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "remodule", "tag": "a", "pos": 0, "childList": [{"text": "re", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/re.html"}, {"text": "re", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n re.sub(r'(.)', r'\\1-', u'Nissim')\n\n count = 1\n def repl(m):\n     global count\n     s = m.group(1) + unicode(count)\n     count += 1\n     return s\n re.sub(r'(.)', repl, u'Nissim')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["this might be a python effective solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s1=\"Nissim\"\ns2=\"------\"\ns3=''.join([''.join(list(x)) for x in zip(s1,s2)])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["have you tested how slow it is or how fast you need, i think something like this will be fast enough"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = u\"\\u0960\\u0961\"\nss = ''.join(sum(map(list,zip(s,\"anurag\")),[]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["So try with simplest and if it doesn't suffice then try to improve upon it, C module should be last option"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: This is also the fastest"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import timeit\n\ns1=\"Nissim\"\ns2=\"------\"\n\ntimeit.f1=lambda s1,s2:''.join(sum(map(list,zip(s1,s2)),[]))\ntimeit.f2=lambda s1,s2:''.join([''.join(list(x)) for x in zip(s1,s2)])\ntimeit.f3=lambda s1,s2:''.join(i+j for i, j in zip(s1, s2))\n\nN=100000\n\nprint \"anurag\",timeit.Timer(\"timeit.f1('Nissim', '------')\",\"import timeit\").timeit(N)\nprint \"dweeves\",timeit.Timer(\"timeit.f2('Nissim', '------')\",\"import timeit\").timeit(N)\nprint \"SilentGhost\",timeit.Timer(\"timeit.f3('Nissim', '------')\",\"import timeit\").timeit(N)\n</code>\n</pre>\n", "senID": 4}, {"text": ["output is"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n anurag 1.95547590546\ndweeves 2.36131184271\nSilentGhost 3.10855625505\n</code>\n</pre>\n", "senID": 6}], [{"text": ["here are my timings.", "Note, it's py3.1"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s1\n'Nissim'\n&gt;&gt;&gt; s2 = '-' * len(s1)\n&gt;&gt;&gt; timeit.timeit(\"''.join(i+j for i, j in zip(s1, s2))\", \"from __main__ import s1, s2\")\n3.5249209707199043\n&gt;&gt;&gt; timeit.timeit(\"''.join(sum(map(list,zip(s1,s2)),[]))\", \"from __main__ import s1, s2\")\n5.903614027402\n&gt;&gt;&gt; timeit.timeit(\"''.join([''.join(list(x)) for x in zip(s1,s2)])\", \"from __main__ import s1, s2\")\n6.04072124013328\n&gt;&gt;&gt; timeit.timeit(\"''.join(i+'-' for i in s1)\", \"from __main__ import s1, s2\")\n2.484378367653335\n&gt;&gt;&gt; timeit.timeit(\"reduce(lambda x, y : x+y+'-', s1, '')\", \"from __main__ import s1; from functools import reduce\")\n2.290644129319844\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use Reduce."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; str = \"Nissim\"\n&gt;&gt;&gt; reduce(lambda x, y : x+y+'-', str, '')\n'N-i-s-s-i-m-'\n</code>\n</pre>\n", "senID": 1}, {"text": ["The same with numbers too as long as you know which char maps to which.", "[dict can be handy]"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mapper = dict([(repr(i), chr(i+ord('a'))) for i in range(9)])\n&gt;&gt;&gt; str1 = '0123'\n&gt;&gt;&gt; reduce(lambda x, y : x+y+mapper[y], str1, '')\n'0a1b2c3d'\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n string=\"\u2122\u00a1\u2122\u00a9\u20ac\"\nunicode(string,\"utf-8\")\ns2='-'*len(s1)\n''.join(sum(map(list,zip(s1,s2)),[])).encode(\"utf-8\")\n</code>\n</pre>\n", "senID": 0}]]