[[{"text": ["You could try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n spam_list = [spam_list[i] for i in spam_order]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can give a special key to the sort function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "key", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n order = dict(zip(spam_list, spam_order))\nspam_list.sort(key=order.get)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: As @ninjagecko points out in his answer, this is not really efficient, as it copies both lists to create the dictionary for the lookup.", "However, with the modified example given by the OP, this is the only way, because one has to build some index.", "The upside is that, at least for the strings, the values will not be copied, so the overhead is just that of the dictionary itself."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "his answer", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/6098250/is-there-a-nice-way-to-sort-a-list-using-a-list-of-indices/6098383#6098383"}]}], [{"text": ["There is ONLY ONE SOLUTION, that does exactly what you ask.", "Every single other solution is implicitly making a copy of one or both lists (or turning it into a dict, etc.).", "What you are asking for is a method which sorts two lists in-place, usingO(1)extra space, using one list as the keys of the other.", "I personally would just accept the extra space complexity, but if you really wanted to, you could do this:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "ONE", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Every single other solution is implicitly making a copy of one or both lists (or turning it into a dict, etc.).", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "usingO(1)extra space", "childNum": 1, "tag": "strong", "pos": 2, "childList": [{"text": "O(1)", "tag": "code"}]}, {"text": "O(1)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["(edit: it may be the case that the original poster doesn't really care about .sort because it's efficient, but rather because it modifies state; in general this is a dangerous thing to want and non-low-level languages attempt to avoid this and even ban it, but the solutions which use slice assignment will achieve \"in-place\" semantics)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": ".sort", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 4, "lis": [{"text": "Create a custom dictionary subclass (effectively a ", "tag": "none", "senID": 2}, {"text": "Indexing ", "tag": "none", "senID": 3}, {"text": "Assignment ", "tag": "none", "senID": 4}, {"text": "Use ", "tag": "none", "senID": 5}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python3\n\nclass LiveZip(list):\n    def __init__(self, list1, list2):\n        self.list1 = list1\n        self.list2 = list2\n\n    def __len__(self):\n        return len(self.list1)\n\n    def __getitem__(self, i):\n        return (self.list1[i], self.list2[i])\n\n    def __setitem__(self, i, tuple):\n        x1,x2 = tuple\n        self.list1[i] = x1\n        self.list2[i] = x2\n\nspam_list = [\"We\", \"are\", \"the\", \"knights\", \"who\", \"say\", \"Ni\"]\nspam_order = [0,1,2,4,5,6,3]\n\n#spam_list.magical_sort(spam_order)\nproxy = LiveZip(spam_order, spam_list)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Now let's see if it works..."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n #proxy.sort()\n#fail --&gt; oops, the internal implementation is not meant to be subclassed! lame\n# It turns out that the python [].sort method does NOT work without passing in\n# a list to the constructor (i.e. the internal implementation does not use the\n# public interface), so you HAVE to implement your own sort if you want to not\n# use any extra space. This kind of dumb. But the approach above means you can \n# just use any standard textbook in-place sorting algorithm:\ndef myInPlaceSort(x):\n    # [replace with in-place textbook sorting algorithm]\n</code>\n</pre>\n", "senID": 9}, {"text": ["NOW it works:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n myInPlaceSort(proxy)\n\nprint(spam_list)\n</code>\n</pre>\n", "senID": 11}, {"text": ["Unfortunately there is no way to just sort one list inO(1)space without sorting the other; if you don't want to sort both lists, you might as well do your original approach which constructs a dummy list."], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "there is no way to just sort one list inO(1)space without sorting the other", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "O(1)", "tag": "code"}]}, {"text": "O(1)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can however do the following:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["spam_list.sort(key=lambda x:x)"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "spam_list.sort(key=lambda x:x)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["but if the key or cmp functions makes any references to any collection (e.g.", "if you pass in a dict.__getitem__ of a dict you had to construct) this is no better than your original O(N)-space approach, unless you already happened to have such a dictionary lying around."], "childNum": 2, "tag": "p", "senID": 15, "childList": [{"text": "dict.__getitem__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "O(N)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Turns out this is a duplicate question of Python sort parallel arrays in place?", ", but that question also had no correct answers except this one , which is equivalent to mine but without the sample code.", "Unless you are incredibly optimized or specialized code, I'd just use your original solution, which is equivalent in space complexity to the other solutions."], "childNum": 2, "tag": "p", "senID": 16, "childList": [{"text": "Python sort parallel arrays in place?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2222769/python-sort-parallel-arrays-in-place"}, {"text": "this one", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2222769/python-sort-parallel-arrays-in-place/2222996#2222996"}]}, {"text": ["edit2:\nAs senderle pointed out, the OP doesn't want a sort at all, but rather wishes to, I think, apply a permutation.", "To achieve this, you can and SHOULD use simply indexing that other answers suggest [spam_list[i] for i in spam_order], but an explicit or implicit copy must be made still because you still need the intermediate data.", "(Unrelated and for the record, applying the inverse permutation is I think the inverse of parallel sorting with the identity, and you can use one to get the other, though sorting is less time-efficient.", "_,spam_order_inverse = parallelSort(spam_order, range(N)), then sort by spam_order_inverse.", "I leave the above discussion about sorting up for the record."], "childNum": 5, "tag": "p", "senID": 17, "childList": [{"text": "apply a permutation", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "[spam_list[i] for i in spam_order]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "_,spam_order_inverse = parallelSort(spam_order, range(N))", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "then", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "spam_order_inverse", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["edit3:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["It is possible, however, to achieve an in-place permutation in O(#cycles) space but with terrible time efficiency.", "Every permutation can be decomposed into disjoint permutations applied in parallel on subsets.", "These subsets are called cycles or orbits.", "The period is equal to their size.", "You thus take a leap of faith and do as follows:"], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "O(#cycles)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Create a temp variable.\n\nFor index i=0...N:\n    Put x_i into temp, assign NULL to x_i\n    Swap temp with x_p(i)\n    Swap temp with x_p(p(i))\n    ...\n    Swap temp with x_p(..p(i)..), which is x_i\n    Put a \"do not repeat\" marker on the smallest element you visited larger than i\n    Whenever you encounter a \"do not repeat\" marker, perform the loop again but\n      without swapping, moving the marker to the smallest element larger than i    \n    To avoid having to perform the loop again, use a bloom filter\n</code>\n</pre>\n", "senID": 20}, {"text": ["This will run in O(N^2) time and O(#cycles) place without a bloom filter, or ~O(N) time and O(#cycle + bloomfilter_space) space if you use them"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}], [{"code": "<pre>\n<code>\n map(lambda x:spam_list[x], spam_order)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If the issue is specifically in-placeness and not memory usage per se -- if you want this to have side effects, in other words -- then you could use slice assignment.", "Stealing from Peter Collingridge:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "in-placeness", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "Peter Collingridge", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/6098250/is-there-a-nice-way-to-sort-a-list-using-a-list-of-indices/6098306#6098306"}]}, {"code": "<pre>\n<code>\n other_spam_list = spam_list\nspam_list[:] = [spam_list[i] for i in spam_order]\nassert other_spam_list == spam_list\n</code>\n</pre>\n", "senID": 1}, {"text": ["It seems you might even be able to do this with a generator expression!", "But I suspect this still implicitly creates a new sequence of some sort -- probably a tuple.", "If it didn't, I think it would exhibit wrong behavior; but I tested it, and its behavior seemed correct. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n spam_list[:] = (spam_list[i] for i in spam_order)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Aha!", "See this excellent answer by the inimitable Sven Marnach -- generator slice assignment does indeed generate an implicit tuple.", "Which means it's safe, but not as memory efficient as you might think.", "Still, tuples are more memory efficient than lists, so the generator expression is preferable from that perspective."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Sven Marnach", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4948293/python-slice-assignment-memory-usage/4948508#4948508"}]}], [{"text": ["If you actually don't care about the efficiency at all, and just want in-place semantics (which is a bit odd, because there are entire programming languages dedicated to avoiding in-place semantics), then you can do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def modifyList(toModify, newList):\n    toModify[:] = newList\n\ndef permuteAndUpdate(toPermute, permutation):\n    modifyList(toPermute, [toPermute[i] for i in permutation])\n\npermuteAndUpdate(spam_list, spam_order)\n\nprint(spam_list)\n# ['We', 'are', 'the', 'Ni', 'knights', 'who', 'say']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Credit goes to senderle for recognizing that this is what the OP may actually be after; he should feel free to copy this answer into his own.", "Should not accept this answer unless you really prefer it over his."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]