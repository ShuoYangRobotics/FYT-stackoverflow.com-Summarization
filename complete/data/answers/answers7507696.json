[[{"text": ["I'd suggest you make a k-d tree.", "It's fast-ish, simple, and easy to implement:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "k-d tree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/K-d_tree"}]}, {"src": "http://i.stack.imgur.com/tJ9Gi.png", "tag": "img", "senID": 1}, {"text": ["And Wikipedia code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Node: pass\n\ndef kdtree(point_list, depth=0):\n    if not point_list:\n        return\n\n    # Select axis based on depth so that axis cycles through all valid values\n    k = len(point_list[0]) # assumes all points have the same dimension\n    axis = depth % k\n\n    # Sort point list and choose median as pivot element\n    point_list.sort(key=lambda point: point[axis])\n    median = len(point_list) // 2 # choose median\n\n    # Create node and construct subtrees\n    node = Node()\n    node.location = point_list[median]\n    node.left_child = kdtree(point_list[:median], depth + 1)\n    node.right_child = kdtree(point_list[median + 1:], depth + 1)\n    return node\n</code>\n</pre>\n", "senID": 3}, {"text": ["You'd have to slightly modify it, though, to fit within your constraints."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["How about Voronoi Diagram?", "It can be generated in O(n log n) using Fortunes algorithm. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Voronoi Diagram", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Voronoi_diagram"}, {"text": "O(n log n)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://en.wikipedia.org/wiki/Fortune%27s_algorithm", "text": "Fortunes algorithm", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["I don't know if it addresses your problem, but Voronoi Diagrams are very \"narural\".", "They are very common in the nature."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Example (from Wikipedia):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"src": "http://i.stack.imgur.com/3PleF.png", "tag": "img", "senID": 3}], [{"text": ["Because you are asking for a regular square grid of user-specified spacing, it sounds like a reasonably straightforward approach should work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Start by passing through the data to work out the minimum and maximum co-ordinate in each dimension.", "Work out the number of steps of user-specified spacing required to cover the distance between maximum and minimum."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Pass through the data again to allocate each point to a cell in the grid, using a grid with a point at the minimum of each co-ordinate and the specified spacing (e.g.", "X_cell = Math.floor((x_i - x_min) / spacing)).", "Use a dictionary or an array to record the number of points in each cell."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Now print out the co-ordinates of the cells with at least one point in them."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You do have some freedom that I have not attempted to optimise: unless the distance between minimum and maximum co-ordinate is an exact multiple of the grid spacing, there will be some slop that allows you to slide the grid around and still have it contain all the points: at the moment the grid starts at the position of the lowest point, but it probably ends before the highest points, so you have room to move it down a little in each dimension.", "As you do this, some points will move from cell to cell, and the number of occupied cells will change. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you consider only moves in one dimension at a time, you can work out what will happen reasonably efficiently.", "Work out the distance in that dimension between each point and the maximum co-ordinate in that dimension of its cell, and then sort these values.", "As you move the grid down, the point with the smallest distance to its maximum co-ordinate will swap cells first, and you can iterate through these points one by one by moving through them in sorted order.", "If you update the counts of points in cells as you do this you can work out which shift minimises the number of occupied cells."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Of course, you have three dimensions to worry about.", "You could work on them one at a time until you getting reductions in the number of cells.", "This is a local minimum, but may not be a global minimum.", "One way to look for other local minima is to start again from a randomly chosen starting point."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Find a minimum-area square that encloses all of the points.", "Repeatedly subdivide each square into 4 sub-squares (so going from 1 to 4 to 16 to 64 to \u2026).", "Stop just before one of the squares becomes empty.", "It's not hard to prove that the resulting grid is at most four times as coarse as the optimal solution (key insight: an empty square is guaranteed to contain at least one square from any grid at least twice as fine)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Probably that constant can be reduced by introducing a random translation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I have experience with grid clustering in 2D and implemented an example in C# code.", "http://kunuk.wordpress.com/2011/09/15/clustering-grid-cluster/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://kunuk.wordpress.com/2011/09/15/clustering-grid-cluster/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://kunuk.wordpress.com/2011/09/15/clustering-grid-cluster/"}]}, {"text": ["This can handle step handle step 1, 2 and 4.", "You will have to modify the code and update it to 3D-space.", "Hope this gives you some ideas."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The code runs in O(m*n) where m is number of grids and n is number of points."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you want the grid cells to be square and regular, you most likely want an Octree.", "If you can relax the square and regular constraint, you can make a k-d-tree. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Octree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Octree"}, {"text": "k-d-tree", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/K-d_tree"}]}]]