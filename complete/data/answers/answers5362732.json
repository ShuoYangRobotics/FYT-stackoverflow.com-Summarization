[[{"text": ["CPython (the main Python implementation) doesn't multi-thread.", "The GIL gets in the way.", "So you just have two threads running on one core (i.e.", "they don't run in parallel) but with all the context switching and other overhead a thread necesarily has.", "Note though:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "GIL", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/GlobalInterpreterLock"}]}, {"tag": "ul", "num": 2, "lis": [{"text": "Even if you do multi-thread, you're still limited by the number of cores. A dual-core computer can only do two computations at the same time, launching a thousand threads won't change that, no matter whether they're split between two cores or all run on one.", "tag": "none", "senID": 1}, {"text": "But running more threads than cores can still be useful if you're e.g. doing lots of I/O - the CPU is idle while it waits for the I/O to be completed anyway, so you're not limited by CPU time.", "tag": "none", "senID": 2}]}, {"text": ["Edit: From the comments it seems your computer is incapable of multi-threading anyway.", "Well, the above still holds."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The application is IO bound not CPU bound so multi-threading is not going to help."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, as noted 1,000 threads is not going to be productive, try smaller numbers, i.e.", "2 - 4, it is popular to try up to around 2 \u00d7 number of cores.", "Increasing the number of threads too high will result in the overhead of thread management causing the application to be significantly slower."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "2 \u00d7 number of cores", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["The multi-thread is usefull and efficient when you have to access to different ressources (files, network, user interface...) on the same time.", "In your code it seems to me that you access at only one ressource, a file, so the mutlti-thread is less efficient"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["David Beazley has done an excellent investigation of this phenomenon here.", "This is a video of the talk.", "In short, your threads are battling each other to send and respond to signals in order to acquire the GIL.", "And no, this does not only happen to CPU-bound threads, IO-bound threads suffer from the same problem too."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/python/UnderstandingGIL.pdf"}, {"text": "video", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pycon.blip.tv/file/3254256/"}]}], [{"text": ["I didn't read your code in details but test it on a multi-core computer, you will probably see an improvement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["One reason is that accessing one file at time can be actual much faster than accessing multiple files at same time, due to reading overhead.", "(you know disk has limited cache, and it is always best to read file as stream from beginning to end)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In anyway bottleneck is disk.", "And more treads you have asking for resources, the worst it gets."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]