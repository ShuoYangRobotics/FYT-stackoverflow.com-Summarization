[[{"tag": "ul", "num": 3, "lis": [{"text": ["Because it puts a lot of stuff into your namespace (might shadow some other object from previous import and you won't know about it). "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Because you don't know exactly what is imported and can't find place from what module certain thing was imported easily (readability). "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Because you can't use cool tools like pyflakes to detect statically errors in your code."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pyflakes", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}], [{"text": ["According to the Python Zen:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python Zen", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0020/"}]}, {"code": "<pre>\n<code>\n Explicit is better than implicit.\n</code>\n</pre>\n", "senID": 1}, {"text": ["... can't argue with that, surely?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["That is because you are polluting the namespace.", "You will import all the funtions and classes in your own namespace, which may clash with the functions you define yourself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Furthermore, I think using a qualified name is more clear for the maintenance task; you see on the code line itself where a function comes from, so you can check out the docs much more easily."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In module foo:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def myFunc():\n    print 1\n</code>\n</pre>\n", "senID": 3}, {"text": ["In your code:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from foo import *\n\ndef doThis():\n    myFunc() # Which myFunc is called?\n\ndef myFunc():\n    print 2\n</code>\n</pre>\n", "senID": 5}], [{"text": ["http://docs.python.org/tutorial/modules.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/tutorial/modules.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/modules.html"}]}], [{"text": ["You don't pass **locals() to functions, do you?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Since Python lacks an \"include\" statement, and the self parameter is explicit, and scoping rules are quite simple, it's usually very easy to point a finger at a variable and tell where that object comes from -- without reading other modules and without any kind of IDE (which are limited in the way of introspection anyway, by the fact the language is very dynamic)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "and", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["The import * breaks all that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also, it has a concrete possibility of hiding bugs."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import os, sys, foo, sqlalchemy, mystuff\nfrom bar import *\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now, if the bar module has any of the \"os\", \"mystuff\", etc... attributes, they will override the explicitly imported ones, and possibly point to very different things.", "Defining __all__ in bar is often wise -- this states what will implicitly be imported - but still it's hard to trace where objects come from, without reading and parsing the bar module and following its imports.", "A network of import * is the first thing I fix when I take ownership of a project."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "__all__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "its", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Don't misunderstand me: if the import * were missing, I would cry to have it.", "But it has to be used carefully.", "A good use case is to provide a facade interface over another module.", "Likewise, the use of conditional import statements, or imports inside function/class namespaces, requires a bit of discipline."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I think in medium-to-big projects, or small ones with several contributors, a minimum of hygiene is needed in terms of statical analysis -- running at least pyflakes or even better a properly configured pylint -- to catch several kind of bugs before they happen."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Of course since this is python -- feel free to break rules, and to explore -- but be wary of projects that could grow tenfold, if the source code is missing discipline it will be a problem."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["say you have the following code in a module called foo:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import ElementTree as etree\n</code>\n</pre>\n", "senID": 1}, {"text": ["and then in your own module you have:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from lxml import etree\nfrom foo import *\n</code>\n</pre>\n", "senID": 3}, {"text": ["You now have a difficult-to-debug module that looks like it has lxml's etree in it, but really has ElementTree instead."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "looks like", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["It is OK to do from ... import * in an interactive session."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "from ... import *", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]