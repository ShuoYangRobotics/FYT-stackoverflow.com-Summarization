[[{"text": ["huffnode_s isn't within itself, only pointers to huffnode_s are in there.", "Since a pointer is of known size, it's no problem."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "huffnode_s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pointers", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "huffnode_s", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["This."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Huffnode(object):\n    def __init__(self, zero, one, val, freq):\n        \"\"\"zero and one are Huffnode's, val is a 'char' and freq is a float.\"\"\"\n        self.zero = zero\n        self.one = one\n        self.val = val\n        self.freq = freq\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can then refactor your various C functions to be methods of this class."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Or maybe this."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from collections import namedtuple\nHuffnode = namedtuple( 'Huffnode', [ 'zero', 'one', 'val', 'freq' ] )\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you want your C functions to remain functions."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["That's it."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n h0 = Huffnode(None, None, 'x', 0.0)\nh1 = Huffnode(None, None, 'y', 1.0)\nh2 = Huffnode(h0, h1, 'z', 2.0)\n</code>\n</pre>\n", "senID": 7}, {"text": ["That's all that's required."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["it does not have a structure in itself.", "it has a pointer to that structure. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["in memory struct huffnode_s would look like (32 bit machine):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "struct huffnode_s", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["|------------------ huffnode_s* zero - 4 bytes --------------| "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["|------------------ huffnode_s* one - 4 bytes----------------| "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["|unsigned char val - 1 byte + 3 bytes padding=======| "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["|------------------- float freq - 4 bytes -------------------------|  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["these sizes would vary machine to machine, and how it looks in memory is decided by compiler ."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["As others have noted, the references to itself are simply pointers to other instances of that structure."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The pointers within the structure would allow one to connect instances together as a linked list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["(struct huffnode_s *) declares a pointer to another structure that includes same variables as the structure that it's declared in.", "See this question."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this question", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/35988/c-like-structures-in-python"}]}], [{"text": ["This is a pointer to a huffnode inside of a huffnode.", "What this means is that you can say:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n huffnode_t *node = ...;\nhuffnode_t *greatgreatgreatgrandchild = node-&gt;zero-&gt;zero-&gt;zero-&gt;zero-&gt;zero;\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will compile, and it will work as long as all those huffnode descendents are actually allocated and pointed to correctly."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Pointers are much like object references in JavaScript.", "They don't actually contain data, they just refer to it.", "Rest assured that you are not looking at an infinite type."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["To add to Carl's answer, the same thing in C++ is also possible:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Foo {\npublic:\n    Foo() {}\n\n    Foo *anotherFoo;\n};\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Note the above class is silly, but the point is you can have a pointer inside a class that is of the class type)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is known as a self referential structure and it is exactly what it sounds like: a structure which contains a reference to itself.", "A common occurrence of this is in a structure which describes a node for a linked list.", "Each node needs a reference to the next node in the chain. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n struct linked_list_node { \n    int data; \n    struct linked_list_node *next; // &lt;- self reference \n};\n</code>\n</pre>\n", "senID": 1}]]