[[{"text": ["1) Well, you can do the same thing in Java too:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import java.util.*;\nimport java.io.*;\n\n...\n\nInputStream x = ...;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Does InputStream come from java.util or java.io?", "Of course, you can choose not to use that feature."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "InputStream", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "java.util", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "java.io", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Now, in theory I realise this means when you're looking with a text editor, you can't tell where the types come from in C#... but in practice, I don't find that to be a problem.", "How often are you actually looking at code and can't use Visual Studio?"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "theory", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "actually", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["2) You can use the same convention in .NET too, of course - and I do, although I don't have empty directories going up the chain... so if I'm creating a project with a default namespace of X.Y, then X.Y.Foo would be in Foo.cs, and X.Y.Z.Bar would be in Z\\Bar.cs"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "X.Y.Foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Foo.cs", "childNum": 0, "tag": "code", "childList": []}, {"text": "Z\\Bar.cs", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["That's also what Visual Studio will do by default - if you create a subfolder, it will create new classes using a namespace based on the project default and the folder structure."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Of course, you can also declare types in any old file - but mostly people will follow the normal convention of declaring a type with a corresponding filename.", "Before generics made delegate declarations rarer, I used to have a Delegates.cs file containing all the delegate declarations for a particular namespace (rather than having a bunch of single-declaration files) but these days that's less of an issue."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "mostly", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "Delegates.cs", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Essentially, you don't - but IntelliSense is helping.", "You cannot actually be sure by just taking a quick glance at the code, but you can hover over the symbol with your cursor, for example.", "But this is also possible in Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from foobar import *\nfrom bazbaz import *\n\na_bar = Bar()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Where does Bar come from now?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["No, assemblies do not correspond to directory structures, which, IMHO, is a good thing.", "The solution explorer is offering a view of all the references added to your project.", "These references being assemblies, have a concrete representation as a PE file somewhere on your machine.", "You can easily look at the properties of a reference to see where the physical file is located."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit: In order not to contradict other answers in this thread and create confusion: What I mean by saying assembly names do not correspond to directory names is that it is not actually enforced."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["I don\u2019t know about other projects but I\u2019m pretty sure that in every .NET project I have worked on, we used this convention, i.e.", "namespaces always corresponded to folder names (except for the outermost namespace(s) which correspond to the assembly from which the namespace comes)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["1) You're right.", "There is no \"direct\" way to know where your class comes from at first glance, but, as you said, you can jump to it in the IDE.", "But declaring the class this way is just the shortest way to do it.", "If you wanted, and assuming your Bar class comes from the Foo one, you could declare it"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n private foo.Bar myBar = new foo.Bar();\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way it would help knowing where your classes come from at first look."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["2)When you add a reference to your class, the Add reference windows gives you the informations you are looking for.", "And if you want to know where they come from after you declared it, there is a window named \"Solution Explorer\" where you can find these informations, under the \"References\" tree node.", "You can set it to be always visible (which it is by default)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Usually, the tooltip when you mouse-over the type name reveals some extra information.", "Else you could always right-click the type name, and 'Go to definition'."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["For Java and Python this is indeed an issue with conventions - import the class you need, not the entire package using wildcards."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In C# you can't do a using directive for the specific class you want, since it only works for namespaces (as the following error reveals).", "It would seem that C# remained true to the C++ concept of namespaces, and merged it with the #include directive for one easy way of referencing external classes."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "using", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "#include", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\nusing System.Net.Sockets.Socket; // Gives the following error:\n\n// A using namespace directive can only be applied to namespaces; \n// 'System.Net.Sockets.Socket' is a type not a namespace\n</pre>\n", "senID": 2}, {"text": ["And about the double Bar deceleration, it's simple - if the compiler has no way of knowing it will give an error:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Bar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\nusing Foo; // Has class Bar {}\nusing Goo; // Has class Bar {}\n\nBar b = new Bar(); // Gives the following error:\n// 'Bar' is an ambiguous reference between 'Foo.Bar' and 'Goo.Bar'\n</pre>\n", "senID": 4}]]