[[{"text": ["if you indeed have only such simple strings to parse you don't need regular expression.", "you can just partition on = and strip (or even lstrip) last element of a resulting tuple:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "=", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; case = 'str = str2'\n&gt;&gt;&gt; case.partition('=')[2].lstrip()\n'str2'\n</code>\n</pre>\n", "senID": 1}, {"text": ["it'll be much faster than regexps.", "and just to show how fast i've made a simple test:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit.timeit(\"'str1 = str2 '.partition('=')[2].strip()\")\n0.49051564213846177\n&gt;&gt;&gt; timeit.timeit(\"'str1 = str2 '.split('=')[1].strip()\")\n0.97673281637025866\n&gt;&gt;&gt; timeit.timeit('import re')\n0.65663786250422618\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n re.search(r'=\\s*(.*)', 'str = str2').group(1)\n</code>\n</pre>\n", "senID": 0}, {"text": ["or if you just want a single word:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n re.search(r'=\\s*(\\w+)', 'str = str2').group(1)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Extended to specific initial string:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n re.search(r'\\bstr\\s*=\\s*(\\w+)', 'str=str2').group(1)\n</code>\n</pre>\n", "senID": 4}, {"text": ["\\b = word boundary, so won't match \"somestr=foo\" "], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "\\b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"somestr=foo\"", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It would be quicker to go trough all options once, instead of searching for single options one at the time:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n option_str = \"a=b, c=d, g=h\"\noptions = dict(re.findall(r'(\\w+)\\s*=\\s*(\\w+)', option_str))\noptions['c']  # -&gt; 'd'\n</code>\n</pre>\n", "senID": 7}], [{"text": ["If your data is fixed then you can do this without using regex.", "Just split it on '='.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; case1 = \"str1=str2\"\n&gt;&gt;&gt; case2 = \"str1 = str2\"\n\n&gt;&gt;&gt; str2 = case1.split('=')[1].strip()\n&gt;&gt;&gt; str2 = case2.split('=')[1].strip()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This YOURCASE.split('=')[1].strip() statement will work for any cases."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "YOURCASE.split('=')[1].strip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Simply use split function"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think a regex is overkill if you only want to deal with the above two cases.", "Here's what I'd do-"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; case1 = \"str1=str2\"\n&gt;&gt;&gt; case2 = \"str1 = str2\"\n&gt;&gt;&gt; case2.split()\n['str1', '=', 'str2']\n&gt;&gt;&gt; ''.join(case2.split())\n'str1=str2'\n&gt;&gt;&gt; case1[5:]\n'str2'\n&gt;&gt;&gt; ''.join(case2.split())[5:]\n'str2'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Assumption"], "childNum": 1, "tag": "h2", "senID": 2, "childList": [{"text": "Assumption", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I assume you are looking for the specific token 'str1'.", "I also assume that str1 can be assigned different values.", "Something like what you'd have in a configuration file => propertyName = value."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This is just my opinion."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I knew that other ways were possible!", "SilentGhost gives a nice (better!", ") alternative."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Hope this helps."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Expanding on @batbrat's answer, and the other suggestions, you can use re.split() to separate the input string.", "The pattern can use \\s (whitespace) or an explicit space."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "re.split()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\s", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; c1=\"str1=str2\"\n&gt;&gt;&gt; c2=\"str1 = str2\"\n&gt;&gt;&gt; re.split(' ?= ?',c1)\n['str1', 'str2']\n&gt;&gt;&gt; re.split(' ?= ?',c2)\n['str1', 'str2']\n&gt;&gt;&gt; re.split(r'\\s?=\\s?',c1)\n['str1', 'str2']\n&gt;&gt;&gt; re.split(r'\\s?=\\s?',c2)\n['str1', 'str2']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Two cases:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["(case 1) if there is a single space before the '=', then there must also be a single space after the '='"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "must", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["(case 2) otherwise,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]}, {"text": ["In the first case, you could also use the \"(?P=\u2026\" construct for the second space or lack of it, but it still wouldn't work for a positive lookbehind assertion, since it wouldn't be a constant length subexpression."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "positive lookbehind assertion", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Related idea: I find using graphical regular expression tool helpful when trying to figure out correct pattern: http://kodos.sf.net."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://kodos.sf.net", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://kodos.sf.net"}]}]]