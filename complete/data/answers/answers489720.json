[[{"text": ["I use decorators mainly for timing purposes"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def time_dec(func):\n\n  def wrapper(*arg):\n      t = time.clock()\n      res = func(*arg)\n      print func.func_name, time.clock()-t\n      return res\n\n  return wrapper\n\n\n@time_dec\ndef myFunction(n):\n    ...\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I've used them for synchronization."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def synchronized(lock):\n    \"\"\" Synchronization decorator. \"\"\"\n\n    def wrap(f):\n        def newFunction(*args, **kw):\n            lock.acquire()\n            try:\n                return f(*args, **kw)\n            finally:\n                lock.release()\n        return newFunction\n    return wrap\n</code>\n</pre>\n", "senID": 1}, {"text": ["You then use it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import threading\nlock = threading.Lock()\n\n@synchronized(lock)\ndef do_something():\n  # etc\n\n@synchronzied(lock)\ndef do_something_else():\n  # etc\n</code>\n</pre>\n", "senID": 3}, {"text": ["Basically it just puts lock.acquire() / lock.release() on either side of the function call."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Decorators are used for anything that you want to transparently \"wrap\" with additional functionality."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Django uses them for wrapping \"login required\" functionality on view functions, as well as for registering filter functions."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "\"login required\" functionality on view functions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/topics/auth/?from=olddocs#the-login-required-decorator"}, {"href": "http://docs.djangoproject.com/en/dev/howto/custom-template-tags/#registering-custom-filters", "text": "registering filter functions", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["You can use class decorators for adding named logs to classes."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "adding named logs to classes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/401277/naming-python-loggers#402471"}]}, {"text": ["Any sufficiently generic functionality that you can \"tack on\" to an existing class or function's behavior is fair game for decoration."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["There's also a discussion of use cases on the Python-Dev newsgroup pointed to by PEP 318 -- Decorators for Functions and Methods."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "discussion of use cases on the Python-Dev newsgroup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-dev/2004-April/044132.html"}, {"href": "http://www.python.org/dev/peps/pep-0318/#background", "text": "PEP 318 -- Decorators for Functions and Methods", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Here is very good tutorial with good examples"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Bruce Eckel on Decorators"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Bruce Eckel on Decorators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=240808"}]}, {"text": ["Example : A Decorator-Based Build System"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Example : A Decorator-Based Build System", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=241209"}]}, {"text": ["I found the article very useful."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I use decorators for type checking parameters which are passed to my Python methods via some RMI.", "So instead of repeating the same parameter counting, exception-raising mumbo-jumbo again and again"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def myMethod(ID, name):\n    if not (myIsType(ID, 'uint') and myIsType(name, 'utf8string')):\n        raise BlaBlaException() ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["I just declare"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @accepts(uint, utf8string)\ndef myMethod(ID, name):\n    ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["and accepts() does all the work for me."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The Twisted library uses decorators combined with generators to give the illusion that an asynchronous function is synchronous.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @inlineCallbacks\ndef asyncf():\n    doStuff()\n    yield someAsynchronousCall()\n    doStuff()\n    yield someAsynchronousCall()\n    doStuff()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Using this, code that would have been broken up into a ton of little callback functions can be written quite naturally as a single block, making it a lot easier to understand and maintain."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["For nosetests, you can write a decorator that supplies a unit test function or method with several sets of parameters:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @parameters(\n   (2, 4, 6),\n   (5, 6, 11),\n)\ndef test_add(a, b, expected):\n    assert a + b == expected\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Recently, While working on social networking web application.", "For Community/Groups, i was suppose to give membership authorization to create new discussion and reply to a message you have to be the member of that particular group.", "So, I wrote a decorator @membership_required and put that where i required in my view.", "Python decorators are really powerful.", "It depends on your requirement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I use them mainly for debugging (wrapper around a function that prints its arguments and result) and verification (e.g.", "to check if an argument is of correct type or, in the case of web application, if the user has sufficient privileges to call a particular method)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I've actually recently had one of those \"A-ha!", "\" moments, as you call them, and used a decorator to enable me to profile decorated functions/methods only.", "It's the profile_func decorator in this file, the output of which can be viewed in KCacheGrind.", "Very useful indeed."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "this file", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "https://translate.svn.sourceforge.net/svnroot/translate/src/trunk/virtaal/devsupport/profiling.py"}, {"text": "KCacheGrind", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://kcachegrind.sourceforge.net/"}]}], [{"text": ["Decorators are used either to define a function's properties or as boilerplate that alters it; it's possible but counter-intuitive for them to return completely different functions.", "Looking at the other responses here, it seems like one of the most common uses is to limit the scope of some other process - be it logging, profiling, security checks, etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["CherryPy uses object-dispatching to match URLs to objects and, eventually, methods.", "Decorators on those methods signal whether or not CherryPy is even allowed to use those methods.", "For example, adapted from the tutorial:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "allowed", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "the tutorial", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.cherrypy.org/wiki/CherryPyTutorial"}]}, {"code": "<pre>\n<code>\n class HelloWorld:\n\n    ...\n\n    def secret(self):\n        return \"You shouldn't be here.\"\n\n    @cherrypy.expose\n    def index(self):\n        return \"Hello world!\"\n\ncherrypy.quickstart(HelloWorld())\n</code>\n</pre>\n", "senID": 2}], [{"text": ["There are a number of suggested usages and snippets at the Python wiki."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python wiki", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonDecoratorLibrary"}]}], [{"text": ["I am using the following decorator for making a function threadsafe.", "It makes the code more readable.", "It is almost similar to the one proposed by John Fouhy but the difference is that one work on a single function and that there is no need to create a lock object explicitely. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def threadsafe_function(fn):\n    \"\"\"decorator making sure that the decorated function is thread safe\"\"\"\n    lock = threading.Lock()\n    def new(*args, **kwargs):\n        lock.acquire()\n        try:\n            r = fn(*args, **kwargs)\n        except Exception as e:\n            raise e\n        finally:\n            lock.release()\n        return r\n    return new\n\nclass X:\n    var = 0\n\n    @threadsafe_function     \n    def inc_var(self):\n        X.var += 1    \n        return X.var\n</code>\n</pre>\n", "senID": 1}]]