[[{"code": "<pre>\n<code>\n import string\n\nallowed = set(string.lowercase + ',')\nif set(text) - allowed:\n   # you know it has forbidden characters\nelse:\n   # it doesn't have forbidden characters\n</code>\n</pre>\n", "senID": 0}, {"text": ["Doing it with sets will be faster than doing it with for loops (especially if you want to check more than one text) and is all together cleaner than regexes for this situation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["an alternative that might be faster than two sets, is "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n allowed = string.lowercase + ','\nif not all(letter in allowed for letter in text):\n    # you know it has forbidden characthers\n</code>\n</pre>\n", "senID": 3}, {"text": ["here's some meaningless mtimeit results.", "one is the generator expression and two is the set based solution."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "mtimeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "one", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "two", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'import scratch3' 'scratch3.one(\"asdfas2423452345sdfadf34\")'\n100000 loops, best of 3: 3.98 usec per loop\n$ python -mtimeit -s'import scratch3' 'scratch3.two(\"asdfas2423452345sdfadf34\")'\n100000 loops, best of 3: 4.39 usec per loop\n$ python -mtimeit -s'import scratch3' 'scratch3.two(\"asdfasasdfadsfasdfasdfdaf\")'\n100000 loops, best of 3: 3.51 usec per loop\n$ python -mtimeit -s'import scratch3' 'scratch3.one(\"asdfasasdfadsfasdfasdfdaf\")'\n100000 loops, best of 3: 7.7 usec per loop\n</code>\n</pre>\n", "senID": 5}, {"text": ["You can see that the setbased one is significantly faster than the generator expression with a small expected alphabet and success conditions.", "the generator expression is faster with failures because it can bail.", "This is pretty much whats to be expected so it's interesting to see the numbers back it up."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["another possibility that I forgot about is the hybrid approach."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n not all(letter in allowed for letter in set(text))\n\n$ python -mtimeit -s'import scratch3' 'scratch3.three(\"asdfasasdfadsfasdfasdfdaf\")'\n100000 loops, best of 3: 5.06 usec per loop\n$ python -mtimeit -s'import scratch3' 'scratch3.three(\"asdfas2423452345sdfadf34\")'\n100000 loops, best of 3: 6.71 usec per loop\n</code>\n</pre>\n", "senID": 8}, {"text": ["it slows down the best case-ish but speeds up the worst case-ish.", "All in all, you'd have to test the different possibilities over a sample of your expected input.", "the broader the sample, the better.  "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"code": "<pre>\n<code>\n import re\ndef matches(s):\n    return re.match(\"^[a-z,]*$\", s) is not None\n</code>\n</pre>\n", "senID": 0}, {"text": ["Which gives you:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; matches(\"tea and cakes\")\nFalse\n&gt;&gt;&gt; matches(\"twiddledee,twiddledum\")\nTrue\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can optimise a bit with re.compile:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import re\nmatcher = re.compile(\"^[a-z,]*$\")\ndef matches(s):\n    return matcher.match(s) is not None\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n import re\n\nif not re.search('[^a-z\\,]', yourString):\n    # True: contains only a-z and comma\n    # False: contains also something else\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Not sure what do you mean with \"contain\", but this should go in your direction:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n reobj = re.compile(r\"[a-z,]+\")\nmatch = reobj.search(subject)\nif match:\n    result = match.group()\nelse\n    result = \"\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def alllower(s):\n    if ',' in s:\n        s=s.replace(',','a')\n    return s.isalpha() and s.islower()\n</code>\n</pre>\n", "senID": 1}, {"text": ["with most efficient and simple."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["or in one line:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n lambda s:s.isalpha() or (',' in s and s.replace(',','a').isalpha()) and s.islower()\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport string\n\ntext = 'aasdfadf$oih,234'\n\nfor letter in text:\n    if letter not in string.ascii_lowercase and letter != ',':\n        print letter\n</code>\n</pre>\n", "senID": 0}], [{"text": ["characters a -z are represented by bytes 97 - 122 and ord(char) returns the byte value of the character.", "Reading the file in binary and making the match should suffice."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open(\"myfile\", \"rb\")\nretVal = False\nlowerAlphabets = range(97, 123)\ntry:\n    byte = f.read(1)\n    while byte != \"\":\n        # Do stuff with byte.\n        byte = f.read(1)\n        if byte:\n            if ord(byte) not in lowerAlphabets:\n                retVal = True\n                break\n\nfinally:\n    f.close()\n    if retVal:\n        print \"characters not from a - z\"\n    else:\n        print \"characters from a - z\"\n</code>\n</pre>\n", "senID": 1}]]