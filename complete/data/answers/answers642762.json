[[{"text": ["As Miya mentioned, you can replace the decorator with another function any point before the interpreter gets to that function declaration.", "However, once the decorator is applied to the function, I don't think there is a way to dynamically replace the decorator with a different one.", "So for example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @aDecorator\ndef myfunc1():\n    pass\n\n# Oops! I didn't want that decorator after all!\n\nmyfunc1 = bDecorator(myfunc1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Won't work, because myfunc1 is no longer the function you originally defined; it has already been wrapped.", "The best approach here is to manually apply the decorators, oldskool-style, i.e:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def myfunc1():\n    pass\n\nmyfunc2 = aDecorator(myfunc1)\nmyfunc3 = bDecorator(myfunc1)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: Or, to be a little clearer,"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def _tempFunc():\n    pass\n\nmyfunc1 = aDecorator(_tempFunc)\nmyfunc1()\nmyfunc1 = bDecorator(_tempFunc)\nmyfunc1()\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here's a terrific recipe to get you started.", "Basically, the idea is to pass a class instance into the decorator.", "You can then set attributes on the class instance (make it a Borg if you like) and use that to control the behavior of the decorator itself."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "recipe to get you started", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/528929/"}]}, {"text": ["Here's an example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Foo:\n    def __init__(self, do_apply):\n        self.do_apply = do_apply\n\ndef dec(foo):\n    def wrap(f):\n        def func(*args, **kwargs):\n            if foo.do_apply:\n                # Do something!\n                pass \n            return f(*args, **kwargs)\n        return func\n    return wrap\n\nfoo = Foo(False)\n@dec(foo)\ndef bar(x):\n    return x\n\nbar('bar') \nfoo.do_apply = True \n# Decorator now active!\nbar('baz')\n</code>\n</pre>\n", "senID": 2}, {"text": ["Naturally, you can also incorporate the \"decorator decorator\" to preserve signatures, etc."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I don't know if there's a way to \"replace\" a decorator once it has been applied, but I guess that probably there's not, because the function has already been changed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You might, anyway, apply a decorator at runtime based on some condition:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nclass PrintCallInfo:\n    def __init__(self,f):\n        self.f = f\n    def __call__(self,*args,**kwargs):\n        print \"--&gt;\",self.f.__name__,args,kwargs\n        r = self.f(*args,**kwargs)\n        print \"&lt;--\",self.f.__name__,\"returned: \",r\n        return r\n\n# the condition to modify the function...\nsome_condition=True\n\ndef my_decorator(f):\n    if (some_condition): # modify the function\n        return PrintCallInfo(f)\n    else: # leave it as it is\n        return f\n\n@my_decorator\ndef foo():\n    print \"foo\"\n\n@my_decorator\ndef bar(s):\n    print \"hello\",s\n    return s\n\n@my_decorator\ndef foobar(x=1,y=2):\n    print x,y\n    return x + y\n\nfoo()\nbar(\"world\")\nfoobar(y=5)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If you want to explicitely change the decorator, you might as well choose a more explicit approach instead of creating a decorated function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n deco1(myfunc1, arg1, arg2)\ndeco2(myfunc1, arg2, arg3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["deco1() and deco2() would apply the functionality your decorators provide and call myfunc1() with the arguments."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Sure - you can get the function object and do whatever you want with it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Bypass a decorator\n\nimport types\n\nclass decorator_test(object):\n\n    def __init__(self, f):\n        self.f = f\n\n    def __call__(self):\n        print \"In decorator ... entering: \", self.f.__name__\n        self.f()\n        print \"In decorator ... exiting: \", self.f.__name__\n\n\n@decorator_test\ndef func1():\n    print \"inside func1()\"\n\nprint \"\\nCalling func1 with decorator...\"\nfunc1()\n\nprint \"\\nBypassing decorator...\"\nfor value in func1.__dict__.values():\n    if isinstance(value, types.FunctionType) and value.func_name == \"func1\":\n        value.__call__()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If the decorator is a function, just replace it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n aDecorator = otherDecorator\n</code>\n</pre>\n", "senID": 1}]]