[[{"text": ["@richard-levasseur"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I agree, sed seems like the right way to go.", "Here's a rough cut at what the OP describes:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "sed", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n sed -i -e's/&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;/\"/g' foo.txt\n</code>\n</pre>\n", "senID": 2}, {"text": ["This will do the replacement in-place in the existing foo.txt.", "For that reason, I recommend having the original file under some sort of version control; any of the DVCS should fit the bill."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "foo.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Yes, open() treats the file as a stream, as does readline().", "It'll only read the next line.", "If you call read(), however, it'll read everything into memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Your example code looks ok at first glance.", "Almost every solution will require you to copy the file elsewhere.", "Its not exactly easy to modify the contents of a file inplace without a 1:1 replacement."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It may be faster to use some standard unix utilities (awk and sed most likely), but I lack the unix and bash-fu necessary to provide a full solution."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "may", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["It's only wasteful if you don't have disk to spare.", "That is, fix it when it's a problem.", "Your solution looks ok as a first attempt."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's not wasteful of memory because a file handler is a stream."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Reading lines is simply done using a file iterator:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "file iterator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#file.next"}]}, {"code": "<pre>\n<code>\n for line in fin:\n       if line.contains(\"&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;\"):\n           fout.writeline(\"\\\"\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also consider the CSV writer object to write CSV files, e.g:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "CSV writer object", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/csv.html#writer-objects"}]}, {"code": "<pre>\n<code>\n import csv\nwriter = csv.writer(open(\"some.csv\", \"wb\"))\nwriter.writerows(someiterable)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["With python you will have to create a new file for safety sake, it will cause alot less headaches than trying to write in place."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The below listed reads your input 1 line at a time and buffers the columns (from what I understood of your test input file was 1 row) and then once the end of row delimiter is hit it will write that buffer to disk, flushing manually every 1000 lines of the original file.", "This will save some IO as well instead of writing every segment, 1000 writes of 32 bytes each will be faster than 4000 writes of 8 bytes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n fin = open(input_fn, \"rb\")\nfout = open(output_fn, \"wb\")\nrow_delim = \"&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;\"\nwrite_buffer = []\n\nfor i, line in enumerate(fin):\n    if not i % 1000:\n        fout.flush()\n    if row_delim in line and i:\n        fout.write('\"%s\"\\r\\n'%'\",\"'.join(write_buffer))\n        write_buffer = []\n    else:\n        write_buffer.append(line.strip())\n</code>\n</pre>\n", "senID": 2}, {"text": ["Hope that helps."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: Forgot to mention, while using .readline() is not a bad thing don't use .readlines() which will go and read the entire content of the file into a list containing each line which is incredibly inefficient.", "Using the built in iterator that comes with a file object is the best memory usage and speed."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["@Constatin suggests that if you would be satisfied with replacing '&lt;>&lt;>&lt;>&lt;>&lt;>&lt;>&lt;>\\n' by '\"             \\n'\nthen the replacement string is the same length, and in that case you can craft a solution to in-place editing with mmap.", "You will need python 2.6.", "It's vital that the file is opened in the right mode!"], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "'&lt;>&lt;>&lt;>&lt;>&lt;>&lt;>&lt;>\\n'", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "'&lt;>&lt;>&lt;>&lt;>&lt;>&lt;>&lt;>\\n'", "tag": "code"}]}, {"text": "'&lt;>&lt;>&lt;>&lt;>&lt;>&lt;>&lt;>\\n'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'\"             \\n'", "childNum": 1, "tag": "pre", "pos": -1, "childList": [{"text": "'\"             \\n'", "tag": "code"}]}, {"text": "'\"             \\n'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "mmap", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import mmap, os\nCHUNK = 2**20\n\noldStr = ''\nnewStr = '\"             '\nstrLen = len(oldStr)\nassert strLen==len(newStr)\n\nf = open(\"myfilename\", \"r+\")\nsize = os.fstat(f.fileno()).st_size\n\nfor offset in range(0,size,CHUNK):\n    map = mmap.mmap(f.fileno(),\n                    length=min(CHUNK+strLen,size-offset),  # not beyond EOF\n                    offset=offset)\n    index = 0  # start at beginning\n    while 1:\n        index = map.find(oldStr,index) # find next match\n        if index == -1:  # no more matches in this map\n            break\n        map[index:index+strLen] = newStr\n\nf.close()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code is not debugged!", "It works for me on a 3 MB test case, but it may not work on a large ( > 2GB) file - the mmap module still seems a bit immature, so I wouldn't rely on it too much."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "may not", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "mmap", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Looking at the bigger picture, from what you've posted it isn't clear that your file will end up as valid CSV.", "Also be aware that the tool you're planning to use to actually process the CSV may be flexible enough to deal with the file as it stands."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["[For the problem exactly as stated] There's no way that this can be done without copying the data, in python or any other language.", "If your processing always replaced substrings with new substrings of equal length, maybe you could do it in-place.", "But whenever you replace &lt;>&lt;>&lt;>&lt;>&lt;>&lt;>&lt;> with \" you are changing the position of all subsequent characters in the file.", "Copying from one place to another is the only way to handle this.  "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "equal length", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "&lt;>&lt;>&lt;>&lt;>&lt;>&lt;>&lt;>", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["EDIT:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Note that the use of sed won't actually save any copying...sed doesn't really edit in-place either.", "From the GNU sed manual: "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "sed", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "GNU sed manual", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.gnu.org/software/sed/manual/html_node/Invoking-sed.html#fn-1"}]}, {"text": ["(emphasis mine."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you're delimiting fields with double quotes, it looks like you need to escape the double quotes you have occurring in your elements (for example 1231214 \"\" will need to be \\n1231214 \\\"\\\")."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "1231214 \"\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\n1231214 \\\"\\\"", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Something like"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n fin = open(\"input\", \"r\")\nfout = open(\"output\", \"w\")\nfor line in fin:\n   if line.contains(\"&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;\"):\n      fout.writeline(\"\\\"\")\n   else:\n      fout.writeline(line.replace('\"',r'\\\"')\nfin.close()\nfout.close()\n</code>\n</pre>\n", "senID": 2}]]