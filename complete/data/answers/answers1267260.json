[[{"text": ["You'll have to measure, but I can imagine this to be more performant:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n myList = filter(lambda x: myDict.get(x[1], None) != x[0], myList)\n</code>\n</pre>\n", "senID": 1}, {"text": ["because the lookup happens in the dict, which is more suited for this kind of thing.", "Note, though, that this will create a new list before removing the old one; so there's a memory tradeoff.", "If that's an issue, rethinking your container type as jkp suggest might be in order."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: Be careful, though, if None is actually in your list -- you'd have to use a different \"placeholder."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["To remove about 10,000 tuples from a list of about 1,000,000, if the values are hashable, the fastest approach should be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n totoss = set((v,k) for (k,v) in myDict.iteritems())\nmyList[:] = [x for x in myList if x not in totoss]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The preparation of the set is a small one-time cost, wich saves doing tuple unpacking and repacking, or tuple indexing, a lot of times.", "Assignign to myList[:] instead of assigning to myList is also semantically important (in case there are any other references to myList around, it's not enough to rebind just the name -- you really want to rebind the contents!-)."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "myList[:]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "myList", "childNum": 0, "tag": "code", "childList": []}, {"text": "myList", "childNum": 0, "tag": "code", "childList": []}, {"text": "contents", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["I don't have your test-data around to do the time measurement myself, alas!, but, let me know how it plays our on your test data!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If the values are not hashable (e.g.", "they're sub-lists, for example), fastest is probably:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n sentinel = object()\nmyList[:] = [x for x in myList if myDict.get(x[0], sentinel) != x[1]]\n</code>\n</pre>\n", "senID": 5}, {"text": ["or maybe (shouldn't make a big difference either way, but I suspect the previous one is better -- indexing is cheaper than unpacking and repacking):"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n sentinel = object()\nmyList[:] = [(a,b) for (a,b) in myList if myDict.get(a, sentinel) != b]\n</code>\n</pre>\n", "senID": 7}, {"text": ["In these two variants the sentinel idiom is used to ward against values of None (which is not a problem for the preferred set-based approach -- if values are hashable!", ") as it's going to be way cheaper than if a not in myDict or myDict[a] != b (which requires two indexings into myDict)."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "if a not in myDict or myDict[a] != b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Every time you call myList.remove, Python has to scan over the entire list to search for that item and remove it.", "In the worst case scenario, every item you look for would be at the end of the list each time."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "myList.remove", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Have you tried doing the \"inverse\" operation of:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n newMyList = [(v,k) for (v,k) in myList if not k in myDict]\n</code>\n</pre>\n", "senID": 2}, {"text": ["But I'm really not sure how well that would scale, either, since you would be making a copy of the original list -- could potentially be a lot of memory usage there."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Probably the best alternative here is to wait for Alex Martelli to post some mind-blowingly intuitive, simple, and efficient approach."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n [(i, j) for i, j in myList if myDict.get(j) != i]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Try something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n myListSet = set(myList)\nmyDictSet = set(zip(myDict.values(), myDict.keys()))\nmyList = list(myListSet - myDictSet)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will convert myList to a set, will swap the keys/values in myDict and put them into a set, and will then find the difference, turn it back into a list, and assign it back to myList.", ":)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "myList", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "myDict", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The problem looks to me to be the fact you are using a list as the container you are trying to remove from, and it is a totally unordered type.", "So to find each item in the list is a linear operation (O(n)), it has to iterate over the whole list until it finds a match."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(n)", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Big%5FO%5Fnotation"}]}, {"text": ["If you could swap the list for some other container (set?", ") which uses a hash() of each item to order them, then each match could be performed much quicker."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "hash()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The following code shows how you could do this using a combination of ideas offered by myself and Nick on this thread:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n list_set = set(original_list)\ndict_set = set(zip(original_dict.values(), original_dict.keys()))\ndifference_set = list(list_set - dict_set)\nfinal_list = []\nfor item in original_list:\n    if item in difference_set:\n        final_list.append(item)\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n [i for i in myList if i not in list(zip(myDict.values(), myDict.keys()))]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["A list containing a million 2-tuples is not large on most machines running Python.", "However if you absolutely must do the removal in situ, here is a clean way of doing it properly:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def filter_by_dict(my_list, my_dict):\n    sentinel = object()\n    for i in xrange(len(my_list) - 1, -1, -1):\n        key = my_list[i][1]\n        if my_dict.get(key, sentinel) is not sentinel:\n            del my_list[i]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update Actually each del costs O(n) shuffling the list pointers down using C's memmove(), so if there are d dels, it's O(n*d) not O(n**2).", "Note that (1) the OP suggests that d approx == 0.01 * n and (2) the O(n*d) effort is copying one pointer to somewhere else in memory ... so this method could in fact be somewhat faster than a quick glance would indicate.", "Benchmarks, anyone?"], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "O(n*d)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "O(n**2)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "0.01 * n", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "O(n*d)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["What are you going to do with the list after you have removed the items that are in the dict?", "Is it possible to piggy-back the dict-filtering onto the next step?"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "after", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]