[[{"text": ["Python does not have a switch statement.", "The recommended alternative is using a chained if/else chain - which is what you ought to be using in your case anyway."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Another common idiom is using a map.", "And in your case you could use a tuple of (var1,var2) to match against results."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n switch = {\n   (1,2): lambda: ..,\n   (3,4): lambda: ...,\n}\nswitch[(var1,var2)]\n</code>\n</pre>\n", "senID": 2}, {"text": ["I'm not sure this is commonly used, but at least it's possible."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Yes/No."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["No traditional language with a \"switch\" statement has this.", "It does exist in something called \"pattern matching\"."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["C#, Java, PHP, and Python do not support pattern matching (not completely sure about PHP, but I don't believe it does.", "Correct me if I'm wrong)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here's an example in Haskell where pattern matching does exist.", "Pattern matching is in a lot of functional style languages."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n function 1 _ = \"first parameter has a one\"\nfunction _ 1 = \"second parameter is a one\"\nfunction _ _ = \"I don't know what crazy number you passed in\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["When that function is called, the runtime/compiler/whoever checks it will see if the first function can be called.", "If it can, it returns that value.", "It then keeps going until it can find some match that works for the given parameters.", "The \"_\" is just a way of saying, \"anything can be here, and I really don't care what it is so don't bind the value to a name\".", "If I cared about the value, I could do:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n function 1 a = \"second parameter is \" ++ (show a)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Now since it usually goes top-down (unlike the switch statement), this is more akin to an if/else than a switch statement which just jumps to the correct spot.", "It's just a very nice looking if/else.", "Also, if I reordered it so the most general case was at the top of the file, the other cases would be ignored."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["You can also do something similar with templates, but that will only work at compile time."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["You could do something similar to what you want in Scala (and any other functional language, with a pattern-matching mechanism):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "similar", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def matchTest(var1: Any, var2: Any): Any = (var1, var2) match {\n  case (a, _) =&gt; \"var1 == a\"\n  case (_, b) =&gt; \"var2 == b\"\n  case (0, 1) =&gt; \"var1 == 0, var2 == 1\"\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think you can do arbitrary case matching in some languages like Haskell and ML.", "See Haskell Pattern Matching.", "The object in question is still a single object, but that object can be a tuple which contains an arbitrary number of objects."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Haskell Pattern Matching", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikibooks.org/wiki/Haskell/Pattern_matching"}]}, {"text": ["An example given in the link is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n describeList :: [a] -&gt; String\ndescribeList list = \n  case list of\n   []     -&gt; \"The list was empty\"\n   (x:xs) -&gt; \"The list wasn't empty: the first element was \" ++ show x ++\n             \", and there were \" ++ show (length xs) ++\n             \" more elements in the list.\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["CHILL allows it:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "CHILL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://psc.informatik.uni-jena.de/languages/chill/chill.htm"}]}, {"code": "<pre>\n<code>\n PROC (b board LOC,m move) EXCEPTIONS (illegal);\nDCL starting square LOC:= b (m.lin_1)(m.col_1),\narriving square LOC:= b (m.lin_2)(m.col_2);\nDO WITH m;\nIF starting.status=free THEN CAUSE illegal; FI;\nIF arriving.status/=free THEN\nIF arriving.p.kind=king THEN CAUSE illegal; FI;\nFI;\nCASE starting.p.kind, starting.p.color OF\n   (pawn),(white):\n      IF col_1 = col_2 AND (arriving.status/=free\n      OR NOT (lin_2=lin_1+1 OR lin_2=lin_1+2 AND lin_2=2))\n      OR (col_2=PRED (col_1) OR col_2=SUCC (col_1))\n      AND arriving.status=free THEN CAUSE illegal; FI;\n      IF arriving.status/=free THEN\n      IF arriving.p.color=white THEN CAUSE illegal; FI; FI;\n   (pawn),(black):\n      IF col_1=col_2 AND (arriving.status/=free\n      OR NOT (lin_2=lin_11 OR lin_2=lin_12 AND lin_1=7))\n      OR (col_2=PRED (col_1) OR col_2=SUCC (col_1))\n      AND arriving.status=free THEN CAUSE illegal; FI;\n      IF arriving.status/=free THEN\n      IF arriving.p.color=black THEN CAUSE illegal; FI; FI;\n   (rook),(*):\n      IF NOT ok_rook (b,m)\n      THEN CAUSE illegal;\n      FI;\n   (bishop),(*):\n      IF NOT ok_bishop (b,m)\n      THEN CAUSE illegal;\n      FI;\n   (queen),(*):\n   IF NOT ok_rook (b,m) AND NOT ok_bishop (b,m)\n     THEN CAUSE illegal;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As said, this pattern matching is typical of functional languages.", "But you can find some at least \"hybrid\" functional/OOP ones that support it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's an example in F#"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n let fnc (var1, var2) =\n    match (var1, var2) with\n        | 2 , _ -&gt; \"something\"\n        | _ , 3 -&gt; \"something else\"\n        | 0, 1  -&gt; \"etc ... \"\n        | a, b -&gt; \"I got \" + a.ToString() + \" and \" + b.ToString()\n\nfnc(0, 1) |&gt; printfn \"%s\" // prints \"etc..\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["and the same in scala"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def fnc(var1: Int, var2: Int) : String = \n  (var1, var2) match { \n    case (2, _) =&gt; \"something\" \n    case ( _,3) =&gt; \"something else\"\n    case (0, 1) =&gt; \"etc...\"\n    case (a, b) =&gt; \"I got \" + a + \" and \" + b\n  } \n\nprintln(fnc(0,1))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I've never seen a language that allows that, no."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Certainly not in C#.", "You'd use an if/else if pattern to fall through conditions like these.", "I can't speak for any other language with authority but I'm 99% sure Java doesn't allow it either.", "Who knows what those crazy PHP and Python guys allow, though..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["No.", "You will have to nest the switch case for one variable inside each case of the other."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you think about it, the languages can't allow that because you could end up with more than one case that would be true."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["AFAIK, python does not have switch-case."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]