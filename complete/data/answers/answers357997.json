[[{"text": ["Java uses anonymous classes mostly to imitate closures or simply code blocks.", "Since in Python you can easily pass around methods there's no need for a construct as clunky as anonymous inner classes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def printStuff():\n   print \"hello\"\n\ndef doit(what):\n   what()\n\ndoit(printStuff)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: I'm aware that this is not what is needed in this special case.", "I just described the most common python solution to the problem most commonly by anonymous inner classes in Java."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can accomplish this in three ways:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example of option 3 (edited to remove use of \"new\" module -- It's deprecated, I did not know ):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import types\nclass someclass(object):\n    val = \"Value\"\n    def some_method(self):\n        print self.val\n\ndef some_method_upper(self):\n    print self.val.upper()\n\nobj = someclass()\nobj.some_method()\n\nobj.some_method = types.MethodType(some_method_upper, obj)\nobj.some_method()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Well, classes are first class objects, so you can create them in methods if you want.", "e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from optparse import OptionParser\ndef make_custom_op(i):\n  class MyOP(OptionParser):\n    def exit(self):\n      print 'custom exit called', i\n  return MyOP\n\ncustom_op_class = make_custom_op(3)\ncustom_op = custom_op_class()\n\ncustom_op.exit()          # prints 'custom exit called 3'\ndir(custom_op)            # shows all the regular attributes of an OptionParser\n</code>\n</pre>\n", "senID": 1}, {"text": ["But, really, why not just define the class at the normal level?", "If you need to customise it, put the customisation in as arguments to __init__."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["(edit: fixed typing errors in code)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python doesn't support this directly (anonymous classes) but because of its terse syntax it isn't really necessary:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyOptionParser(OptionParser):\n    def exit(self, status=0, msg=None):\n        # body of method\n\np = MyOptionParser()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The only downside is you add MyOptionParser to your namespace, but as John Fouhy pointed out, you can hide that inside a function if you are going to do it multiple times."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Python probably has better ways to solve your problem.", "If you could provide more specific details of what you want to do it would help."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, if you need to change the method being called in a specific point in code, you can do this by passing the function as a parameter (functions are first class objects in python, you can pass them to functions, etc).", "You can also create anonymous lambda functions (but they're restricted to a single expression)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Also, since python is very dynamic, you can change methods of an object after it's been created object.method1 = alternative_impl1, although it's actually a bit more complicated, see gnud's answer"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "object.method1 = alternative_impl1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/357997/python-does-have-something-like-anonymous-inner-classes-of-java#358055", "text": "gnud's answer", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You can use the type(name, bases, dict) builtin function to create classes on the fly.", "For example:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "type(name, bases, dict)", "tag": "a", "pos": 0, "childList": [{"text": "type(name, bases, dict)", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#type"}, {"text": "type(name, bases, dict)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n op = type(\"MyOptionParser\", (OptionParser,object), {\"foo\": lambda self: \"foo\" })\nop().foo()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Since OptionParser isn't a new-style class, you have to explicitly include object in the list of base classes."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "object", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["In python you have anonymous functions, declared using lambda statement.", "I do not like them very much - they are not so readable, and have limited functionality."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, what you are talking about may be implemented in python with a completely different approach:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class a(object):\n  def meth_a(self):\n    print \"a\"\n\ndef meth_b(obj):\n  print \"b\"\n\nb = a()\nb.__class__.meth_a = meth_b\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You can always hide class by variables:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class var(...):\n     pass\n var = var()\n</code>\n</pre>\n", "senID": 1}, {"text": ["instead of"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n var = new ...() {};\n</code>\n</pre>\n", "senID": 3}]]