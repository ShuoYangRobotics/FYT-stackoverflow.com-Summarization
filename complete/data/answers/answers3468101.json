[[{"text": ["This is specific to Java."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can use Thread.currentThread().getStackTrace().", "This will return an array of StackTraceElements."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "Thread.currentThread().", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "getStackTrace()", "tag": "a", "pos": -1, "childList": [{"text": "getStackTrace()", "tag": "code"}], "childNum": 1, "href": "http://download.oracle.com/javase/6/docs/api/java/lang/Thread.html#getStackTrace%28%29"}, {"text": "getStackTrace()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "StackTraceElements", "tag": "a", "pos": 1, "childList": [{"text": "StackTraceElements", "tag": "code"}], "childNum": 1, "href": "http://download.oracle.com/javase/6/docs/api/java/lang/StackTraceElement.html"}, {"text": "StackTraceElements", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The 2nd element in the array will be the calling method."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n public void methodThatPrintsCaller() {\n    StackTraceElement elem = Thread.currentThread.getStackTrace()[2];\n    System.out.println(elem);\n\n    // rest of you code\n}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["If all you want to do is print out the stack trace and go hunting for the class, use "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Thread.dumpStack();\n</code>\n</pre>\n", "senID": 1}, {"text": ["See the API doc."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "API doc", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://download-llnw.oracle.com/javase/6/docs/api/java/lang/Thread.html#dumpStack%28%29"}]}], [{"text": ["Justin has the general case down; I wanted to mention two special cases demonstrated by this snippit:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import java.util.Comparator;\n\npublic class WhoCalledMe {\n\n    public static void main(String[] args) {\n        ((Comparator)(new SomeReifiedGeneric())).compare(null, null);\n        new WhoCalledMe().new SomeInnerClass().someInnerMethod();\n    }\n\n    public static StackTraceElement getCaller() {\n        //since it's a library function we use 3 instead of 2 to ignore ourself\n        return Thread.currentThread().getStackTrace()[3];\n    }\n\n    private void somePrivateMethod() {\n        System.out.println(\"somePrivateMethod() called by: \" + WhoCalledMe.getCaller());\n    }\n\n    private class SomeInnerClass {\n        public void someInnerMethod() {\n            somePrivateMethod();\n        }\n    }\n}\n\nclass SomeReifiedGeneric implements Comparator&lt;SomeReifiedGeneric&gt; {\n    public int compare(SomeReifiedGeneric o1, SomeReifiedGeneric o2) {\n        System.out.println(\"SomeRefiedGeneric.compare() called by: \" + WhoCalledMe.getCaller());\n        return 0;\n    }\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["This prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n SomeRefiedGeneric.compare() called by: SomeReifiedGeneric.compare(WhoCalledMe.java:1)\nsomePrivateMethod() called by: WhoCalledMe.access$0(WhoCalledMe.java:14)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Even though the first is called \"directly\" from main() and the second from SomeInnerClass.someInnerMethod().", "These are two cases where there is a transparent call made in between the two methods."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "main()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "SomeInnerClass.someInnerMethod()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "In the first case, this is because we are calling the ", "tag": "none", "senID": 5}, {"text": "In the second case, it is because we are calling a private member of WhoCalledMe from an inner class.  To accomplish this, the compiler adds a synthetic method as a go-between to override the visibility problems.", "tag": "none", "senID": 6}]}], [{"text": ["the sequence of method calls is located in stack.", "this is how you get the stack: http://stackoverflow.com/questions/1069066/get-current-stack-trace-in-java then get previous item."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/questions/1069066/get-current-stack-trace-in-java", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1069066/get-current-stack-trace-in-java"}]}], [{"text": ["Since you asked about other languages, Tcl gives you a command (info level) that lets you examine the call stack.", "For example, [info level -1] returns the caller of the current procedure, as well as the arguments used to call the current procedure."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "info level", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://tcl.tk/man/tcl8.5/TclCmd/info.htm#M27"}, {"text": "[info level -1]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Yes, it is possible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Have a look at Thread.getStackTrace()"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Thread.getStackTrace()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Thread.html#getStackTrace%28%29"}]}], [{"text": ["This question deals with how to view the call stack in javascript."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2060272/while-debugging-javascript-is-there-a-way-to-alert-current-call-stack"}]}], [{"text": ["In python you would use the traceback module.", "You can see examples there."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "traceback", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/traceback.html"}]}], [{"text": ["In Python, you should use the traceback or inspect modules.", "These will modules will shield you from the implementation details of the interpreter, which can differ even today (e.g.", "IronPython, Jython) and may change even more in the future.", "The way these modules do it under the standard Python interpreter today, however, is with sys._getframe().", "In particular, sys._getframe(1).f_code.co_name provides the information you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In Python you use the inspect module.", "Getting the function's name and file name is easy, as you see in the example below. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "inspect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/inspect.html"}]}, {"text": ["Getting the function itself is more work.", "I think you could use the __import__ function to import the caller's module.", "However you must somehow convert the filename to a valid module name."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__import__", "tag": "a", "pos": 1, "childList": [{"text": "__import__", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html?highlight=_import#__import__"}, {"text": "__import__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import inspect\n\ndef find_caller():\n    caller_frame = inspect.currentframe().f_back\n    print \"Called by function:\", caller_frame.f_code.co_name\n    print \"In file           :\", caller_frame.f_code.co_filename\n    #Alternative, probably more portable way\n    #print inspect.getframeinfo(caller_frame)\n\ndef foo():\n    find_caller()\n\nfoo()\n</code>\n</pre>\n", "senID": 2}]]