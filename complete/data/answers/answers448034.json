[[{"text": ["For your use case one approach could be to write a file subclass that locks:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "file", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class LockedWrite(file):\n    \"\"\" Wrapper class to a file object that locks writes \"\"\"\n    def __init__(self, *args, **kwds):\n        super(LockedWrite, self).__init__(*args, **kwds)\n        self._lock = Lock()\n\n    def write(self, *args, **kwds):\n        self._lock.acquire()\n        try:\n            super(LockedWrite, self).write(*args, **kwds)\n        finally:\n            self._lock.release()\n</code>\n</pre>\n", "senID": 1}, {"text": ["To use in your code just replace following functions:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def main():\n    f = LockedWrite('foo.txt', 'a')\n\n    for i in range(20):\n        agent = Agent(i, f)\n        agent.start()\n\nclass Agent(Thread):\n    def __init__(self, thread_num, fileobj):\n        Thread.__init__(self)\n        self.thread_num = thread_num\n        self._file = fileobj    \n\n#   ...\n\n    def write_result(self):\n        self._file.write('hello from thread %s\\n' % self.thread_num)\n</code>\n</pre>\n", "senID": 3}, {"text": ["This approach puts file locking in the file itself which seems cleaner IMHO"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Create the lock outside the method."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Agent(Thread):\n    mylock = Lock()\n    def write_result(self):\n        self.mylock.acquire()\n        try:\n            ...\n        finally:\n            self.mylock.release()\n</code>\n</pre>\n", "senID": 1}, {"text": ["or if using python >= 2.5:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Agent(Thread):\n    mylock = Lock()\n    def write_result(self):\n        with self.mylock:\n            ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["To use that with python 2.5 you must import the statement from the future:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import with_statement\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The lock() method returns a lock object for every call.", "So every thread ( actually every call to write_result ) will have a different lock object.", "And there will be no locking. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The lock that's used needs to be common to all threads, or at least ensure that two locks can't lock the same resource at the same time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The lock instance should be associated with the file instance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In other words, you should create both the lock and file at the same time and pass both to each thread."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["MSN"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can simplify things a bit (at the cost of slightly more overhead) by designating a single thread (probably created exclusively for this purpose) as the sole thread that writes to the file, and have all other threads delegate to the file-writer by placing the string that they want to add to the file into a queue.Queue object.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "queue.Queue", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Queues have all of the locking built-in, so any thread can safely call Queue.put() at any time.", "The file-writer would be the only thread calling Queue.get(), and can presumably spend much of its time blocking on that call (with a reasonable timeout to allow the thread to cleanly respond to a shutdown request).", "All of the synchronization issues will be handled by the Queue, and you'll be spared having to worry about whether you've forgotten some lock acquire/release somewhere... :)"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Queue.put()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Queue.get()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I'm pretty sure that the lock needs to be the same object for each thread.", "Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import time\nfrom threading import Thread, Lock\n\ndef main():\n    lock = Lock()\n    for i in range(20):\n        agent = Agent(i, lock)\n        agent.start()\n\nclass Agent(Thread, Lock):\n    def __init__(self, thread_num, lock):\n        Thread.__init__(self)\n        self.thread_num = thread_num\n        self.lock = lock\n\n    def run(self):\n        while True:\n            print 'hello from thread %s' % self.thread_num\n            self.write_result()   \n\n    def write_result(self):\n        self.lock.acquire()\n        try:\n            f = open('foo.txt', 'a')\n            f.write('hello from thread %s\\n' % self.thread_num)\n            f.flush()\n            f.close()\n        finally:\n            lock.release()\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}]]