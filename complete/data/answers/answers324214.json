[[{"text": ["I looks to me as if you do not need any DOM capabilities from your program.", "I would second the use of the (c)ElementTree library.", "If you use the iterparse function of the cElementTree module, you can work your way through the xml and deal with the events as they occur. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Note however, Fredriks advice on using cElementTree iterparse function:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "iterparse function", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/element-iterparse.htm"}]}, {"code": "<pre>\nfor event, elem in iterparse(source):\n    if elem.tag == \"record\":\n        ... process record elements ...\n        elem.clear()\n</pre>\n", "senID": 2}, {"code": "<pre>\n# get an iterable\ncontext = iterparse(source, events=(\"start\", \"end\"))\n\n# turn it into an iterator\ncontext = iter(context)\n\n# get the root element\nevent, root = context.next()\n\nfor event, elem in context:\n    if event == \"end\" and elem.tag == \"record\":\n        ... process record elements ...\n        root.clear()\n</pre>\n", "senID": 3}, {"text": ["The lxml.iterparse() does not allow this."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "lxml.iterparse()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codespeak.net/lxml/FAQ.html#why-can-t-i-just-delete-parents-or-clear-the-root-node-in-iterparse"}]}], [{"text": ["I recommend you to use lxml, it's a python binding for the libxml2 library which is really fast. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lxml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codespeak.net/lxml/"}]}, {"text": ["In my experience, libxml2 and expat have very similar performance.", "But I prefer libxml2 (and lxml for python) because it seems to be more actively developed and tested.", "Also libxml2 has more features."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["lxml is mostly API compatible with xml.etree.ElementTree.", "And there is good documentation in its web site."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "xml.etree.ElementTree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-xml.etree.ElementTree.html"}]}], [{"text": ["Have you tried The cElementTree Module?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["cElementTree is included with Python 2.5 and later, as xml.etree.cElementTree.", "Refer the benchmarks."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "benchmarks", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/celementtree.htm"}]}, {"src": "http://img293.imageshack.us/img293/3732/20081128002409vy0.th.png", "tag": "img", "senID": 2}], [{"text": ["If your application is performance-sensitive and likely to encounter large files (like you said, > 1GB) then I'd strongly advise against using the code you're showing in your question for the simple reason that it loads the entire document into RAM.", "I would encourage you to rethink your design (if at all possible) to avoid holding the whole document tree in RAM at once.", "Not knowing what your application's requirements are, I can't properly suggest any specific approach, other than the generic piece of advice to try to use an \"event-based\" design."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "strongly", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "it loads the entire document into RAM", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["Registering callbacks slows down the parsing tremendously.", "[EDIT]This is because the (fast) C code has to invoke the python interpreter which is just not as fast as C. Basically, you're using the C code to read the file (fast) and then build the DOM in Python (slow).", "[/EDIT]"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Try to use xml.etree.ElementTree which is implemented 100% in C and which can parse XML without any callbacks to python code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["After the document has been parsed, you can filter it to get what you want."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If that's still too slow and you don't need a DOM another option is to read the file into a string and use simple string operations to process it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Apparently PyRXP is really fast."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PyRXP", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.reportlab.org/pyrxp.html"}]}, {"text": ["They claim it is the fastest parser - but cElementTree isn't in their stats list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]