[[{"code": "<pre>\n<code>\n from collections import defaultdict\n\nmorsecode = [('a','._'), ('b','_...'), ('c','_._.')]\ncodedict = defaultdict(lambda:' ')\nfor k,v in morsecode:\n    codedict[k] = v\n\ntomorse = lambda x: ' '.join([codedict[chr] for chr in x])\n\nprint tomorse('bab cab')\n</code>\n</pre>\n", "senID": 0}, {"text": ["Gives: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n _... ._ _...   _._. ._ _...\n</code>\n</pre>\n", "senID": 2}], [{"text": ["In Python, strings are immutable, so probably (depending on what you're doing with the output), you want to create a list of all the simple substitution results.", "Something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n MORSE = {'A': '.-', ...}\n\ndef morsify(data):\n    return [MORSE[c] for c in data if c in MORSE]\n</code>\n</pre>\n", "senID": 1}, {"text": ["You'd need to get corresondingly fancier if you wanted to support different national versions of Morse code etc."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(Edited to deal with the fact that Morse code is apparently not a prefix code."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You could use str.translate:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "str.translate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n m = {ord('S'): '---', ord('O'): '...'}\nprint('S O S'.translate(m))\n</code>\n</pre>\n", "senID": 1}, {"text": ["will print:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n --- ... ---\n</code>\n</pre>\n", "senID": 3}], [{"text": ["On the Python side the string class' translate function is the way to go.", "On the C++ side I would go with a std::map to hold the character mapping.", "Then I would probably use std::for_each to do the look up and swap."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There's no simple optimal structure - for any given fixed mapping, there might be fiendish bit-twiddling optimisations for that precise mapping, that are better or worse on different architectures and different inputs.", "A map/dictionary should be pretty good all the time, and the code is pretty simple."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My official advice is to stick with that.", "Lookup performance is very unlikely to be an issue for code like this, since most likely you can easily encode/decode faster than you can input/output."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As it's a learning exercise, and you want to try out different possibilities: for the text -> morse you could use an array rather than a map/dictionary.", "Perhaps surprisingly, this is difficult to do in C++ and be completely portable.", "The following assumes that all uppercase letters have char values greater than A, which is not guaranteed by the standard:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "char", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "A", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n std::string encode['Z'-'A'];\nencode['A' - 'A'] = \".-\";\nencode['B' - 'A'] = \"-...\";\n// etc.\nencode['Z' - 'A'] = \"--..\";\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you're willing to assume that your code will only ever run on machines whose basic character set has the letters in a continuous run (true of ASCII, but not EBCDIC), you can tidy it up a bit:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n std::string encode[26] = {\".-\", \"-...\", /* etc */ \"--..\"};\n</code>\n</pre>\n", "senID": 5}, {"text": ["To look up the character stored in the variable c:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n morse = encode[c - 'A'];\n</code>\n</pre>\n", "senID": 7}, {"text": ["The Python version can assume ASCII (I think), and you'd have to throw in some use of ord. "], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "ord", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To cope with anything other than upper case letters, you need either a bigger array (to contain an entry for every possible char value), or else multiple arrays with bounds checks, special case code for punctuation and so on."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["The first hit on Google."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "first hit", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://jijo.free.net.ph/files/python/morse.py"}, {"href": "http://www.google.com", "text": "Google", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Depending on the quantity of text, 'foo'.replace('f', '..-.", "').replace('o','---') would work."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Unless you're translating thousands of lines of text, you probably won't notice a whole lot of difference in any method that you use - though you can easily use the timeit module to test each different method."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["python (expects a string):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def m(t):\n m=0xBFAFA7AEA1A0B0B8BCBE121A021D11120C41888A642082668040876584434267868D626021618163898B8C\n r=[]\n for c in t.upper():\n  val=int((m/(256**(90-ord(c))))%256)\n  r.append(\"\".join([str((val&gt;&gt;y)&amp;1) for y in range(val/32-1,-1,-1)]))\n return \" \".join(r)\n</code>\n</pre>\n", "senID": 1}]]