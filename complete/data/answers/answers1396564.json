[[{"text": ["I can reproduce this on my Q6600 (Python 2.6.2); increasing the range to 100000000:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ('+=', 11.370000000000001)\n('-=', 10.769999999999998)\n</code>\n</pre>\n", "senID": 1}, {"text": ["First, some observations:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "This is 5% for a trivial operation.  That's significant.", "tag": "none", "senID": 3}, {"text": "The speed of the native addition and subtraction opcodes is irrelevant.  It's in the noise floor, completely dwarfed by the bytecode evaluation.  That's talking about one or two native instructions around thousands.", "tag": "none", "senID": 4}, {"text": "The bytecode generates exactly the same number of instructions; the only difference is ", "tag": "none", "senID": 5}]}, {"text": ["Looking at the Python source, I can make a guess.", "This is handled in ceval.c, in PyEval_EvalFrameEx.", "INPLACE_ADD has a significant extra block of code, to handle string concatenation.", "That block doesn't exist in INPLACE_SUBTRACT, since you can't subtract strings.", "That means INPLACE_ADD contains more native code.", "Depending (heavily!", ") on how the code is being generated by the compiler, this extra code may be inline with the rest of the INPLACE_ADD code, which means additions can hit the instruction cache harder than subtraction.", "This could be causing extra L2 cache hits, which could cause a significant performance difference."], "childNum": 5, "tag": "p", "senID": 6, "childList": [{"text": "PyEval_EvalFrameEx", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "INPLACE_ADD", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "INPLACE_SUBTRACT", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "INPLACE_ADD", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "could", "childNum": 0, "tag": "em", "pos": 7, "childList": []}]}, {"text": ["This is heavily dependent on the system you're on (different processors have different amounts of cache and cache architectures), the compiler in use, including the particular version and compilation options (different compilers will decide differently which bits of code are on the critical path, which determines how assembly code is lumped together), and so on."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Also, the difference is reversed in Python 3.0.1 (+: 15.66, -: 16.71); no doubt this critical function has changed a lot."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"code": "<pre>\n<code>\n $ python -m timeit -s \"x=0\" \"x+=1\"\n10000000 loops, best of 3: 0.151 usec per loop\n$ python -m timeit -s \"x=0\" \"x-=-1\"\n10000000 loops, best of 3: 0.154 usec per loop\n</code>\n</pre>\n", "senID": 0}, {"text": ["Looks like you've some measurement bias"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "measurement bias", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www-plan.cs.colorado.edu/diwan/asplos09.pdf"}]}], [{"text": ["That's your explanation right there.", "Re-order your script so the subtraction test is timed first, then the addition, and suddenly addition becomes the faster operation again:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "then", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n -= 3.05\n+= 2.84\n</code>\n</pre>\n", "senID": 1}, {"text": ["Obviously something happens to the second half of the script that makes it faster.", "My guess is that the first call to range() is slower because python needs to allocate enough memory for such a long list, but it is able to re-use that memory for the second call to range():"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "guess", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "range()", "childNum": 0, "tag": "code", "childList": []}, {"text": "range()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import time\nstart = time.clock()\nx = range(10000000)\nend = time.clock()\ndel x\nprint 'first range()',end-start\nstart = time.clock()\nx = range(10000000)\nend = time.clock()\nprint 'second range()',end-start\n</code>\n</pre>\n", "senID": 3}, {"text": ["A few runs of this script show that the extra time needed for the first range() accounts for nearly all of the time difference between '+=' and '-=' seen above:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "range()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n first range() 0.4\nsecond range() 0.23\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I think the \"general programming lesson\" is that it is really hard to predict, solely by looking at the source code, which sequence of statements will be the fastest.", "Programmers at all levels frequently get caught up by this sort of \"intuitive\" optimisation.", "What you think you know may not necessarily be true."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["There is simply no substitute for actually measuring your program performance.", "Kudos for doing so; answering why undoubtedly requires delving deep into the implementation of Python, in this case."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "measuring", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "why", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["With byte-compiled languages such as Java, Python, and .NET, it is not even sufficient to measure performance on just one machine.", "Differences between VM versions, native code translation implementations, CPU-specific optimisations, and so on will make this sort of question ever more tricky to answer."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It's always a good idea when asking a question to say what platform and what version of Python you are using.", "Sometimes it does't matter.", "This is NOT one of those times:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["With Python 2.5 the biggest problem here is using range, which will allocate a list that big to iterate over it.", "When using xrange, whichever is done second is a tiny bit faster for me.", "(Not sure if range has become a generator in Python 3."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Your experiment is faulty.", "The way this experiment should be designed is to write 2 different programs - 1 for addition, 1 for subtraction.", "They should be exactly the same and run under the same conditions with the data being put to file.", "Then you need to average the runs (at least several thousand), but you'd need a statistician to tell you an appropriate number."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you wanted to analyze different methods of addition, subtraction, and looping, again each of those should be a separate program."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Experimental error might arise from heat of processor and other activity going on the cpu, so i'd execute the runs in a variety of patterns..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["That would be remarkable, so I have thoroughly evaluated your code and also setup the expiriment as I would find it more correct (all declarations and function calls outside the loop).", "Both versions I have run five times."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "correct", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "Running your code validated your claims:\n-= takes constantly less time; 3.6% on average", "tag": "none", "senID": 1}, {"text": "Running my code, though, contradicts the outcome of your experiment:\n+= takes on average (not always) 0.5% less time.", "tag": "none", "senID": 2}]}, {"text": ["To show all results I have put plots online:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Your evaluation: ", "tag": "none", "senID": 4}, {"text": "My evaluation: ", "tag": "none", "senID": 5}]}, {"text": ["So, I conclude that your experiment has a bias, and it is significant."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Finally here is my code:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import time\n\naddtimes = [0.] * 100\nsubtracttimes = [0.] * 100\n\nrange100 = range(100)\nrange10000000 = range(10000000)\n\nj = 0\ni = 0\nx = 0\nstart = 0.\n\n\nfor j in range100:\n start = time.clock()\n x = 0\n for i in range10000000:\n  x += 1\n addtimes[j] = time.clock() - start\n\nfor j in range100:\n start = time.clock()\n x = 0\n for i in range10000000:\n  x -= -1\n subtracttimes[j] = time.clock() - start\n\nprint '+=', sum(addtimes)\nprint '-=', sum(subtracttimes)\n</code>\n</pre>\n", "senID": 8}], [{"text": ["The more general programming lesson here is that intuition is a poor guide when predicting run-time performance of computer code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One can reason about algorithmic complexity, hypothesise about compiler optimisations, estimate cache performance and so on.", "However, since these things can interact in non-trivial ways, the only way to be sure about how fast a particular piece of code is going to be is to benchmark it in the target environment (as you have rightfully done."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The running loop backwards is faster because the computer has an easier time comparing if a number is equal to 0."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Have you tried reversing the order of the loops? "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]