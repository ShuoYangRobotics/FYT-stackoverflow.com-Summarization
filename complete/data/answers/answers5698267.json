[[{"text": ["If efficiency is a major concern I would re.compile() the re string, since you're going to use the same regex many times. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["re.match and re.search behave differently.", "Splitting words is not required to search using regular expressions."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "re.match", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "re.search", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "differently", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html#matching-vs-searching"}]}, {"code": "<pre>\n<code>\n import re\nsymbols_re = re.compile(r\"[^&lt;&gt;/\\{}[]~`]\");\n\nif symbols_re.search(self.cleaned_data('topic_message')):\n    //raise Validation error\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You have to be much more careful when using regular expressions - they are full of traps."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["in the case of [^&lt;&gt;/\\{}[]~] the first ] closes the group which is probably not what you intended.", "If you want to use ] in a group it has to be the first character after the [ eg []^&lt;&gt;/\\{}[~]"], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "[^&lt;&gt;/\\{}[]~]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "]", "childNum": 0, "tag": "code", "childList": []}, {"text": "[", "childNum": 0, "tag": "code", "childList": []}, {"text": "[]^&lt;&gt;/\\{}[~]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["simple test confirms this"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; re.search(\"[[]]\",\"]\")\n&gt;&gt;&gt; re.search(\"[][]\",\"]\")\n&lt;_sre.SRE_Match object at 0xb7883db0&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["regex is overkill for this problem anyway"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def clean_topic_message(self):\n    topic_message = self.cleaned_data['topic_message']\n    invalid_chars = '^&lt;&gt;/\\{}[]~`$'\n    if (topic_message == \"\"):\n        raise forms.ValidationError(_(u'Please provide a message for your topic'))\n    if set(invalid_chars).intersection(topic_message):\n        raise forms.ValidationError(_(u'Topic message cannot contain the following: %s'%invalid_chars))\n    return topic_message\n</code>\n</pre>\n", "senID": 5}], [{"text": ["For a regex solution, there are two ways to go here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is a script that implements both:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n import re\ntopic_message = 'This topic is a-ok'\n\n# Option 1: Invalidate one char in string.\nre1 = re.compile(r\"[&lt;&gt;/{}[\\]~`]\");\nif re1.search(topic_message):\n    print (\"RE1: Invalid char detected.\")\nelse:\n    print (\"RE1: No invalid char detected.\")\n\n# Option 2: Validate all chars in string.\nre2 =  re.compile(r\"^[^&lt;&gt;/{}[\\]~`]*$\");\nif re2.match(topic_message):\n    print (\"RE2: All chars are valid.\")\nelse:\n    print (\"RE2: Not all chars are valid.\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["Take your pick."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Note: the original regex erroneously has a right square bracket in the character class which needs to be escaped."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Benchmarks: After seeing gnibbler's interesting solution using set(), I was curious to find out which of these methods would actually be fastest, so I decided to measure them.", "Here are the benchmark data and statements measured and the timeit result values:"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "Benchmarks:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "set()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "timeit", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Test data:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Test data:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n r\"\"\"\nTEST topic_message STRINGS:\nok:  'This topic is A-ok.     This topic is     A-ok.'\nbad: 'This topic is &lt;not&gt;-ok. This topic is {not}-ok.'\n\nMEASURED PYTHON STATEMENTS:\nMethod 1: 're1.search(topic_message)'\nMethod 2: 're2.match(topic_message)'\nMethod 3: 'set(invalid_chars).intersection(topic_message)'\n\"\"\"\n</code>\n</pre>\n", "senID": 7}, {"text": ["Results:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Results:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n r\"\"\"\nSeconds to perform 1000000 Ok-match/Bad-no-match loops:\nMethod  Ok-time  Bad-time\n1        1.054    1.190\n2        1.830    1.636\n3        4.364    4.577\n\"\"\"\n</code>\n</pre>\n", "senID": 9}, {"text": ["The benchmark tests show that Option 1 is slightly faster than option 2 and both are much faster than the set().intersection() method.", "This is true for strings which both match and don't match."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "set().intersection()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I can't say what would be more efficient, but you certainly should get rid of the $ (unless it's an invalid character for the message)... right now you only match the re if the characters are at the end of topic_message because $ anchors the match to the right-hand side of the line."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "$", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "re", "childNum": 0, "tag": "code", "childList": []}, {"text": "topic_message", "childNum": 0, "tag": "code", "childList": []}, {"text": "$", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["is_valid = not any(k in text for k in '&lt;>/{}[]~`')"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I agree with gnibbler, regex is an overkiller for this situation.", "Probably after removing this unwanted chars you'll want to remove unwanted words also, here's a little basic way to do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def remove_bad_words(title):\n'''Helper to remove bad words from a sentence based in a dictionary of words.\n'''\nword_list = title.split(' ')\nfor word in word_list:\n    if word in BAD_WORDS: # BAD_WORDS is a list of unwanted words\n        word_list.remove(word)\n#let's build the string again\ntitle2 = u''\nfor word in word_list:\n    title2 = ('%s %s') % (title2, word)\n    #title2 = title2 + u' '+ word\n\nreturn title2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In any case you need to scan the entire message.", "So wouldn't something simple like this work ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def checkMessage(topic_message):\n  for char in topic_message:\n       if char in \"&lt;&gt;/\\{}[]~`\":\n           return False\n  return True\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Example: just tailor to your needs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ### valid chars: 0-9 , a-z, A-Z only\nimport re\nREGEX_FOR_INVALID_CHARS=re.compile( r'[^0-9a-zA-Z]+' )\nlist_of_invalid_chars_found=REGEX_FOR_INVALID_CHARS.findall( topic_message )\n</code>\n</pre>\n", "senID": 1}]]