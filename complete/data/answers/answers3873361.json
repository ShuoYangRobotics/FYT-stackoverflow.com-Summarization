[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; text = \"Allowed Hello Hollow\"\n&gt;&gt;&gt; for m in re.finditer( 'll', text ):\n...     print( 'll found', m.start(), m.end() )\n\nll found 1 3\nll found 10 12\nll found 16 18\n</code>\n</pre>\n", "senID": 0}, {"text": ["Alternatively, if you don't want the overhead of RegularExpressions:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; text = \"Allowed Hello Hollow\"\n&gt;&gt;&gt; index = 0\n&gt;&gt;&gt; while index &lt; len( text ):\n...     index = text.find( 'll', index )\n...     if index == -1:\n...         break\n...     print( 'll found at', index )\n...     index += 2 # +2 because len('ll') == 2\n\nll found at  1\nll found at  10\nll found at  16\n</code>\n</pre>\n", "senID": 2}, {"text": ["This works also for lists."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["FWIW, here are a couple of non-RE alternatives that I think are neater than poke's solution."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "poke's solution", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3873361/finding-multiple-occurrences-of-a-string-within-a-string-in-python/3873422#3873422"}]}, {"text": ["The first uses str.index and checks for ValueError:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "str.index", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ValueError", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def findall(sub, string):\n    \"\"\"\n    &gt;&gt;&gt; text = \"Allowed Hello Hollow\"\n    &gt;&gt;&gt; tuple(findall('ll', text))\n    (1, 10, 16)\n    \"\"\"\n    index = 0 - len(sub)\n    try:\n        while True:\n            index = string.index(sub, index + len(sub))\n            yield index\n    except ValueError:\n        pass\n</code>\n</pre>\n", "senID": 2}, {"text": ["The second tests uses str.find and checks for the sentinel of -1 by using iter:"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "str.find", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "-1", "childNum": 0, "tag": "code", "childList": []}, {"text": "iter", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def findall_iter(sub, string):\n    \"\"\"\n    &gt;&gt;&gt; text = \"Allowed Hello Hollow\"\n    &gt;&gt;&gt; tuple(findall_iter('ll', text))\n    (1, 10, 16)\n    \"\"\"\n    def next_index(length):\n        index = 0 - length\n        while True:\n            index = string.find(sub, index + length)\n            yield index\n    return iter(next_index(len(sub)).next, -1)\n</code>\n</pre>\n", "senID": 4}, {"text": ["To apply any of these functions to a list, tuple or other iterable of strings, you can use a higher-level function \u2014one that takes a function as one of its arguments\u2014 like this one:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "iterable", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "higher-level function", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n def findall_each(findall, sub, strings):\n    \"\"\"\n    &gt;&gt;&gt; texts = (\"fail\", \"dolly the llama\", \"Hello\", \"Hollow\", \"not ok\")\n    &gt;&gt;&gt; list(findall_each(findall, 'll', texts))\n    [(), (2, 10), (2,), (2,), ()]\n    &gt;&gt;&gt; texts = (\"parallellized\", \"illegally\", \"dillydallying\", \"hillbillies\")\n    &gt;&gt;&gt; list(findall_each(findall_iter, 'll', texts))\n    [(4, 7), (1, 6), (2, 7), (2, 6)]\n    \"\"\"\n    return (tuple(findall(sub, string)) for string in strings)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["For your list example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [1]: x = ['ll','ok','ll']\n\nIn [2]: for idx, value in enumerate(x):\n   ...:     if value == 'll':\n   ...:         print idx, value       \n0 ll\n2 ll\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you wanted all the items in a list that contained 'll', you could also do that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n In [3]: x = ['Allowed','Hello','World','Hollow']\n\nIn [4]: for idx, value in enumerate(x):\n   ...:     if 'll' in value:\n   ...:         print idx, value\n   ...:         \n   ...:         \n0 Allowed\n1 Hello\n3 Hollow\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; for n,c in enumerate(text):\n...   try:\n...     if c+text[n+1] == \"ll\": print n\n...   except: pass\n...\n1\n10\n16\n</code>\n</pre>\n", "senID": 0}], [{"text": ["For the list example, use a comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = ['ll', 'xx', 'll']\n&gt;&gt;&gt; print [n for (n, e) in enumerate(l) if e == 'll']\n[0, 2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Similarly for strings:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; text = \"Allowed Hello Hollow\"\n&gt;&gt;&gt; print [n for n in xrange(len(text)) if text.find('ll', n) == n]\n[1, 10, 16]\n</code>\n</pre>\n", "senID": 3}, {"text": ["this will list adjacent runs of \"ll', which may or may not be what you want:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; text = 'Alllowed Hello Holllow'\n&gt;&gt;&gt; print [n for n in xrange(len(text)) if text.find('ll', n) == n]\n[1, 2, 11, 17, 18]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I think what you are looking for is string.count"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "string.count", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n \"Allowed Hello Hollow\".count('ll')\n&gt;&gt;&gt; 3\n</code>\n</pre>\n", "senID": 1}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]