[[{"text": ["After opening the file, iterate through the lines like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n input_file = open('huge_file.txt', 'r')\nfor input_line in input_file:\n   # process the line however you need - consider learning some basic regular expressions\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will allow you to easily process the file by reading it in line by line as needed rather than loading it all into memory at once"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I don't know regular expressions well, but you can solve this problem without them, using the string method find() and line slicing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n answer = ''\n\nwith open('yourFile.txt','r') as open_file, open('output_file','w') as output_file:\n    for each_line in open_file:\n        if each_line.find('[A&gt;]'):\n            start_position = each_line.find('[A&gt;]')\n            start_position = start_position + 3\n            end_position = each_line[start_position:].find('[/W]')\n\n            answer = each_line[start_position:end_position] + '\\n'\n            output_file.write(answer)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Let me explain what is happening:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You're getting a memory error with readlines() because given the filesize you're likely reading in more data than your memory can reasonably handle.", "Since this file is an XML file, you should be able to read through it iterparse(), which will parse the XML lazily without taking up excess memory.", "Here's some code I used to parse Wikipedia dumps:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for event, elem in parser:\n    if event == 'start' and root == None:\n        root = elem\n    elif event == 'end' and elem.tag == namespace + 'title':\n        page_title = elem.text\n        #This clears bits of the tree we no longer use.\n        elem.clear()\n    elif event == 'end' and elem.tag == namespace + 'text':\n        page_text = elem.text\n        #Clear bits of the tree we no longer use\n        elem.clear()\n\n        #Now lets grab all of the outgoing links and store them in a list\n        key_vals = []\n\n\n        #Eliminate duplicate outgoing links.\n        key_vals = set(key_vals)\n        key_vals = list(key_vals)\n\n        count += 1\n\n        if count % 1000 == 0:\n            print str(count) + ' records processed.'\n    elif event == 'end' and elem.tag == namespace + 'page':\n        root.clear()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's roughly how it works:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You should look into a tool called \"Grep\".", "You can give it a pattern to match and a file, and it will print out occurences in the file and line numbers, if you want.", "Very useful and probably can be interfaced with Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Instead of parsing the file by hand why not parse it as XML to have better control of the data?", "You mentioned that the data is HTML-like so I assume it is parseable as an XML document. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "XML", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.etree.elementtree.html"}]}], [{"text": ["Please, test the following code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nregx = re.compile('&lt;A&gt;.+?&lt;/A&gt;.*?&lt;W&gt;.*?&lt;/W&gt;')\n\nwith open('/Users/Desktop/2e.txt','rb')         as open_file,\\\n     open('/Users/Desktop/Poetrylist.txt','wb') as output_file:\n\n    remain = ''\n\n    while True:\n        chunk = open_file.read(65536) # 65536 == 16 x 16 x 16 x 16\n        if not chunk:  break\n        output_file.writelines( mat.group() + '\\n' for mat in regx.finditer(remain + chunk) )\n        remain = chunk[mat.end(0)-len(remain):]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I couldn't test it because I have no file to test on."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]