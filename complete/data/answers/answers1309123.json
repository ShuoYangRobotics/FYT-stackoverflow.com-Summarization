[[{"text": ["I might suggest that for raw speed, Python isn't the right tool for this task.", "A hand-coded C implementation will beat Python easily."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You will get some percentage of speed by ensuring only \"local\" variables are used in your tightest of loops.", "The int function is a global, so looking it up will be more expensive than a local."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Do you really need all billion numbers in memory at all times.", "Consider using some iterators to give you only a few values at a time A billion numbers will take a bit of storage.", "Appending these to a list, one at a time, is going to require several large reallocations. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Get your looping out of Python entirely if possible.", "The map function here can be your friend.", "I'm not sure how your data is stored.", "If it is a single number per line, you could reduce the code to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n values = map(int, open(\"numberfile.txt\"))\n</code>\n</pre>\n", "senID": 3}, {"text": ["If there are multiple values per line that are white space separated, dig into the itertools to keep the looping code out of Python.", "This version has the added benefit of creating a number iterator, so you can spool only one or several numbers out of the file at a time, instead of one billion in one shot."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n numfile = open(\"numberfile.txt\")\nvalIter = itertools.imap(int, itertools.chain(itertools.imap(str.split, numfile)))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The following most simplistic C extension already improves heavily on the builtin, managing to convert over three times as many strings per second (650kcps vs 214kcps):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n static PyObject *fastint_int(PyObject *self, PyObject *args) {\n    char *s; unsigned r = 0;\n    if (!PyArg_ParseTuple(args, \"s\", &amp;s)) return NULL;\n    for (r = 0; *s; r = r * 10 + *s++ - '0');\n    return Py_BuildValue(\"i\", r);\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["This obviously does not cater for integers of arbitrary length and various other special cases, but that's no problem in our scenario."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As others have said you could code up your own C module to do the parsing/conversion for you.", "Then you could simply import that and call on it.", "You might be able to use Pyrex or its Cython derivative to generate your C from your Python (by adding a few type constraining hints to the Python)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can read more about Cython and see if that will help."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Cython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cython.org/"}]}, {"text": ["Another question that comes to mind though ... what are you going to be doing with these billion integers?", "Is it possible that you might load them as strings, search for them as strings and perform a lazy conversion as necessary?", "Or could you parallelize the conversion and the other computations using threading or multiprocessing modules and Queues?", "(Have one or more threads/processes performing the conversion and feeding a Queue from which your processing engine fetches them).", "In other words would a producer/consumer design alleviate the problem?"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "threading", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "multiprocessing", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Agree with Greg; Python, as an interpreted language, is generally slow.", "You could try compiling the source code on-the-fly with the Psyco library or coding the app in a lower level language such C/C++."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Psyco library", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://psyco.sourceforge.net/"}]}], [{"text": ["It may not be an option for you, but I would look real hard at using a binary file rather than text.", "Does it change often?", "If not, you could pre-process it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]