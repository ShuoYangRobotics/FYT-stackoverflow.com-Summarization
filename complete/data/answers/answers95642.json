[[{"text": ["I like top-level exception handlers in general (regardless of language).", "They're a great place to cleanup resources that may not be immediately related to resources consumed inside the method that throws the exception."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's also a fantastic place to log those exceptions if you have such a framework in place.", "Top-level handlers will catch those bizarre exceptions you didn't plan on and let you correct them in the future, otherwise, you may never know about them at all."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "log", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Just be careful that your top-level handler doesn't throw exceptions!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A destructor (as in a __del__ method) is a bad idea, as these are not guaranteed to be called.", "The atexit module is a safer approach, although these will still not fire if the Python interpreter crashes (rather than the Python application), or if os._exit() is used, or the process is killed aggressively, or the machine reboots.", "(Of course, the last item isn't an issue in your case.", ") If your process is crash-prone (it uses fickle third-party extension modules, for instance) you may want to do the cleanup in a simple parent process for more isolation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you aren't really worried, use the atexit module."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Application wide handler is fine.", "They are great for logging.", "Just make sure that the application wide one is durable and is unlikely to crash itself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["if you use classes, you should free the resources they allocate in their destructors instead, of course.", "Use the try: on entire application just if you want to free resources that aren't already liberated by your classes' destructors."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["And instead of using a catch-all except:, you should use the following block:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n try:\n    main()\nfinally:\n    cleanup()\n</code>\n</pre>\n", "senID": 2}, {"text": ["That will ensure cleanup in a more pythonic way."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["That seems like a reasonable approach, and more straightforward and reliable than a destructor on a singleton class.", "You might also look at the \"atexit\" module.", "(Pronounced \"at exit\", not \"a tex it\" or something like that.", "I confused that for a long while."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "atexit", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-atexit.html"}]}], [{"text": ["Consider writing a context manager and using the with statement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]