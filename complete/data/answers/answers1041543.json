[[{"text": ["Python use arbitrary-precision arithmetic to calculate with integers, so it can exactly calculate 200!.", "For real numbers (so-called floating-point), Python does not use an exact representation.", "It uses a binary representation called IEEE 754, which is essentially scientific notation, except in base 2 instead of base 10."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "arbitrary-precision arithmetic", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Arbitrary-precision%5Farithmetic"}, {"text": "floating-point", "tag": "a", "pos": 1, "childList": [{"text": "floating-point", "tag": "em"}], "childNum": 1, "href": "http://en.wikipedia.org/wiki/Floating-point"}, {"text": "floating-point", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "IEEE 754", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/IEEE%5F754"}]}, {"text": ["Thus, any real number that cannot be exactly represented in base 2 with 53 bits of precision, Python cannot produce an exact result.", "For example, 0.1 (in base 10) is an infinite decimal in base 2, 0.0001100110011..., so it cannot be exactly represented.", "Hence, if you enter on a Python prompt:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 0.1\n0.10000000000000001\n</code>\n</pre>\n", "senID": 2}, {"text": ["The result you get back is different, since has been converted from decimal to binary (with 53 bits of precision), back to decimal.", "As a consequence, you get things like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 0.1 + 0.2 == 0.3\nFalse\n</code>\n</pre>\n", "senID": 4}, {"text": ["For a good (but long) read, see What Every Programmer Should Know About Floating-Point Arithmetic."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "What Every Programmer Should Know About Floating-Point Arithmetic", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.sun.com/source/806-3568/ncg%5Fgoldberg.html"}]}], [{"text": ["Python has unbounded integer sizes in the form of a long type.", "That is to say, if it is a whole number, the limit on the size of the number is restricted by the memory available to Python."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "integer", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "long", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["When you compute a large number such as 200!", "and you see an L on the end of it, that means Python has automatically cast the int to a long, because an int was not large enough to hold that number."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "long", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["See section 6.4 of this page for more information."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this page", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html"}]}], [{"text": ["See Handling very large numbers in Python. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Handling very large numbers in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/538551/handling-very-large-numbers-in-python"}]}, {"text": ["Python has a BigNum class for holding 200!", "and will use it automatically. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Your teacher's statement, though not exactly true here is true in general.", "Computers have limitations, and it is good to know what they are.", "Remember that every time you add another integer of data storage, you can store a number that is 2^32 (4 billion +) times larger.", "It is hard to comprehend how many more numbers that is - but maths gets slower as you add more integers to store the exact value of a very large number."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As an example (what you can store with 1000 bits)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 2 &lt;&lt; 1000\n2143017214372534641896850098120003621122809623411067214887500776740702102249872244986396\n7576313917162551893458351062936503742905713846280871969155149397149607869135549648461970\n8421492101247422837559083643060929499671638825347975351183310878921541258291423929553730\n84335320859663305248773674411336138752L\n</code>\n</pre>\n", "senID": 4}, {"text": ["I tried to illustrate how big a number you can store with 10000 bits, or even 8,000,000 bits (a megabyte) but that number is many pages long."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["200!", "is a very large number indeed. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If the range of an IEEE 64-bit double is 1.7E +/- 308 (15 digits), you can see that the largest factorial you can get is around 170!.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Python can handle arbitrary sized numbers, as can Java with its BigInteger."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Without some sort of clarification to that statement, it's obviously false.", "Just from personal experience, early lessons in programming (in the late 1980s) included solving very similar, if not exactly the same, problems.", "In general, to know some device which does calculations isn't making approximations, you have to prove (in the math sense of a proof) that it isn't."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python's integer types (named int and long in 2.x, both folded into just the int type in 3.x) are very good, and do not overflow like, for example, the int type in C. If you do the obvious of print 200 * 199 * 198 * ... it may be slow, but it will be exact.", "Similiarly, addition, subtraction, and modulus are exact.", "Division is a mixed bag, as there's two operators, / and //, and they underwent a change in 2.x&mdash;in general you can only treat it as inexact."], "childNum": 7, "tag": "p", "senID": 1, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "long", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "print 200 * 199 * 198 * ...", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "/", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "//", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you want more control yet don't want to limit yourself to integers, look at the decimal module."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "decimal", "tag": "a", "pos": 0, "childList": [{"text": "decimal", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/decimal.html"}, {"text": "decimal", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Python handles large numbers automatically (unlike a language like C where you can overflow its datatypes and the values reset to zero, for example) - over a certain point (sys.maxint or 2147483647) it converts the integer to a \"long\" (denoted by the L after the number), which can be any length:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sys.maxint", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "L", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def fact(x):\n...     return reduce(lambda x, y: x * y, range(1, x+1))\n... \n&gt;&gt;&gt; fact(10)\n3628800\n&gt;&gt;&gt; fact(200)\n788657867364790503552363213932185062295135977687173263294742533244359449963403342920304284011984623904177212138919638830257642790242637105061926624952829931113462857270763317237396988943922445621451664240254033291864131227428294853277524242407573903240321257405579568660226031904170324062351700858796178922222789623703897374720000000000000000000000000000000000000000000000000L\n</code>\n</pre>\n", "senID": 1}, {"text": ["Long numbers are \"easy\", floating point is more complicated, and almost any computer representation of a floating point number is an approximation, for example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; float(1)/3\n0.33333333333333331\n</code>\n</pre>\n", "senID": 3}, {"text": ["Obviously you can't store an infinite number of 3's in memory, so it cheats and rounds it a bit.."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You may want to look at the decimal module:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "decimal", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/decimal.html"}]}]]