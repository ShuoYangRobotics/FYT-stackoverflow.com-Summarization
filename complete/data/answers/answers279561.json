[[{"text": ["A bit reversed, but this should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n    foo.counter += 1\n    print \"Counter is %d\" % foo.counter\nfoo.counter = 0\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can create a decorator:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def static_var(varname, value):\n    def decorate(func):\n        setattr(func, varname, value)\n        return func\n    return decorate\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then use the code like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n @static_var(\"counter\", 0)\ndef foo():\n    foo.counter += 1\n    print \"Counter is %d\" % foo.counter\n</code>\n</pre>\n", "senID": 5}, {"text": ["It'll still require you to use the 'foo.", "' prefix, unfortunately."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["In addition to the way Claudiu demonstrated, you can also do it like this.", "(Though it's probably a bad idea; it's not very clear."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo(counter=[0]):\n...   counter[0] += 1\n...   print(\"Counter is %i.\" % counter[0]);\n... \n&gt;&gt;&gt; foo()\nCounter is 1.\n&gt;&gt;&gt; foo()\nCounter is 2.\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Default values are initialized only when the function is first evaluated, not each time it is executed, so you can use a list or any other mutable object to maintain static values."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can add attributes to a function, and use it as a static variable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def myfunc():\n  myfunc.counter += 1\n  print myfunc.counter\n\n# attribute must be initialized\nmyfunc.counter = 0\n</code>\n</pre>\n", "senID": 1}, {"text": ["Alternatively, if you don't want to setup the variable outside the function, you have to resort to getattr to avoid an AttributeNotFound exception, which is kind of ugly :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def myfunc():\n  myfunc.counter += getattr(myfunc,\"counter\",0) # 0 is the default value\n</code>\n</pre>\n", "senID": 3}, {"text": ["Anyway static variables are rather rare, and you should find a better place for this variable, most likely inside a class."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Python doesn't have static variables but you can fake it by defineing a callable object and then use it as a function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n  counter = 0\n\n  def __call__(self):\n    Foo.counter += 1\n    print Foo.counter\n\nfoo = Foo()\n\nfoo() #prints 1\nfoo() #prints 2\nfoo() #prints 3\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use a generator function to generate an iterator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo_gen():\n    n = 0\n    while True:\n        n+=1\n        yield n\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then use it like"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n foo = foo_gen().next\nfor i in range(0,10):\n    print foo()\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you want an upper limit:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def foo_gen(limit=100000):\n    n = 0\n    while n &lt; limit:\n       n+=1\n       yield n\n</code>\n</pre>\n", "senID": 5}, {"text": ["If the iterator terminates (like the example above), you can also loop over it directly, like"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n for i in foo_gen(20):\n    print i\n</code>\n</pre>\n", "senID": 7}, {"text": ["Of course, in these simple cases it's better to use xrange :)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Here is the documentation on the yield statement."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "yield statement", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/simple_stmts.html#the-yield-statement"}]}], [{"code": "<pre>\n_counter = 0\ndef foo():\n   global _counter\n   _counter += 1\n   print 'counter is', _counter\n</pre>\n", "senID": 0}, {"text": ["Python customarily uses underscores to indicate private variables.", "The only reason in C to declare the static variable inside the function is to hide it outside the function, which is not really idiomatic Python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The idiomatic way is to use a class, which can have attributes.", "If you need instances to not be separate, use a singleton."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "idiomatic", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "class", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["There are a number of ways you could fake or munge \"static\" variables into Python (one not mentioned so far is to have a mutable default argument), but this is not the Pythonic, idiomatic way to do it.", "Just use a class."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Pythonic, idiomatic", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Or possibly a generator, if your usage pattern fits."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]