[[{"text": ["For a web application you should use a database, the way you're doing it you are creating one copy of your dict for each apache process, which is extremely wasteful.", "If you have enough memory on the server the database table will be cached in memory (if you don't have enough for one copy of your table, put more RAM into the server).", "Just remember to put correct indices on your database table or you will get bad performance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I suggest the following: store all the values in a DB, and keep an in-memory dictionary with string hashes as keys.", "If a collision occurs, fetch values from the DB, otherwise (vast majority of the cases) use the dictionary.", "Effectively, it will be a giant cache."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A problem with dictionaries in Python is that they use a lot of space: even an int-int dictionary uses 45-80 bytes per key-value pair on a 32-bit system.", "At the same time, an array.array('i') uses only 8 bytes per a pair of ints, and with a little bit of bookkeeping one can implement a reasonably fast array-based int \u2192 int dictionary."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "45-80 bytes", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "array.array('i')", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "8 bytes", "childNum": 0, "tag": "strong", "childList": []}, {"text": "int \u2192 int", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Once you have a memory-efficient implementation of an int-int dictionary, split your string \u2192 (object, int, int) dictionary into three dictionaries and use hashes instead of full strings.", "You'll get one int \u2192 object and two int \u2192 int dictionaries.", "Emulate the int \u2192 object dictionary as follows: keep a list of objects and store indexes of the objects as values of an int \u2192 int dictionary."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "string \u2192 (object, int, int)", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "int \u2192 object", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "int \u2192 int", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "int \u2192 object", "childNum": 0, "tag": "em", "childList": []}, {"text": "int \u2192 int", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["I do realize there's a considerable amount of coding involved to get an array-based dictionary.", "I had had problem similar to yours and I have implemented a reasonably fast, very memory-efficient, generic hash-int dictionary.", "Here's my code (BSD license).", "It is array-based (8 bytes per pair), it takes care of key hashing and collision checking, it keeps the array (several smaller arrays, actually) ordered during writes and does binary search on reads.", "Your code is reduced to something like:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Here's my code", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.google.com/p/interwiki-analysis/source/browse/trunk/import-analysis/wikitools/memoptpy.py"}]}, {"code": "<pre>\n<code>\n dictionary = HashIntDict(checking = HashIntDict.CHK_SHOUTING)\n# ...\ndatabase.store(k, v)\ntry:\n    dictionary[k] = v\nexcept CollisionError:\n    pass\n# ...\ntry:\n    v = dictionary[k]\nexcept CollisionError:\n    v = database.fetch(k)\n</code>\n</pre>\n", "senID": 4}, {"text": ["The checking parameter specifies what happens when a collision occurs: CHK_SHOUTING raises CollisionError on reads and writes, CHK_DELETING returns None on reads and remains silent on writes, CHK_IGNORING doesn't do collision checking."], "childNum": 6, "tag": "p", "senID": 5, "childList": [{"text": "checking", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "CHK_SHOUTING", "childNum": 0, "tag": "code", "childList": []}, {"text": "CollisionError", "childNum": 0, "tag": "code", "childList": []}, {"text": "CHK_DELETING", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}, {"text": "CHK_IGNORING", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What follows is a brief description of my implementation, optimization hints are welcome!", "The top-level data structure is a regular dictionary of arrays.", "Each array contains up to 2^16 = 65536 integer pairs (square root of 2^32).", "A key k and a corresponding value v are both stored in k/65536-th array.", "The arrays are initialized on-demand and kept ordered by keys.", "Binary search is executed on each read and write.", "Collision checking is an option.", "If enabled, an attempt to overwrite an already existing key will remove the key and associated value from the dictionary, add the key to a set of colliding keys, and (again, optionally) raise an exception."], "childNum": 5, "tag": "p", "senID": 6, "childList": [{"text": "2^16 = 65536", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "2^32", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "v", "childNum": 0, "tag": "code", "pos": 7, "childList": []}, {"text": "k/65536", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I've had situations where I've had a collection of large objects that I've needed to sort and filter by different methods based on several metadata properties.", "I didn't need the larger parts of them so I dumped them to disk."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As you data is so simple in type, a quick SQLite database might solve all your problems, even speed things up a little."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Use shelve or a database to store the data instead of an in-memory dict."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "shelve", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you want to stay with the in-memory data store, you could try something like memcached."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "memcached", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://memcached.org/"}]}, {"text": ["That way, you can use a single in-memory key/value-store from all the Python processes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There are several python memcached client libraries."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Redis would be a great option here if you have the option to use it on a shared host - similar to memcached, but optimised for data structures.", "Redis also supports python bindings."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Redis", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/redis/"}]}, {"text": ["I use it on a day to day basis for number crunching but also in production systems as a datastore and cannot recommend it highly enough."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Als, di you have an topion to proxy your app behind nginx instead fo using Apache?", "You might find (if allowed) this proxy/webapp arrangement less hungry on resources."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Good luck."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you want to do extensive optimization and have full control on memory usage you could also write a C/C++ module.", "Using Swig the code wrapping into Python can be done easily, with some small performance overhead comparing to pure C Python module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Swig", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.swig.org/"}]}]]