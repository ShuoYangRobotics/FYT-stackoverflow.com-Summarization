[[{"text": ["Here is a snippet of code that allows to access errno:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "errno", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from ctypes import *\n\nlibc = CDLL(\"libc.so.6\")\n\nget_errno_loc = libc.__errno_location\nget_errno_loc.restype = POINTER(c_int)\n\ndef errcheck(ret, func, args):\n    if ret == -1:\n        e = get_errno_loc()[0]\n        raise OSError(e)\n    return ret\n\ncopen = libc.open\ncopen.errcheck = errcheck\n\nprint copen(\"nosuchfile\", 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The important thing is that you check errno as soon as possible after your function call, otherwise it may already be overwritten."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "errno", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Belowed code is not reliable (or comprehensive, there are a plefora of ways errno could be defined) but it should get you started (or reconsider your position on a tiny extension module (after all on Debian python setup.py install or easy_install should have no problem to build it)).", "From  http://codespeak.net/pypy/dist/pypy/rpython/lltypesystem/ll2ctypes.py"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "errno", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "python setup.py install", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "easy_install", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "http://codespeak.net/pypy/dist/pypy/rpython/lltypesystem/ll2ctypes.py", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://codespeak.net/pypy/dist/pypy/rpython/lltypesystem/ll2ctypes.py"}]}, {"code": "<pre>\n<code>\n if not hasattr(ctypes, 'get_errno'):\n    # Python 2.5 or older\n    if sys.platform == 'win32':\n        standard_c_lib._errno.restype = ctypes.POINTER(ctypes.c_int)\n        def _where_is_errno():\n            return standard_c_lib._errno()\n\n    elif sys.platform in ('linux2', 'freebsd6'):\n        standard_c_lib.__errno_location.restype = ctypes.POINTER(ctypes.c_int)\n        def _where_is_errno():\n            return standard_c_lib.__errno_location()\n\n    elif sys.platform in ('darwin', 'freebsd7'):\n        standard_c_lib.__error.restype = ctypes.POINTER(ctypes.c_int)\n        def _where_is_errno():\n            return standard_c_lib.__error()\n    ctypes.get_errno = lambda: _where_is_errno().contents.value\n</code>\n</pre>\n", "senID": 1}, {"text": ["Where standard_c_lib:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "standard_c_lib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def get_libc_name():\n    if sys.platform == 'win32':\n        # Parses sys.version and deduces the version of the compiler\n        import distutils.msvccompiler\n        version = distutils.msvccompiler.get_build_version()\n        if version is None:\n            # This logic works with official builds of Python.\n            if sys.version_info &lt; (2, 4):\n                clibname = 'msvcrt'\n            else:\n                clibname = 'msvcr71'\n        else:\n            if version &lt;= 6:\n                clibname = 'msvcrt'\n            else:\n                clibname = 'msvcr%d' % (version * 10)\n\n        # If python was built with in debug mode\n        import imp\n        if imp.get_suffixes()[0][0] == '_d.pyd':\n            clibname += 'd'\n\n        return clibname+'.dll'\n    else:\n        return ctypes.util.find_library('c')\n\n# Make sure the name is determined during import, not at runtime\nlibc_name = get_libc_name() \nstandard_c_lib = ctypes.cdll.LoadLibrary(get_libc_name())\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It looks like you can use this patch that will provide you with ctypes.get_errno/set_errno"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ctypes.get_errno/set_errno", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["http://bugs.python.org/issue1798"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://bugs.python.org/issue1798", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bugs.python.org/issue1798"}]}, {"text": ["This is the patch that was actually applied to the repository:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://svn.python.org/view?view=rev&amp;revision=63977"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://svn.python.org/view?view=rev&amp;revision=63977", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view?view=rev&revision=63977"}]}, {"text": ["Otherwise, adding a new C module that does nothing but return errno /is/ disgusting, but so is the library that you're using.", "I would do that in preference to patching python myself."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Gave up and tracked through the C headers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import ctypes\nc = ctypes.CDLL(\"libc.so.6\")\nc.__errno_location.restype = ctypes.POINTER(ctypes.c_int)\nc.write(5000, \"foo\", 4)\nprint c.__errno_location().contents # -&gt; c_long(9)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It doesn't work in the python command prompt because it resets errno to read from stdin."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Once you know the magic word of __errno_location this looks like a common pattern.", "But with just errno I was pretty lost."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "magic word of __errno_location", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.com/search?q=%5F%5Ferrno%5Flocation%2Bctypes"}, {"text": "errno", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.google.com/search?q=errno%2Bctypes"}]}], [{"text": ["I'm not sure if this is what you and Jerub are referring to, but you could write a very short C extension that just exports errno, i.e.", "with the python language interface. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the python language interface", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.1/ext/simpleExample.html"}]}, {"text": ["Otherwise, I agree with you that having to add this small bit of compiled code is a pain."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["ctypes actually gives a standard way to access python's c implementation, which is using errno.", "I haven't tested this on anything other than my (linux) system, but this should be very portable:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["ctypes.c_int.in_dll(ctypes.pythonapi,\"errno\")"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["which returns a c_int containing the current value."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]