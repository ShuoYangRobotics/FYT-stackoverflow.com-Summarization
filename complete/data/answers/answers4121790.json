[[{"text": ["You might want to crank up the optimisation level of your C compiler.", "With gcc -O3, that makes a big difference, a drop from 2.015 seconds to 0.766 seconds, a reduction of about 62%."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "gcc -O3", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Beyond that, you need to ensure you've tested correctly.", "You should run each program ten times, remove the outliers (fastest and slowest), then average the other eight."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In addition, make sure you're measuring CPU time rather than clock time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Anything less than that, I would not consider a decent statistical analysis and it may well be subject to noise, rendering your results useless."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["For what it's worth, those C timings above were for seven runs with the outliers taken out before averaging."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In fact, this question shows how important algorithm selection is when aiming for high performance.", "Although recursive solutions are usually elegant, this one suffers from the fault that you duplicate a lot of calculations.", "The iterative version:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "lot", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n int fib(unsigned int n) {\n    int t, a, b;\n    if (n &lt; 2) return 1;\n    a = b = 1;\n    while (n-- &gt;= 2) {\n        t = a + b;\n        a = b;\n        b = t;\n    }\n    return b;\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["further drops the time taken, from 0.766 seconds to 0.078 seconds, a further reduction of 89% and a whopping reduction of 96% from the original code."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "whopping", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["And, as a final attempt, you should try out the following, which combines a lookup table with calculations beyond a certain point:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n static int fib(unsigned int n) {\n    static int lookup[] = {\n        1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377,\n        610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657,\n        46368, 75025, 121393, 196418, 317811, 514229, 832040,\n        1346269, 2178309, 3524578, 5702887, 9227465, 14930352,\n        24157817, 39088169, 63245986, 102334155, 165580141 };\n    int t, a, b;\n\n    if (n &lt; sizeof(lookup)/sizeof(*lookup))\n        return lookup[n];\n    a = lookup[sizeof(lookup)/sizeof(*lookup)-2];\n    b = lookup[sizeof(lookup)/sizeof(*lookup)-1];\n    while (n-- &gt;= sizeof(lookup)/sizeof(*lookup)) {\n        t = a + b;\n        a = b;\n        b = t;\n    }\n\n    return b;\n}\n</code>\n</pre>\n", "senID": 9}, {"text": ["That reduces the time yet again but I suspect we're hitting the point of diminishing returns here."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["You say very little about your configuration (in benchmarking, details are everything: commandlines, computer used, ...)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When I try to reproduce for OCaml I get:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n let rec f n = if n &lt; 2 then 1 else (f (n-1)) + (f (n-2))\n\nlet () = Format.printf \"%d@.\" (f 40)\n\n\n$ ocamlopt fib.ml\n$ time ./a.out \n165580141\n\nreal    0m1.643s\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is on an Intel Xeon 5150 (Core 2) at 2.66GHz.", "If I use the bytecode OCaml compiler ocamlc on the other hand, I get a time similar to your result (11s).", "But of course, for running a speed comparison, there is no reason to use the bytecode compiler, unless you want to benchmark the speed of compilation itself (ocamlc is amazing for speed of compilation)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "ocamlc", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "ocamlc", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["One possibility is that the C compiler is optimizing on the guess that the first branch (n &lt; 2) is the one more frequently taken.", "It has to do that purely at compile time: make a guess and stick with it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "n &lt; 2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Hotspot gets to run the code, see what actually happens more often, and reoptimize based on that data."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "actually", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["You may be able to see a difference by inverting the logic of the if:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "may", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n public static int fib(int n) {\n if (n &gt;= 2) return fib(n-1) + fib(n-2);\n return 1;\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["It's worth a try, anyway :)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["As always, check the optimization settings for all platforms, too.", "Obviously the compiler settings for C - and on Java, try using the client version of Hotspot vs the server version.", "(Note that you need to run for longer than a second or so to really get the full benefit of Hotspot... it might be interesting to put the outer call in a loop to get runs of a minute or so."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I can explain the Python performance.", "Python's performance for recursion is abysmal at best, and it should be avoided like the plague when coding in it.", "Especially since stack overflow occurs by default at a recursion depth of only 1000..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As for Java's performance, that's amazing.", "It's rare that Java beats C (even with very little compiler optimization on the C side)... what the JIT might be doing is memoization or tail recursion..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Note that if the Java Hotspot VM is smart enough to memoise fib() calls, it can cut down the exponentional cost of the algorithm to something nearer to linear cost."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["With C, you should either declare the fibonacci function \"inline\", or, using gcc, add the -finline-functions argument to the compile options.", "That will allow the compiler to do recursive inlining.", "That's also the reason why with -O3 you get better performance, it activates -finline-functions."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "-finline-functions", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "-finline-functions", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Edit You need to at least specify -O/-O1 to have recursive inlining, also if the function is declared inline.", "Actually, testing myself I found that declaring the function inline and using -O as compilation flag, or just using -O -finline-functions, my recursive fibonacci code was faster than with -O2 or -O2 -finline-functions."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "-O", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "-O -finline-functions", "childNum": 0, "tag": "code", "childList": []}, {"text": "-O2", "childNum": 0, "tag": "code", "childList": []}, {"text": "-O2 -finline-functions", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I wrote a C version of the naive Fibonacci function and compiled it to assembler in gcc (4.3.2 Linux).", "I then compiled it with gcc -O3.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The unoptimised version was 34 lines long and looked like a straight translation of the C code.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The optimised version was 190 lines long and (it was difficult to tell but) it appeared to inline at least the calls for values up to about 5."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["One C trick which you can try is to disable the stack checking (i e built-in code which makes sure that the stack is large enough to permit the additional allocation of the current function's local variables).", "This could be dicey for a recursive function and indeed could be the reason behind the slow C times: the executing program might well have run out of stack space which forces the stack-checking to reallocate the entire stack several times during the actual run."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Try to approximate the stack size you need and force the linker to allocate that much stack space.", "Then disable stack-checking and re-make the program."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]