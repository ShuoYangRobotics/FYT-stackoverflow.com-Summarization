[[{"text": ["The fastest way seems to be to preallocate the array, given as option 7 right at the bottom of this answer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; A=np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14])\n&gt;&gt;&gt; A\narray([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])\n&gt;&gt;&gt; np.array(zip(A,A[1:],A[2:],A[3:]))\narray([[ 1,  2,  3,  4],\n       [ 2,  3,  4,  5],\n       [ 3,  4,  5,  6],\n       [ 4,  5,  6,  7],\n       [ 5,  6,  7,  8],\n       [ 6,  7,  8,  9],\n       [ 7,  8,  9, 10],\n       [ 8,  9, 10, 11],\n       [ 9, 10, 11, 12],\n       [10, 11, 12, 13],\n       [11, 12, 13, 14]])\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can easily adapt this to do it for variable chunk size."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; n=5\n&gt;&gt;&gt; np.array(zip(*(A[i:] for i in range(n))))\narray([[ 1,  2,  3,  4,  5],\n       [ 2,  3,  4,  5,  6],\n       [ 3,  4,  5,  6,  7],\n       [ 4,  5,  6,  7,  8],\n       [ 5,  6,  7,  8,  9],\n       [ 6,  7,  8,  9, 10],\n       [ 7,  8,  9, 10, 11],\n       [ 8,  9, 10, 11, 12],\n       [ 9, 10, 11, 12, 13],\n       [10, 11, 12, 13, 14]])\n</code>\n</pre>\n", "senID": 3}, {"text": ["You may wish to compare performance between this and using itertools.islice."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "itertools.islice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import islice\n&gt;&gt;&gt; n=4\n&gt;&gt;&gt; np.array(zip(*[islice(A,i,None) for i in range(n)]))\narray([[ 1,  2,  3,  4],\n       [ 2,  3,  4,  5],\n       [ 3,  4,  5,  6],\n       [ 4,  5,  6,  7],\n       [ 5,  6,  7,  8],\n       [ 6,  7,  8,  9],\n       [ 7,  8,  9, 10],\n       [ 8,  9, 10, 11],\n       [ 9, 10, 11, 12],\n       [10, 11, 12, 13],\n       [11, 12, 13, 14]])\n</code>\n</pre>\n", "senID": 5}, {"code": "<pre>\n<code>\n 1. timeit np.array(zip(A,A[1:],A[2:],A[3:]))\n10000 loops, best of 3: 92.9 us per loop\n\n2. timeit np.array(zip(*(A[i:] for i in range(4))))\n10000 loops, best of 3: 101 us per loop\n\n3. timeit np.array(zip(*[islice(A,i,None) for i in range(4)]))\n10000 loops, best of 3: 101 us per loop\n\n4. timeit numpy.array([ A[i:i+4] for i in range(len(A)-3) ])\n10000 loops, best of 3: 37.8 us per loop\n\n5. timeit numpy.array(list(chunks(A, 4)))\n10000 loops, best of 3: 43.2 us per loop\n\n6. timeit numpy.array(byN(A, 4))\n10000 loops, best of 3: 100 us per loop\n\n# Does preallocation of the array help? (11 is from len(A)+1-4)\n7. timeit B=np.zeros(shape=(11, 4),dtype=np.int32)\n100000 loops, best of 3: 2.19 us per loop\n   timeit for i in range(4):B[:,i]=A[i:11+i]\n10000 loops, best of 3: 20.9 us per loop\ntotal 23.1us per loop\n</code>\n</pre>\n", "senID": 6}, {"text": ["As len(A) increases (20000) 4 and 5 converge to be equivalent speed (44 ms).", "1,2,3 and 6 all remain about 3 times slower (135 ms).", "7 is much faster (1.36 ms)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["You should use stride_tricks.", "When I first saw this, the word 'magic' did spring to mind.", "It's simple and is by far the fastest method."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "stride_tricks", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; as_strided = numpy.lib.stride_tricks.as_strided\n&gt;&gt;&gt; a = numpy.arange(1,15)\n&gt;&gt;&gt; a\narray([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])\n&gt;&gt;&gt; b = as_strided(a,(11,4),(4,4))\n&gt;&gt;&gt; b\narray([[ 1,  2,  3,  4],\n       [ 2,  3,  4,  5],\n       [ 3,  4,  5,  6],\n       [ 4,  5,  6,  7],\n       [ 5,  6,  7,  8],\n       [ 6,  7,  8,  9],\n       [ 7,  8,  9, 10],\n       [ 8,  9, 10, 11],\n       [ 9, 10, 11, 12],\n       [10, 11, 12, 13],\n       [11, 12, 13, 14]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Be aware that the values in array b are those in a, just viewed differently.", "Do a .copy() on b if you plan to modify it."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": ".copy()", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I saw this at a SciPy conference.", "Here are the slides for more explanation."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "slides", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://mentat.za.net/numpy/numpy_advanced_slides/"}]}], [{"text": ["Quick&amp;dirty solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = numpy.arange(1,15)\n&gt;&gt;&gt; numpy.array([ a[i:i+4] for i in range(len(a)-3) ])\narray([[ 1,  2,  3,  4],\n       [ 2,  3,  4,  5],\n       [ 3,  4,  5,  6],\n       [ 4,  5,  6,  7],\n       [ 5,  6,  7,  8],\n       [ 6,  7,  8,  9],\n       [ 7,  8,  9, 10],\n       [ 8,  9, 10, 11],\n       [ 9, 10, 11, 12],\n       [10, 11, 12, 13],\n       [11, 12, 13, 14]])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using itertools, and assuming Python 2.6:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html"}]}, {"code": "<pre>\n<code>\n import itertools\n\ndef byN(iterable, N):\n    itrs = itertools.tee(iter(iterable), N)\n    for n in range(N):\n        for i in range(n):\n            next(itrs[n], None)\n    return zip(*itrs)\n\naby4 = numpy.array(byN(thearray, 4))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Broadcast!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from numpy import ogrid\ndef stretch(N=5,M=15):\n    x, y = ogrid[0:M,0:N]\n    return x+y+1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that ogrid does give things like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; ogrid[0:5,0:5]\n&gt;&gt; \n[array([[0],\n       [1],\n       [2],\n       [3],\n       [4]]),\n array([[0, 1, 2, 3, 4]])]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Let's compare with another solution given here:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def zipping(N=5,M=15):\n    A = numpy.arange(1, M+1)\n    return numpy.array(zip(*(A[i:] for i in range(N))))\n</code>\n</pre>\n", "senID": 5}, {"text": ["comparison (python 2.6, 32 bit, 1Go RAM) gives"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; %timeit stretch(5,15)\n10000 loops, best of 3: 61.2 us per loop\n\n&gt;&gt;&gt; %timeit zipping(5,15)\n10000 loops, best of 3: 72.5 us per loop\n\n&gt;&gt;&gt; %timeit stretch(5,1e3)\n10000 loops, best of 3: 128 us per loop\n\n&gt;&gt;&gt; %timeit zipping(5,1e3)\n100 loops, best of 3: 4.25 ms per loop\n</code>\n</pre>\n", "senID": 7}, {"text": ["The 40-fold speed-up is kind of consistant to scaling."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I know of no Python stdlib function that quite does that.", "It's easy enough to do.", "Here is a generator that basically does it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def chunks(sequence, length):\n    for index in xrange(0, len(sequence) - length + 1):\n        yield sequence[index:index + length]\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could use it like so"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy\n&gt;&gt;&gt; a = numpy.arange(1, 15)\n&gt;&gt;&gt; a\narray([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])\n&gt;&gt;&gt; numpy.array(list(chunks(a, 4)))\narray([[ 1,  2,  3,  4],\n       [ 2,  3,  4,  5],\n       [ 3,  4,  5,  6],\n       [ 4,  5,  6,  7],\n       [ 5,  6,  7,  8],\n       [ 6,  7,  8,  9],\n       [ 7,  8,  9, 10],\n       [ 8,  9, 10, 11],\n       [ 9, 10, 11, 12],\n       [10, 11, 12, 13],\n       [11, 12, 13, 14]])\n</code>\n</pre>\n", "senID": 3}, {"text": ["The only weird thing about this code is that I called list on the result of chunks(a, 4).", "This is since numpy.array does not accept an arbitrary iterable, such as the generator chunks returns.", "If you just want to iterate over these chunks, you don't need to bother.", "If you really need to put the result into an array you can do it this way or some more efficient ways."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "chunks(a, 4)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "numpy.array", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "chunks", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["The efficient NumPy way to do this is given here, which is somewhat too long to reproduce here.", "It boils down to using some stride tricks, and is much faster than itertools for largish window sizes.", "For example, using a method essentially the same as that of of Alex Martelli's:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://projects.scipy.org/numpy/attachment/ticket/901/segmentaxis.py"}]}, {"code": "<pre>\n<code>\n In [16]: def windowed(sequence, length):\n    seqs = tee(sequence, length)\n    [ seq.next() for i, seq in enumerate(seqs) for j in xrange(i) ]\n    return zip(*seqs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["We get:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n In [19]: data = numpy.random.randint(0, 2, 1000000)\n\nIn [20]: %timeit windowed(data, 2)\n100000 loops, best of 3: 6.62 us per loop\nIn [21]: %timeit windowed(data, 10)\n10000 loops, best of 3: 29.3 us per loop\nIn [22]: %timeit windowed(data, 100)\n1000 loops, best of 3: 1.41 ms per loop\nIn [23]: %timeit segment_axis(data, 2, 1)\n10000 loops, best of 3: 30.1 us per loop\nIn [24]: %timeit segment_axis(data, 10, 9)\n10000 loops, best of 3: 30.2 us per loop\nIn [25]: %timeit segment_axis(data, 100, 99)\n10000 loops, best of 3: 30.5 us per loop\n</code>\n</pre>\n", "senID": 3}]]