[[{"text": ["I`d do something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ifstream f(\"data.txt\");\nstring str;\nwhile (getline(f, str)) {\n    Point p;\n    sscanf(str.c_str(), \"%f, %f, %f\\n\", &amp;p.x, &amp;p.y, &amp;p.z); \n    points.push_back(p);\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["x,y,z must be floats."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["And include:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n#include &lt;fstream&gt;\n</code>\n</pre>\n", "senID": 4}], [{"text": ["All these good examples aside, in C++ you would normally override the operator &gt;&gt; for your point type to achieve something like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "operator &gt;&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n point p;\nwhile (file &gt;&gt; p)\n    points.push_back(p);\n</code>\n</pre>\n", "senID": 1}, {"text": ["or even:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n copy(\n    istream_iterator&lt;point&gt;(file),\n    istream_iterator&lt;point&gt;(),\n    back_inserter(points)\n);\n</code>\n</pre>\n", "senID": 3}, {"text": ["The relevant implementation of the operator could look very much like the code by j_random_hacker."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The C++ String Toolkit Library (StrTk) has the following solution to your problem:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "C++ String Toolkit Library (StrTk)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.partow.net/programming/strtk/index.html"}]}, {"code": "<pre>\n<code>\n #include &lt;string&gt;\n#include &lt;deque&gt;\n#include \"strtk.hpp\"\n\nstruct point { double x,y,z; }\n\nint main()\n{\n   std::deque&lt;point&gt; points;\n   point p;\n   strtk::for_each_line(\"data.txt\",\n                        [&amp;points,&amp;p](const std::string&amp; str)\n                        {\n                           strtk::parse(str,\",\",p.x,p.y,p.z);\n                           points.push_back(p);\n                        });\n   return 0;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["More examples can be found Here"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codeproject.com/KB/recipes/Tokenizer.aspx"}]}], [{"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;     // For replace()\n\nusing namespace std;\n\nstruct Point {\n    double a, b, c;\n};\n\nint main(int argc, char **argv) {\n    vector&lt;Point&gt; points;\n\n    ifstream f(\"data.txt\");\n\n    string str;\n    while (getline(f, str)) {\n        replace(str.begin(), str.end(), ',', ' ');\n        istringstream iss(str);\n        Point p;\n        iss &gt;&gt; p.a &gt;&gt; p.b &gt;&gt; p.c;\n        points.push_back(p);\n    }\n\n    // Do something with points...\n\n    return 0;\n}\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This answer is based on the previous answer by j_random_hacker and makes use of Boost Spirit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;boost/spirit.hpp&gt;\n\nusing namespace std;\nusing namespace boost;\nusing namespace boost::spirit;\n\nstruct Point {\n    double a, b, c;\n};\n\nint main(int argc, char **argv) \n{\n    vector&lt;Point&gt; points;\n\n    ifstream f(\"data.txt\");\n\n    string str;\n    Point p;\n    rule&lt;&gt; point_p = \n           double_p[assign_a(p.a)] &gt;&gt; ',' \n        &gt;&gt; double_p[assign_a(p.b)] &gt;&gt; ',' \n        &gt;&gt; double_p[assign_a(p.c)] ; \n\n    while (getline(f, str)) \n    {\n        parse( str, point_p, space_p );\n        points.push_back(p);\n    }\n\n    // Do something with points...\n\n    return 0;\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Fun with Boost.Tuples:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;boost/tuple/tuple_io.hpp&gt;\n#include &lt;vector&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    using namespace boost::tuples;\n    typedef boost::tuple&lt;float,float,float&gt; PointT;\n\n    std::ifstream f(\"input.txt\");\n    f &gt;&gt; set_open(' ') &gt;&gt; set_close(' ') &gt;&gt; set_delimiter(',');\n\n    std::vector&lt;PointT&gt; v;\n\n    std::copy(std::istream_iterator&lt;PointT&gt;(f), std::istream_iterator&lt;PointT&gt;(),\n             std::back_inserter(v)\n    );\n\n    std::copy(v.begin(), v.end(), \n              std::ostream_iterator&lt;PointT&gt;(std::cout)\n    );\n    return 0;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that this is not strictly equivalent to the Python code in your question because the tuples don't have to be on separate lines.", "For example, this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 1,2,3 4,5,6\n</code>\n</pre>\n", "senID": 3}, {"text": ["will give the same output than:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n 1,2,3\n4,5,6\n</code>\n</pre>\n", "senID": 5}, {"text": ["It's up to you to decide if that's a bug or a feature :)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["You could read the file from a std::iostream line by line, put each line into a std::string and then use boost::tokenizer to split it.", "It won't be quite as elegant/short as the python one but a lot easier than reading things in a character at a time..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["One of Sony Picture Imagework's open-source projects is Pystring, which should make for a mostly direct translation of the string-splitting parts:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Pystring", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pystring/"}]}, {"text": ["There are a few examples, and some documentation"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "a few examples", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pystring/wiki/Examples"}, {"href": "http://code.google.com/p/pystring/wiki/Documentation", "text": "some documentation", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Its nowhere near as terse, and of course I didn't compile this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n float atof_s( std::string &amp; s ) { return atoi( s.c_str() ); }\n{ \nifstream f(\"data.txt\")\nstring str;\nvector&lt;vector&lt;float&gt;&gt; data;\nwhile( getline( f, str ) ) {\n  vector&lt;float&gt; v;\n  boost::algorithm::split_iterator&lt;string::iterator&gt; e;\n  std::transform( \n     boost::algorithm::make_split_iterator( str, token_finder( is_any_of( \",\" ) ) ),\n     e, v.begin(), atof_s );\n  v.resize(3); // only grab the first 3\n  data.push_back(v);\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["all these are good examples.", "yet they dont answer the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["so for those who are still looking,  this class:\nhttp://www.codeguru.com/cpp/tic/tic0226.shtml\nis pretty cool... some changes might be needed "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.codeguru.com/cpp/tic/tic0226.shtml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codeguru.com/cpp/tic/tic0226.shtml"}]}]]