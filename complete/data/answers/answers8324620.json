[[{"text": ["You need to decide what you are trying achieve here.", "The use of the word \"error\" is probably misleading."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you are actually trying to handle the case where the wrong type of object is passed to your function then you don't want to handle that and should raise an exception."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you are trying to allow your function to be used on a series of different types then that's not really an error and using a default value may be reasonable."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The simplest option is to test whether the attribute exists first.", "For example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if hasattr(lst, \"attr\"):\n    attr = lst.attr\nelse:\n    attr = {}\n</code>\n</pre>\n", "senID": 4}, {"text": ["I'm assuming the lst.attr is a dictionary, in which case you can handle the default value like so:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "lst.attr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n lst.attr.get(idx, default_value)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Never use a try/except statement where you don't specify what exception you are catching.", "You can end up masking much more than you intended to."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "try", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "except", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["With your final piece of code I think you should not try and solve it in a single line.", "Readability counts.", "I'm not happy with the code below, but it would be improved if x, y and attr were replaced with more descriptive names."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}, {"text": "attr", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n attrs = [(x.attr if hasattr(x) else {}) for x in y]\n\nprint [attr.get(idx, default_value) for attr in attrs]\n</code>\n</pre>\n", "senID": 9}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import this\n...\nExplicit is better than implicit.\n...\nSparse is better than dense.\nReadability counts.\n...\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\n</code>\n</pre>\n", "senID": 0}, {"text": ["I have the feeling that the \"Pythonic way to assign default values\"* is either to handle exception - as you already mentioned in your question - either to write you own getters."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "\"Pythonic", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "Pythonic", "tag": "strong"}]}, {"text": "Pythonic", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["write a function and make it smart enough:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_attr_with_index_and_default(obj, attr_name, index, default):\n    try:\n        return getattr(obj, attr_name)[index]\n    except (AttributeError, IndexError):\n         return default\n\nprint [get_attr_with_index_and_default(x, 'attr', idx, some_default) for x in y]\n</code>\n</pre>\n", "senID": 1}, {"text": ["if you control the class of x, you can use this as a method, or adapt it as a a descriptor, but imo this is not worth it and will result in obscure code and difficult to trace bugs. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Even if there exists one-liner, it would be really complicated.", "E.g.", "this one still doesn't handle index problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n some_value = getattr(lst, 'attr', {idx: default_value})[idx]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I would suggest to write some getter for your lst."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "lst", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["When there is 'attr' in object"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class C(object):\n    attr = \"attr on class\"\nlst = C()\nprint lst.attr if hasattr(lst,'attr') else \"default value\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["When there is no attribute 'attr'"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class C(object):\n    #attr = \"attr on class\"\n    pass\nlst = C()\nprint lst.attr if hasattr(lst,'attr') else \"default value\"\n</code>\n</pre>\n", "senID": 3}], [{"text": ["There is no simple, elegant solution to your problem.", "If it must be done using a one-liner that can be used in list-comprehensions for example, then you could do the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # If lst.attr is a dict.\nsome_value = getattr(lst, 'attr', {}).get(idx, default_value)\n# OR\nsome_value = lst.attr.get(idx, default_value) if hasattr(lst, 'attr') else default_value\n# OR\nsome_value = lst.attr[idx] if hasattr(lst, 'attr') and idx in lst.attr else default_value\n\n# If lst.attr is a sequence.\nsome_value = lst.attr[idx] if idx &lt; len(getattr(lst, 'attr', ())) else default_value\n# OR\nsome_value = lst.attr[idx] if hasattr(lst, 'attr') and idx &lt; len(lst.attr) else default_value\n</code>\n</pre>\n", "senID": 1}]]