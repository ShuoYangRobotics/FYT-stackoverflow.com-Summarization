[[{"text": ["Functions are first-class objects in Python:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "first-class objects", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/First-class_object"}]}, {"code": "<pre>\n<code>\n def do_this():\n    pass\n\ndef do_that():\n    pass\n\ndct = [do_this, do_that]\ndct[0]()  # calls do_this()\n</code>\n</pre>\n", "senID": 1}, {"text": ["If dct absolutely has to be a list of strings, I'd go with eval():"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "dct", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "eval()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n eval(dct[0] + \"()\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["It's not pretty, but switching between globals() and getattr() on the proper module can be a pain."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "globals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "getattr()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Funtions are first class objects.", "So like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def do_this():\n    print \"In do_this\"\n\ndef do_that():\n    print \"In do_that\"\n\ndct = [do_this, do_that]\ndct[0]()\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you really want to call them from a string list you can use globals():"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n dct = ['do_this', 'do_that']\nglobals()[dct[0]]()\n</code>\n</pre>\n", "senID": 3}, {"text": ["But I would suggest that using globals() (or locals()) probably isn't the right way to solve your problem.", "Grok the python way: &gt;&gt;&gt; import this"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "&gt;&gt;&gt; import this", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You can use getattr if they are in a module or globals() if they are in the global namespace:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "getattr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "globals()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n dct = ['do_this', 'do_that']\n\ngetattr(my_module, dct[0])()\n\nglobals()[dct[0]]()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["having the functions in some dict or in a class or instance"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fn_a():\n    pass\n\nsome_dict = {\n    'fn_a': fn_a,\n}\n\nclass Someclass(object):\n\n  @classmethod\n  def fn_a(cls):\n    pass\n\n  # normal instance method\n  def fn_b(self):\n    pass\n\nsome_instance = Someclass()\n</code>\n</pre>\n", "senID": 1}, {"text": ["you could do: some_dict['name']() or getattr(some_instance, 'fn_b')() or getattr(Someclass, 'fn_a')()"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "some_dict['name']()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "getattr(some_instance, 'fn_b')()", "childNum": 0, "tag": "code", "childList": []}, {"text": "getattr(Someclass, 'fn_a')()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If the functions you want to call are part of a module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import module\ngetattr(module, funcname_string)(*args, **kwargs)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As others have said, functions in Python are first-class objects.", "If you really want to get their names from a list, you can either use eval() (not popular) or use the globals() dictionary.", "Keep in mind that if these strings come from users, they're pretty dangerous.", "And if they don't come from users, then don't use strings."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "eval()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "globals()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"code": "<pre>\n<code>\n def do_this(): pass\ndef do_that(): pass\n\ndct = dict((x.__name__, x) for x in [do_this, do_that])\n# dct maps function names to the function objects\n# the names *don't* have to match the function name in your source:\n#   dct = {\"foo\": do_this}\n# which means user-facing names can be anything you want\n\ndct[\"do_this\"]()  # call do_this\n</code>\n</pre>\n", "senID": 0}]]