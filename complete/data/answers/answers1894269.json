[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; import ast\n&gt;&gt;&gt; x = u'[ \"A\",\"B\",\"C\" , \" D\"]'\n&gt;&gt;&gt; x = ast.literal_eval(x)\n&gt;&gt;&gt; x\n['A', 'B', 'C', ' D']\n&gt;&gt;&gt; x = [n.strip() for n in x]\n&gt;&gt;&gt; x\n['A', 'B', 'C', 'D']\n</code>\n</pre>\n", "senID": 0}, {"text": ["ast.literal_eval:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ast.literal_eval", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/ast.html#ast.literal%5Feval"}]}], [{"text": ["The eval is dangerous - you shouldn't execute user input."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you have 2.6 or newer, use ast instead of eval:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import ast\n&gt;&gt;&gt; ast.literal_eval('[\"A\",\"B\" ,\"C\" ,\" D\"]')\n[\"A\", \"B\", \"C\", \" D\"]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Once you have that, strip the strings."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "strip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you're on an older version of Python, you can get very close to what you want with a simple regular expression:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x='[  \"A\",  \" B\", \"C\",\"D \"]'\n&gt;&gt;&gt; re.findall(r'\"\\s*([^\"]*?)\\s*\"', x)\n['A', 'B', 'C', 'D']\n</code>\n</pre>\n", "senID": 5}, {"text": ["This isn't as good as the ast solution, for example it doesn't correctly handle escaped quotes in strings.", "But it's simple, doesn't involve a dangerous eval, and might be good enough for your purpose if you're on an older Python without ast."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"code": "<pre>\n<code>\n import ast\nl = ast.literal_eval('[ \"A\",\"B\",\"C\" , \" D\"]')\nl = [i.strip() for i in l]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["There is a quick solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n x = eval('[ \"A\",\"B\",\"C\" , \" D\"]')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Unwanted whitespaces in the list elements may be removed in this way:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n x = [x.strip() for x in eval('[ \"A\",\"B\",\"C\" , \" D\"]')]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you know that your lists only contain quoted strings, this pyparsing example will give you your list of stripped strings (even preserving the original Unicode-ness)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from pyparsing import *\n&gt;&gt;&gt; x =u'[ \"A\",\"B\",\"C\" , \" D\"]'\n&gt;&gt;&gt; LBR,RBR = map(Suppress,\"[]\")\n&gt;&gt;&gt; qs = quotedString.setParseAction(removeQuotes, lambda t: t[0].strip())\n&gt;&gt;&gt; qsList = LBR + delimitedList(qs) + RBR\n&gt;&gt;&gt; print qsList.parseString(x).asList()\n[u'A', u'B', u'C', u'D']\n</code>\n</pre>\n", "senID": 1}, {"text": ["If your lists can have more datatypes, or even contain lists within lists, then you will need a more complete grammar - like this one on the pyparsing wiki, which will handle tuples, lists, ints, floats, and quoted strings.", "Will work with Python versions back to 2.4."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this one", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/file/view/parsePythonValue.py"}]}], [{"text": ["Assuming that all your inputs are lists and that the double quotes in the input actually don't matter, this can be done with a simple regexp replace.", "It is a bit perl-y but works like a charm.", "Note also that the output is now a list of unicode strings, you didn't specify that you needed that, but it seems to make sense given unicode input."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nx = u'[ \"A\",\"B\",\"C\" , \" D\"]'\njunkers = re.compile('[[\" \\]]')\nresult = junkers.sub('', x).split(',')\nprint result\n---&gt;  [u'A', u'B', u'C', u'D']\n</code>\n</pre>\n", "senID": 1}, {"text": ["The junkers variable contains a compiled regexp (for speed) of all characters we don't want, using ] as a character required some backslash trickery.", "The re.sub replaces all these characters with nothing, and we split the resulting string at the commas.   "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note that this also removes spaces from inside entries u'[\"oh no\"]' ---> [u'ohno'].", "If this is not what you wanted, the regexp needs to be souped up a bit.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]