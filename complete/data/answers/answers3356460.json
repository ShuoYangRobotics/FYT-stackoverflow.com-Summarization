[[{"text": ["Let's say you read the names into one list, then the values into another.", "Once you have a names and values list, you can do something like:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "names", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "values", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n result = [n for n, v in zip(names, values) if v != 'na']\n</code>\n</pre>\n", "senID": 1}, {"text": ["result is now a list of all names whose value is not \"na\"."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "result", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n s = \"name1 name2 name3 v1 na v2\"\ns = s.split(' ')\nnames = s[:len(s)/2]\nvalues = s[len(s)/2:]\n\nnames_and_values = zip(names, values)\nnames, values = [], []\n[(names.append(n) or values.append(v)) for n, v in names_and_values if v != \"na\"]\nnames.extend(values)\n\nprint ' '.join(names)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Update"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Minor improvement after suggestion from Paul.", "I'm sure the list comprehension is fairly unpythonic, as it leverages the fact that list.append returns None, so both append expressions will be evaluated and a list of None values will be constructed and immediately thrown away."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "list.append", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}, {"text": "append", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["or say you have a string which you have read from a file.", "Let's call this string as \"s\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n words = filter(lambda x: x!=\"na\", s.split())\n</code>\n</pre>\n", "senID": 1}, {"text": ["should give you all the strings except for \"na\""], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["edit: the code above obviously doesn't do what you want it to do."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["the one below should work though"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n d = s.split()\nkeys = d[:len(d)/2]\nvals = d[len(d)/2:]\nw = \" \".join(map(lambda (k,v): (k + \" \" + v) if v!=\"na\" else \"\", zip(keys, vals)))\nprint \" \".join([\" \".join(w.split()[::2]), \" \".join(w.split()[1::2])])\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I agree with Justin than using zip is a good idea.", "The problems is how to put the data into two different lists.", "Here is a proposal that should work ok."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n reader = open('input.txt')\nwriter = open('output.txt', 'w')\nnames, nums = [], []\nrow = reader.read().split(' ')\nx = len(row)/2\nfor (a, b) in [(n, v) for n, v in zip(row[:x], row[x:]) if v!='na']:\n    names.append(a)\n    nums.append(b)\nwriter.write(' '.join(names))\nwriter.write(' ')\nwriter.write(' '.join(nums))\n#writer.write(' '.join(names+nums)) is nicer but cause list to be concat\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n strlist = 'namenexttolast nameonemore namethelast 0 na 2'.split()\nvals = ('0', '1', '2', '3', '4', 'na')\nkey_list = [s for s in strlist if s not in vals]\nval_list = [s for s in strlist if s in vals]\n\n#print [(key_list[i],v) for i, v in enumerate(val_list) if v != 'na']\nfiltered_keys = [key_list[i] for i, v in enumerate(val_list) if v != 'na']\nfiltered_vals = [v for v in val_list if v != 'na']\n\nprint filtered_keys + filtered_vals\n</code>\n</pre>\n", "senID": 0}, {"text": ["If you'd rather group the vals, you could create a list of tuples instead (commented out line)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here is a solution that uses just iterators plus a single buffer element, with no calls to len and no other intermediate lists created.", "(In Python 3, just use map and zip, no need to import imap and izip from itertools."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "childList": []}, {"text": "imap", "childNum": 0, "tag": "code", "childList": []}, {"text": "izip", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import izip, imap, ifilter\n\ndef iterStartingAt(cond, seq):\n    it1,it2 = iter(seq),iter(seq)\n    while not cond(it1.next()):\n        it2.next()\n    for item in it2:\n        yield item\n\ndataline = \"namenexttolast nameonemore namethelast 0 na 2\"\ndatalinelist = dataline.split()\n\nvalueset = set(\"0 1 2 3 4 na\".split())\n\nprint \" \".join(imap(\" \".join, \n                    izip(*ifilter(lambda (n,v): v != 'na', \n                                  izip(iter(datalinelist), \n                                       iterStartingAt(lambda s: s in valueset, \n                                                      datalinelist))))))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n namenexttolast namethelast 0 2\n</code>\n</pre>\n", "senID": 3}]]