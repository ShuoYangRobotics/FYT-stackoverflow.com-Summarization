[[{"text": ["Every object has a __dict__ variable containing all the variables and its values in it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Try this"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hi_obj = hi()\n&gt;&gt;&gt; hi_obj.__dict__.keys()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Use vars()"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n    def __init__(self):\n        self.a = 1\n        self.b = 2\n\nvars(Foo()) #==&gt; {'a': 1, 'b': 2}\nvars(Foo()).keys() #==&gt; ['a', 'b']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You normally can't get instance attributes given just a class, at least not without instantiating the class.", "You can get instance attributes given an instance, though, or class attributes given a class.", "See the 'inspect' module.", "You can't get a list of instance attributes because instances really can have anything as attribute, and -- as in your example -- the normal way to create them is to just assign to them in the __init__ method."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["An exception is if your class uses slots, which is a fixed list of attributes that the class allows instances to have.", "Slots are explained in http://www.python.org/2.2.3/descrintro.html, but there are various pitfalls with slots; they affect memory layout, so multiple inheritance may be problematic, and inheritance in general has to take slots into account, too."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.python.org/2.2.3/descrintro.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/2.2.3/descrintro.html"}]}], [{"text": ["You can also test if an object has a specific variable with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hi_obj = hi()\n&gt;&gt;&gt; hasattr(hi_obj, \"some attribute\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Suggest"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print vars.__doc__\nvars([object]) -&gt; dictionary\n\nWithout arguments, equivalent to locals().\nWith an argument, equivalent to object.__dict__.\n</code>\n</pre>\n", "senID": 1}, {"text": ["In otherwords, it essentially just wraps __dict__ "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Although not directly an answer to the OP question, there is a pretty sweet way of finding out what variables are in scope in a function.", "take a look at this code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def f(x, y):\n    z = x**2 + y**2\n    sqrt_z = z**.5\n    return sqrt_z\n\n&gt;&gt;&gt; f.func_code.co_varnames\n('x', 'y', 'z', 'sqrt_z')\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["The func_code attribute has all kinds of interesting things in it.", "It allows you todo some cool stuff.", "Here is an example of how I have have used this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def exec_command(self, cmd, msg, sig):\n\n    def message(msg):\n        a = self.link.process(self.link.recieved_message(msg))\n        self.exec_command(*a)\n\n    def error(msg):\n        self.printer.printInfo(msg)\n\n    def set_usrlist(msg):\n        self.client.connected_users = msg\n\n    def chatmessage(msg):\n        self.printer.printInfo(msg)\n\n    if not locals().has_key(cmd): return\n    cmd = locals()[cmd]\n\n    try:\n        if 'sig' in cmd.func_code.co_varnames and \\\n                       'msg' in cmd.func_code.co_varnames: \n            cmd(msg, sig)\n        elif 'msg' in cmd.func_code.co_varnames: \n            cmd(msg)\n        else:\n            cmd()\n    except Exception, e:\n        print '\\n-----------ERROR-----------'\n        print 'error: ', e\n        print 'Error proccessing: ', cmd.__name__\n        print 'Message: ', msg\n        print 'Sig: ', sig\n        print '-----------ERROR-----------\\n'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Your example shows \"instance variables\",  not really class variables."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Look in hi_obj.__class__.__dict__.items() for the class variables, along with other other class members like member functions and the containing module."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "hi_obj.__class__.__dict__.items()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Hi( object ):\n    class_var = ( 23, 'skidoo' ) # class variable\n    def __init__( self ):\n        self.ii = \"foo\" # instance variable\n        self.jj = \"bar\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["Class variables are shared by all instances of the class."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Both the Vars() and dict methods will work for the example the OP posted, but they won't work for \"loosely\" defined objects like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class foo:\n  a = 'foo'\n  b = 'bar'\n</code>\n</pre>\n", "senID": 1}, {"text": ["To print all non-callable attributes, you can use the following function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def printVars(object):\n    for i in [v for v in dir(object) if not callable(getattr(object,v))]:\n        print '\\n%s:' % i\n        exec('print object.%s\\n\\n') % i\n</code>\n</pre>\n", "senID": 3}]]