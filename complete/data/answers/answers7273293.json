[[{"text": ["The most obvious way might be to alter the class object after the fact:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Vector3(object):\n    # ...\nVector3.zero = Vector3(0, 0, 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The main problem with this is that there's then only one zero object, and if it's mutable you can cause accidental damage all over the place.", "It may be easier (and feel less hacky) to use a dynamic descriptor that creates a zero vector every time it's accessed (this is done by creating a ClassProperty class):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "ClassProperty", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/128573/using-property-on-classmethods"}]}, {"code": "<pre>\n<code>\n class ClassProperty(property):\n    def __get__(self, cls, owner):\n        return self.fget.__get__(None, owner)()\n\nclass Vector3(object):\n    @ClassProperty\n    @classmethod\n    def zero(cls):\n        return cls(0, 0, 0)\n</code>\n</pre>\n", "senID": 3}, {"text": ["I consider none of these really \"pythonic\", though.", "Consider the other mathematical types in Python: ints, floats, and complex numbers.", "None of these have a \"zero\" class attribute, or a zero constructor, instead they return zero when called with no arguments.", "So perhaps it might be best to do like so:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class Vector3(object):\n    def __init__(self, x=0, y=0, z=0):\n        self.x = x\n        self.y = y\n        self.z = z\n</code>\n</pre>\n", "senID": 5}, {"text": ["This is less like Unity3D and more like Python, if you know what I mean."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Use a metaclass"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MetaVector3(type):\n\n    @property\n    def zero(cls):\n        return cls(0,0,0)\n\nclass Vector3(object):\n    __metaclass__ = MetaVector3\n\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n&gt;&gt;&gt; v = Vector3.zero\n&gt;&gt;&gt; v.x, v.y, v.z\n(0, 0, 0)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use a descriptor:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "descriptor", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#descriptors"}]}, {"code": "<pre>\n<code>\n class Zero(object):\n    def __get__(self, instance, owner):\n        return owner(0, 0, 0)\n\n    def __set__(self, instance, value):\n        #could raise an exception here or somethiing\n        #this gets called if the user attempts to overwrite the property\n        pass  \n\nclass Vector3(object):\n    zero = Zero()\n\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __repr__(self):\n        return str(self.__dict__)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Should do what you want:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; v = Vector3(1, 2, 3)\n&gt;&gt;&gt; v\n{'y': 2, 'x': 1, 'z': 3}\n&gt;&gt;&gt; v.zero\n{'y': 0, 'x': 0, 'z': 0}\n&gt;&gt;&gt; v.zero = 'foo'\n&gt;&gt;&gt; v.zero\n{'y': 0, 'x': 0, 'z': 0}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["What you're imagining is possible, but not necessary in this case.", "Just wait until after your class is defined to assign the attribute"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Vector3(object):\n    ...\nVector3.zero = Vector3(0, 0, 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or make it a module level constant."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["There is a good chance you want simply to use a shape (3,) numpy array instead of writing this class, for any practical purposes."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "(3,)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["That's a really interesting question, the workaround I would go with is to do a classmethod as a \"getter\" for the zero object:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Vector3(object):\n    __zero = None\n    def __init__(self, x,y,z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    @classmethod\n    def zero(cls):\n        if not cls.__zero:\n            cls.__zero = Vector3(0,0,0) \n        return cls.__zero\n\nmyzerovec = Vector3.zero()\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n class ClassProperty(property):\n    def __get__(self, cls, owner):\n        return self.fget.__get__(None, owner)()\n\nclass Vector3(object):\n    _zero = None\n\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    @ClassProperty\n    @classmethod\n    def zero(cls):\n        if cls._zero is None:\n            cls._zero = cls(0,0,0) \n        return cls._zero\n</code>\n</pre>\n", "senID": 0}, {"text": ["Shamelessly stolen from here"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/128573/using-property-on-classmethods"}]}], [{"text": ["As for the read-only part, this is a good resource."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.bright-green.com/blog/2004_06_03/read_only_python_attributes.html"}]}, {"code": "<pre>\n<code>\n template = property(lambda self: self.__template)\n</code>\n</pre>\n", "senID": 1}]]