[[{"text": ["I was quite surprised to learn that you could use the bisect module to do a very fast binary search in a sequence.", "It's documentation doesn't say anything about it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The usage is very simple:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import bisect\n&gt;&gt;&gt; lst = [4, 7, 10, 23, 25, 100, 103, 201, 333]\n&gt;&gt;&gt; bisect.bisect_left(lst, 23)\n3\n</code>\n</pre>\n", "senID": 2}, {"text": ["You have to remember though, that it's quicker to linearly look for something in a list goes item by item, than sorting the list and then doing a binary search on it.", "The first option is O(n), the second is O(nlogn)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Oft overlooked modules, uses and tricks:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["collections.defaultdict(): for when you want missing keys in a dict to have a default value."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["functools.wraps(): for writing decorators that play nicely with introspection."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["posixpath: the os.path module for POSIX systems.", "You can use it for manipulating POSIX paths (including URI elements) even on Windows and other non-POSIX systems."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["ntpath: the os.path module for Windows; usable for manipulation of Windows paths on non-Windows systems."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["(also: macpath, for MacOS 9 and earlier, os2emxpath for OS/2 EMX, but I'm not sure if anyone still cares."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["pprint: more structured printing of the repr() of containers makes debugging much easier."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["imp: all the tools you need to write your own plugin system or make Python import modules from arbitrary archives."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["rlcompleter: getting tab-completion in the normal interactive interpreter.", "Just do \"import readline, rlcompleter; readline.parse_and_bind('tab: complete')\""], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["the PYTHONSTARTUP environment variable: can be set to the path to a file that will be executed (in the main namespace) when entering the interactive interpreter; useful for putting things in like the rlcompleter recipe above."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["I use itertools (especially cycle, repeat, chain) to make python behave more like R and in other functional / vector applications.", "Often this lets me avoid the overhead and complication of Numpy.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # in R, shorter iterables are automatically cycled\n# and all functions \"apply\" in a \"map\"-like way over lists\n&gt; 0:10 + 0:2\n [1]  0  2  4  3  5  7  6  8 10  9 11\n</code>\n</pre>\n", "senID": 1}, {"text": ["Python\n    #Normal python\n    In [1]: range(10) + range(3)\n    Out[1]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2]"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ## this code is terrible, but it demos the idea.\nfrom itertools import cycle\ndef addR(L1,L2):\n    n = max( len(L1), len(L2))\n    out = [None,]*n\n    gen1,gen2 = cycle(L1), cycle(L2)\n    ii = 0\n    while ii &lt; n:\n        out[ii] = gen1.next() + gen2.next()\n        ii += 1\n    return out\n\nIn [21]: addR(range(10), range(3))\nOut[21]: [0, 2, 4, 3, 5, 7, 6, 8, 10, 9]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I found struct.unpack to be a godsend for unpacking binary data formats after I learned of it!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["getpass is useful for determining the login name of the current user."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "getpass", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-getpass.html"}]}, {"text": ["grp allows you to lookup Unix group IDs by name, and vice versa."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "grp", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-grp.html"}]}, {"text": ["dircache might be useful in situations where you're repeatedly polling the contents of a directory."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "dircache", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-dircache.html"}]}, {"text": ["glob can find filenames matching wildcards like a Unix shell does."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "glob", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-glob.html"}]}, {"text": ["shutil is useful when you need to copy, delete or rename a file."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "shutil", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-shutil.html"}]}, {"text": ["csv can simplify parsing of delimited text files."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "csv", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-csv.html"}]}, {"text": ["optparse provides a reliable way to parse command line options."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "optparse", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-optparse.html"}]}, {"text": ["bz2 comes in handy when you need to manipulate a bzip2-compressed file."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "bz2", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-bz2.html"}]}, {"text": ["urlparse will save you the hassle of breaking up a URL into component parts."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "urlparse", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-urlparse.html"}]}], [{"text": ["I've found sched module to be helpful in cron-like activities.", "It simplifies things a lot.", "Unfortunately I found it too late. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sched module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-sched.html"}]}], [{"text": ["Most of the other examples are merely overlooked, not unexpected uses for module."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["fnmatch, like shlex, can be applied in unexpected ways.", "fnmatch is a kind of poor-person's RE, and can be used for more than matching files, it can compare strings with the simplified wild-card patterns."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["One function I've come to appreciate is string.translate.", "Its very fast at what it does, and useful anywhere you want to alter or remove characters in a string.", "I've just used it in a seemingly inapplicable problem and found it beat all the other solutions handily."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "problem", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/89909/in-python-how-to-i-verify-that-a-string-only-contains-letters-numbers-underscor#92000"}]}, {"text": ["The downside is that its API is a bit clunky, but this is improving in Py2.6 / Py3.0."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The pickle module is pretty awesome"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pickle", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-pickle.html"}]}], [{"text": ["complex numbers.", "(The complexobject.c defines a class, so technically it's not a module).", "Great for 2d coordinates, with easy translation/rotations etc"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["eg."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n TURN_LEFT_90= 1j\nTURN_RIGHT_90= -1j\n\ncoord= 5+4j # x=5 y=4\nprint coord*TURN_LEFT_90\n</code>\n</pre>\n", "senID": 2}]]