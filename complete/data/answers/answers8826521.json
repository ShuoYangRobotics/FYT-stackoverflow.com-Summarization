[[{"text": ["You asked the wrong question here.", "The clue is in your reply to one of the comments where you say \"I have 10+ tags, if I can get 3 line to 1 line, I will save 20+ lines\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So your problem actually is not that you have 3 lines of code but that you are needlessly repeating 3 lines of code over and over.", "You could use a function to extract the repeated lines, but it sounds like in this case you may actually want a loop:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n THE_TAGS = ('tag1', 'tag2', 'and so on')\nfor tag in THE_TAGS:\n    a = r.find(tag) # a may get None if did not find it\n    if a != None:\n        b.append(a)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or if you need to append to different lists:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def extract_tag(r, tag_name, to):\n    a = r.find(tag_name) # a may get None if did not find it\n    if a != None:\n        to.append(a)\n\nextract_tag(r, 'tag1', b)\nextract_tag(r, 'tag2', c)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["If you can call func() beforehand, and you want to combine the test and assignment statements into a single statement, then you can do this, with an if-else expression:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n b += [a] if a is not None else []\n</code>\n</pre>\n", "senID": 1}, {"text": ["If a is not None, then this will add [a] to b -- essentially the same operation as b.append(a)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If a is None, then this will add [] to b, which will leave b unchanged."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["This won't work unless b is a list, or at least supports \"+=\" in-place addition.", "If it doesn't -- perhaps it's some custom object, then you should be able to do this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n (b.append(a) if a is not None else None)\n</code>\n</pre>\n", "senID": 5}, {"text": ["This is an expression, evaluated for its side effects, and then thrown away.", "If a is None, then the b.append(a) call will never be executed.", "In either case, the value of the expression is None, but we don't care about it, so it gets ignored."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "b.append(a)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Now, if you want to combine the func() call with this, then you'll have to do something different in order to avoid calling func twice.", "If you can use the \"+=\" syntax, then you can do it like this:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n b += filter(None, [func()])\n</code>\n</pre>\n", "senID": 8}, {"text": ["filter(None, &lt;list&gt;) returns the list with all false elements (None included, but also 0 and []) removed.", "This statement, then, will add either [func()] or [] to b."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "filter(None, &lt;list&gt;)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["[Edited]"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "[Edited]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Finally, for the worst case scenario: If you can't call func() more than once, and you can't use b += &lt;list&gt;, and you need to accept 0, \"\", [], etc, and only exclude None, and you need it all on one line, here's the ugliest line of code yet:"], "childNum": 5, "tag": "p", "senID": 11, "childList": [{"text": "and", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "b += &lt;list&gt;", "childNum": 0, "tag": "code", "childList": []}, {"text": "and", "childNum": 0, "tag": "em", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}, {"text": "and", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n (lambda l, a: l.append(a) if a is not None else None)(b, func())\n</code>\n</pre>\n", "senID": 12}, {"text": ["This is essentially @ekhumoro's solution, compressed into one line.", "It defines an anonymous function, calls it, discards the value, and then discards the function, all for the sake of the side effect."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Now, this is a single line, but it's certainly not easier to read or understand than the original code.", "If I were you, I'd stick with the original, or go with @ekhumoro's idea of just defining a helper function and using that."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["Attacking your real problem, and doing it in two lines for clarity:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n temp = [r.find(tag) for tag in list_of_tags]\nb.extend(x for x in temp if x is not None)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note: Element.extend is new in Python 2.7/3.2"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Element.extend", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Presumably you're not trying to remove just a single if statement from your code..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So the obvious answer is to use a function:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import xml.etree.ElementTree as etree\n\ndef append(parent, child):\n    if child is not None:\n        parent.append(child)\n\nr = etree.parse(f).getroot()\nb = etree.Element('register',{})\n\nappend(b, r.find('tag_name'))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Short answer:  Not really."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Longer answer: If you really wanted to avoid this (perhaps because you want to implement this behavior --- appending only non-None values) from several different blocks of code) then you could create a class as a proxy around the underlying b object and hide the details in its append method."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "b", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class NonNoneAppender:\n    def __init__(self, obj):\n        if not hasattr(obj, 'append') or not callable(obj.append):\n            raise ValueError, \"Object must have append method\"\n        self.__obj = obj\n    def append(self, item):\n        if item is not None:\n            return self.__obj.append(item)\n    def __getattr__(self, attr):\n        return getattr( self.__obj, attr)\n</code>\n</pre>\n", "senID": 2}, {"text": ["... and then you could do something like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n b = NonNoneAppender(b)\n</code>\n</pre>\n", "senID": 4}, {"text": ["However, I'm not sure this would make any sense at all for your code."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["b+=list(set([r.find('tag_name')])-set([None]))"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "b+=list(set([r.find('tag_name')])-set([None]))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["But it's very ugly.", "A little cleaner, but also a line longer:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n b.append(r.find('tag_name'))\nb.remove(None)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Still not very neat though.", "If I were you I'd just keep that if statement."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]