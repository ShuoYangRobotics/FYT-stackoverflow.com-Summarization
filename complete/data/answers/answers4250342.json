[[{"text": ["Try this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n neighbors = {0: [8], \n             1: [2,4], \n             2: [1,4,3], \n             3: [2,6], \n             4: [1,5,7], \n             5: [2,4,6,8], \n             6: [3,5,9], \n             7: [4,8], \n             8: [7,5,9,0], \n             9: [6,8]}\n\n\ndef get_sequences(n):\n    if not n:\n        return\n    stack = [(i,) for i in  range(10)]\n    while stack:\n        cur = stack.pop()\n        if len(cur) == n:\n            yield cur\n        else:\n            stack.extend(cur + (d, ) for d in neighbors[cur[-1]]) \n\nprint list(get_sequences(3))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will produce all possible sequences.", "You didn't mention if you wanted ones that have cycles in them, for example (0, 8, 9, 8) so I left them in.", "If you don't want them, then just use"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "(0, 8, 9, 8)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n stack.extend(cur + (d, ) \n              for d in neighbors[cur[-1]]\n              if d not in cur)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that I made the entry for 0 a list with one element instead of just an integer.", "This is for consistency.", "It's very nice be able to index into the dictionary and know that you're going to get a list back. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Also note that this isn't recursive.", "Recursive functions are great in languages that properly support them.", "In Python, you should almost always manage a stack like I demonstrate here.", "It's just as easy as a recursive solution and sidesteps function call overhead (python doesn't support tail recursion) and maximum recursion depth concerns."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "great", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n neighbors = {0: [8], 1: [2,5,4], 2: [1,4,3], 3: [2,5,6], 4: [1,5,7], 5: [2,4,6,8], 6: [3,5,9], 7: [4,5,8], 8: [7,5,9,0], 9: [6,5,8]}\n\ndef gen_neighbor_permutations(n, current_prefix, available_digit_set, removed_digits=set(), unique_digits=False):\n    if n == 0:\n            print current_prefix\n            return\n    for d in available_digit_set:\n            if unique_digits:\n                    gen_neighbor_permutations(n-1, current_prefix + str(d), set(neighbors[d]).difference(removed_digits), removed_digits.union(set([d])), unique_digits=True )\n            else:\n                    gen_neighbor_permutations(n-1, current_prefix + str(d), set(neighbors[d]).difference(removed_digits) )\n\ngen_neighbor_permutations(n=3, current_prefix='', available_digit_set=start_set)\n</code>\n</pre>\n", "senID": 0}, {"text": ["I also couldn't help but notice that in your examples, none of the digits are reused.", "If you want that, then you would use the unique_digits = True option; this will disallow recursion on digits that are already used. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "unique_digits = True", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["+1 What a fun puzzle.", "I hope this works for you!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n gen_neighbor_permutations(n=3, current_prefix='', available_digit_set=start_set, unique_digits = True)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Recursion isn't really much of an issue here because the sequence is relatively short as are the choices for each digit except the first -- so there appear to \"only\" be 4790 possibilities disallowing diagonals.", "This is written as an iterator to eliminate the need to create and return a large container with all possibilities produced in it. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It occurred to me that an additional benefit of the data-driven approach of storing the neighbor adjacency information in a data structure (as the OP suggested) was that besides easily supporting different keypads, it also makes controlling whether diagonals are allowed or not trivial. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I debated briefly about whether to make it a list instead of a dictionary for faster lookups, but realized that doing so would make it more difficult to adapt to produce sequences other than digits (and likely wouldn't make it significantly faster anyway)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n adjacent = {1: [2,4],   2: [1,3,4],   3: [2,6],\n            4: [1,5,7], 5: [2,4,6,8], 6: [3,5,9],\n            7: [4,8],   8: [0,5,7,9], 9: [6,8],\n                        0: [8]}\n\ndef adj_sequences(ndigits):\n    seq = [None]*ndigits  # pre-allocate\n\n    def next_level(i):\n        for neighbor in adjacent[seq[i-1]]:\n            seq[i] = neighbor\n            if i == ndigits-1:  # last digit?\n                yield seq\n            else:\n                for digits in next_level(i+1):\n                    yield digits\n\n    for first_digit in range(10):\n        seq[0] = first_digit\n        for digits in next_level(1):\n            yield digits\n\ncnt = 1\nfor digits in adj_sequences(7):\n    print '{:d}: {!r}'.format(cnt, ''.join(map(str,digits)))\n    cnt += 1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["That's a classic recursive algorithm.", "Some pseudo code to show the concept:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n function(numbers) { \n  if (length(numbers)==7) { \n    print numbers; \n    return; \n  } \n  if (numbers[last]=='1') { \n    function(concat(numbers,  '2')); \n    function(concat(numbers,  '4')); \n    return; \n  } \n  if (numbers[last]==='2') { \n    function(concat(numbers,  '1')); \n    function(concat(numbers,  '3')); \n    function(concat(numbers,  '5')); \n    return; \n  } \n  ...keep going with a condition for each digit..\n}\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n neighbors = {0: [8], 1: [2,5,4], 2: [1,4,3], 3: [2,5,6], 4: [1,5,7], 5: [2,4,6,8], 6: [3,5,9], 7: [4,5,8], 8: [7,5,9,0], 9: [6,5,8]}\n\ndef keyNeighborsRec(x, length):\n    if length == 0:\n            print x\n            return\n    for i in neighbors[x%10]:\n            keyNeighborsRec(x*10+i,length-1)\n\n\ndef keyNeighbors(l):\n    for i in range(10):\n            keyNeighborsRec(i,length-1)\n\nkeyNeighbors(7)\n</code>\n</pre>\n", "senID": 0}, {"text": ["its really easy without the neighbor condition..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def keypadSequences(length):\n    return map(lambda x: '0'*(length-len(repr(x)))+repr(x), range(10**length))\n\nkeypadSequences(7)\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n states = [\n    [8],\n    [2, 4],\n    [1, 3, 5],\n    [2, 6],\n    [1, 5, 7],\n    [2, 4, 6, 8],\n    [3, 5, 9],\n    [4, 8],\n    [5, 7, 9, 0],\n    [6, 8]\n]\n\ndef traverse(distance_left, last_state):\n    if not distance_left:\n        yield []\n    else:\n        distance_left -= 1\n        for s in states[last_state]:\n            for n in traverse(distance_left, s):\n                yield [s] + n\n\ndef produce_all_series():\n    return [t for i in range(10) for t in traverse(7, i)]\n\nfrom pprint import pprint\npprint(produce_all_series())\n</code>\n</pre>\n", "senID": 0}]]