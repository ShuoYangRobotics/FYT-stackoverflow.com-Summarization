[[{"text": ["FTP is quite a rudimentary protocol and there's no built-in protocol query allowing you to get the type (file, dir) of each node, so a heuristic like the one you found is the only solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If getting the size of each node doesn't work, perhaps you should consider calling FTP.nlst() on each of those nodes: those that error out will be files rather than dirs."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "FTP.nlst()", "tag": "a", "pos": 0, "childList": [{"text": "FTP.nlst()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/ftplib.html#ftplib.FTP.nlst"}, {"text": "FTP.nlst()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["FTP.dir returns a directory listing, that you can parse with a callback function to find out whether it's a directory.", "For example, like this:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "FTP.dir", "tag": "a", "pos": 0, "childList": [{"text": "FTP.dir", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/ftplib.html?highlight=ftplib#ftplib.FTP.dir"}, {"text": "FTP.dir", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def parse(line):\n    if line[0] == 'd':\n        print(line.rpartition(' ')[2])   # gives you the name of a directory\n\nftp.dir(parse)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def is_file(filename):\n    return ftp.size(filename) is not None\n</code>\n</pre>\n", "senID": 0}, {"text": ["This works because ftp.size returns None if it is a directory."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n def is_file(filename):\n    current = ftp.pwd()\n    try:\n        ftp.cwd(filename)\n    except:\n        ftp.cwd(current)\n        return True\n    ftp.cwd(current)\n    return False\n</code>\n</pre>\n", "senID": 0}, {"text": ["Here is another solution.", "Half way writing it out I realized it has a problem.", "If you don't have permission to change to a folder, it'll read it as a file instead.", "It'll work if you have access to any folder. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I still posted it because maybe it'll give some ideas."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'm running into this concern now too.", "I suppose no more progress has been made?", "Also I'm wondering if an sftp solution is available yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can use MLST command:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import ftplib\nf = ftplib.FTP()\nf.connect(\"localhost\")\nf.login()\nprint f.sendcmd('MLST /')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Against pyftpdlib server the code above prints:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pyftpdlib server", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pyftpdlib/"}]}, {"code": "<pre>\n<code>\n 250-Listing \"/\":\n modify=20111212124834;perm=el;size=12288;type=dir;unique=807g100001; /\n250 End MLST.\n</code>\n</pre>\n", "senID": 3}, {"text": ["What you have to do is parse that string and look for \"type=dir\" or \"type=cdir\" (current dir, as in \".", "\") or \"type=pdir\" (parent dir as in \"..\") via a regular expression.", "If you get a match, it means that the provided path refers to a directory."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]