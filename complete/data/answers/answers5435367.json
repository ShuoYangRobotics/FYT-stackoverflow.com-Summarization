[[{"text": ["One easy way to do this would be by using regular expressions.", "Since it is unclear whether this question is homework, the details are left as an exercise for the reader."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "regular expressions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}]}], [{"text": ["Instead of using _ to denote wildcards, use \\w instead.", "Add \\b to the beginning and end of the pattern, then just run the dictionary through a regexp matcher.", "So -un--- becomes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; re.findall(r'\\b\\wun\\w\\w\\w\\b', \"run runner bunt bunter bunted bummer\")\n['runner', 'bunter', 'bunted']\n</code>\n</pre>\n", "senID": 1}, {"text": ["\\w matches any 'word character'.", "\\b matches any word boundary."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you want to do this repeatedly you should create a index:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n wordlist = [word.strip() for word in \"run, ran, rat, rob, fish, tree\".split(',')]\n\nfrom collections import defaultdict\n\nclass Index(object):\n\n    def __init__(self, wordlist=()):\n        self.trie = defaultdict(set)\n        for word in wordlist:\n            self.add_word(word)\n\n    def add_word(self, word):\n        \"\"\" adds word to the index \"\"\"\n        # save the length of the word\n        self.trie[len(word)].add(word)    \n        for marker in enumerate(word):\n            # add word to the set of words with (pos,char)\n            self.trie[marker].add(word)\n\n\n    def find(self, pattern, wildcard='-' ):\n        # get all word with matching length as candidates\n        candidates = self.trie[len(pattern)]\n\n        # get all words with all the markers\n        for marker in enumerate(pattern):            \n            if marker[1] != wildcard:\n                candidates &amp;= self.trie[marker]\n\n            # exit early if there are no candicates\n            if not candidates:                \n                return None\n\n        return candidates\n\n\nwith open('dict.txt', 'rt') as lines:\n    wordlist = [word.strip() for word in lines]\n\ns = Index(wordlist)\nprint s.find(\"r--\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["Tries are made for searching strings.", "This is a simple prefix trie, using a single dict."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Tries", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Trie"}]}], [{"text": ["A few approaches occur to me;"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first is to preprocess your dictionary into words[wordlength][offset][charAtOffset] = set(matching words); then your query becomes an intersection of all relevant word-sets.", "Very fast, but memory-intensive and a lot of set-up work."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Ex:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # search for 'r-n'\nmatches = list(words[3][0]['r'] &amp; words[3][2]['n'])\n</code>\n</pre>\n", "senID": 3}, {"text": ["The second is a linear scan of the dictionary using regular expressions; much slower, but minimal memory footprint."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Ex:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nfoundMatch = re.compile('r.n').match\nmatches = [word for word in allWords if foundMatch(word)]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Third would be a recursive search into a word-Trie;"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Fourth - and it sounds like what you want - is a naive word-matcher:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n with open('dictionary.txt') as inf:\n    all_words = [word.strip().lower() for word in inf]  # one word per line\n\nfind_word = 'r-tt-r'\nmatching_words = []\nfor word in all_words:\n    if len(word)==len(find_word):\n        if all(find==ch or find=='-' for find,ch in zip(find_word, word)):\n            matching_words.append(word)\n</code>\n</pre>\n", "senID": 9}, {"text": ["Edit: full code for the first option follows:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\nimport operator\n\ntry:\n    inp = raw_input    # Python 2.x\nexcept NameError:\n    inp = input        # Python 3.x\n\nclass Words(object):\n    @classmethod\n    def fromFile(cls, fname):\n        with open(fname) as inf:\n            return cls(inf)\n\n    def __init__(self, words=None):\n        super(Words,self).__init__()\n        self.words = set()\n        self.index = defaultdict(lambda: defaultdict(lambda: defaultdict(set)))\n        _addword = self.addWord\n        for word in words:\n            _addword(word.strip().lower())\n\n    def addWord(self, word):\n        self.words.add(word)\n        _ind = self.index[len(word)]\n        for ind,ch in enumerate(word):\n            _ind[ind][ch].add(word)\n\n    def findAll(self, pattern):\n        pattern = pattern.strip().lower()\n        _ind = self.index[len(pattern)]\n        return reduce(operator.__and__, (_ind[ind][ch] for ind,ch in enumerate(pattern) if ch!='-'), self.words)\n\ndef main():\n    print('Loading dict... ')\n    words = Words.fromFile('dict.txt')\n    print('done.')\n\n    while True:\n        seek = inp('Enter partial word (\"-\" is wildcard, nothing to exit): ').strip()\n        if seek:\n            print(\"Matching words: \"+' '.join(words.findAll(seek))+'\\n')\n        else:\n            break\n\nif __name__==\"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 11}], [{"text": ["Sounds like homework involving searching algorithms or something, but I'll give you a start."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One solution might be to index the file (if this can be done in a reasonable time) into a tree structure with  each character representing a node value and each child being all subsequent characters.", "You could then traverse the tree using the input as a map.", "A character represents the next node to go to and a dash represents that it should include all child nodes.", "Every time you hit a leaf n levels deeps with n being the length of the input you know you've found a match."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The nice thing is that once you index, your search will speed up considerably.", "It's the indexing that can take forever..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Takes a bit of memory but this does the trick:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nimport sys\n\nword = '\\\\b' + sys.argv[1].replace('-', '\\\\w') + '\\\\b'\nprint word\n\nwith open('data.txt', 'r') as fh:\n    print re.findall(word, fh.read())\n</code>\n</pre>\n", "senID": 1}]]