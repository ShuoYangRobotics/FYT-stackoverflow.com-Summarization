[[{"text": ["Neither, I would go for"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f2(c):\n  d = {\n    \"USA\": \"N.Y.\",\n    \"China\": \"Shanghai\"\n  }\n\n  return d.get(c, \"N/A\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way is shorter and \"get\" is designed for the job."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also an except without an explicit exception is bad pratice, so use except KeyError: not just except. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "except KeyError:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Exceptions do not have much overhead in python.", "It is generally better to use them if there are not better alternatives or sometimes even when it saves an attribute lookup (to use instead of hasattr). "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit: to clear up general point about exceptions. "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["paxdiablo is correct on the general point.", "Python is mainly designed for \"its easier to ask forgivness then permission\" i.e try then see what fails (exceptions), then \"look before you leap\" see whats there and then apply.", "This is because attribute lookup in python can be expensive, so calling the same stuff again (to check boundries) is a waste of resources.", "However, internal stuff in python has normally got nicer helpers so its better to use them."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["In general terms (not necessarily Python), I tend to prefer the \"try-then-tell-me-if-it-went-wrong\" method (exceptions) in all but the simplest cases.", "This is because, in threaded environments or during database access, the underlying data can change between the key check and the value extraction."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're not changing the associative array outside of the current thread, then you can do the \"check-first-then-extract\" method."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["But that's for the general case.", "Here, specifically, you can use the get method which allows you to specify a default if the key doesn't exist:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "get", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n return d.get (c, \"N/A\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["I'll clarify what I stated in the first paragraph.", "In situations where the underlying data can change between checking and using, you should always use an exception-type operation (unless you have an operation that will not cause a problem, such as d.get(), mentioned above).", "Consider for example the following two thread time-lines:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "always", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "d.get()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n +------------------------------+--------------------+\n| Thread1                      | Thread2            |\n+------------------------------+--------------------+\n| Check is NY exists as a key. |                    |\n|                              | Delete NY key/val. |\n| Extract value for NY.        |                    |\n+------------------------------+--------------------+\n</code>\n</pre>\n", "senID": 5}, {"text": ["When thread 1 attempts to extract the value, it will get an exception anyway, so you may as well just code for the possibility and remove the initial check."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The comment about databases is also relevant since that's another situation where the underlying data can change.", "That's why I tend to prefer atomic SQL (where possible) rather than something like getting a list of keys then processing them with individual statements."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Typically, exceptions carry some overhead, and are meant for truly 'exceptional' cases.", "In this case, this sounds like a normal part of the execution, not an 'exceptional' or 'error' state. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In general, I think your code will benefit by using the \"if/else\" convention, and saving exceptions for only when they are truly needed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Neither."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n return d.get(c, 'N/A')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm with David on this one: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f2(c):\n   d = {\n        \"USA\": \"N.Y.\",\n        \"China\": \"Shanghai\"\n       }\n\n   return d.get(c, \"N/A\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["...is exactly how I'd write it. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["To address your other options: "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In 'f1()', there's nothing wrong with this, per se, but dictionaries have a get() method for pretty much this exact use case: \"get this from the dict, and if it's not there, return this other thing instead\".", "That's all your code is saying, using get() is just more concise. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In 'f2()', using 'except' by itself like that is frowned upon, and in addition, you don't really do anything useful in response to the exception -- in your case the calling code will never know there was an exception.", "So why use the construct if it doesn't add value to your function or the code that calls it? "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I see people using \"get\", which I recommend.", "However, if you find yourself in a similar situation in the future, catch the exception you mean:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    return d[k]\nexcept KeyError:\n    return \"N/A\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way, other exceptions (including KeyboardInterrupt) don't get caught.", "You almost never want to catch KeyboardInterrupt."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "KeyboardInterrupt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "KeyboardInterrupt", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I agree that in this case, dict.get is the best solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In general, I think your choice will depend on how likely the exceptions are.", "If you expect the key lookups to mostly pass, then the try/catch is a better choice IMO.", "Similarly, if they will be failing often, an if statement is better."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Performance of exceptions versus attribute lookups is not so different in Python, so I'd worry more about the logic of using exceptions/look-before-you-leap than about the performance aspects."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]