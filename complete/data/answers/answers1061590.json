[[{"text": ["Your algorithm seems pretty good at first blush, and I don't think OO or another language would improve the code.", "I can't say if recursion would have helped but I admire the non-recursive approach.", "I bet it was harder to get working and it's harder to read but it likely is more efficient and it's definitely quite clever.", "To be honest I didn't analyze the algorithm in detail but it certainly looks like something that took a long while to get working correctly.", "I bet there were lots of off-by-1 errors and weird edge cases you had to think through, eh?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Given all that, basically all I tried to do was pretty up your code as best I could by replacing the numerous C-isms with more idiomatic Python-isms.", "Often times what requires a loop in C can be done in one line in Python.", "Also I tried to rename things to follow Python naming conventions better and cleaned up the comments a bit.", "Hope I don't offend you with any of my changes.", "You can take what you want and leave the rest.", ":-)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here are the notes I took as I worked:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 13, "lis": [{"text": "Changed the code that initializes ", "tag": "none", "senID": 3}, {"text": "Changed ", "tag": "none", "senID": 4}, {"text": "Then replaced all the loops with a ", "tag": "none", "senID": 5}, {"text": "Moved ", "tag": "none", "senID": 6}, {"text": "The check in ", "tag": "none", "senID": 7}, {"text": "Normalized mix of 4 spaces and 8 spaces for indentation.", "tag": "none", "senID": 8}, {"text": "Removed unnecessary parentheses around your ", "tag": "none", "senID": 9}, {"text": ["tmp[p2] - tmp[p1] == 0"], "childNum": 0, "tag": "code", "senID": 10, "childList": []}, {"text": "Changed ", "tag": "none", "senID": 11}, {"text": "You don't need to initialize variables to 0 at the top of your functions.", "tag": "none", "senID": 12}, {"text": "Removed ", "tag": "none", "senID": 13}, {"text": "Renamed ", "tag": "none", "senID": 14}, {"text": "Renamed ", "tag": "none", "senID": 15}]}, {"text": ["And here's the code for your perusal:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n def initial_combo(ceiling=5, target_sum=13, num_cells=4):\n    \"\"\"\n    Returns a list of possible addends, probably to be modified further.\n    Starts a new combo list, then, starting from left, fills items to ceiling\n    or intermediate between 1 and ceiling or just 1.  E.g.:\n    Given ceiling = 5, target_sum = 13, num_cells = 4: creates [5,5,2,1].\n    \"\"\"\n    num_full_cells = (target_sum - num_cells) // (ceiling - 1)\n\n    combo = [ceiling] * num_full_cells \\\n          + [1]       * (num_cells - num_full_cells)\n\n    if num_cells &gt; num_full_cells:\n        combo[num_full_cells] += target_sum - sum(combo)\n\n    return combo\n\ndef all_combos(ceiling, target_sum, num_cells):\n    # p0   points at the rightmost item and moves left under some conditions\n    # p1   starts out at rightmost items and steps left\n    # p2   starts out immediately to the left of p1 and steps left as p1 does\n    #      So, combo[p2] and combo[p1] always point at a pair of adjacent items.\n    # d    combo[p2] - combo[p1]; immediate difference\n    # cd   combo[p2] - combo[p0]; cumulative difference\n\n    # The ceiling decreases by 1 each iteration.\n    while True:\n        combo = initial_combo(ceiling, target_sum, num_cells)\n        yield tuple(combo)\n\n        ceiling_changed = False\n\n        # Generate all of the remaining combos with this ceiling.\n        while not ceiling_changed:\n            p2, p1, p0 = -2, -1, -1\n\n            while combo[p2] == combo[p1] and abs(p2) &lt;= num_cells:\n                # 3,3,3,3\n                if abs(p2) == num_cells:\n                    return\n\n                p2 -= 1\n                p1 -= 1\n                p0 -= 1\n\n            cd = 0\n\n            # slide_ptrs_left loop\n            while abs(p2) &lt;= num_cells:\n                d   = combo[p2] - combo[p1]\n                cd += d\n\n                # 5,5,3,3 or 5,5,4,3\n                if cd &gt; 1:\n                    if abs(p2) &lt; num_cells:\n                        # 5,5,3,3 --&gt; 5,4,4,3\n                        if d &gt; 1:\n                            combo[p2] -= 1\n                            combo[p1] += 1\n                        # d == 1; 5,5,4,3 --&gt; 5,4,4,4\n                        else:\n                            combo[p2] -= 1\n                            combo[p0] += 1\n\n                        yield tuple(combo)\n\n                    # abs(p2) == num_cells; 5,4,4,3\n                    else:\n                        ceiling -= 1\n                        ceiling_changed = True\n\n                    # Resume at make_combo_same_ceiling while\n                    # and follow branch.\n                    break\n\n                # 4,3,3,3 or 4,4,3,3\n                elif cd == 1:\n                    if abs(p2) == num_cells:\n                        return\n\n                    p1 -= 1\n                    p2 -= 1\n\nif __name__ == '__main__':\n    print list(all_combos(ceiling=6, target_sum=12, num_cells=4))\n</code>\n</pre>\n", "senID": 17}], [{"text": ["Here's the simplest recursive solution that I can think of to \"find all possible combinations of n numbers with values x such that 1 &lt;= x &lt;= max_val and x(1) + ... + x(n) = target\".", "I'm developing it from scratch.", "Here's a version without any optimization at all, just for simplicity:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def apcnx(n, max_val, target, xsofar=(), sumsofar=0):\n  if n==0:\n    if sumsofar==target:\n      yield xsofar\n    return\n\n  if xsofar:\n    minx = xsofar[-1] - 1\n  else:\n    minx = 0\n\n  for x in xrange(minx, max_val):\n    for xposs in apcnx(n-1, max_val, target, xsofar + (x+1,), sumsofar+x+1):\n      yield xposs\n\nfor xs in apcnx(4, 6, 12):\n  print xs\n</code>\n</pre>\n", "senID": 1}, {"text": ["The base case n==0 (where we can't yield any more numbers) either yield the tuple so far if it satisfies the condition, or nothing, then finishes (returns)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "n==0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If we're supposed to yield longer tuples than we've built so far, the if/else makes sure we only yield non-decreasing tuples, to avoid repetition (you did say \"combination\" rather than \"permutation\")."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "if/else", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The for tries all possibilities for \"this\" item and loops over whatever the next-lower-down level of recursion is still able to yield."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The output I see is:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n (1, 1, 4, 6)\n(1, 1, 5, 5)\n(1, 2, 3, 6)\n(1, 2, 4, 5)\n(1, 3, 3, 5)\n(1, 3, 4, 4)\n(2, 2, 2, 6)\n(2, 2, 3, 5)\n(2, 2, 4, 4)\n(2, 3, 3, 4)\n(3, 3, 3, 3)\n</code>\n</pre>\n", "senID": 6}, {"text": ["which seems correct."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["There are a bazillion possible optimizations, but, remember:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["I corresponded with Kent Beck to properly attribute this quote in \"Python in a Nutshell\", and he tells me he got it from his dad, whose job was actually unrelated to programming;-)."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["In this case, it seems to me that the key issue is understanding what's going on, and any optimization might interfere, so I'm going all out for \"simple and understandable\"; we can, if need be!, optimize the socks off it once the OP confirms they can understand what's going on in this sheer, unoptimized version!"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "understanding", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "can", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["First of all, I'd use variable names that mean something, so that the code gets comprehensible.", "Then, after I understood the problem, it's clearly a recursive problem, as once you have chosen one number, the question of finding the possible values for the rest of the squares are exactly the same problem, but with different values in."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So I would do it like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import division\nfrom math import ceil\n\ndef make_combos(max_val,target_sum,n_cells):\n    combos = []\n    # The highest possible value of the next cell is whatever is \n    # largest of the max_val, or the target_sum minus the number \n    # of remaining cells (as you can't enter 0).\n    highest = min(max_val, target_sum - n_cells + 1)\n    # The lowest is the lowest number you can have that will add upp to \n    # target_sum if you multiply it with n_cells.\n    lowest = int(ceil(target_sum/n_cells))\n    for x in range(highest, lowest-1, -1):\n        if n_cells == 1: # This is the last cell, no more recursion.\n            combos.append((x,))\n            break\n        # Recurse to get the next cell:\n        # Set the max to x (or we'll get duplicates like\n        # (6,3,2,1) and (6,2,3,1), which is pointless.\n        # Reduce the target_sum with x to keep the sum correct.\n        # Reduce the number of cells with 1.\n        for combo in make_combos(x, target_sum-x, n_cells-1):\n            combos.append((x,)+combo)\n    return combos\n\nif __name__ == '__main__':\n    import pprint\n    # And by using pprint the output gets easier to read\n    pprint.pprint(make_combos( 6,12,4))\n</code>\n</pre>\n", "senID": 2}, {"text": ["I also notice that your solution still seems buggy.", "For the values max_val=8, target_sum=20 and n_cells=5 your code doesn't find the solution (8,6,4,1,1,), as an example.", "I'm not sure if that means I've missed a rule in this or not, but as I understand the rules that should be a valid option."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "max_val=8, target_sum=20 and n_cells=5", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(8,6,4,1,1,)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Here's a version using generators, It saves a couple of lines, and memory if the values are really big, but as recursion, generators can be tricky to \"get\". "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import division\nfrom math import ceil\n\ndef make_combos(max_val,target_sum,n_cells):\n    highest = min(max_val, target_sum - n_cells + 1)\n    lowest = int(ceil(target_sum/n_cells))\n    for x in xrange(highest, lowest-1, -1):\n        if n_cells == 1:\n            yield (x,)\n            break\n        for combo in make_combos(x, target_sum-x, n_cells-1):\n            yield (x,)+combo\n\nif __name__ == '__main__':\n    import pprint\n    pprint.pprint(list(make_combos( 6,12,4)))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Sorry to say, your code is kind of long and not particularly readable.", "If you can try to summarize it somehow, maybe someone can help you write it more clearly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As for the problem itself, my first thought would be to use recursion.", "(For all I know, you're already doing that.", "Sorry again for my inability to read your code.", ") Think of a way that you can reduce the problem to a smaller easier version of the same problem, repeatedly, until you have a trivial case with a very simple answer."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["To be a bit more concrete, you have these three parameters, max_val, target_sum, and n_cells.", "Can you set one of those numbers to some particular value, in order to give you an extremely simple problem requiring no thought at all?", "Once you have that, can you reduce the slightly harder version of the problem to the already solved one?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: Here is my code.", "I don't like the way it does de-duplication.", "I'm sure there's a more Pythonic way.", "Also, it disallows using the same number twice in one combination.", "To undo this behavior, just take out the line if n not in numlist:.", "I'm not sure if this is completely correct, but it seems to work and is (IMHO) more readable.", "You could easily add memoization and that would probably speed it up quite a bit."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "if n not in numlist:", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"code": "<pre>\n<code>\n def get_combos(max_val, target, n_cells):\n    if target &lt;= 0:\n        return []\n    if n_cells is 1:\n        if target &gt; max_val:\n            return []\n        else:\n            return [[target]]\n    else:\n        combos = []\n        for n in range(1, max_val+1, 1):\n            for numlist in get_combos(max_val, target-n, n_cells-1):\n                if n not in numlist:\n                    combos.append(numlist + [n])\n        return combos\n\ndef deduplicate(combos):\n    for numlist in combos:\n        numlist.sort()\n    answer = [tuple(numlist) for numlist in combos]\n    return set(answer)\n\ndef kenken(max_val, target, n_cells):\n    return deduplicate(get_combos(max_val, target, n_cells))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["First of all, I am learning Python myself so this solution won't be great but this is just an attempt at solving this.", "I have tried to solve it recursively and I think a recursive solution would be ideal for this kind of problem although THAT recursive solution might not be this one:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def GetFactors(maxVal, noOfCells, targetSum):\n    l = []\n    while(maxVal != 0):\n        remCells = noOfCells - 1\n        if(remCells &gt; 2):\n            retList = GetFactors(maxVal, remCells, targetSum - maxVal)\n            #Append the returned List to the original List\n            #But first, add the maxVal to the start of every elem of returned list.\n            for i in retList:\n                i.insert(0, maxVal)\n            l.extend(retList)\n\n        else:\n            remTotal = targetSum - maxVal\n            for i in range(1, remTotal/2 + 1):\n                itemToInsert = remTotal - i;\n                if (i &gt; maxVal or itemToInsert &gt; maxVal):\n                    continue\n                l.append([maxVal, i, remTotal - i])\n        maxVal -= 1\n    return l\n\n\n\nif __name__ == \"__main__\":\n    l = GetFactors(5, 5, 15)\n    print l\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here a simple solution in C/C++:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n const int max = 6;\nint sol[N_CELLS];\n\nvoid enum_solutions(int target, int n, int min) {\n  if (target == 0 &amp;&amp; n == 0)\n    report_solution(); /* sol[0]..sol[N_CELLS-1] is a solution */\n  if (target &lt;= 0 || n == 0) return; /* nothing further to explore */\n  sol[n - 1] = min; /* remember */\n  for (int i = min; i &lt;= max; i++)\n    enum_solutions(target - i, n - 1, i);\n}\n\nenum_solutions(12, 4, 1);\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is a naive, but succinct, solution using generators:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def descending(v):\n  \"\"\"Decide if a square contains values in descending order\"\"\"\n  return list(reversed(v)) == sorted(v)\n\ndef latinSquares(max_val, target_sum, n_cells):\n  \"\"\"Return all descending n_cells-dimensional squares,\n     no cell larger than max_val, sum equal to target_sum.\"\"\"\n  possibilities = itertools.product(range(1,max_val+1),repeat=n_cells)\n  for square in possibilities:\n    if descending(square) and sum(square) == target_sum:\n      yield square\n</code>\n</pre>\n", "senID": 1}, {"text": ["I could have optimized this code by directly enumerating the list of descending grids, but I find itertools.product much clearer for a first-pass solution.", "Finally, calling the function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for m in latinSquares(6, 12, 4):\n  print m\n</code>\n</pre>\n", "senID": 3}], [{"text": ["And here is another recursive, generator-based solution, but this time using some simple math to calculate ranges at each step, avoiding needless recursion:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def latinSquares(max_val, target_sum, n_cells):\n  if n_cells == 1:\n    assert(max_val &gt;= target_sum &gt;= 1)\n    return ((target_sum,),)\n  else:\n    lower_bound = max(-(-target_sum / n_cells), 1)\n    upper_bound = min(max_val, target_sum - n_cells + 1)\n    assert(lower_bound &lt;= upper_bound)\n    return ((v,) + w for v in xrange(upper_bound, lower_bound - 1, -1)\n                     for w in latinSquares(v, target_sum - v, n_cells - 1))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code will fail with an AssertionError if you supply parameters that are impossible to satisfy; this is a side-effect of my \"correctness criterion\" that we never do an unnecessary recursion.", "If you don't want that side-effect, remove the assertions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note the use of -(-x/y) to round up after division.", "There may be a more pythonic way to write that.", "Note also I'm using generator expressions instead of yield."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "generator expressions", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0289/"}]}, {"code": "<pre>\n<code>\n for m in latinSquares(6,12,4):\n  print m\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Little bit offtopic, but still might help at programming kenken."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I got good results using DLX algorhitm for solving Killer Sudoku (very simmilar as KenKen it has cages, but only sums).", "It took less than second for most of problems and it was implemented in MATLAB language. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["reference this forum\nhttp://www.setbb.com/phpbb/viewtopic.php?t=1274&amp;highlight=&amp;mforum=sudoku"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.setbb.com/phpbb/viewtopic.php?t=1274&amp;highlight=&amp;mforum=sudoku", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.setbb.com/phpbb/viewtopic.php?t=1274&highlight=&mforum=sudoku"}]}, {"text": ["killer sudoku\n\"look at wikipedia, cant post hyper link\" damt spammers"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]