[[{"text": ["Latest comparison available here at the thrift-protobuf-compare project wiki.", "It includes many other serialization libraries."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "thrift-protobuf-compare", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/eishay/jvm-serializers/wiki/"}]}], [{"text": ["I'm in the process of writing some code in an open source project named thrift-protobuf-compare comparing between protobuf and thrift.", "For now it covers few serialization aspects, but I intend to cover more.", "The results (for Thrift and Protobuf) are discussed in my blog, I'll add more when I'll get to it.", "You may look at the code to compare API, description language and generated code.", "I'll be happy to have contributions to achieve a more rounded comparison. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "open source project named thrift-protobuf-compare", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/thrift-protobuf-compare/"}, {"text": "Thrift", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://eishay.blogspot.com/search/label/Thrift"}, {"text": "Protobuf", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://eishay.blogspot.com/search/label/protobuf"}]}], [{"text": ["You may be interested in this question: \"Biggest differences of Thrift vs Protocol Buffers?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\"Biggest differences of Thrift vs Protocol Buffers?\"", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/69316/biggest-differences-of-thrift-vs-protocol-buffers"}]}], [{"text": ["I did test performance of PB with number of other data formats (xml, json, default object serialization, hessian, one proprietary one) and libraries (jaxb, fast infoset, hand-written) for data binding task (both reading and writing), but thrift's format(s) was not included.", "Performance for formats with multiple converters (like xml) had very high variance, from very slow to pretty-darn-fast.", "Correlation between claims of authors and perceived performance was rather weak.", "Especially so for packages that made wildest claims."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For what it is worth, I found PB performance to be bit over hyped (usually not by its authors, but others who only know who wrote it).", "With default settings it did not beat fastest textual xml alternative.", "With optimized mode (why is this not default?", "), it was bit faster, comparable with the fastest JSON package.", "Hessian was rather fast, textual json also.", "Properietary binary format (no name here, it was company internal) was the slowest.", "Java object serialization was fast for larger messages, less so for small objects (i.e.", "high fixed per-operation noverhead).", "With PB message size was compact, but given all trade-offs you have to do (data is not self-descriptive: if you lose the schema, you lose data; there are indexes of course, and value types, but from what you have reverse-engineer back to field names if you want), I personally would only choose it for specific use cases -- size-sensitive, closely coupled system where interface/format never (or very very rarely) changes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["My opinion in this is that (a) implementation often matters more than specification (of data format), (b) end-to-end, differences between best-of-breed (for different formats) are usually not big enough to dictate the choice.", "That is, you may be better off choosing format+API/lib/framework you like using most (or has best tool support), find best implementation, and see if that works fast enough.", "If (and only if!", ") not, consider next best alternative."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["ps.", "Not sure what EJB3 here would be.", "Maybe just plain of Java serialization?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["One of the things near the top of my \"to-do\" list for PBs is to port Google's internal Protocol Buffer performance benchmark - it's mostly a case of taking confidential message formats and turning them into entirely bland ones, and then doing the same for the data."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When that's been done, I'd imagine you could build the same messages in Thrift and then compare the performance."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In other words, I don't have the data for you yet - but hopefully in the next couple of weeks..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If the raw net performance is the target, then nothing beats IIOP (see RMI/IIOP).", "Smallest possible footprint -- only binary data, no markup at all.", "Serialization/deserialization is very fast too."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Since it's IIOP (that is CORBA), almost all languages have bindings."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["But I presume the performance is not the only requirement, right?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "only", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["To back up Vladimir's point about IIOP, here's an interesting performance test, that should give some additional info over the google benchmarks, since it compares Thrift and CORBA.", "To quote from the study:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Thrift and CORBA", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.com/url?sa=t&source=web&cd=15&ved=0CC4QFjAEOAo&url=http://forge.morfeo-project.org/frs/download.php/1156/Performance_TIDorb_vs_Thrift_morfeo.pdf&rct=j&q=thrift%20vs.%20corba&ei=23CbTcmoAYz0tgPF5-SNBA&usg=AFQjCNGijXQ7At7oFsdF5csNRmFW1fGzMg"}]}, {"text": ["Another odd limitation, not having to do with performance, is that Thrift is limited to returning only several values as a struct - although this, like performance, can surely be improved perhaps.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It is interesting that the Thrift IDL closely matches the CORBA IDL, nice.", "I haven't used Thrift, it looks interesting especially for smaller messages, and one of the design goals was for a less cumbersome install, so these are other advantages of Thrift.", "That said, CORBA has a bad rap, there are many excellent implementations out there like omniORB for example, which has bindings for Python, that are easy to install and use."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "omniORB", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://omniorb.sourceforge.net/"}]}]]