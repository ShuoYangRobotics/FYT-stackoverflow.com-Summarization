[[{"text": ["Python is a dynamic language.", "It bad idea to test the types explicitly.", "In fact the code you write should in itself be such that you dont ever need to test the types of variables."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you are coming from C/C++/Java then takes some time to get over that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Couple of things:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["You have an incoming parameter named \"type\".", "This is masking the \"type\" built-in because it is a global, and locals trump globals.", "I assume this exception occurs because \"type\" has a string value."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Why are you printing error messages?", "The correct way to report an error is to raise an exception."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]}, {"text": ["Overall I concur with the other answers that type-checking in general is a python anti-pattern.", "It it needed only in rare cases."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Not answering the \"why\", but "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It's not a good idea testing for types like this.", "However, if you must, do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if isinstance(item, str):\n   # do your thing\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Beside the ideas presented before you might want to check out decorator based type checking and contracts."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "decorator based type checking", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/454322-type-checking-decorator/"}, {"href": "http://www.wayforward.net/pycontract/", "text": "contracts", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Historically there has been some interest in integrating optional typing to the language."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "some interest", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=86641"}]}, {"text": ["There are specific extension languages, such as Cython and Pyrex, that pretty much force you to type to some extent in order.", "The cool thing is that these languages allow you to generate high performance C extensions to use with your regular Python code."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Cython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cython.org/"}, {"text": "Pyrex", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/"}]}], [{"text": ["In general don't type-check, but if it's a genuine precondition for the arguments then verify them using assert rather than printing errors to stdout."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n assert isinstance(code, str)\nassert isinstance(name, str)\n...\n</code>\n</pre>\n", "senID": 1}], [{"text": ["in python you just use the variables as if they where the type you want.", "if for some reason you have a function you call with different types, you can wrap your code in a try/catch."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def addOne(a):\n    ''' \n    increments a with 1 if a is a number. \n    if a is a string, append '.' to it.    \n    '''\n    try:\n        return a + 1\n    except TypeError:\n        return a + \".\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["but you generally dont want to do that.", "for the case above use to different functions"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]