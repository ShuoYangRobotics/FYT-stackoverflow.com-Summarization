[[{"text": ["on linux, you can look in the directory /proc/$PID to get information about that process.", "In fact, if the directory exists, the process is running."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Mark's answer is the way to go, after all, that's why the /proc file system is there.", "For something a little more copy/pasteable:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import os.path\n &gt;&gt;&gt; os.path.exists(\"/proc/0\")\n False\n &gt;&gt;&gt; os.path.exists(\"/proc/12\")\n True\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It should work on any POSIX system (although looking at the /proc filesystem, as others have suggested, is easier if you know it's going to be there)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "/proc", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["However: os.kill may also fail if you don't have permission to signal the process.", "You would need to do something like:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "os.kill", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import sys\nimport os\nimport errno\n\ntry:\n    os.kill(int(sys.argv[1]), 0)\nexcept OSError, err:\n    if err.errno == errno.ESRCH:\n        print \"Not running\"\n    elif err.errno == errno.EPERM:\n        print \"No permission to signal this process!\"\n    else:\n        print \"Unknown error\"\nelse:\n    print \"Running\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["// But is this reliable?", "Does it work with every process and every distribution?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Yes, it should work on any Linux distribution.", "Be aware that /proc is not easily available on Unix based systems, though (FreeBSD, OSX)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here's the solution that solved it for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport subprocess\nimport re\n\ndef findThisProcess( process_name ):\n  ps     = subprocess.Popen(\"ps -eaf | grep \"+process_name, shell=True, stdout=subprocess.PIPE)\n  output = ps.stdout.read()\n  ps.stdout.close()\n  ps.wait()\n\n  return output\n\n# This is the function you can use  \ndef isThisRunning( process_name ):\n  output = findThisProcess( process_name )\n\n  if re.search('path/of/process'+process_name, output) is None:\n    return False\n  else:\n    return True\n\n# Example of how to use\nif isThisRunning('some_process') == False:\n  print(\"Not running\")\nelse:\n  print(\"Running!\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm a Python + Linux newbie, so this might not be optimal.", "It solved my problem, and hopefully will help other people as well."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Seems to me a PID-based solution is too vulnerable.", "If the process you're trying to check the status of has been terminated, its PID can be reused by a new process.", "So, IMO ShaChris23 the Python + Linux newbie gave the best solution to the problem.", "Even it only works if the process in question is uniquely identifiable by its command string, or you are sure there would be only one running at a time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Sligtly modified version of ShaChris23 script.", "Checks if proc_name value is found within process args string (for example Python script executed with python ):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def process_exists(proc_name):\n    ps = subprocess.Popen(\"ps ax -o pid= -o args= \", shell=True, stdout=subprocess.PIPE)\n    ps_pid = ps.pid\n    output = ps.stdout.read()\n    ps.stdout.close()\n    ps.wait()\n\n    for line in output.split(\"\\n\"):\n        res = re.findall(\"(\\d+) (.*)\", line)\n        if res:\n            pid = int(res[0][0])\n            if proc_name in res[0][1] and pid != os.getpid() and pid != ps_pid:\n                return True\n    return False\n</code>\n</pre>\n", "senID": 1}]]