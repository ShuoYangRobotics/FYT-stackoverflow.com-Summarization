[[{"text": ["Stackless Python's main benefit is the support for very lightweight coroutines.", "CPython doesn't support coroutines natively (although I expect someone to post a generator-based hack in the comments) so Stackless is a clear improvement on CPython when you have a problem that benefits from coroutines. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think the main area where they excel are when you have many concurrent tasks running within your program.", "Examples might be game entities that run a looping script for their AI, or a web server that is servicing many clients with pages that are slow to create."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You still have many of the typical problems with concurrency correctness however regarding shared data, but the deterministic task switching makes it easier to write safe code since you know exactly where control will be transferred and therefore know the exact points at which the shared state must be up to date."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It allows you to work with massive amounts of concurrency.", "Nobody sane would create 100.000 system threads, but you can do this using stackless."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This article tests doing just that, creating 100.000 tasklets in both Python and Google Go (a new programming language): http://dalkescientific.com/writings/diary/archive/2009/11/15/100000_tasklets.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://dalkescientific.com/writings/diary/archive/2009/11/15/100000_tasklets.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://dalkescientific.com/writings/diary/archive/2009/11/15/100000_tasklets.html"}]}, {"text": ["Surprisingly, even if Google Go is compiled to native code, and they tout their co-routines implementation, Python still wins."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Stackless would be good for implementing a map/reduce algorithm, where you can have a very large number of reducers depending on your input data."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Thirler already mentioned that stackless was used in Eve Online.", "Keep in mind, that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(got this citation from here)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.tentonhammer.com/node/10044"}]}, {"text": ["At PyCon 2009 there was given a very intersting talk, describing why and how stackless is used at CCP Games."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "PyCon 2009", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://us.pycon.org/2009/conference/schedule/event/91/"}]}, {"text": ["Also, there is a very good introductory material, which describes why stackless is a good solution for Your applications.", "(it may be somewhat old, but I think that it is worth reading)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "introductory material", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://members.verizon.net/olsongt/stackless/why_stackless.html#why-stackless"}]}], [{"text": ["The basic usefulness for green threads, the way I see it, is to implement a system in which you have a large amount of objects that do high latency operations.", "A concrete example would be communicating with other machines:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def Run():\n    # Do stuff\n    request_information() # This call might block\n    # Proceed doing more stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["Threads let you write the above code naturally, but if the number of objects is large enough, threads just cannot perform adequately.", "But you can use green threads even for in really large amounts.", "The request_information() above could switch out to some scheduler where other work is waiting and return later.", "You get all the benefits of being able to call \"blocking\" functions as if they return immediately without using threads."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "request_information()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "as if they return immediately", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["This is obviously very useful for any kind of distributed computing if you want to write code in a straightforward way."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It is also interesting for multiple cores to mitigate waiting for locks:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def Run():\n    # Do some calculations\n    green_lock(the_foo)\n    # Do some more calculations\n</code>\n</pre>\n", "senID": 5}, {"text": ["The green_lock function would basically attempt to acquire the lock and just switch out to a main scheduler if it fails due to other cores using the object. "], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "green_lock", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Again, green threads are being used to mitigate blocking, allowing code to be written naturally and still perform well."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["EVEOnline is largely programmed in Stackless Python.", "They have several dev blogs on the use of it.", "It seems it is very useful for high performance computing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["While I've not used Stackless itself, I have used Greenlet for implementing highly-concurrent network applications.", "Some of the use cases Linden Lab has put it towards are: high-performance smart proxies, a fast system for distributing commands over huge numbers of machines, and an application that does a ton of database writes and reads (at a ratio of about 1:2, which is very write-heavy, so it's spending most of its time waiting for the database to return), and a web-crawler-type-thing for internal web data.", "Basically any app that's expecting to have to do a lot of network I/O will benefit from being able to create a bajillion lightweight threads.", "10,000 connected clients doesn't seem like a huge deal to me."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Stackless or Greenlet aren't really a complete solution, though.", "They are very low-level and you're going to have to do a lot of monkeywork to build an application with them that uses them to their fullest.", "I know this because I maintain a library that provides a networking and scheduling layer on top of Greenlet, specifically because writing apps is so much easier with it.", "There are a bunch of these now; I maintain Eventlet, but also there is Concurrence, Chiral, and probably a few more that I don't know about.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If the sort of app you want to write sounds like what I wrote about, consider one of these libraries.", "The choice of Stackless vs Greenlet is somewhat less important than deciding what library best suits the needs of what you want to do."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]