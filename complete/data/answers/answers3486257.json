[[{"text": ["This is quite hackish, but you can delete i and then check if it exists after the loop (if not, the loop never happened):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n try:\n    del i\nexcept NameException: pass\n\nfor i in iterable:\n    do_something(i)\n\ntry:\n    del i\nexcept NameException:\n    do_something_else()\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think that's probably uglier than just using a flag though"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Update 2"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Update 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I liked Odomontois' answer.", "IMHO it is better suited to this problem than what I have written below. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Odomontois' answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3486257/idiomatic-way-of-taking-action-on-attempt-to-loop-over-an-empty-iterable/3486566#3486566"}]}, {"text": ["Update"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["(After reading the OP's comment and edited question) You can do that too.", "See below:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def with_divisible(n, a, b, f):\n it = (i for i in xrange(a, b) if not i % n)\n for i in wrapper(it):\n  f(i)\n\n&gt;&gt;&gt; with_divisible(1, 1, 1, lambda x: x)\nTraceback (most recent call last):\n  File \"&lt;pyshell#55&gt;\", line 1, in &lt;module&gt;\n    with_divisible(1, 1, 1, lambda x: x)\n  File \"&lt;pyshell#54&gt;\", line 3, in with_divisible\n    for i in wrapper(it):\n  File \"&lt;pyshell#46&gt;\", line 4, in wrapper\n    raise EmptyIterableException(\"Empty\")\nEmptyIterableException: Empty\n\n&gt;&gt;&gt; with_divisible(7, 1, 21, lambda x: x)\n7\n14\n...Snipped...\n    raise EmptyIterableException(\"Empty\")\nEmptyIterableException: Empty\n</code>\n</pre>\n", "senID": 4}, {"text": ["Original Answer"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Original Answer", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Interesting problem.", "I did some experiments and came up with the following:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class EmptyIterableException(Exception):\n    pass\n\ndef wrapper(iterable):\n    for each in iterable:\n        yield each\n    raise EmptyIterableException(\"Empty\")\n\ntry:\n    for each in wrapper(iterable):\n        do_something(each)\nexcept EmptyIterableException, e:\n    do_something_else()\n</code>\n</pre>\n", "senID": 7}], [{"code": "<pre>\n<code>\n if not map(do_something_callable,iterable) : \n    # do something else\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I think this the the cleanest way to do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # first try with exceptions\ndef nonempty( iter ):\n    \"\"\" returns `iter` if iter is not empty, else raises TypeError \"\"\"\n    try:\n        first = next(iter)\n    except StopIteration:\n        raise TypeError(\"Emtpy Iterator\")\n    yield first\n    for item in iter:\n        yield item\n\n\n# a version without exceptions. Seems nicer:\ndef isempty( iter ):\n    \"\"\" returns `(True, ())` if `iter` if is empty else `(False, iter)`\n         Don't use the original iterator! \"\"\"\n    try:\n        first = next(iter)\n    except StopIteration:\n        return True, ()\n    else:\n        def iterator():\n            yield first\n            for item in iter:\n                yield item\n        return False, iterator()\n\n\n\nfor x in ([],[1]):\n    # first version\n    try:\n        list(nonempty(iter(x))) # trying to consume a empty iterator raises\n    except TypeError:\n        print x, \"is empty\"\n    else:\n        print x, \"is not empty\"\n\n    # with isempty\n    empty, it = isempty(iter(x))\n    print x,  \"is\", (\"empty\" if empty else \"not empty\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The general way forward if an iterator is to be partially checked before being consumed is to use itertools.tee.", "This way we can have two copies of the iterator and check one for emptiness while still consuming the other copy from the start."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.tee", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import tee\nit1, it2 = tee(iterable)\ntry:\n    it1.next()\n    for i in it2:\n        do_some_action(i) #iterator is not empty\nexcept StopIteration:\n    do_empty_action() #iterator is empty\n</code>\n</pre>\n", "senID": 1}, {"text": ["The StopIteration exception is bound to be a result of the call to it1.next(), as any StopIteration exceptions raised froom inside the loop will terminate that loop."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "StopIteration", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "it1.next()", "childNum": 0, "tag": "code", "childList": []}, {"text": "StopIteration", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: for those who don't like such exceptions, islice can be used to set up a single step loop:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "islice", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import tee, islice\nit1, it2 = tee(iterable)\nfor _ in islice(it1, 1):\n    #loop entered if iterator is not empty\n    for i in it2:\n        do_some_action(i)\n    break #if loop entered don't execute the else section\nelse:\n    do_empty_action()\n</code>\n</pre>\n", "senID": 4}, {"text": ["I personally prefer the first style.", "YMMV."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["What about reversing \"if\" and \"for\":"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if iterable:\n    for i in iterable:\n        do_something(i)\nelse:\n    do_something_else()\n</code>\n</pre>\n", "senID": 1}, {"text": ["OK, this does not work!"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "OK, this does not work!", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here is an other solution: http://code.activestate.com/recipes/413614-testing-for-an-empty-iterator/ "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://code.activestate.com/recipes/413614-testing-for-an-empty-iterator/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/413614-testing-for-an-empty-iterator/"}]}], [{"text": ["This is a combination of Michael Mrozek's and FM's answers: "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Michael Mrozek", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3486257/idiomatic-way-of-taking-action-on-attempt-to-loop-over-an-empty-iterable/3486280#3486280"}, {"href": "http://stackoverflow.com/questions/3486257/idiomatic-way-of-taking-action-on-attempt-to-loop-over-an-empty-iterable/3487375#3487375", "text": "FM", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def with_divisible(n, a, b, f):\n    '''apply f to every integer x such that n divides x and a &lt;= x &lt; b'''\n    it = (i for i in xrange(a, b) if not i % n)\n    for i in it:\n        f(i)\n    try: i            # test if `it` was empty\n    except NameError: print('do something else')\n\ndef g(i):\n    print i,\n\nwith_divisible( 3, 1, 10, g)   # Prints 3 6 9.\nwith_divisible(33, 1, 10, g)   # Prints \"do something else\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Generators have a 'gi_frame' property which is None once the generator is exhausted, but only after StopIteration has been raised.", "If that's acceptable, here's something you could try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import types\n\ndef do(x, f, f_empty):\n    if type(x) == types.GeneratorType:\n        # generators have a 'gi_frame' property,\n        # which is None once the generator is exhausted\n        if x.gi_frame:\n            # not empty\n            return f(x)\n        return f_empty(x)\n    if x:\n        return f(x)\n    return f_empty(x)\n\ndef nempty(lst):\n    print lst, 'not empty'\n\ndef empty(lst):\n    print 'Twas empty!'\n\n# lists\ndo([2,3,4], nempty, empty)\ndo([], nempty, empty)\n\n# generators\ndo((i for i in range(5)), nempty, empty)\ngen = (i for i in range(1))\ngen.next()\ntry:\n    gen.next()\nexcept StopIteration:\n    pass\ndo(gen, nempty, empty)\n</code>\n</pre>\n", "senID": 1}]]