[[{"text": ["In python >= 2.6 there is a as_integer_ratio method on floats:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "as_integer_ratio", "tag": "a", "pos": 0, "childList": [{"text": "as_integer_ratio", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#float.as_integer_ratio"}, {"text": "as_integer_ratio", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = 6.75\n&gt;&gt;&gt; a.as_integer_ratio()\n(27, 4)\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.pi.as_integer_ratio()\n(884279719003555, 281474976710656)\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, due to the way floats are defined in programming languages there are no irrational numbers."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "there are no irrational numbers", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Any number with a finite decimal expansion is a rational number.", "You could always solve for instance"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n 5.195181354985216\n</code>\n</pre>\n", "senID": 1}, {"text": ["by saying that it corresponds to "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 5195181354985216 / 1000000000000000\n</code>\n</pre>\n", "senID": 3}, {"text": ["So since floats and doubles have finite precision they're all rationals."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The nature of floating-point numbers means that it makes no sense to check if a floating-point number is rational, since all floating-point numbers are really fractions of the form n / 2e.", "However, you might well want to know whether there is a simple fraction (one with a small denominator rather than a big power of 2) that closely approximates a given floating-point number."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "check", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "e", "childNum": 1, "tag": "sup", "childList": [{"text": "e", "tag": "em"}]}, {"text": "e", "childNum": 0, "tag": "em", "childList": []}, {"text": "simple", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Donald Knuth discusses this latter problem in The Art of Computer Programming volume II.", "See the answer to exercise 4.53-39.", "The idea is to search for the fraction with the lowest denominator within a range, by expanding the endpoints of the range as continued fractions so long as their coefficients are equal, and then when they differ, take the simplest value between them.", "Here's a fairly straightforward implementation in Python:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "The Art of Computer Programming", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from fractions import Fraction\nfrom math import modf\n\ndef simplest_fraction_in_interval(x, y):\n    \"\"\"Return the fraction with the lowest denominator in [x,y].\"\"\"\n    if x == y:\n        # The algorithm will not terminate if x and y are equal.\n        raise ValueError(\"Equal arguments.\")\n    elif x &lt; 0 and y &lt; 0:\n        # Handle negative arguments by solving positive case and negating.\n        return -simplest_fraction_in_interval(-y, -x)\n    elif x &lt;= 0 or y &lt;= 0:\n        # One argument is 0, or arguments are on opposite sides of 0, so\n        # the simplest fraction in interval is 0 exactly.\n        return Fraction(0)\n    else:\n        # Remainder and Coefficient of continued fractions for x and y.\n        xr, xc = modf(1/x);\n        yr, yc = modf(1/y);\n        if xc &lt; yc:\n            return Fraction(1, int(xc) + 1)\n        elif yc &lt; xc:\n            return Fraction(1, int(yc) + 1)\n        else:\n            return 1 / (int(xc) + simplest_fraction_in_interval(xr, yr))\n\ndef approximate_fraction(x, e):\n    \"\"\"Return the fraction with the lowest denominator that differs\n    from x by no more than e.\"\"\"\n    return simplest_fraction_in_interval(x - e, x + e)\n</code>\n</pre>\n", "senID": 2}, {"text": ["And here are some results:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; approximate_fraction(6.75, 0.01)\nFraction(27, 4)\n&gt;&gt;&gt; approximate_fraction(math.pi, 0.00001)\nFraction(355, 113)\n&gt;&gt;&gt; approximate_fraction((1 + math.sqrt(5)) / 2, 0.00001)\nFraction(377, 233)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Python uses floating-point representation rather than rational numbers.", "Take a look at the standard libraryfractionsmodule for some details about rational numbers."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "the standard libraryfractionsmodule", "tag": "a", "pos": 1, "childList": [{"text": "fractions", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/fractions.html"}, {"text": "fractions", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Observe, for example, this, to see why it goes wrong:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; 1.1  # Uh oh.\n1.1000000000000001\n&gt;&gt;&gt; Fraction(1.1)  # Will only work in &gt;= Python 2.7, anyway.\nFraction(2476979795053773, 2251799813685248)\n&gt;&gt;&gt; Fraction(*1.1.as_integer_ratio())  # Python 2.6 compatible\nFraction(2476979795053773, 2251799813685248)\n</code>\n</pre>\n", "senID": 2}, {"text": ["(Oh, you want to see a case where it works?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Fraction('1.1')\nFraction(11, 10)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["May be this will be interesting to you: Best rational approximation"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Best rational approximation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+TheEndeavour+%28The+Endeavour%29"}]}], [{"text": ["As you noted any floating point number can be converted to a rational number by moving the decimal point and dividing by the appropriate power of ten."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can then remove the greatest common divisor from the dividend and divisor and check if both of these numbers fit in the data type of your choice."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The problem with real numbers in programming languages is that they are usually defined as functions returning a finite representation given an accuracy (eg.", "a function which takes n as an argument and returns a floating point number within 2^-n accuracy)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can definitely turn a rational/integer into a real, but even comparing reals for equality is undecidable (it is essentially the halting problem)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You cannot tell whether a real number x is rational: even in mathematics, it is usually difficult, since you have to find p and q such that x = p/q, and this is often non constructive."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["However, given an accuracy window, you can find the \"best\" rational approximation for this accuracy using for instance continuous fraction expansion.", "I believe that is essentially what mathematica does.", "But in your exemple, 6.75 is already rational.", "Try with Pi instead."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]