[[{"text": ["Here's a simple solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyIterator(object):   # undo-able iterator wrapper\n    def __init__(self, iterable):\n    \tsuper(MyIterator, self).__init__()\n    \tself.iterator = iter(iterable)\n    \tself.stack = []\n\n    def __iter__(self):\n    \treturn self\n\n    def next(self):\n    \tif self.stack:\n    \t\treturn self.stack.pop()\n    \treturn self.iterator.next()  # Raises StopIteration eventually\n\n    def undo(self, item):\n    \tself.stack.append(item)\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n for i in  MyIterator(xrange(5)): print i\n0\n1\n2\n3\n4\n</code>\n</pre>\n", "senID": 2}, {"code": "<pre>\n<code>\n rng = MyIterator(xrange(5))\nrng.next()\n0\nrng.next()\n1\nrng.undo(1)\nrng.next()\n1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Why bother with unshifting when the else clause should always occur?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for apple in tree:\n    if (apple.weight + basket.weight) &gt; 10:\n       send(basket)\n       basket.clear()\n    basket.add(apple)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Anyway, I'm fairly certain that Python doesn't have the sort of behavior you're looking for."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'd say that the most Pythonic solution is the simplest one.", "Instead of trying to wrap an iterator in a generator expression that allows you to \"backtrack\" or something similarly complex, use a while loop, as you have in Perl!", "Iterators don't mix very nicely with mutation, anywho."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "the most Pythonic solution is the simplest one", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2004-March/253893.html"}, {"text": "Iterators don't mix very nicely with mutation", "childNum": 1, "tag": "strong", "pos": 2, "childList": [{"text": "Iterators don't mix very nicely with mutation", "tag": "a"}]}, {"href": "http://stackoverflow.com/questions/299135/when-i-sort-a-list-what-happens-to-its-iterators", "text": "Iterators don't mix very nicely with mutation", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Simple translation of your implementation (ignoring @Patrick's optimization):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "@Patrick", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/418915/pythonic-equivalent-of-unshift-or-redo#418946"}]}, {"code": "<pre>\n<code>\n while tree:\n    apple = tree.pop(0)\n    if apple.weight + basket.weight &gt; 10:\n        basket.send()\n        basket.clear()\n        tree.insert(0, apple) # Put it back.\n    else:\n        basket.append(apple)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or, you could use a peek-like functionality with ordered sequence indices:    "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "peek", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n while tree:\n    apple = tree[0] # Take a peek at it.\n    if apple.weight + basket.weight &gt; 10:\n        basket.send()\n        basket.clear()\n    else:\n        basket.append(tree.pop(0))\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you don't like the \"simple\" argument, check out the collections.deque iterators mentioned in the above (linked) thread."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "collections.deque", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you don't want to follow the other's suggestion of just removing the else clause, you can write your own unshift function that will work in a way similar to perl's with any iterable:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "unshift", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class UnshiftableIterable(object):\n    def __init__(self, iterable):\n        self._iter = iter(iterable)\n        self._unshifted = [] # empty list of unshifted stuff\n    def __iter__(self):\n        while True:\n            if self._unshifted:\n                yield self._unshifted.pop()\n            else:\n                yield self._iter.next()\n    def unshift(self, item):\n        self._unshifted.append(item)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then in your code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n it = UnshiftableIterable(tree)\nfor apple in tree:\n    if weigth(basket) + weight(apple) &gt; MAX_WEIGHT:\n        send(basket)\n        basket = []\n        it.unshift(apple)\n    else:\n        basket.append(apple)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Some testing of the UnshiftableIterable:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "UnshiftableIterable", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n it = UnshiftableIterable(xrange(5))\n\nfor i in it:\n    print '*',\n    if i == 2:\n        it.unshift(10)\n    else:\n        print i,\n# output: * 0 * 1 * * 10 * 3 * 4\n</code>\n</pre>\n", "senID": 5}], [{"text": ["You're looking for a generator, an iterator that can receive modifications to its internal state via the send() method"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.python.org/doc/current/howto/functional.html#passing-values-into-a-generator"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.python.org/doc/current/howto/functional.html#passing-values-into-a-generator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/current/howto/functional.html#passing-values-into-a-generator"}]}], [{"text": ["While I was writing this @Patrick already suggested the same thing.", "But since I have written it I will paste the code anyways, with comments in code marking methods from Patrick."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\n\napples=[random.randint(1,3) for j in range(10)]\nprint 'apples',apples\n\nbasket=[]\ny=6\nbaskets=[]\n\nfor i in range(len(apples)):\n    if sum(basket+[apples[i]])&gt;y:\n        #basket is full                                                                                                                                     \n        baskets.append(basket)#basket.send()                                                                                                                \n        basket=[]#basket.empty()                                                                                                                            \n    basket.append(apples[i])#add apple to basket                                                                                                            \n\nprint 'baskets',baskets\n</code>\n</pre>\n", "senID": 1}, {"text": ["though this does not pop() the apples from the original iterator.", "Please remark if that's a desired behavior too."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["the output"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n apples [1, 1, 3, 3, 1, 1, 3, 3, 2, 3]\nbaskets [[1, 1, 3], [3, 1, 1], [3, 3]]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["By the way, what you really want is list.insert(0,yourObject)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There is no way general way to push a value into an iterator in python.", "A stack or linked list is better suited to that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're iterating over a list or something, of course you can add the item manually back to the list.", "But you can also iterate over objects which can't be manipulated in such a way."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want to use python to implement that algorithm, you'll have to choose a data structure that allows the operations you want to use.", "I suggest the .push() and .pop() methods which let you treat lists as stacks."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": ".push()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": ".pop()", "childNum": 0, "tag": "code", "childList": []}]}]]