[[{"text": ["Since you have two dense matrices then the double for loop is the only option you have.", "You don't need a sparse matrix class at all since you only want to know the list of indices (i,j) for which a[i,j] != b[i,j]."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "(i,j)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a[i,j] != b[i,j]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In languages like R and Python the double for loop will perform poorly.", "I'd probably write this in native code for a double for loop and add the indices to a list object.", "But no doubt the wizards of interpreted code (i.e.", "R, Python etc.", ") know efficient ways to do it without resorting to native coding."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["In R, if you use the Matrix package, and sparseMatrix for the conversion from the coordinate list to the sparse matrix, then you can convert back to the 3 column via:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Matrix", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sparseMatrix", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29", "text": "coordinate list", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n TmpX &lt;- as(M, \"dgTMatrix\")\nX3col &lt;- matrix(c(TmpX@i, TmpX@j, TmpX@val), ncol = 3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will give you the coordinates and values in the sparse matrix."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Depending on the locations of non-zero entries in A and B, you may find it much better to work with the coordinate list than the sparse matrix representation (there are, by the way, dozens of sparse matrix representations), as you can take direct advantage of vectorized operations, rather than rely upon your sparse matrix package to perform optimally.", "I tend to alternate between using the COO or sparse matrix support in different languages, depending on how I will get the fastest performance for the algorithm of interest."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Update 1: I was unaware that your two matrices, A and B, are dense.", "As such, the easiest solution for finding non-zero entries in C is quite simply to not even subtract at first - just compare the entries of A and B.", "A logical comparison should be faster than a subtraction.", "First, find the entries of A and B where A != B, then subtract just those entries.", "Next, you simply need to convert from the vectorization of indices in A and B to their (row, col) representation.", "This is similar to ind2sub and sub2ind of Matlab - take a look at this R reference for the calculations."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "A != B", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "this R reference", "tag": "a", "pos": 5, "childList": [], "childNum": 0, "href": "http://cran.r-project.org/doc/contrib/Hiebeler-matlabR.pdf"}]}], [{"text": ["You could use c.nonzero() method:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "c.nonzero()", "tag": "a", "pos": 0, "childList": [{"text": "c.nonzero()", "tag": "code"}], "childNum": 1, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.nonzero.html#numpy-nonzero"}, {"text": "c.nonzero()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from scipy.sparse import lil_eye\n&gt;&gt;&gt; c = lil_eye((4, 10)) # as an example\n&gt;&gt;&gt; c\n&lt;4x10 sparse matrix of type '&lt;type 'numpy.float64'&gt;'\n        with 4 stored elements in LInked List format&gt;\n&gt;&gt;&gt; c.nonzero()\n(array([0, 1, 2, 3], dtype=int32), array([0, 1, 2, 3], dtype=int32))\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; np.ascontiguousarray(c)\narray([  (0, 0) 1.0\n  (1, 1)        1.0\n  (2, 2)        1.0\n  (3, 3)        1.0], dtype=object)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You don't need to calculate c matrix to find out indexes of non-zero elements in c = a - b; you could do (a != b).nonzero():"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "c = a - b", "childNum": 0, "tag": "code", "childList": []}, {"text": "(a != b).nonzero()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = np.random.random_integers(2, size=(4,4))\n&gt;&gt;&gt; b = np.random.random_integers(2, size=(4,4))\n&gt;&gt;&gt; (a != b).nonzero()\n(array([0, 0, 1, 1, 1, 2, 3]), array([1, 2, 1, 2, 3, 2, 0]))\n&gt;&gt;&gt; a - b\narray([[ 0,  1,  1,  0],\n       [ 0,  1, -1, -1],\n       [ 0,  0,  1,  0],\n       [-1,  0,  0,  0]])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["have a look at numpy it have everything you ask for and more!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}, {"text": ["See this for sparse matrix support"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/scipy/reference/sparse.html"}]}], [{"text": ["This code takes less then 0.1s."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n m &lt;- matrix(rpois(1000000,0.01),ncol=1000)\nm0 &lt;- lapply(seq(NCOL(m)),function(x) which(m[,x] != 0))\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT:\nFor sparse matrices of any size (which fits memory)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["DATA"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n library(data.table)\n\nN &lt;- 1e+5\nn &lt;- 1e+6\n\nta &lt;- data.table(r=sample(seq(N), n,replace=TRUE),\n                 c=sample(seq(N), n,replace=TRUE),\n                 a=sample(1:20,n,replace=TRUE))\ntb &lt;- data.table(r=sample(seq(N), n,replace=TRUE),\n                 c=sample(seq(N), n,replace=TRUE),\n                 b=sample(1:20,n,replace=TRUE))\nsetkey(ta,r,c)\nsetkey(tb,r,c)\n</code>\n</pre>\n", "senID": 4}, {"text": ["CODE"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n system.time(tw &lt;- ta[tb][is.na(a)|is.na(b)|(a-b != 0),list(r=r,c=c)])\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I haven't timed it, but the simplest code is"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n all.indices&lt;- which (C&gt;0, arr.ind=T)\n</code>\n</pre>\n", "senID": 1}]]