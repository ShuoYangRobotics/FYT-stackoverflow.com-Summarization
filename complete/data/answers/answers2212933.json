[[{"text": ["Although it would likely be possible with some combination of pre-processing, use of csv module, post-processing, and use of regular expressions, your stated requirements do not fit well with the design of the csv module, nor possibly with regular expressions (depending on the complexity of nested quotation marks that you might have to handle)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "csv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "csv", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In complex parsing cases, pyparsing is always a good package to fall back on.", "If this isn't a one-off situation, it will likely produce the most straightforward and maintainable result, at the cost of possibly a little extra effort up front.", "Consider that investment to be paid back quickly, however, as you save yourself the extra effort of debugging the regex solutions to handle corner cases..."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}]}, {"text": ["You can likely find examples of pyparsing-based CSV parsing easily, with this question maybe enough to get you started."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1387644/verify-csv-against-given-format"}]}], [{"text": ["Python has a standard library module to read csv files:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import csv\n\nreader = csv.reader(open('file.csv'))\n\nfor line in reader:\n    print line\n</code>\n</pre>\n", "senID": 1}, {"text": ["For your example input this prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['data1', ' data2 ', \"data3'''\", ' \\'data4\"\"\\'', '', '', 'data5', '']\n</code>\n</pre>\n", "senID": 3}, {"text": ["EDIT:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["you need to add skipinitalspace=True to allow spaces before double quotation marks for the extra examples you provided.", "Not sure about the single quotes yet."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(csv.reader(StringIO('''2, \"dat,a1\", 'dat,a2','''), skipinitialspace=True))\n[['2', 'dat,a1', \"'dat\", \"a2'\", '']]\n\n&gt;&gt;&gt; list(csv.reader(StringIO('''2,\"dat,a1\",'dat,a2','''), skipinitialspace=True))\n[['2', 'dat,a1', \"'dat\", \"a2'\", '']]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["While the csv module is the right answer here, a regex that could do this is quite doable:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "csv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\nr = re.compile(r'''\n    \\s*                # Any whitespace.\n    (                  # Start capturing here.\n      [^,\"']+?         # Either a series of non-comma non-quote characters.\n      |                # OR\n      \"(?:             # A double-quote followed by a string of characters...\n          [^\"\\\\]|\\\\.   # That are either non-quotes or escaped...\n       )*              # ...repeated any number of times.\n      \"                # Followed by a closing double-quote.\n      |                # OR\n      '(?:[^'\\\\]|\\\\.)*'# Same as above, for single quotes.\n    )                  # Done capturing.\n    \\s*                # Allow arbitrary space before the comma.\n    (?:,|$)            # Followed by a comma or the end of a string.\n    ''', re.VERBOSE)\n\nline = r\"\"\"data1, data2  ,\"data3'''\",  'data4\"\"',,,data5,\"\"\"\n\nprint r.findall(line)\n\n# That prints: ['data1', 'data2', '\"data3\\'\\'\\'\"', '\\'data4\"\"\\'', 'data5']\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: To validate lines, you can reuse the regex above with small additions:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\nr_validation = re.compile(r'''\n    ^(?:    # Capture from the start.\n      # Below is the same regex as above, but condensed.\n      # One tiny modification is that it allows empty values\n      # The first plus is replaced by an asterisk.\n      \\s*([^,\"']*?|\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*')\\s*(?:,|$)\n    )*$    # And don't stop until the end.\n    ''', re.VERBOSE)\n\nline1 = r\"\"\"data1, data2  ,\"data3'''\",  'data4\"\"',,,data5,\"\"\"\nline2 = r\"\"\"data1, data2, da\"ta3\", 'data4',\"\"\"\n\nif r_validation.match(line1):\n    print 'Line 1 is valid.'\nelse:\n    print 'Line 1 is INvalid.'\n\nif r_validation.match(line2):\n    print 'Line 2 is valid.'\nelse:\n    print 'Line 2 is INvalid.'\n\n# Prints:\n#    Line 1 is valid.\n#    Line 2 is INvalid.\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It is not possible to give you an answer, because you have not completely specified the protocol that is being used by the writer."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "It is not possible to give you an answer, because you have not completely specified the protocol that is being used by the writer.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["It evidently contains rules like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If a field contains any commas or single quotes, quote it with double quotes.", "Else if the field contains any double quotes, quote it with single quotes.", "Note: the result is still valid if you swap double and single in the above 2 clauses.", "Else don't quote it.", "The resultant field may have spaces (or other whitespace?", ") prepended or appended.", "The so-augmented fields are assembled into a row, separated by commas and terminated by the platform's newline (LF or CRLF).  "], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 3, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 4, "childList": []}]}, {"text": ["What is not mentioned is what the writer does in these cases:\n   (0) field contains BOTH single quotes and double quotes\n   (1) field contains leading non-newline whitespace\n   (2) field contains trailing non-newline whitespace\n   (3) field contains any newlines.", "Where the writer ignores any of these cases, please specify what outcomes you want."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["You also mention \"quotation marks can only be prepended or trailed by spaces\" -- surely you mean commas are allowed also, otherwise your example 'data4\"\"',,,data5, fails on the first comma."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "'data4\"\"',,,data5,", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["How is your data encoded?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["This probably sounds too simple, but really from the looks of things you are looking for a string that contains either [a-zA-Z0-9][\"']+[a-zA-Z0-9], I mean without in depth testing against the data really what you're looking for is a quote or double quote (or any combination) in between letters (you could also add numbers there)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Based on what you were asking, it really doesn't matter that it's a CSV, it matter's that you have data that doesn't conform.", "Which I believe just doing a search for a letter, then any combination of one or more \" or ' and another letter.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now are you looking to get a \"quantity\" or just a printout of the line that contains it so you know which ones to go back and fix?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I'm sorry I don't know python regex's but in perl this would look something like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # Look for one or more letter/number at least one ' or \" or more and at least one    \n#  or more letter/number\nif ($line =~ m/[a-zA-Z0-9]+['\"]+[a-zA-Z0-9]+/ig)\n{\n    # Prints the line if the above regex is found\n    print $line;\n\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["Just simply convert that for when you look at a line."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I'm sorry if I misunderstood the question"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I hope it helps!"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["If your goal is to convert the data to XML (or JSON, or YAML), look at this example for a Gelatin syntax that produces the following output:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "this example", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/knipknap/Gelatin/tree/master/syntax/csv/syntax.gel"}, {"href": "http://wiki.github.com/knipknap/Gelatin/", "text": "Gelatin", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n &lt;xml&gt;\n  &lt;line&gt;\n    &lt;column&gt;data1&lt;/column&gt;\n    &lt;column&gt;data2  &lt;/column&gt;\n    &lt;column&gt;data3'''&lt;/column&gt;\n    &lt;column&gt;data4\"\"&lt;/column&gt;\n    &lt;column/&gt;\n    &lt;column/&gt;\n    &lt;column&gt;data5&lt;/column&gt;\n    &lt;column/&gt;\n  &lt;/line&gt;\n&lt;/xml&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that Gelatin also has a Python API:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from Gelatin.util import compile, generate_to_file\nsyntax = compile('syntax.gel')\ngenerate_to_file(syntax, 'input.csv', 'output.xml', 'xml')\n</code>\n</pre>\n", "senID": 3}]]