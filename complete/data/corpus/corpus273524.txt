Question (ID-273524): Python 3.0 and language evolution Python 3.0 breaks backwards compatibility with previous versions and splits the language into two paths (at least temporarily). Do you know of any other language that went through such a major design phase while in maturity? 

 Also, do you believe that this is how programming languages should evolve or is the price to pay simply too high? 
 Answers (Total-12): #0 The only language I can think of to attempt such a mid-stream change would be Perl. Of course, Python is beating Perl to that particular finish line by releasing first. It should be noted, however, that Perl's changes are much more extensive than Python's and likely will be harder to detangle. 

 (There's a price for Perl's "There's More Than One Way To Do It" philosophy.) 

 There are examples like the changes from version to version of .NET-based languages (ironic, considering the whole point of .NET was supposed to be API stability and cross-platform compatibility). However, I would hardly call those languages "mature"; it's always been more of a design-on-the-go, build-the-plane-as-we-fly approach to things. 

 Or, as I tend to think of it, most languages come from either "organic growth" or "engineered construction." Perl is the perfect example of organic growth; it started as a fancy text processing tool ala awk/sed and grew into a full language. 

 Python, on the other hand, is much more engineered. Spend a bit of time wandering around the extensive whitepapers on their website to see the extensive debate that goes into every even minor change to the language's syntax and implementation. 

 The idea of making these sorts of far-reaching changes is somewhat new to programming languages because programming languages themselves have changed in nature. It used to be that programming methodologies changed only when a new processor came out that had a new instruction set. The early languages tended to either be so low-level and married to assembly language (e.g. C) or so utterly dynamic in nature (Forth, Lisp) that such a mid-stream change wouldn't even come up as a consideration. 

 As to whether or not the changes are good ones, I'm not sure. I tend to have faith in the people guiding Python's development, however; the changes in the language thus far have been largely for the better. 

 I think in the days to come the Global Interpreter Lock will prove more central than syntax changes. Though the new multiprocessor library might alleviate most of that. 
 #1 The price of insisting on near-absolute backwards compatibility is just too high. Spend two minutes programming in C++ if you want to see why. 
 #2 The python team has worked very hard to make the lack of backward compatibility as painless as possible, to the point where the 2.6 release of python was created with a mind towards a painless upgrade process. Once you have upgraded to 2.6 there are scripts that you can run that will move you to 3.0 without issue. 
 #3 It's worth mentioning that backward compatibility incurs costs of its own. In some cases it's almost impossible to evolve a language in the ideal way if 100% backward compatibility is required. Java's implementation of generics (which erases type information at compile-time in order to be backwardly-compatible) is a good example of how implementing features with 100% backward compatibility can result in a sub-optimal language feature. 

 So loosely speaking, it can come down to a choice between a poorly implemented new feature that's backwardly compatible, or a nicely implemented new feature that's not. In many cases, the latter is a better choice, particularly if there are tools that can automatically translate incompatible code. 
 #4 I think there are many examples of backward compatibility breakages. Many of the languages that did this were either small or died out along the way. 

 Many examples of this involved renaming the language. 

 Algol 60 and Algol 68 were so different that the meetings on Algol 68 broke up into factions. The Algol 68 faction, the Pascal faction and the PL/I faction. 

 Wirth's Pascal morphed into Modula-3. It was very similar to pascal -- very similar syntax and semantics -- but several new features. Was that really a Pascal-2 with no backward compatibility? 

 The Lisp to Scheme thing involved a rename. 

 If you track down a scan of the old B programming language manual, you'll see that the evolution to C looks kind of incremental -- not radical -- but it did break compatibility. 

 Fortran existed in many forms. I don't know for sure, but I think that Digital's Fortran 90 for VAX/VMS wasn't completely compatible with ancient Fortran IV programs. 

 RPG went through major upheavals -- I think that there are really two incompatible languages called RPG. 

 Bottom Line I think that thinking and learning are inevitable. You have three responses to learning the limitations of a language. 

 
 Invent a new language that's utterly incompatible. 
 Incremental chagne until you are forced to invent a new language. 
 Break compatibility in a controlled, thoughtful way. 
 

 I think that #1 and #2 are both coward's ways out. Chucking the old is easier than attempting to preserve it. Preserving every nuanced feature (no matter how bad) is a lot of work, some of it of little or no value. 

 Commercial enterprises opt for cowardly approaches in the name of "new marketing" or "preserving our existing customers". That's why commercial software ventures aren't hot-beds of innovation. 

 I think that only open-source projects can be embrace innovation in the way that the Python community is tackling this change. 
 #5 C# and the .NET framework broke compatibility between versions 1.0 and 1.1 as well as between 1.1 and 2.0. Running applications in different versions required having multiple versions of the .NET runtime installed. 

 At least they did include an upgrade wizard to upgrade source from one version to the next (it worked for most of our code). 
 #6 Wouldn't VB6 to VB.net be the biggest example of this? Or do you all consider them two separate languages? 
 #7 In the Lisp world it has happened a few times. of course, the language is so dynamic that usually evolution is simply deprecating part of the standard library and making standard another part. 

 also, Lua 4 to 5 was pretty significant; but the language core is so minimal that even wide-reaching changes are documented in a couple of pages. 
 #8 Perl 6 is also going through this type of split right now. Perl 5 programs won't run directly on Perl 6, but there will be a translator to translate the code into a form that may work (I don't think it can handle 100% of the cases). 

 Perl 6 even has its own article on Wikipedia. 
 #9 First, here is a video talk about the changes Python will go through.
Second, changes are no good.
Third, I for one welcome evolution and believe it is necessary. 
 #10 gcc regularly changes how it handles C++ almost every minor release. Of course, this is more a consequence of gcc tightening how they follow the rules, and less of C++ itself changing. 
 #11 The new version of the Ruby programming language will also break compatibility. 

 And think of the libraries one might use: gtk, Qt, and so on (they also have incompatible versions). 

 I think incompatibility is necessary sometimes (but not too often) to support progress.