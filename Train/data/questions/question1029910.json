[{"text": ["GCC on HP-UX, lots of poll(), pipe(), and file issues"], "tag": "h2", "senID": 0}, {"text": ["I'm having a lot of trouble building a 'middleman' logger - the intention is to place it on the path above an item in /usr/bin and capture everything going to and from the application.", "(Black box 3rd-party app is failing FTP for some reason.", ")  Once run, the middleman will fork, redirect stdout and stdin to/from pipes that the parent has control of, and then execute the program in /usr/bin.", "(Hardcoded; yes, I know, I'm bad."], "tag": "p", "senID": 1}, {"text": ["However, once I run poll(), things get weird.", "I lose the handle to my logfile, the poll on the output pipe from the child throws an error, cats and dogs start living together, et cetera."], "tag": "p", "senID": 2}, {"text": ["Can anyone shed some light on this?"], "tag": "p", "senID": 3}, {"text": ["Here's what I currently have...", "The poll() in question is marked with non-indented comments for ease of location."], "tag": "p", "senID": 4}, {"code": "<pre>\n<code>\n #include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;poll.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;fcntl.h&gt;\n\n#define MAX_STR_LEN 1024\nstatic int directionFlag; /* 0 = input, 1 = output */\nstatic int eofFlag;\n\n/* Splits the next char from the stream inFile, with extra\ninformation logged if directionFlag swaps */\nvoid logChar(int inFilDes, int outFilDes, FILE *logFile, int direction)\n{\n    char inChar = 0;\n    if(read(inFilDes, &amp;inChar, sizeof(char)) &gt; 0)\n    {\n\n    \tif(direction != directionFlag)\n    \t{\n    \t\tdirectionFlag = direction;\n    \t\tif(direction)\n    \t\t{\n    \t\t\tfprintf(logFile, \"\\nOUTPUT: \");\n    \t\t} else {\n    \t\t\tfprintf(logFile, \"\\nINPUT: \");\n    \t\t}\n    \t}\n\n    \twrite(outFilDes, &amp;inChar, sizeof(char));\n    \tfputc(inChar, stderr);\n    \tfputc(inChar, logFile);\n    } else {\n    \teofFlag = 1;\n    }\n    return;\n}\n\nint main(int argc, char* argv[])\n{\n    pid_t pid;\n\n    int childInPipe[2];\n    int childOutPipe[2];\n\n    eofFlag = 0;\n\n    /* [0] is input, [1] is output*/\n\n    if(pipe(childInPipe) &lt; 0 || pipe(childOutPipe) &lt; 0) {\n    \tfprintf(stderr,\"Pipe error; aborting\\n\");\n    \t\texit(1);\n    }\n\n    if((pid = fork()) == -1){\n    \tfprintf(stderr,\"Fork error; aborting\\n\");\n    \texit(1);\n    }\n\n    if(pid)\n    {\n    \t/*Parent process*/\n\n    \tint i;\n    \tint errcode;\n    \ttime_t rawtime;\n    \tstruct tm * timeinfo;\n    \ttime(&amp;rawtime);\n    \ttimeinfo=localtime(&amp;rawtime);\n\n    \tstruct pollfd pollArray[2] = {\n    \t\t{ .fd = 0, .events = POLLIN, .revents = 0 },\n    \t\t{ .fd = childOutPipe[0], .events = POLLIN, .revents = 0 }\n    \t};\n    \t/* Yet again, 0 = input, 1 = output */\n\n    \tnfds_t nfds = sizeof(struct pollfd[2]);\n\n    \tclose(childInPipe[0]);\n    \tclose(childOutPipe[1]);\n\n    \t/* We don't want to change around the streams for this one,\n    \tas we will be logging everything - and I do mean everything */\n\n    \tFILE *logFile;\n    \tif(!(logFile = fopen(\"/opt/middleman/logfile.txt\", \"a\"))) {\n    \t\tfprintf(stderr, \"fopen fail on /opt/middleman/logfile.txt\\n\");\n    \t\texit(1);\n    \t}\n\n    \tfprintf(logFile, \"Commandline: \");\n\n    \tfor(i=0; i &lt; argc; i++)\n    \t{\n    \t\tfprintf(logFile, \"%s \", argv[i]);\n    \t}\n    \tfprintf(logFile, \"\\nTIMESTAMP: %s\\n\", asctime(timeinfo));\n\n    \twhile(!eofFlag)\n    \t{\n\n// RIGHT HERE is where things go to pot\n    \t\terrcode = poll(pollArray, nfds, 1);\n// All following fprintf(logfile)s do nothing\n    \t\tif(errcode &lt; 0) {\n    \t\t\tfprintf(stderr, \"POLL returned with error %d!\", errcode);\n    \t\t\teofFlag = 1;\n    \t\t}\n    \t\tif((pollArray[0].revents &amp;&amp; POLLERR) &amp; errno != EAGAIN ) {\n    \t\t\tfprintf(stderr, \"POLL on input has thrown an exception!\\n\");\n    \t\t\tfprintf(stderr, \"ERRNO value: %d\\n\", errno);\n    \t\t\tfprintf(logFile, \"POLL on input has thrown an exception!\\n\");\n    \t\t\teofFlag = 1;\n    \t\t} else if(pollArray[0].revents &amp;&amp; POLLIN) {\n    \t\t\tlogChar(pollArray[0].fd, childInPipe[1], logFile, 0);\n    \t\t} else if((pollArray[1].revents &amp;&amp; POLLERR) &amp; errno != EAGAIN ) {\n    \t\t\tfprintf(stderr, \"POLL on output has thrown an exception!\\n\");\n    \t\t\tfprintf(stderr, \"ERRNO value: %d\\n\", errno);\n    \t\t\tfprintf(logFile, \"POLL on output has thrown an exception!\\n\");\n    \t\t\teofFlag = 1;\n    \t\t} else if(pollArray[1].revents &amp;&amp; POLLIN) {\n    \t\t\tlogChar(pollArray[1].fd, 1, logFile, 1);\n    \t\t}\n\n    \t}\n\n    \tfclose(logFile);\n\n    }\n    else\n    {\n    \t/*Child process; switch streams and execute application*/\n    \tint i;\n    \tint catcherr = 0;\n    \tchar stmt[MAX_STR_LEN] = \"/usr/bin/\";\n\n    \tclose(childInPipe[1]);\n    \tclose(childOutPipe[0]);\n\n    \tstrcat(stmt, argv[0]);\n\n    \tif(dup2(childInPipe[0],0) &lt; 0) {\n    \t\tfprintf(stderr, \"dup2 threw error %d on childInPipe[0] to stdin!\\n\", errno);\n    \t}\n//  \tclose(childInPipe[0]);\n\n    \tif(dup2(childOutPipe[1],1) &lt; 0)\n    \t{\n    \t\tfprintf(stderr, \"dup2 threw error %d on childInPipe[1] to stdout!\\n\", errno);\n    \t}\n\n    \t/* Arguments need to be in a different format for execv */\n    \tchar* args[argc+1];\n    \tfor(i = 0; i &lt; argc; i++)\n    \t{\n    \t\targs[i] = argv[i];\n    \t}\n    \targs[i] = (char *)0;\n\n    \tfprintf(stderr, \"Child setup complete, executing %s\\n\", stmt);\n    \tfprintf(stdout, \"Child setup complete, executing %s\\n\", stmt);\n\n    \tif(execv(stmt, args) == -1) {\n    \t\tfprintf(stderr, \"execvP error!\\n\");\n    \t\texit(1);\n    \t}\n    }\n    return 0;\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["\nEDIT 6/23/09 12:20PM"], "tag": "p", "senID": 6}, {"text": ["After the fixes, I have attempted to run 'banner' through this program, and here's the output I get..."], "tag": "p", "senID": 7}, {"code": "<pre>\n<code>\n Child setup complete, executing /usr/bin/banner\nPOLL on output has thrown an exception!\nERRNO value: 0\n</code>\n</pre>\n", "senID": 8}, {"text": ["The logfile has the following:"], "tag": "p", "senID": 9}, {"code": "<pre>\n<code>\n Commandline: banner testing \nTIMESTAMP: Tue Jun 23 11:21:00 2009\n</code>\n</pre>\n", "senID": 10}, {"text": ["The reason ERRNO has a 0 in it is because poll() returns just fine; it's the pollArray[1].revents that came back with an error, which means childOutPipe[0] polled as having an error.", "logChar(), as far as I can tell, never gets called."], "tag": "p", "senID": 11}, {"text": ["I'm going to try splitting out poll() into two different calls.", "Okay, the moment I poll() - even on stdin, which doesn't return with an error message - it kills my ability to write to the logFile.", "Also, I discovered that the while() loop runs several times before the output poll comes back with an error on the pipe.", "I'm becoming increasingly convinced that poll() is simply a lost cause.", "Every attempt to write to logFile fails after the poll(), even a successful poll(), with errno set to \"Bad file number\".", "This really should not be happening.", "I honestly cannot see how it would be affecting my file handle.", "Okay, so apparently I'm a moron.", "Thanks for setting me straight; I was assuming nfds was a byte size, not an array size.", "That's fixed, and voila!", "It's not killing my logFile handle any more."], "tag": "p", "senID": 12}]